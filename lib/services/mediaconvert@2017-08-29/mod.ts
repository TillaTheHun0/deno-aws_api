// Autogenerated API client for: AWS Elemental MediaConvert

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class MediaConvert {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaConvert.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-08-29",
    "endpointPrefix": "mediaconvert",
    "signingName": "mediaconvert",
    "serviceFullName": "AWS Elemental MediaConvert",
    "serviceId": "MediaConvert",
    "protocol": "rest-json",
    "jsonVersion": "1.1",
    "uid": "mediaconvert-2017-08-29",
    "signatureVersion": "v4",
    "serviceAbbreviation": "MediaConvert"
  };

  async associateCertificate(
    {abortSignal, ...params}: RequestConfig & AssociateCertificateRequest,
  ): Promise<AssociateCertificateResponse> {
    const body: jsonP.JSONObject = {
      arn: params["Arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateCertificate",
      requestUri: "/2017-08-29/certificates",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelJob(
    {abortSignal, ...params}: RequestConfig & CancelJobRequest,
  ): Promise<CancelJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelJob",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/jobs/${params["Id"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createJob(
    {abortSignal, ...params}: RequestConfig & CreateJobRequest,
  ): Promise<CreateJobResponse> {
    const body: jsonP.JSONObject = {
      accelerationSettings: fromAccelerationSettings(params["AccelerationSettings"]),
      billingTagsSource: params["BillingTagsSource"],
      clientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      hopDestinations: params["HopDestinations"]?.map(x => fromHopDestination(x)),
      jobTemplate: params["JobTemplate"],
      priority: params["Priority"],
      queue: params["Queue"],
      role: params["Role"],
      settings: fromJobSettings(params["Settings"]),
      simulateReservedQueue: params["SimulateReservedQueue"],
      statusUpdateInterval: params["StatusUpdateInterval"],
      tags: params["Tags"],
      userMetadata: params["UserMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJob",
      requestUri: "/2017-08-29/jobs",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Job": toJob,
      },
    }, await resp.json());
  }

  async createJobTemplate(
    {abortSignal, ...params}: RequestConfig & CreateJobTemplateRequest,
  ): Promise<CreateJobTemplateResponse> {
    const body: jsonP.JSONObject = {
      accelerationSettings: fromAccelerationSettings(params["AccelerationSettings"]),
      category: params["Category"],
      description: params["Description"],
      hopDestinations: params["HopDestinations"]?.map(x => fromHopDestination(x)),
      name: params["Name"],
      priority: params["Priority"],
      queue: params["Queue"],
      settings: fromJobTemplateSettings(params["Settings"]),
      statusUpdateInterval: params["StatusUpdateInterval"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJobTemplate",
      requestUri: "/2017-08-29/jobTemplates",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobTemplate": toJobTemplate,
      },
    }, await resp.json());
  }

  async createPreset(
    {abortSignal, ...params}: RequestConfig & CreatePresetRequest,
  ): Promise<CreatePresetResponse> {
    const body: jsonP.JSONObject = {
      category: params["Category"],
      description: params["Description"],
      name: params["Name"],
      settings: fromPresetSettings(params["Settings"]),
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePreset",
      requestUri: "/2017-08-29/presets",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Preset": toPreset,
      },
    }, await resp.json());
  }

  async createQueue(
    {abortSignal, ...params}: RequestConfig & CreateQueueRequest,
  ): Promise<CreateQueueResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      name: params["Name"],
      pricingPlan: params["PricingPlan"],
      reservationPlanSettings: fromReservationPlanSettings(params["ReservationPlanSettings"]),
      status: params["Status"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateQueue",
      requestUri: "/2017-08-29/queues",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Queue": toQueue,
      },
    }, await resp.json());
  }

  async deleteJobTemplate(
    {abortSignal, ...params}: RequestConfig & DeleteJobTemplateRequest,
  ): Promise<DeleteJobTemplateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteJobTemplate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/jobTemplates/${params["Name"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deletePreset(
    {abortSignal, ...params}: RequestConfig & DeletePresetRequest,
  ): Promise<DeletePresetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePreset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/presets/${params["Name"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteQueue(
    {abortSignal, ...params}: RequestConfig & DeleteQueueRequest,
  ): Promise<DeleteQueueResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteQueue",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/queues/${params["Name"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeEndpoints(
    {abortSignal, ...params}: RequestConfig & DescribeEndpointsRequest = {},
  ): Promise<DescribeEndpointsResponse> {
    const body: jsonP.JSONObject = {
      maxResults: params["MaxResults"],
      mode: params["Mode"],
      nextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoints",
      requestUri: "/2017-08-29/endpoints",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Endpoints": [toEndpoint],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async disassociateCertificate(
    {abortSignal, ...params}: RequestConfig & DisassociateCertificateRequest,
  ): Promise<DisassociateCertificateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DisassociateCertificate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/certificates/${params["Arn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async getJob(
    {abortSignal, ...params}: RequestConfig & GetJobRequest,
  ): Promise<GetJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetJob",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/jobs/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Job": toJob,
      },
    }, await resp.json());
  }

  async getJobTemplate(
    {abortSignal, ...params}: RequestConfig & GetJobTemplateRequest,
  ): Promise<GetJobTemplateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetJobTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/jobTemplates/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobTemplate": toJobTemplate,
      },
    }, await resp.json());
  }

  async getPreset(
    {abortSignal, ...params}: RequestConfig & GetPresetRequest,
  ): Promise<GetPresetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetPreset",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/presets/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Preset": toPreset,
      },
    }, await resp.json());
  }

  async getQueue(
    {abortSignal, ...params}: RequestConfig & GetQueueRequest,
  ): Promise<GetQueueResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetQueue",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/queues/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Queue": toQueue,
      },
    }, await resp.json());
  }

  async listJobTemplates(
    {abortSignal, ...params}: RequestConfig & ListJobTemplatesRequest = {},
  ): Promise<ListJobTemplatesResponse> {
    const query = new URLSearchParams;
    if (params["Category"] != null) query.set("category", params["Category"]?.toString() ?? "");
    if (params["ListBy"] != null) query.set("listBy", params["ListBy"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobTemplates",
      method: "GET",
      requestUri: "/2017-08-29/jobTemplates",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobTemplates": [toJobTemplate],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & ListJobsRequest = {},
  ): Promise<ListJobsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    if (params["Queue"] != null) query.set("queue", params["Queue"]?.toString() ?? "");
    if (params["Status"] != null) query.set("status", params["Status"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobs",
      method: "GET",
      requestUri: "/2017-08-29/jobs",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Jobs": [toJob],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPresets(
    {abortSignal, ...params}: RequestConfig & ListPresetsRequest = {},
  ): Promise<ListPresetsResponse> {
    const query = new URLSearchParams;
    if (params["Category"] != null) query.set("category", params["Category"]?.toString() ?? "");
    if (params["ListBy"] != null) query.set("listBy", params["ListBy"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPresets",
      method: "GET",
      requestUri: "/2017-08-29/presets",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Presets": [toPreset],
      },
    }, await resp.json());
  }

  async listQueues(
    {abortSignal, ...params}: RequestConfig & ListQueuesRequest = {},
  ): Promise<ListQueuesResponse> {
    const query = new URLSearchParams;
    if (params["ListBy"] != null) query.set("listBy", params["ListBy"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListQueues",
      method: "GET",
      requestUri: "/2017-08-29/queues",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Queues": [toQueue],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/tags/${params["Arn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceTags": toResourceTags,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      arn: params["Arn"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: "/2017-08-29/tags",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      tagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-08-29/tags/${params["Arn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateJobTemplate(
    {abortSignal, ...params}: RequestConfig & UpdateJobTemplateRequest,
  ): Promise<UpdateJobTemplateResponse> {
    const body: jsonP.JSONObject = {
      accelerationSettings: fromAccelerationSettings(params["AccelerationSettings"]),
      category: params["Category"],
      description: params["Description"],
      hopDestinations: params["HopDestinations"]?.map(x => fromHopDestination(x)),
      priority: params["Priority"],
      queue: params["Queue"],
      settings: fromJobTemplateSettings(params["Settings"]),
      statusUpdateInterval: params["StatusUpdateInterval"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateJobTemplate",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-08-29/jobTemplates/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobTemplate": toJobTemplate,
      },
    }, await resp.json());
  }

  async updatePreset(
    {abortSignal, ...params}: RequestConfig & UpdatePresetRequest,
  ): Promise<UpdatePresetResponse> {
    const body: jsonP.JSONObject = {
      category: params["Category"],
      description: params["Description"],
      settings: fromPresetSettings(params["Settings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePreset",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-08-29/presets/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Preset": toPreset,
      },
    }, await resp.json());
  }

  async updateQueue(
    {abortSignal, ...params}: RequestConfig & UpdateQueueRequest,
  ): Promise<UpdateQueueResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      reservationPlanSettings: fromReservationPlanSettings(params["ReservationPlanSettings"]),
      status: params["Status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateQueue",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-08-29/queues/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Queue": toQueue,
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface AssociateCertificateRequest {
  Arn: string;
}

// refs: 1 - tags: named, input
export interface CancelJobRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface CreateJobRequest {
  AccelerationSettings?: AccelerationSettings | null;
  BillingTagsSource?: BillingTagsSource | null;
  ClientRequestToken?: string | null;
  HopDestinations?: HopDestination[] | null;
  JobTemplate?: string | null;
  Priority?: number | null;
  Queue?: string | null;
  Role: string;
  Settings: JobSettings;
  SimulateReservedQueue?: SimulateReservedQueue | null;
  StatusUpdateInterval?: StatusUpdateInterval | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  UserMetadata?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateJobTemplateRequest {
  AccelerationSettings?: AccelerationSettings | null;
  Category?: string | null;
  Description?: string | null;
  HopDestinations?: HopDestination[] | null;
  Name: string;
  Priority?: number | null;
  Queue?: string | null;
  Settings: JobTemplateSettings;
  StatusUpdateInterval?: StatusUpdateInterval | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreatePresetRequest {
  Category?: string | null;
  Description?: string | null;
  Name: string;
  Settings: PresetSettings;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateQueueRequest {
  Description?: string | null;
  Name: string;
  PricingPlan?: PricingPlan | null;
  ReservationPlanSettings?: ReservationPlanSettings | null;
  Status?: QueueStatus | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface DeleteJobTemplateRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeletePresetRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteQueueRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeEndpointsRequest {
  MaxResults?: number | null;
  Mode?: DescribeEndpointsMode | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DisassociateCertificateRequest {
  Arn: string;
}

// refs: 1 - tags: named, input
export interface GetJobRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetJobTemplateRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetPresetRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetQueueRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface ListJobTemplatesRequest {
  Category?: string | null;
  ListBy?: JobTemplateListBy | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  Order?: Order | null;
}

// refs: 1 - tags: named, input
export interface ListJobsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
  Order?: Order | null;
  Queue?: string | null;
  Status?: JobStatus | null;
}

// refs: 1 - tags: named, input
export interface ListPresetsRequest {
  Category?: string | null;
  ListBy?: PresetListBy | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  Order?: Order | null;
}

// refs: 1 - tags: named, input
export interface ListQueuesRequest {
  ListBy?: QueueListBy | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  Order?: Order | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  Arn: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  Arn: string;
  Tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  Arn: string;
  TagKeys?: string[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateJobTemplateRequest {
  AccelerationSettings?: AccelerationSettings | null;
  Category?: string | null;
  Description?: string | null;
  HopDestinations?: HopDestination[] | null;
  Name: string;
  Priority?: number | null;
  Queue?: string | null;
  Settings?: JobTemplateSettings | null;
  StatusUpdateInterval?: StatusUpdateInterval | null;
}

// refs: 1 - tags: named, input
export interface UpdatePresetRequest {
  Category?: string | null;
  Description?: string | null;
  Name: string;
  Settings?: PresetSettings | null;
}

// refs: 1 - tags: named, input
export interface UpdateQueueRequest {
  Description?: string | null;
  Name: string;
  ReservationPlanSettings?: ReservationPlanSettings | null;
  Status?: QueueStatus | null;
}

// refs: 1 - tags: named, output
export interface AssociateCertificateResponse {
}

// refs: 1 - tags: named, output
export interface CancelJobResponse {
}

// refs: 1 - tags: named, output
export interface CreateJobResponse {
  Job?: Job | null;
}

// refs: 1 - tags: named, output
export interface CreateJobTemplateResponse {
  JobTemplate?: JobTemplate | null;
}

// refs: 1 - tags: named, output
export interface CreatePresetResponse {
  Preset?: Preset | null;
}

// refs: 1 - tags: named, output
export interface CreateQueueResponse {
  Queue?: Queue | null;
}

// refs: 1 - tags: named, output
export interface DeleteJobTemplateResponse {
}

// refs: 1 - tags: named, output
export interface DeletePresetResponse {
}

// refs: 1 - tags: named, output
export interface DeleteQueueResponse {
}

// refs: 1 - tags: named, output
export interface DescribeEndpointsResponse {
  Endpoints?: Endpoint[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DisassociateCertificateResponse {
}

// refs: 1 - tags: named, output
export interface GetJobResponse {
  Job?: Job | null;
}

// refs: 1 - tags: named, output
export interface GetJobTemplateResponse {
  JobTemplate?: JobTemplate | null;
}

// refs: 1 - tags: named, output
export interface GetPresetResponse {
  Preset?: Preset | null;
}

// refs: 1 - tags: named, output
export interface GetQueueResponse {
  Queue?: Queue | null;
}

// refs: 1 - tags: named, output
export interface ListJobTemplatesResponse {
  JobTemplates?: JobTemplate[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListJobsResponse {
  Jobs?: Job[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPresetsResponse {
  NextToken?: string | null;
  Presets?: Preset[] | null;
}

// refs: 1 - tags: named, output
export interface ListQueuesResponse {
  NextToken?: string | null;
  Queues?: Queue[] | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  ResourceTags?: ResourceTags | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateJobTemplateResponse {
  JobTemplate?: JobTemplate | null;
}

// refs: 1 - tags: named, output
export interface UpdatePresetResponse {
  Preset?: Preset | null;
}

// refs: 1 - tags: named, output
export interface UpdateQueueResponse {
  Queue?: Queue | null;
}

// refs: 10 - tags: input, named, interface, output
export interface AccelerationSettings {
  Mode: AccelerationMode;
}
function fromAccelerationSettings(input?: AccelerationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    mode: input["Mode"],
  }
}
function toAccelerationSettings(root: jsonP.JSONValue): AccelerationSettings {
  return jsonP.readObj({
    required: {
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<AccelerationMode>(x),
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type AccelerationMode =
| "DISABLED"
| "ENABLED"
| "PREFERRED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type BillingTagsSource =
| "QUEUE"
| "PRESET"
| "JOB_TEMPLATE"
| "JOB"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface HopDestination {
  Priority?: number | null;
  Queue?: string | null;
  WaitMinutes?: number | null;
}
function fromHopDestination(input?: HopDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    priority: input["Priority"],
    queue: input["Queue"],
    waitMinutes: input["WaitMinutes"],
  }
}
function toHopDestination(root: jsonP.JSONValue): HopDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "Priority": "n",
      "Queue": "s",
      "WaitMinutes": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface JobSettings {
  AdAvailOffset?: number | null;
  AvailBlanking?: AvailBlanking | null;
  Esam?: EsamSettings | null;
  Inputs?: Input[] | null;
  MotionImageInserter?: MotionImageInserter | null;
  NielsenConfiguration?: NielsenConfiguration | null;
  NielsenNonLinearWatermark?: NielsenNonLinearWatermarkSettings | null;
  OutputGroups?: OutputGroup[] | null;
  TimecodeConfig?: TimecodeConfig | null;
  TimedMetadataInsertion?: TimedMetadataInsertion | null;
}
function fromJobSettings(input?: JobSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adAvailOffset: input["AdAvailOffset"],
    availBlanking: fromAvailBlanking(input["AvailBlanking"]),
    esam: fromEsamSettings(input["Esam"]),
    inputs: input["Inputs"]?.map(x => fromInput(x)),
    motionImageInserter: fromMotionImageInserter(input["MotionImageInserter"]),
    nielsenConfiguration: fromNielsenConfiguration(input["NielsenConfiguration"]),
    nielsenNonLinearWatermark: fromNielsenNonLinearWatermarkSettings(input["NielsenNonLinearWatermark"]),
    outputGroups: input["OutputGroups"]?.map(x => fromOutputGroup(x)),
    timecodeConfig: fromTimecodeConfig(input["TimecodeConfig"]),
    timedMetadataInsertion: fromTimedMetadataInsertion(input["TimedMetadataInsertion"]),
  }
}
function toJobSettings(root: jsonP.JSONValue): JobSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdAvailOffset": "n",
      "AvailBlanking": toAvailBlanking,
      "Esam": toEsamSettings,
      "Inputs": [toInput],
      "MotionImageInserter": toMotionImageInserter,
      "NielsenConfiguration": toNielsenConfiguration,
      "NielsenNonLinearWatermark": toNielsenNonLinearWatermarkSettings,
      "OutputGroups": [toOutputGroup],
      "TimecodeConfig": toTimecodeConfig,
      "TimedMetadataInsertion": toTimedMetadataInsertion,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AvailBlanking {
  AvailBlankingImage?: string | null;
}
function fromAvailBlanking(input?: AvailBlanking | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    availBlankingImage: input["AvailBlankingImage"],
  }
}
function toAvailBlanking(root: jsonP.JSONValue): AvailBlanking {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailBlankingImage": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface EsamSettings {
  ManifestConfirmConditionNotification?: EsamManifestConfirmConditionNotification | null;
  ResponseSignalPreroll?: number | null;
  SignalProcessingNotification?: EsamSignalProcessingNotification | null;
}
function fromEsamSettings(input?: EsamSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestConfirmConditionNotification: fromEsamManifestConfirmConditionNotification(input["ManifestConfirmConditionNotification"]),
    responseSignalPreroll: input["ResponseSignalPreroll"],
    signalProcessingNotification: fromEsamSignalProcessingNotification(input["SignalProcessingNotification"]),
  }
}
function toEsamSettings(root: jsonP.JSONValue): EsamSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestConfirmConditionNotification": toEsamManifestConfirmConditionNotification,
      "ResponseSignalPreroll": "n",
      "SignalProcessingNotification": toEsamSignalProcessingNotification,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface EsamManifestConfirmConditionNotification {
  MccXml?: string | null;
}
function fromEsamManifestConfirmConditionNotification(input?: EsamManifestConfirmConditionNotification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    mccXml: input["MccXml"],
  }
}
function toEsamManifestConfirmConditionNotification(root: jsonP.JSONValue): EsamManifestConfirmConditionNotification {
  return jsonP.readObj({
    required: {},
    optional: {
      "MccXml": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface EsamSignalProcessingNotification {
  SccXml?: string | null;
}
function fromEsamSignalProcessingNotification(input?: EsamSignalProcessingNotification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sccXml: input["SccXml"],
  }
}
function toEsamSignalProcessingNotification(root: jsonP.JSONValue): EsamSignalProcessingNotification {
  return jsonP.readObj({
    required: {},
    optional: {
      "SccXml": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Input {
  AudioSelectorGroups?: { [key: string]: AudioSelectorGroup | null | undefined } | null;
  AudioSelectors?: { [key: string]: AudioSelector | null | undefined } | null;
  CaptionSelectors?: { [key: string]: CaptionSelector | null | undefined } | null;
  Crop?: Rectangle | null;
  DeblockFilter?: InputDeblockFilter | null;
  DecryptionSettings?: InputDecryptionSettings | null;
  DenoiseFilter?: InputDenoiseFilter | null;
  FileInput?: string | null;
  FilterEnable?: InputFilterEnable | null;
  FilterStrength?: number | null;
  ImageInserter?: ImageInserter | null;
  InputClippings?: InputClipping[] | null;
  InputScanType?: InputScanType | null;
  Position?: Rectangle | null;
  ProgramNumber?: number | null;
  PsiControl?: InputPsiControl | null;
  SupplementalImps?: string[] | null;
  TimecodeSource?: InputTimecodeSource | null;
  TimecodeStart?: string | null;
  VideoSelector?: VideoSelector | null;
}
function fromInput(input?: Input | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectorGroups: jsonP.serializeMap(input["AudioSelectorGroups"], x => fromAudioSelectorGroup(x)),
    audioSelectors: jsonP.serializeMap(input["AudioSelectors"], x => fromAudioSelector(x)),
    captionSelectors: jsonP.serializeMap(input["CaptionSelectors"], x => fromCaptionSelector(x)),
    crop: fromRectangle(input["Crop"]),
    deblockFilter: input["DeblockFilter"],
    decryptionSettings: fromInputDecryptionSettings(input["DecryptionSettings"]),
    denoiseFilter: input["DenoiseFilter"],
    fileInput: input["FileInput"],
    filterEnable: input["FilterEnable"],
    filterStrength: input["FilterStrength"],
    imageInserter: fromImageInserter(input["ImageInserter"]),
    inputClippings: input["InputClippings"]?.map(x => fromInputClipping(x)),
    inputScanType: input["InputScanType"],
    position: fromRectangle(input["Position"]),
    programNumber: input["ProgramNumber"],
    psiControl: input["PsiControl"],
    supplementalImps: input["SupplementalImps"],
    timecodeSource: input["TimecodeSource"],
    timecodeStart: input["TimecodeStart"],
    videoSelector: fromVideoSelector(input["VideoSelector"]),
  }
}
function toInput(root: jsonP.JSONValue): Input {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSelectorGroups": x => jsonP.readMap(String, toAudioSelectorGroup, x),
      "AudioSelectors": x => jsonP.readMap(String, toAudioSelector, x),
      "CaptionSelectors": x => jsonP.readMap(String, toCaptionSelector, x),
      "Crop": toRectangle,
      "DeblockFilter": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeblockFilter>(x),
      "DecryptionSettings": toInputDecryptionSettings,
      "DenoiseFilter": (x: jsonP.JSONValue) => cmnP.readEnum<InputDenoiseFilter>(x),
      "FileInput": "s",
      "FilterEnable": (x: jsonP.JSONValue) => cmnP.readEnum<InputFilterEnable>(x),
      "FilterStrength": "n",
      "ImageInserter": toImageInserter,
      "InputClippings": [toInputClipping],
      "InputScanType": (x: jsonP.JSONValue) => cmnP.readEnum<InputScanType>(x),
      "Position": toRectangle,
      "ProgramNumber": "n",
      "PsiControl": (x: jsonP.JSONValue) => cmnP.readEnum<InputPsiControl>(x),
      "SupplementalImps": ["s"],
      "TimecodeSource": (x: jsonP.JSONValue) => cmnP.readEnum<InputTimecodeSource>(x),
      "TimecodeStart": "s",
      "VideoSelector": toVideoSelector,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AudioSelectorGroup {
  AudioSelectorNames?: string[] | null;
}
function fromAudioSelectorGroup(input?: AudioSelectorGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectorNames: input["AudioSelectorNames"],
  }
}
function toAudioSelectorGroup(root: jsonP.JSONValue): AudioSelectorGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSelectorNames": ["s"],
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AudioSelector {
  CustomLanguageCode?: string | null;
  DefaultSelection?: AudioDefaultSelection | null;
  ExternalAudioFileInput?: string | null;
  LanguageCode?: LanguageCode | null;
  Offset?: number | null;
  Pids?: number[] | null;
  ProgramSelection?: number | null;
  RemixSettings?: RemixSettings | null;
  SelectorType?: AudioSelectorType | null;
  Tracks?: number[] | null;
}
function fromAudioSelector(input?: AudioSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    customLanguageCode: input["CustomLanguageCode"],
    defaultSelection: input["DefaultSelection"],
    externalAudioFileInput: input["ExternalAudioFileInput"],
    languageCode: input["LanguageCode"],
    offset: input["Offset"],
    pids: input["Pids"],
    programSelection: input["ProgramSelection"],
    remixSettings: fromRemixSettings(input["RemixSettings"]),
    selectorType: input["SelectorType"],
    tracks: input["Tracks"],
  }
}
function toAudioSelector(root: jsonP.JSONValue): AudioSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomLanguageCode": "s",
      "DefaultSelection": (x: jsonP.JSONValue) => cmnP.readEnum<AudioDefaultSelection>(x),
      "ExternalAudioFileInput": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "Offset": "n",
      "Pids": ["n"],
      "ProgramSelection": "n",
      "RemixSettings": toRemixSettings,
      "SelectorType": (x: jsonP.JSONValue) => cmnP.readEnum<AudioSelectorType>(x),
      "Tracks": ["n"],
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type AudioDefaultSelection =
| "DEFAULT"
| "NOT_DEFAULT"
| cmnP.UnexpectedEnumValue;

// refs: 62 - tags: input, named, enum, output
export type LanguageCode =
| "ENG"
| "SPA"
| "FRA"
| "DEU"
| "GER"
| "ZHO"
| "ARA"
| "HIN"
| "JPN"
| "RUS"
| "POR"
| "ITA"
| "URD"
| "VIE"
| "KOR"
| "PAN"
| "ABK"
| "AAR"
| "AFR"
| "AKA"
| "SQI"
| "AMH"
| "ARG"
| "HYE"
| "ASM"
| "AVA"
| "AVE"
| "AYM"
| "AZE"
| "BAM"
| "BAK"
| "EUS"
| "BEL"
| "BEN"
| "BIH"
| "BIS"
| "BOS"
| "BRE"
| "BUL"
| "MYA"
| "CAT"
| "KHM"
| "CHA"
| "CHE"
| "NYA"
| "CHU"
| "CHV"
| "COR"
| "COS"
| "CRE"
| "HRV"
| "CES"
| "DAN"
| "DIV"
| "NLD"
| "DZO"
| "ENM"
| "EPO"
| "EST"
| "EWE"
| "FAO"
| "FIJ"
| "FIN"
| "FRM"
| "FUL"
| "GLA"
| "GLG"
| "LUG"
| "KAT"
| "ELL"
| "GRN"
| "GUJ"
| "HAT"
| "HAU"
| "HEB"
| "HER"
| "HMO"
| "HUN"
| "ISL"
| "IDO"
| "IBO"
| "IND"
| "INA"
| "ILE"
| "IKU"
| "IPK"
| "GLE"
| "JAV"
| "KAL"
| "KAN"
| "KAU"
| "KAS"
| "KAZ"
| "KIK"
| "KIN"
| "KIR"
| "KOM"
| "KON"
| "KUA"
| "KUR"
| "LAO"
| "LAT"
| "LAV"
| "LIM"
| "LIN"
| "LIT"
| "LUB"
| "LTZ"
| "MKD"
| "MLG"
| "MSA"
| "MAL"
| "MLT"
| "GLV"
| "MRI"
| "MAR"
| "MAH"
| "MON"
| "NAU"
| "NAV"
| "NDE"
| "NBL"
| "NDO"
| "NEP"
| "SME"
| "NOR"
| "NOB"
| "NNO"
| "OCI"
| "OJI"
| "ORI"
| "ORM"
| "OSS"
| "PLI"
| "FAS"
| "POL"
| "PUS"
| "QUE"
| "QAA"
| "RON"
| "ROH"
| "RUN"
| "SMO"
| "SAG"
| "SAN"
| "SRD"
| "SRB"
| "SNA"
| "III"
| "SND"
| "SIN"
| "SLK"
| "SLV"
| "SOM"
| "SOT"
| "SUN"
| "SWA"
| "SSW"
| "SWE"
| "TGL"
| "TAH"
| "TGK"
| "TAM"
| "TAT"
| "TEL"
| "THA"
| "BOD"
| "TIR"
| "TON"
| "TSO"
| "TSN"
| "TUR"
| "TUK"
| "TWI"
| "UIG"
| "UKR"
| "UZB"
| "VEN"
| "VOL"
| "WLN"
| "CYM"
| "FRY"
| "WOL"
| "XHO"
| "YID"
| "YOR"
| "ZHA"
| "ZUL"
| "ORJ"
| "QPC"
| "TNG"
| cmnP.UnexpectedEnumValue;

// refs: 26 - tags: input, named, interface, output
export interface RemixSettings {
  ChannelMapping?: ChannelMapping | null;
  ChannelsIn?: number | null;
  ChannelsOut?: number | null;
}
function fromRemixSettings(input?: RemixSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channelMapping: fromChannelMapping(input["ChannelMapping"]),
    channelsIn: input["ChannelsIn"],
    channelsOut: input["ChannelsOut"],
  }
}
function toRemixSettings(root: jsonP.JSONValue): RemixSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelMapping": toChannelMapping,
      "ChannelsIn": "n",
      "ChannelsOut": "n",
    },
  }, root);
}

// refs: 26 - tags: input, named, interface, output
export interface ChannelMapping {
  OutputChannels?: OutputChannelMapping[] | null;
}
function fromChannelMapping(input?: ChannelMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    outputChannels: input["OutputChannels"]?.map(x => fromOutputChannelMapping(x)),
  }
}
function toChannelMapping(root: jsonP.JSONValue): ChannelMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputChannels": [toOutputChannelMapping],
    },
  }, root);
}

// refs: 26 - tags: input, named, interface, output
export interface OutputChannelMapping {
  InputChannels?: number[] | null;
}
function fromOutputChannelMapping(input?: OutputChannelMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputChannels: input["InputChannels"],
  }
}
function toOutputChannelMapping(root: jsonP.JSONValue): OutputChannelMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputChannels": ["n"],
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type AudioSelectorType =
| "PID"
| "TRACK"
| "LANGUAGE_CODE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface CaptionSelector {
  CustomLanguageCode?: string | null;
  LanguageCode?: LanguageCode | null;
  SourceSettings?: CaptionSourceSettings | null;
}
function fromCaptionSelector(input?: CaptionSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    customLanguageCode: input["CustomLanguageCode"],
    languageCode: input["LanguageCode"],
    sourceSettings: fromCaptionSourceSettings(input["SourceSettings"]),
  }
}
function toCaptionSelector(root: jsonP.JSONValue): CaptionSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomLanguageCode": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "SourceSettings": toCaptionSourceSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface CaptionSourceSettings {
  AncillarySourceSettings?: AncillarySourceSettings | null;
  DvbSubSourceSettings?: DvbSubSourceSettings | null;
  EmbeddedSourceSettings?: EmbeddedSourceSettings | null;
  FileSourceSettings?: FileSourceSettings | null;
  SourceType?: CaptionSourceType | null;
  TeletextSourceSettings?: TeletextSourceSettings | null;
  TrackSourceSettings?: TrackSourceSettings | null;
}
function fromCaptionSourceSettings(input?: CaptionSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ancillarySourceSettings: fromAncillarySourceSettings(input["AncillarySourceSettings"]),
    dvbSubSourceSettings: fromDvbSubSourceSettings(input["DvbSubSourceSettings"]),
    embeddedSourceSettings: fromEmbeddedSourceSettings(input["EmbeddedSourceSettings"]),
    fileSourceSettings: fromFileSourceSettings(input["FileSourceSettings"]),
    sourceType: input["SourceType"],
    teletextSourceSettings: fromTeletextSourceSettings(input["TeletextSourceSettings"]),
    trackSourceSettings: fromTrackSourceSettings(input["TrackSourceSettings"]),
  }
}
function toCaptionSourceSettings(root: jsonP.JSONValue): CaptionSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AncillarySourceSettings": toAncillarySourceSettings,
      "DvbSubSourceSettings": toDvbSubSourceSettings,
      "EmbeddedSourceSettings": toEmbeddedSourceSettings,
      "FileSourceSettings": toFileSourceSettings,
      "SourceType": (x: jsonP.JSONValue) => cmnP.readEnum<CaptionSourceType>(x),
      "TeletextSourceSettings": toTeletextSourceSettings,
      "TrackSourceSettings": toTrackSourceSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AncillarySourceSettings {
  Convert608To708?: AncillaryConvert608To708 | null;
  SourceAncillaryChannelNumber?: number | null;
  TerminateCaptions?: AncillaryTerminateCaptions | null;
}
function fromAncillarySourceSettings(input?: AncillarySourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    sourceAncillaryChannelNumber: input["SourceAncillaryChannelNumber"],
    terminateCaptions: input["TerminateCaptions"],
  }
}
function toAncillarySourceSettings(root: jsonP.JSONValue): AncillarySourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<AncillaryConvert608To708>(x),
      "SourceAncillaryChannelNumber": "n",
      "TerminateCaptions": (x: jsonP.JSONValue) => cmnP.readEnum<AncillaryTerminateCaptions>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type AncillaryConvert608To708 =
| "UPCONVERT"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type AncillaryTerminateCaptions =
| "END_OF_INPUT"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface DvbSubSourceSettings {
  Pid?: number | null;
}
function fromDvbSubSourceSettings(input?: DvbSubSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toDvbSubSourceSettings(root: jsonP.JSONValue): DvbSubSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pid": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface EmbeddedSourceSettings {
  Convert608To708?: EmbeddedConvert608To708 | null;
  Source608ChannelNumber?: number | null;
  Source608TrackNumber?: number | null;
  TerminateCaptions?: EmbeddedTerminateCaptions | null;
}
function fromEmbeddedSourceSettings(input?: EmbeddedSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    source608ChannelNumber: input["Source608ChannelNumber"],
    source608TrackNumber: input["Source608TrackNumber"],
    terminateCaptions: input["TerminateCaptions"],
  }
}
function toEmbeddedSourceSettings(root: jsonP.JSONValue): EmbeddedSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<EmbeddedConvert608To708>(x),
      "Source608ChannelNumber": "n",
      "Source608TrackNumber": "n",
      "TerminateCaptions": (x: jsonP.JSONValue) => cmnP.readEnum<EmbeddedTerminateCaptions>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type EmbeddedConvert608To708 =
| "UPCONVERT"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type EmbeddedTerminateCaptions =
| "END_OF_INPUT"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface FileSourceSettings {
  Convert608To708?: FileSourceConvert608To708 | null;
  Framerate?: CaptionSourceFramerate | null;
  SourceFile?: string | null;
  TimeDelta?: number | null;
}
function fromFileSourceSettings(input?: FileSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    framerate: fromCaptionSourceFramerate(input["Framerate"]),
    sourceFile: input["SourceFile"],
    timeDelta: input["TimeDelta"],
  }
}
function toFileSourceSettings(root: jsonP.JSONValue): FileSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<FileSourceConvert608To708>(x),
      "Framerate": toCaptionSourceFramerate,
      "SourceFile": "s",
      "TimeDelta": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type FileSourceConvert608To708 =
| "UPCONVERT"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface CaptionSourceFramerate {
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
}
function fromCaptionSourceFramerate(input?: CaptionSourceFramerate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
  }
}
function toCaptionSourceFramerate(root: jsonP.JSONValue): CaptionSourceFramerate {
  return jsonP.readObj({
    required: {},
    optional: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type CaptionSourceType =
| "ANCILLARY"
| "DVB_SUB"
| "EMBEDDED"
| "SCTE20"
| "SCC"
| "TTML"
| "STL"
| "SRT"
| "SMI"
| "TELETEXT"
| "NULL_SOURCE"
| "IMSC"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface TeletextSourceSettings {
  PageNumber?: string | null;
}
function fromTeletextSourceSettings(input?: TeletextSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pageNumber: input["PageNumber"],
  }
}
function toTeletextSourceSettings(root: jsonP.JSONValue): TeletextSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PageNumber": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface TrackSourceSettings {
  TrackNumber?: number | null;
}
function fromTrackSourceSettings(input?: TrackSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    trackNumber: input["TrackNumber"],
  }
}
function toTrackSourceSettings(root: jsonP.JSONValue): TrackSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrackNumber": "n",
    },
  }, root);
}

// refs: 52 - tags: input, named, interface, output
export interface Rectangle {
  Height?: number | null;
  Width?: number | null;
  X?: number | null;
  Y?: number | null;
}
function fromRectangle(input?: Rectangle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    height: input["Height"],
    width: input["Width"],
    x: input["X"],
    y: input["Y"],
  }
}
function toRectangle(root: jsonP.JSONValue): Rectangle {
  return jsonP.readObj({
    required: {},
    optional: {
      "Height": "n",
      "Width": "n",
      "X": "n",
      "Y": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type InputDeblockFilter =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface InputDecryptionSettings {
  DecryptionMode?: DecryptionMode | null;
  EncryptedDecryptionKey?: string | null;
  InitializationVector?: string | null;
  KmsKeyRegion?: string | null;
}
function fromInputDecryptionSettings(input?: InputDecryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    decryptionMode: input["DecryptionMode"],
    encryptedDecryptionKey: input["EncryptedDecryptionKey"],
    initializationVector: input["InitializationVector"],
    kmsKeyRegion: input["KmsKeyRegion"],
  }
}
function toInputDecryptionSettings(root: jsonP.JSONValue): InputDecryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DecryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<DecryptionMode>(x),
      "EncryptedDecryptionKey": "s",
      "InitializationVector": "s",
      "KmsKeyRegion": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type DecryptionMode =
| "AES_CTR"
| "AES_CBC"
| "AES_GCM"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type InputDenoiseFilter =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type InputFilterEnable =
| "AUTO"
| "DISABLE"
| "FORCE"
| cmnP.UnexpectedEnumValue;

// refs: 26 - tags: input, named, interface, output
export interface ImageInserter {
  InsertableImages?: InsertableImage[] | null;
}
function fromImageInserter(input?: ImageInserter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    insertableImages: input["InsertableImages"]?.map(x => fromInsertableImage(x)),
  }
}
function toImageInserter(root: jsonP.JSONValue): ImageInserter {
  return jsonP.readObj({
    required: {},
    optional: {
      "InsertableImages": [toInsertableImage],
    },
  }, root);
}

// refs: 26 - tags: input, named, interface, output
export interface InsertableImage {
  Duration?: number | null;
  FadeIn?: number | null;
  FadeOut?: number | null;
  Height?: number | null;
  ImageInserterInput?: string | null;
  ImageX?: number | null;
  ImageY?: number | null;
  Layer?: number | null;
  Opacity?: number | null;
  StartTime?: string | null;
  Width?: number | null;
}
function fromInsertableImage(input?: InsertableImage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    duration: input["Duration"],
    fadeIn: input["FadeIn"],
    fadeOut: input["FadeOut"],
    height: input["Height"],
    imageInserterInput: input["ImageInserterInput"],
    imageX: input["ImageX"],
    imageY: input["ImageY"],
    layer: input["Layer"],
    opacity: input["Opacity"],
    startTime: input["StartTime"],
    width: input["Width"],
  }
}
function toInsertableImage(root: jsonP.JSONValue): InsertableImage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Duration": "n",
      "FadeIn": "n",
      "FadeOut": "n",
      "Height": "n",
      "ImageInserterInput": "s",
      "ImageX": "n",
      "ImageY": "n",
      "Layer": "n",
      "Opacity": "n",
      "StartTime": "s",
      "Width": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface InputClipping {
  EndTimecode?: string | null;
  StartTimecode?: string | null;
}
function fromInputClipping(input?: InputClipping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    endTimecode: input["EndTimecode"],
    startTimecode: input["StartTimecode"],
  }
}
function toInputClipping(root: jsonP.JSONValue): InputClipping {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndTimecode": "s",
      "StartTimecode": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type InputScanType =
| "AUTO"
| "PSF"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type InputPsiControl =
| "IGNORE_PSI"
| "USE_PSI"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type InputTimecodeSource =
| "EMBEDDED"
| "ZEROBASED"
| "SPECIFIEDSTART"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface VideoSelector {
  AlphaBehavior?: AlphaBehavior | null;
  ColorSpace?: ColorSpace | null;
  ColorSpaceUsage?: ColorSpaceUsage | null;
  Hdr10Metadata?: Hdr10Metadata | null;
  Pid?: number | null;
  ProgramNumber?: number | null;
  Rotate?: InputRotate | null;
}
function fromVideoSelector(input?: VideoSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alphaBehavior: input["AlphaBehavior"],
    colorSpace: input["ColorSpace"],
    colorSpaceUsage: input["ColorSpaceUsage"],
    hdr10Metadata: fromHdr10Metadata(input["Hdr10Metadata"]),
    pid: input["Pid"],
    programNumber: input["ProgramNumber"],
    rotate: input["Rotate"],
  }
}
function toVideoSelector(root: jsonP.JSONValue): VideoSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "AlphaBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<AlphaBehavior>(x),
      "ColorSpace": (x: jsonP.JSONValue) => cmnP.readEnum<ColorSpace>(x),
      "ColorSpaceUsage": (x: jsonP.JSONValue) => cmnP.readEnum<ColorSpaceUsage>(x),
      "Hdr10Metadata": toHdr10Metadata,
      "Pid": "n",
      "ProgramNumber": "n",
      "Rotate": (x: jsonP.JSONValue) => cmnP.readEnum<InputRotate>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type AlphaBehavior =
| "DISCARD"
| "REMAP_TO_LUMA"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type ColorSpace =
| "FOLLOW"
| "REC_601"
| "REC_709"
| "HDR10"
| "HLG_2020"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type ColorSpaceUsage =
| "FORCE"
| "FALLBACK"
| cmnP.UnexpectedEnumValue;

// refs: 26 - tags: input, named, interface, output
export interface Hdr10Metadata {
  BluePrimaryX?: number | null;
  BluePrimaryY?: number | null;
  GreenPrimaryX?: number | null;
  GreenPrimaryY?: number | null;
  MaxContentLightLevel?: number | null;
  MaxFrameAverageLightLevel?: number | null;
  MaxLuminance?: number | null;
  MinLuminance?: number | null;
  RedPrimaryX?: number | null;
  RedPrimaryY?: number | null;
  WhitePointX?: number | null;
  WhitePointY?: number | null;
}
function fromHdr10Metadata(input?: Hdr10Metadata | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bluePrimaryX: input["BluePrimaryX"],
    bluePrimaryY: input["BluePrimaryY"],
    greenPrimaryX: input["GreenPrimaryX"],
    greenPrimaryY: input["GreenPrimaryY"],
    maxContentLightLevel: input["MaxContentLightLevel"],
    maxFrameAverageLightLevel: input["MaxFrameAverageLightLevel"],
    maxLuminance: input["MaxLuminance"],
    minLuminance: input["MinLuminance"],
    redPrimaryX: input["RedPrimaryX"],
    redPrimaryY: input["RedPrimaryY"],
    whitePointX: input["WhitePointX"],
    whitePointY: input["WhitePointY"],
  }
}
function toHdr10Metadata(root: jsonP.JSONValue): Hdr10Metadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "BluePrimaryX": "n",
      "BluePrimaryY": "n",
      "GreenPrimaryX": "n",
      "GreenPrimaryY": "n",
      "MaxContentLightLevel": "n",
      "MaxFrameAverageLightLevel": "n",
      "MaxLuminance": "n",
      "MinLuminance": "n",
      "RedPrimaryX": "n",
      "RedPrimaryY": "n",
      "WhitePointX": "n",
      "WhitePointY": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type InputRotate =
| "DEGREE_0"
| "DEGREES_90"
| "DEGREES_180"
| "DEGREES_270"
| "AUTO"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface MotionImageInserter {
  Framerate?: MotionImageInsertionFramerate | null;
  Input?: string | null;
  InsertionMode?: MotionImageInsertionMode | null;
  Offset?: MotionImageInsertionOffset | null;
  Playback?: MotionImagePlayback | null;
  StartTime?: string | null;
}
function fromMotionImageInserter(input?: MotionImageInserter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerate: fromMotionImageInsertionFramerate(input["Framerate"]),
    input: input["Input"],
    insertionMode: input["InsertionMode"],
    offset: fromMotionImageInsertionOffset(input["Offset"]),
    playback: input["Playback"],
    startTime: input["StartTime"],
  }
}
function toMotionImageInserter(root: jsonP.JSONValue): MotionImageInserter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Framerate": toMotionImageInsertionFramerate,
      "Input": "s",
      "InsertionMode": (x: jsonP.JSONValue) => cmnP.readEnum<MotionImageInsertionMode>(x),
      "Offset": toMotionImageInsertionOffset,
      "Playback": (x: jsonP.JSONValue) => cmnP.readEnum<MotionImagePlayback>(x),
      "StartTime": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface MotionImageInsertionFramerate {
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
}
function fromMotionImageInsertionFramerate(input?: MotionImageInsertionFramerate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
  }
}
function toMotionImageInsertionFramerate(root: jsonP.JSONValue): MotionImageInsertionFramerate {
  return jsonP.readObj({
    required: {},
    optional: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type MotionImageInsertionMode =
| "MOV"
| "PNG"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface MotionImageInsertionOffset {
  ImageX?: number | null;
  ImageY?: number | null;
}
function fromMotionImageInsertionOffset(input?: MotionImageInsertionOffset | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    imageX: input["ImageX"],
    imageY: input["ImageY"],
  }
}
function toMotionImageInsertionOffset(root: jsonP.JSONValue): MotionImageInsertionOffset {
  return jsonP.readObj({
    required: {},
    optional: {
      "ImageX": "n",
      "ImageY": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type MotionImagePlayback =
| "ONCE"
| "REPEAT"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface NielsenConfiguration {
  BreakoutCode?: number | null;
  DistributorId?: string | null;
}
function fromNielsenConfiguration(input?: NielsenConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    breakoutCode: input["BreakoutCode"],
    distributorId: input["DistributorId"],
  }
}
function toNielsenConfiguration(root: jsonP.JSONValue): NielsenConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "BreakoutCode": "n",
      "DistributorId": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface NielsenNonLinearWatermarkSettings {
  ActiveWatermarkProcess?: NielsenActiveWatermarkProcessType | null;
  AdiFilename?: string | null;
  AssetId?: string | null;
  AssetName?: string | null;
  CbetSourceId?: string | null;
  EpisodeId?: string | null;
  MetadataDestination?: string | null;
  SourceId?: number | null;
  SourceWatermarkStatus?: NielsenSourceWatermarkStatusType | null;
  TicServerUrl?: string | null;
  UniqueTicPerAudioTrack?: NielsenUniqueTicPerAudioTrackType | null;
}
function fromNielsenNonLinearWatermarkSettings(input?: NielsenNonLinearWatermarkSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    activeWatermarkProcess: input["ActiveWatermarkProcess"],
    adiFilename: input["AdiFilename"],
    assetId: input["AssetId"],
    assetName: input["AssetName"],
    cbetSourceId: input["CbetSourceId"],
    episodeId: input["EpisodeId"],
    metadataDestination: input["MetadataDestination"],
    sourceId: input["SourceId"],
    sourceWatermarkStatus: input["SourceWatermarkStatus"],
    ticServerUrl: input["TicServerUrl"],
    uniqueTicPerAudioTrack: input["UniqueTicPerAudioTrack"],
  }
}
function toNielsenNonLinearWatermarkSettings(root: jsonP.JSONValue): NielsenNonLinearWatermarkSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveWatermarkProcess": (x: jsonP.JSONValue) => cmnP.readEnum<NielsenActiveWatermarkProcessType>(x),
      "AdiFilename": "s",
      "AssetId": "s",
      "AssetName": "s",
      "CbetSourceId": "s",
      "EpisodeId": "s",
      "MetadataDestination": "s",
      "SourceId": "n",
      "SourceWatermarkStatus": (x: jsonP.JSONValue) => cmnP.readEnum<NielsenSourceWatermarkStatusType>(x),
      "TicServerUrl": "s",
      "UniqueTicPerAudioTrack": (x: jsonP.JSONValue) => cmnP.readEnum<NielsenUniqueTicPerAudioTrackType>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type NielsenActiveWatermarkProcessType =
| "NAES2_AND_NW"
| "CBET"
| "NAES2_AND_NW_AND_CBET"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type NielsenSourceWatermarkStatusType =
| "CLEAN"
| "WATERMARKED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type NielsenUniqueTicPerAudioTrackType =
| "RESERVE_UNIQUE_TICS_PER_TRACK"
| "SAME_TICS_PER_TRACK"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface OutputGroup {
  CustomName?: string | null;
  Name?: string | null;
  OutputGroupSettings?: OutputGroupSettings | null;
  Outputs?: Output[] | null;
}
function fromOutputGroup(input?: OutputGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    customName: input["CustomName"],
    name: input["Name"],
    outputGroupSettings: fromOutputGroupSettings(input["OutputGroupSettings"]),
    outputs: input["Outputs"]?.map(x => fromOutput(x)),
  }
}
function toOutputGroup(root: jsonP.JSONValue): OutputGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomName": "s",
      "Name": "s",
      "OutputGroupSettings": toOutputGroupSettings,
      "Outputs": [toOutput],
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface OutputGroupSettings {
  CmafGroupSettings?: CmafGroupSettings | null;
  DashIsoGroupSettings?: DashIsoGroupSettings | null;
  FileGroupSettings?: FileGroupSettings | null;
  HlsGroupSettings?: HlsGroupSettings | null;
  MsSmoothGroupSettings?: MsSmoothGroupSettings | null;
  Type?: OutputGroupType | null;
}
function fromOutputGroupSettings(input?: OutputGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cmafGroupSettings: fromCmafGroupSettings(input["CmafGroupSettings"]),
    dashIsoGroupSettings: fromDashIsoGroupSettings(input["DashIsoGroupSettings"]),
    fileGroupSettings: fromFileGroupSettings(input["FileGroupSettings"]),
    hlsGroupSettings: fromHlsGroupSettings(input["HlsGroupSettings"]),
    msSmoothGroupSettings: fromMsSmoothGroupSettings(input["MsSmoothGroupSettings"]),
    type: input["Type"],
  }
}
function toOutputGroupSettings(root: jsonP.JSONValue): OutputGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CmafGroupSettings": toCmafGroupSettings,
      "DashIsoGroupSettings": toDashIsoGroupSettings,
      "FileGroupSettings": toFileGroupSettings,
      "HlsGroupSettings": toHlsGroupSettings,
      "MsSmoothGroupSettings": toMsSmoothGroupSettings,
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<OutputGroupType>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface CmafGroupSettings {
  AdditionalManifests?: CmafAdditionalManifest[] | null;
  BaseUrl?: string | null;
  ClientCache?: CmafClientCache | null;
  CodecSpecification?: CmafCodecSpecification | null;
  Destination?: string | null;
  DestinationSettings?: DestinationSettings | null;
  Encryption?: CmafEncryptionSettings | null;
  FragmentLength?: number | null;
  ManifestCompression?: CmafManifestCompression | null;
  ManifestDurationFormat?: CmafManifestDurationFormat | null;
  MinBufferTime?: number | null;
  MinFinalSegmentLength?: number | null;
  MpdProfile?: CmafMpdProfile | null;
  SegmentControl?: CmafSegmentControl | null;
  SegmentLength?: number | null;
  StreamInfResolution?: CmafStreamInfResolution | null;
  WriteDashManifest?: CmafWriteDASHManifest | null;
  WriteHlsManifest?: CmafWriteHLSManifest | null;
  WriteSegmentTimelineInRepresentation?: CmafWriteSegmentTimelineInRepresentation | null;
}
function fromCmafGroupSettings(input?: CmafGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    additionalManifests: input["AdditionalManifests"]?.map(x => fromCmafAdditionalManifest(x)),
    baseUrl: input["BaseUrl"],
    clientCache: input["ClientCache"],
    codecSpecification: input["CodecSpecification"],
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
    encryption: fromCmafEncryptionSettings(input["Encryption"]),
    fragmentLength: input["FragmentLength"],
    manifestCompression: input["ManifestCompression"],
    manifestDurationFormat: input["ManifestDurationFormat"],
    minBufferTime: input["MinBufferTime"],
    minFinalSegmentLength: input["MinFinalSegmentLength"],
    mpdProfile: input["MpdProfile"],
    segmentControl: input["SegmentControl"],
    segmentLength: input["SegmentLength"],
    streamInfResolution: input["StreamInfResolution"],
    writeDashManifest: input["WriteDashManifest"],
    writeHlsManifest: input["WriteHlsManifest"],
    writeSegmentTimelineInRepresentation: input["WriteSegmentTimelineInRepresentation"],
  }
}
function toCmafGroupSettings(root: jsonP.JSONValue): CmafGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdditionalManifests": [toCmafAdditionalManifest],
      "BaseUrl": "s",
      "ClientCache": (x: jsonP.JSONValue) => cmnP.readEnum<CmafClientCache>(x),
      "CodecSpecification": (x: jsonP.JSONValue) => cmnP.readEnum<CmafCodecSpecification>(x),
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
      "Encryption": toCmafEncryptionSettings,
      "FragmentLength": "n",
      "ManifestCompression": (x: jsonP.JSONValue) => cmnP.readEnum<CmafManifestCompression>(x),
      "ManifestDurationFormat": (x: jsonP.JSONValue) => cmnP.readEnum<CmafManifestDurationFormat>(x),
      "MinBufferTime": "n",
      "MinFinalSegmentLength": "n",
      "MpdProfile": (x: jsonP.JSONValue) => cmnP.readEnum<CmafMpdProfile>(x),
      "SegmentControl": (x: jsonP.JSONValue) => cmnP.readEnum<CmafSegmentControl>(x),
      "SegmentLength": "n",
      "StreamInfResolution": (x: jsonP.JSONValue) => cmnP.readEnum<CmafStreamInfResolution>(x),
      "WriteDashManifest": (x: jsonP.JSONValue) => cmnP.readEnum<CmafWriteDASHManifest>(x),
      "WriteHlsManifest": (x: jsonP.JSONValue) => cmnP.readEnum<CmafWriteHLSManifest>(x),
      "WriteSegmentTimelineInRepresentation": (x: jsonP.JSONValue) => cmnP.readEnum<CmafWriteSegmentTimelineInRepresentation>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface CmafAdditionalManifest {
  ManifestNameModifier?: string | null;
  SelectedOutputs?: string[] | null;
}
function fromCmafAdditionalManifest(input?: CmafAdditionalManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestNameModifier: input["ManifestNameModifier"],
    selectedOutputs: input["SelectedOutputs"],
  }
}
function toCmafAdditionalManifest(root: jsonP.JSONValue): CmafAdditionalManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestNameModifier": "s",
      "SelectedOutputs": ["s"],
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type CmafClientCache =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafCodecSpecification =
| "RFC_6381"
| "RFC_4281"
| cmnP.UnexpectedEnumValue;

// refs: 50 - tags: input, named, interface, output
export interface DestinationSettings {
  S3Settings?: S3DestinationSettings | null;
}
function fromDestinationSettings(input?: DestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Settings: fromS3DestinationSettings(input["S3Settings"]),
  }
}
function toDestinationSettings(root: jsonP.JSONValue): DestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Settings": toS3DestinationSettings,
    },
  }, root);
}

// refs: 50 - tags: input, named, interface, output
export interface S3DestinationSettings {
  AccessControl?: S3DestinationAccessControl | null;
  Encryption?: S3EncryptionSettings | null;
}
function fromS3DestinationSettings(input?: S3DestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessControl: fromS3DestinationAccessControl(input["AccessControl"]),
    encryption: fromS3EncryptionSettings(input["Encryption"]),
  }
}
function toS3DestinationSettings(root: jsonP.JSONValue): S3DestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccessControl": toS3DestinationAccessControl,
      "Encryption": toS3EncryptionSettings,
    },
  }, root);
}

// refs: 50 - tags: input, named, interface, output
export interface S3DestinationAccessControl {
  CannedAcl?: S3ObjectCannedAcl | null;
}
function fromS3DestinationAccessControl(input?: S3DestinationAccessControl | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cannedAcl: input["CannedAcl"],
  }
}
function toS3DestinationAccessControl(root: jsonP.JSONValue): S3DestinationAccessControl {
  return jsonP.readObj({
    required: {},
    optional: {
      "CannedAcl": (x: jsonP.JSONValue) => cmnP.readEnum<S3ObjectCannedAcl>(x),
    },
  }, root);
}

// refs: 50 - tags: input, named, enum, output
export type S3ObjectCannedAcl =
| "PUBLIC_READ"
| "AUTHENTICATED_READ"
| "BUCKET_OWNER_READ"
| "BUCKET_OWNER_FULL_CONTROL"
| cmnP.UnexpectedEnumValue;

// refs: 50 - tags: input, named, interface, output
export interface S3EncryptionSettings {
  EncryptionType?: S3ServerSideEncryptionType | null;
  KmsKeyArn?: string | null;
}
function fromS3EncryptionSettings(input?: S3EncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryptionType: input["EncryptionType"],
    kmsKeyArn: input["KmsKeyArn"],
  }
}
function toS3EncryptionSettings(root: jsonP.JSONValue): S3EncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<S3ServerSideEncryptionType>(x),
      "KmsKeyArn": "s",
    },
  }, root);
}

// refs: 50 - tags: input, named, enum, output
export type S3ServerSideEncryptionType =
| "SERVER_SIDE_ENCRYPTION_S3"
| "SERVER_SIDE_ENCRYPTION_KMS"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface CmafEncryptionSettings {
  ConstantInitializationVector?: string | null;
  EncryptionMethod?: CmafEncryptionType | null;
  InitializationVectorInManifest?: CmafInitializationVectorInManifest | null;
  SpekeKeyProvider?: SpekeKeyProviderCmaf | null;
  StaticKeyProvider?: StaticKeyProvider | null;
  Type?: CmafKeyProviderType | null;
}
function fromCmafEncryptionSettings(input?: CmafEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constantInitializationVector: input["ConstantInitializationVector"],
    encryptionMethod: input["EncryptionMethod"],
    initializationVectorInManifest: input["InitializationVectorInManifest"],
    spekeKeyProvider: fromSpekeKeyProviderCmaf(input["SpekeKeyProvider"]),
    staticKeyProvider: fromStaticKeyProvider(input["StaticKeyProvider"]),
    type: input["Type"],
  }
}
function toCmafEncryptionSettings(root: jsonP.JSONValue): CmafEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConstantInitializationVector": "s",
      "EncryptionMethod": (x: jsonP.JSONValue) => cmnP.readEnum<CmafEncryptionType>(x),
      "InitializationVectorInManifest": (x: jsonP.JSONValue) => cmnP.readEnum<CmafInitializationVectorInManifest>(x),
      "SpekeKeyProvider": toSpekeKeyProviderCmaf,
      "StaticKeyProvider": toStaticKeyProvider,
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<CmafKeyProviderType>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type CmafEncryptionType =
| "SAMPLE_AES"
| "AES_CTR"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafInitializationVectorInManifest =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface SpekeKeyProviderCmaf {
  CertificateArn?: string | null;
  DashSignaledSystemIds?: string[] | null;
  HlsSignaledSystemIds?: string[] | null;
  ResourceId?: string | null;
  Url?: string | null;
}
function fromSpekeKeyProviderCmaf(input?: SpekeKeyProviderCmaf | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["CertificateArn"],
    dashSignaledSystemIds: input["DashSignaledSystemIds"],
    hlsSignaledSystemIds: input["HlsSignaledSystemIds"],
    resourceId: input["ResourceId"],
    url: input["Url"],
  }
}
function toSpekeKeyProviderCmaf(root: jsonP.JSONValue): SpekeKeyProviderCmaf {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateArn": "s",
      "DashSignaledSystemIds": ["s"],
      "HlsSignaledSystemIds": ["s"],
      "ResourceId": "s",
      "Url": "s",
    },
  }, root);
}

// refs: 20 - tags: input, named, interface, output
export interface StaticKeyProvider {
  KeyFormat?: string | null;
  KeyFormatVersions?: string | null;
  StaticKeyValue?: string | null;
  Url?: string | null;
}
function fromStaticKeyProvider(input?: StaticKeyProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyFormat: input["KeyFormat"],
    keyFormatVersions: input["KeyFormatVersions"],
    staticKeyValue: input["StaticKeyValue"],
    url: input["Url"],
  }
}
function toStaticKeyProvider(root: jsonP.JSONValue): StaticKeyProvider {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyFormat": "s",
      "KeyFormatVersions": "s",
      "StaticKeyValue": "s",
      "Url": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type CmafKeyProviderType =
| "SPEKE"
| "STATIC_KEY"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafManifestCompression =
| "GZIP"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafManifestDurationFormat =
| "FLOATING_POINT"
| "INTEGER"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafMpdProfile =
| "MAIN_PROFILE"
| "ON_DEMAND_PROFILE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafSegmentControl =
| "SINGLE_FILE"
| "SEGMENTED_FILES"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafStreamInfResolution =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafWriteDASHManifest =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafWriteHLSManifest =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CmafWriteSegmentTimelineInRepresentation =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface DashIsoGroupSettings {
  AdditionalManifests?: DashAdditionalManifest[] | null;
  BaseUrl?: string | null;
  Destination?: string | null;
  DestinationSettings?: DestinationSettings | null;
  Encryption?: DashIsoEncryptionSettings | null;
  FragmentLength?: number | null;
  HbbtvCompliance?: DashIsoHbbtvCompliance | null;
  MinBufferTime?: number | null;
  MpdProfile?: DashIsoMpdProfile | null;
  SegmentControl?: DashIsoSegmentControl | null;
  SegmentLength?: number | null;
  WriteSegmentTimelineInRepresentation?: DashIsoWriteSegmentTimelineInRepresentation | null;
}
function fromDashIsoGroupSettings(input?: DashIsoGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    additionalManifests: input["AdditionalManifests"]?.map(x => fromDashAdditionalManifest(x)),
    baseUrl: input["BaseUrl"],
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
    encryption: fromDashIsoEncryptionSettings(input["Encryption"]),
    fragmentLength: input["FragmentLength"],
    hbbtvCompliance: input["HbbtvCompliance"],
    minBufferTime: input["MinBufferTime"],
    mpdProfile: input["MpdProfile"],
    segmentControl: input["SegmentControl"],
    segmentLength: input["SegmentLength"],
    writeSegmentTimelineInRepresentation: input["WriteSegmentTimelineInRepresentation"],
  }
}
function toDashIsoGroupSettings(root: jsonP.JSONValue): DashIsoGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdditionalManifests": [toDashAdditionalManifest],
      "BaseUrl": "s",
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
      "Encryption": toDashIsoEncryptionSettings,
      "FragmentLength": "n",
      "HbbtvCompliance": (x: jsonP.JSONValue) => cmnP.readEnum<DashIsoHbbtvCompliance>(x),
      "MinBufferTime": "n",
      "MpdProfile": (x: jsonP.JSONValue) => cmnP.readEnum<DashIsoMpdProfile>(x),
      "SegmentControl": (x: jsonP.JSONValue) => cmnP.readEnum<DashIsoSegmentControl>(x),
      "SegmentLength": "n",
      "WriteSegmentTimelineInRepresentation": (x: jsonP.JSONValue) => cmnP.readEnum<DashIsoWriteSegmentTimelineInRepresentation>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface DashAdditionalManifest {
  ManifestNameModifier?: string | null;
  SelectedOutputs?: string[] | null;
}
function fromDashAdditionalManifest(input?: DashAdditionalManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestNameModifier: input["ManifestNameModifier"],
    selectedOutputs: input["SelectedOutputs"],
  }
}
function toDashAdditionalManifest(root: jsonP.JSONValue): DashAdditionalManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestNameModifier": "s",
      "SelectedOutputs": ["s"],
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface DashIsoEncryptionSettings {
  PlaybackDeviceCompatibility?: DashIsoPlaybackDeviceCompatibility | null;
  SpekeKeyProvider?: SpekeKeyProvider | null;
}
function fromDashIsoEncryptionSettings(input?: DashIsoEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    playbackDeviceCompatibility: input["PlaybackDeviceCompatibility"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toDashIsoEncryptionSettings(root: jsonP.JSONValue): DashIsoEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlaybackDeviceCompatibility": (x: jsonP.JSONValue) => cmnP.readEnum<DashIsoPlaybackDeviceCompatibility>(x),
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type DashIsoPlaybackDeviceCompatibility =
| "CENC_V1"
| "UNENCRYPTED_SEI"
| cmnP.UnexpectedEnumValue;

// refs: 30 - tags: input, named, interface, output
export interface SpekeKeyProvider {
  CertificateArn?: string | null;
  ResourceId?: string | null;
  SystemIds?: string[] | null;
  Url?: string | null;
}
function fromSpekeKeyProvider(input?: SpekeKeyProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["CertificateArn"],
    resourceId: input["ResourceId"],
    systemIds: input["SystemIds"],
    url: input["Url"],
  }
}
function toSpekeKeyProvider(root: jsonP.JSONValue): SpekeKeyProvider {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateArn": "s",
      "ResourceId": "s",
      "SystemIds": ["s"],
      "Url": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type DashIsoHbbtvCompliance =
| "HBBTV_1_5"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type DashIsoMpdProfile =
| "MAIN_PROFILE"
| "ON_DEMAND_PROFILE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type DashIsoSegmentControl =
| "SINGLE_FILE"
| "SEGMENTED_FILES"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type DashIsoWriteSegmentTimelineInRepresentation =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface FileGroupSettings {
  Destination?: string | null;
  DestinationSettings?: DestinationSettings | null;
}
function fromFileGroupSettings(input?: FileGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
  }
}
function toFileGroupSettings(root: jsonP.JSONValue): FileGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface HlsGroupSettings {
  AdMarkers?: HlsAdMarkers[] | null;
  AdditionalManifests?: HlsAdditionalManifest[] | null;
  AudioOnlyHeader?: HlsAudioOnlyHeader | null;
  BaseUrl?: string | null;
  CaptionLanguageMappings?: HlsCaptionLanguageMapping[] | null;
  CaptionLanguageSetting?: HlsCaptionLanguageSetting | null;
  ClientCache?: HlsClientCache | null;
  CodecSpecification?: HlsCodecSpecification | null;
  Destination?: string | null;
  DestinationSettings?: DestinationSettings | null;
  DirectoryStructure?: HlsDirectoryStructure | null;
  Encryption?: HlsEncryptionSettings | null;
  ManifestCompression?: HlsManifestCompression | null;
  ManifestDurationFormat?: HlsManifestDurationFormat | null;
  MinFinalSegmentLength?: number | null;
  MinSegmentLength?: number | null;
  OutputSelection?: HlsOutputSelection | null;
  ProgramDateTime?: HlsProgramDateTime | null;
  ProgramDateTimePeriod?: number | null;
  SegmentControl?: HlsSegmentControl | null;
  SegmentLength?: number | null;
  SegmentsPerSubdirectory?: number | null;
  StreamInfResolution?: HlsStreamInfResolution | null;
  TimedMetadataId3Frame?: HlsTimedMetadataId3Frame | null;
  TimedMetadataId3Period?: number | null;
  TimestampDeltaMilliseconds?: number | null;
}
function fromHlsGroupSettings(input?: HlsGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    additionalManifests: input["AdditionalManifests"]?.map(x => fromHlsAdditionalManifest(x)),
    audioOnlyHeader: input["AudioOnlyHeader"],
    baseUrl: input["BaseUrl"],
    captionLanguageMappings: input["CaptionLanguageMappings"]?.map(x => fromHlsCaptionLanguageMapping(x)),
    captionLanguageSetting: input["CaptionLanguageSetting"],
    clientCache: input["ClientCache"],
    codecSpecification: input["CodecSpecification"],
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
    directoryStructure: input["DirectoryStructure"],
    encryption: fromHlsEncryptionSettings(input["Encryption"]),
    manifestCompression: input["ManifestCompression"],
    manifestDurationFormat: input["ManifestDurationFormat"],
    minFinalSegmentLength: input["MinFinalSegmentLength"],
    minSegmentLength: input["MinSegmentLength"],
    outputSelection: input["OutputSelection"],
    programDateTime: input["ProgramDateTime"],
    programDateTimePeriod: input["ProgramDateTimePeriod"],
    segmentControl: input["SegmentControl"],
    segmentLength: input["SegmentLength"],
    segmentsPerSubdirectory: input["SegmentsPerSubdirectory"],
    streamInfResolution: input["StreamInfResolution"],
    timedMetadataId3Frame: input["TimedMetadataId3Frame"],
    timedMetadataId3Period: input["TimedMetadataId3Period"],
    timestampDeltaMilliseconds: input["TimestampDeltaMilliseconds"],
  }
}
function toHlsGroupSettings(root: jsonP.JSONValue): HlsGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdMarkers": [(x: jsonP.JSONValue) => cmnP.readEnum<HlsAdMarkers>(x)],
      "AdditionalManifests": [toHlsAdditionalManifest],
      "AudioOnlyHeader": (x: jsonP.JSONValue) => cmnP.readEnum<HlsAudioOnlyHeader>(x),
      "BaseUrl": "s",
      "CaptionLanguageMappings": [toHlsCaptionLanguageMapping],
      "CaptionLanguageSetting": (x: jsonP.JSONValue) => cmnP.readEnum<HlsCaptionLanguageSetting>(x),
      "ClientCache": (x: jsonP.JSONValue) => cmnP.readEnum<HlsClientCache>(x),
      "CodecSpecification": (x: jsonP.JSONValue) => cmnP.readEnum<HlsCodecSpecification>(x),
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
      "DirectoryStructure": (x: jsonP.JSONValue) => cmnP.readEnum<HlsDirectoryStructure>(x),
      "Encryption": toHlsEncryptionSettings,
      "ManifestCompression": (x: jsonP.JSONValue) => cmnP.readEnum<HlsManifestCompression>(x),
      "ManifestDurationFormat": (x: jsonP.JSONValue) => cmnP.readEnum<HlsManifestDurationFormat>(x),
      "MinFinalSegmentLength": "n",
      "MinSegmentLength": "n",
      "OutputSelection": (x: jsonP.JSONValue) => cmnP.readEnum<HlsOutputSelection>(x),
      "ProgramDateTime": (x: jsonP.JSONValue) => cmnP.readEnum<HlsProgramDateTime>(x),
      "ProgramDateTimePeriod": "n",
      "SegmentControl": (x: jsonP.JSONValue) => cmnP.readEnum<HlsSegmentControl>(x),
      "SegmentLength": "n",
      "SegmentsPerSubdirectory": "n",
      "StreamInfResolution": (x: jsonP.JSONValue) => cmnP.readEnum<HlsStreamInfResolution>(x),
      "TimedMetadataId3Frame": (x: jsonP.JSONValue) => cmnP.readEnum<HlsTimedMetadataId3Frame>(x),
      "TimedMetadataId3Period": "n",
      "TimestampDeltaMilliseconds": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type HlsAdMarkers =
| "ELEMENTAL"
| "ELEMENTAL_SCTE35"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface HlsAdditionalManifest {
  ManifestNameModifier?: string | null;
  SelectedOutputs?: string[] | null;
}
function fromHlsAdditionalManifest(input?: HlsAdditionalManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestNameModifier: input["ManifestNameModifier"],
    selectedOutputs: input["SelectedOutputs"],
  }
}
function toHlsAdditionalManifest(root: jsonP.JSONValue): HlsAdditionalManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestNameModifier": "s",
      "SelectedOutputs": ["s"],
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type HlsAudioOnlyHeader =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface HlsCaptionLanguageMapping {
  CaptionChannel?: number | null;
  CustomLanguageCode?: string | null;
  LanguageCode?: LanguageCode | null;
  LanguageDescription?: string | null;
}
function fromHlsCaptionLanguageMapping(input?: HlsCaptionLanguageMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captionChannel: input["CaptionChannel"],
    customLanguageCode: input["CustomLanguageCode"],
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
  }
}
function toHlsCaptionLanguageMapping(root: jsonP.JSONValue): HlsCaptionLanguageMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "CaptionChannel": "n",
      "CustomLanguageCode": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "LanguageDescription": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type HlsCaptionLanguageSetting =
| "INSERT"
| "OMIT"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsClientCache =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsCodecSpecification =
| "RFC_6381"
| "RFC_4281"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsDirectoryStructure =
| "SINGLE_DIRECTORY"
| "SUBDIRECTORY_PER_STREAM"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface HlsEncryptionSettings {
  ConstantInitializationVector?: string | null;
  EncryptionMethod?: HlsEncryptionType | null;
  InitializationVectorInManifest?: HlsInitializationVectorInManifest | null;
  OfflineEncrypted?: HlsOfflineEncrypted | null;
  SpekeKeyProvider?: SpekeKeyProvider | null;
  StaticKeyProvider?: StaticKeyProvider | null;
  Type?: HlsKeyProviderType | null;
}
function fromHlsEncryptionSettings(input?: HlsEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constantInitializationVector: input["ConstantInitializationVector"],
    encryptionMethod: input["EncryptionMethod"],
    initializationVectorInManifest: input["InitializationVectorInManifest"],
    offlineEncrypted: input["OfflineEncrypted"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
    staticKeyProvider: fromStaticKeyProvider(input["StaticKeyProvider"]),
    type: input["Type"],
  }
}
function toHlsEncryptionSettings(root: jsonP.JSONValue): HlsEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConstantInitializationVector": "s",
      "EncryptionMethod": (x: jsonP.JSONValue) => cmnP.readEnum<HlsEncryptionType>(x),
      "InitializationVectorInManifest": (x: jsonP.JSONValue) => cmnP.readEnum<HlsInitializationVectorInManifest>(x),
      "OfflineEncrypted": (x: jsonP.JSONValue) => cmnP.readEnum<HlsOfflineEncrypted>(x),
      "SpekeKeyProvider": toSpekeKeyProvider,
      "StaticKeyProvider": toStaticKeyProvider,
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<HlsKeyProviderType>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type HlsEncryptionType =
| "AES128"
| "SAMPLE_AES"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsInitializationVectorInManifest =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsOfflineEncrypted =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsKeyProviderType =
| "SPEKE"
| "STATIC_KEY"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsManifestCompression =
| "GZIP"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsManifestDurationFormat =
| "FLOATING_POINT"
| "INTEGER"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsOutputSelection =
| "MANIFESTS_AND_SEGMENTS"
| "SEGMENTS_ONLY"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsProgramDateTime =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsSegmentControl =
| "SINGLE_FILE"
| "SEGMENTED_FILES"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsStreamInfResolution =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsTimedMetadataId3Frame =
| "NONE"
| "PRIV"
| "TDRL"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface MsSmoothGroupSettings {
  AdditionalManifests?: MsSmoothAdditionalManifest[] | null;
  AudioDeduplication?: MsSmoothAudioDeduplication | null;
  Destination?: string | null;
  DestinationSettings?: DestinationSettings | null;
  Encryption?: MsSmoothEncryptionSettings | null;
  FragmentLength?: number | null;
  ManifestEncoding?: MsSmoothManifestEncoding | null;
}
function fromMsSmoothGroupSettings(input?: MsSmoothGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    additionalManifests: input["AdditionalManifests"]?.map(x => fromMsSmoothAdditionalManifest(x)),
    audioDeduplication: input["AudioDeduplication"],
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
    encryption: fromMsSmoothEncryptionSettings(input["Encryption"]),
    fragmentLength: input["FragmentLength"],
    manifestEncoding: input["ManifestEncoding"],
  }
}
function toMsSmoothGroupSettings(root: jsonP.JSONValue): MsSmoothGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdditionalManifests": [toMsSmoothAdditionalManifest],
      "AudioDeduplication": (x: jsonP.JSONValue) => cmnP.readEnum<MsSmoothAudioDeduplication>(x),
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
      "Encryption": toMsSmoothEncryptionSettings,
      "FragmentLength": "n",
      "ManifestEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<MsSmoothManifestEncoding>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface MsSmoothAdditionalManifest {
  ManifestNameModifier?: string | null;
  SelectedOutputs?: string[] | null;
}
function fromMsSmoothAdditionalManifest(input?: MsSmoothAdditionalManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestNameModifier: input["ManifestNameModifier"],
    selectedOutputs: input["SelectedOutputs"],
  }
}
function toMsSmoothAdditionalManifest(root: jsonP.JSONValue): MsSmoothAdditionalManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestNameModifier": "s",
      "SelectedOutputs": ["s"],
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type MsSmoothAudioDeduplication =
| "COMBINE_DUPLICATE_STREAMS"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface MsSmoothEncryptionSettings {
  SpekeKeyProvider?: SpekeKeyProvider | null;
}
function fromMsSmoothEncryptionSettings(input?: MsSmoothEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toMsSmoothEncryptionSettings(root: jsonP.JSONValue): MsSmoothEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type MsSmoothManifestEncoding =
| "UTF8"
| "UTF16"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type OutputGroupType =
| "HLS_GROUP_SETTINGS"
| "DASH_ISO_GROUP_SETTINGS"
| "FILE_GROUP_SETTINGS"
| "MS_SMOOTH_GROUP_SETTINGS"
| "CMAF_GROUP_SETTINGS"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface Output {
  AudioDescriptions?: AudioDescription[] | null;
  CaptionDescriptions?: CaptionDescription[] | null;
  ContainerSettings?: ContainerSettings | null;
  Extension?: string | null;
  NameModifier?: string | null;
  OutputSettings?: OutputSettings | null;
  Preset?: string | null;
  VideoDescription?: VideoDescription | null;
}
function fromOutput(input?: Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptions: input["AudioDescriptions"]?.map(x => fromAudioDescription(x)),
    captionDescriptions: input["CaptionDescriptions"]?.map(x => fromCaptionDescription(x)),
    containerSettings: fromContainerSettings(input["ContainerSettings"]),
    extension: input["Extension"],
    nameModifier: input["NameModifier"],
    outputSettings: fromOutputSettings(input["OutputSettings"]),
    preset: input["Preset"],
    videoDescription: fromVideoDescription(input["VideoDescription"]),
  }
}
function toOutput(root: jsonP.JSONValue): Output {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioDescriptions": [toAudioDescription],
      "CaptionDescriptions": [toCaptionDescription],
      "ContainerSettings": toContainerSettings,
      "Extension": "s",
      "NameModifier": "s",
      "OutputSettings": toOutputSettings,
      "Preset": "s",
      "VideoDescription": toVideoDescription,
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface AudioDescription {
  AudioChannelTaggingSettings?: AudioChannelTaggingSettings | null;
  AudioNormalizationSettings?: AudioNormalizationSettings | null;
  AudioSourceName?: string | null;
  AudioType?: number | null;
  AudioTypeControl?: AudioTypeControl | null;
  CodecSettings?: AudioCodecSettings | null;
  CustomLanguageCode?: string | null;
  LanguageCode?: LanguageCode | null;
  LanguageCodeControl?: AudioLanguageCodeControl | null;
  RemixSettings?: RemixSettings | null;
  StreamName?: string | null;
}
function fromAudioDescription(input?: AudioDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioChannelTaggingSettings: fromAudioChannelTaggingSettings(input["AudioChannelTaggingSettings"]),
    audioNormalizationSettings: fromAudioNormalizationSettings(input["AudioNormalizationSettings"]),
    audioSourceName: input["AudioSourceName"],
    audioType: input["AudioType"],
    audioTypeControl: input["AudioTypeControl"],
    codecSettings: fromAudioCodecSettings(input["CodecSettings"]),
    customLanguageCode: input["CustomLanguageCode"],
    languageCode: input["LanguageCode"],
    languageCodeControl: input["LanguageCodeControl"],
    remixSettings: fromRemixSettings(input["RemixSettings"]),
    streamName: input["StreamName"],
  }
}
function toAudioDescription(root: jsonP.JSONValue): AudioDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioChannelTaggingSettings": toAudioChannelTaggingSettings,
      "AudioNormalizationSettings": toAudioNormalizationSettings,
      "AudioSourceName": "s",
      "AudioType": "n",
      "AudioTypeControl": (x: jsonP.JSONValue) => cmnP.readEnum<AudioTypeControl>(x),
      "CodecSettings": toAudioCodecSettings,
      "CustomLanguageCode": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "LanguageCodeControl": (x: jsonP.JSONValue) => cmnP.readEnum<AudioLanguageCodeControl>(x),
      "RemixSettings": toRemixSettings,
      "StreamName": "s",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface AudioChannelTaggingSettings {
  ChannelTag?: AudioChannelTag | null;
}
function fromAudioChannelTaggingSettings(input?: AudioChannelTaggingSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channelTag: input["ChannelTag"],
  }
}
function toAudioChannelTaggingSettings(root: jsonP.JSONValue): AudioChannelTaggingSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelTag": (x: jsonP.JSONValue) => cmnP.readEnum<AudioChannelTag>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type AudioChannelTag =
| "L"
| "R"
| "C"
| "LFE"
| "LS"
| "RS"
| "LC"
| "RC"
| "CS"
| "LSD"
| "RSD"
| "TCS"
| "VHL"
| "VHC"
| "VHR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface AudioNormalizationSettings {
  Algorithm?: AudioNormalizationAlgorithm | null;
  AlgorithmControl?: AudioNormalizationAlgorithmControl | null;
  CorrectionGateLevel?: number | null;
  LoudnessLogging?: AudioNormalizationLoudnessLogging | null;
  PeakCalculation?: AudioNormalizationPeakCalculation | null;
  TargetLkfs?: number | null;
}
function fromAudioNormalizationSettings(input?: AudioNormalizationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    algorithm: input["Algorithm"],
    algorithmControl: input["AlgorithmControl"],
    correctionGateLevel: input["CorrectionGateLevel"],
    loudnessLogging: input["LoudnessLogging"],
    peakCalculation: input["PeakCalculation"],
    targetLkfs: input["TargetLkfs"],
  }
}
function toAudioNormalizationSettings(root: jsonP.JSONValue): AudioNormalizationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Algorithm": (x: jsonP.JSONValue) => cmnP.readEnum<AudioNormalizationAlgorithm>(x),
      "AlgorithmControl": (x: jsonP.JSONValue) => cmnP.readEnum<AudioNormalizationAlgorithmControl>(x),
      "CorrectionGateLevel": "n",
      "LoudnessLogging": (x: jsonP.JSONValue) => cmnP.readEnum<AudioNormalizationLoudnessLogging>(x),
      "PeakCalculation": (x: jsonP.JSONValue) => cmnP.readEnum<AudioNormalizationPeakCalculation>(x),
      "TargetLkfs": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type AudioNormalizationAlgorithm =
| "ITU_BS_1770_1"
| "ITU_BS_1770_2"
| "ITU_BS_1770_3"
| "ITU_BS_1770_4"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AudioNormalizationAlgorithmControl =
| "CORRECT_AUDIO"
| "MEASURE_ONLY"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AudioNormalizationLoudnessLogging =
| "LOG"
| "DONT_LOG"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AudioNormalizationPeakCalculation =
| "TRUE_PEAK"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AudioTypeControl =
| "FOLLOW_INPUT"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface AudioCodecSettings {
  AacSettings?: AacSettings | null;
  Ac3Settings?: Ac3Settings | null;
  AiffSettings?: AiffSettings | null;
  Codec?: AudioCodec | null;
  Eac3AtmosSettings?: Eac3AtmosSettings | null;
  Eac3Settings?: Eac3Settings | null;
  Mp2Settings?: Mp2Settings | null;
  Mp3Settings?: Mp3Settings | null;
  OpusSettings?: OpusSettings | null;
  VorbisSettings?: VorbisSettings | null;
  WavSettings?: WavSettings | null;
}
function fromAudioCodecSettings(input?: AudioCodecSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    aacSettings: fromAacSettings(input["AacSettings"]),
    ac3Settings: fromAc3Settings(input["Ac3Settings"]),
    aiffSettings: fromAiffSettings(input["AiffSettings"]),
    codec: input["Codec"],
    eac3AtmosSettings: fromEac3AtmosSettings(input["Eac3AtmosSettings"]),
    eac3Settings: fromEac3Settings(input["Eac3Settings"]),
    mp2Settings: fromMp2Settings(input["Mp2Settings"]),
    mp3Settings: fromMp3Settings(input["Mp3Settings"]),
    opusSettings: fromOpusSettings(input["OpusSettings"]),
    vorbisSettings: fromVorbisSettings(input["VorbisSettings"]),
    wavSettings: fromWavSettings(input["WavSettings"]),
  }
}
function toAudioCodecSettings(root: jsonP.JSONValue): AudioCodecSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AacSettings": toAacSettings,
      "Ac3Settings": toAc3Settings,
      "AiffSettings": toAiffSettings,
      "Codec": (x: jsonP.JSONValue) => cmnP.readEnum<AudioCodec>(x),
      "Eac3AtmosSettings": toEac3AtmosSettings,
      "Eac3Settings": toEac3Settings,
      "Mp2Settings": toMp2Settings,
      "Mp3Settings": toMp3Settings,
      "OpusSettings": toOpusSettings,
      "VorbisSettings": toVorbisSettings,
      "WavSettings": toWavSettings,
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface AacSettings {
  AudioDescriptionBroadcasterMix?: AacAudioDescriptionBroadcasterMix | null;
  Bitrate?: number | null;
  CodecProfile?: AacCodecProfile | null;
  CodingMode?: AacCodingMode | null;
  RateControlMode?: AacRateControlMode | null;
  RawFormat?: AacRawFormat | null;
  SampleRate?: number | null;
  Specification?: AacSpecification | null;
  VbrQuality?: AacVbrQuality | null;
}
function fromAacSettings(input?: AacSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptionBroadcasterMix: input["AudioDescriptionBroadcasterMix"],
    bitrate: input["Bitrate"],
    codecProfile: input["CodecProfile"],
    codingMode: input["CodingMode"],
    rateControlMode: input["RateControlMode"],
    rawFormat: input["RawFormat"],
    sampleRate: input["SampleRate"],
    specification: input["Specification"],
    vbrQuality: input["VbrQuality"],
  }
}
function toAacSettings(root: jsonP.JSONValue): AacSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioDescriptionBroadcasterMix": (x: jsonP.JSONValue) => cmnP.readEnum<AacAudioDescriptionBroadcasterMix>(x),
      "Bitrate": "n",
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<AacCodecProfile>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<AacCodingMode>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<AacRateControlMode>(x),
      "RawFormat": (x: jsonP.JSONValue) => cmnP.readEnum<AacRawFormat>(x),
      "SampleRate": "n",
      "Specification": (x: jsonP.JSONValue) => cmnP.readEnum<AacSpecification>(x),
      "VbrQuality": (x: jsonP.JSONValue) => cmnP.readEnum<AacVbrQuality>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type AacAudioDescriptionBroadcasterMix =
| "BROADCASTER_MIXED_AD"
| "NORMAL"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AacCodecProfile =
| "LC"
| "HEV1"
| "HEV2"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AacCodingMode =
| "AD_RECEIVER_MIX"
| "CODING_MODE_1_0"
| "CODING_MODE_1_1"
| "CODING_MODE_2_0"
| "CODING_MODE_5_1"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AacRateControlMode =
| "CBR"
| "VBR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AacRawFormat =
| "LATM_LOAS"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AacSpecification =
| "MPEG2"
| "MPEG4"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AacVbrQuality =
| "LOW"
| "MEDIUM_LOW"
| "MEDIUM_HIGH"
| "HIGH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Ac3Settings {
  Bitrate?: number | null;
  BitstreamMode?: Ac3BitstreamMode | null;
  CodingMode?: Ac3CodingMode | null;
  Dialnorm?: number | null;
  DynamicRangeCompressionProfile?: Ac3DynamicRangeCompressionProfile | null;
  LfeFilter?: Ac3LfeFilter | null;
  MetadataControl?: Ac3MetadataControl | null;
  SampleRate?: number | null;
}
function fromAc3Settings(input?: Ac3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dialnorm: input["Dialnorm"],
    dynamicRangeCompressionProfile: input["DynamicRangeCompressionProfile"],
    lfeFilter: input["LfeFilter"],
    metadataControl: input["MetadataControl"],
    sampleRate: input["SampleRate"],
  }
}
function toAc3Settings(root: jsonP.JSONValue): Ac3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3BitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3CodingMode>(x),
      "Dialnorm": "n",
      "DynamicRangeCompressionProfile": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3DynamicRangeCompressionProfile>(x),
      "LfeFilter": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3LfeFilter>(x),
      "MetadataControl": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3MetadataControl>(x),
      "SampleRate": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Ac3BitstreamMode =
| "COMPLETE_MAIN"
| "COMMENTARY"
| "DIALOGUE"
| "EMERGENCY"
| "HEARING_IMPAIRED"
| "MUSIC_AND_EFFECTS"
| "VISUALLY_IMPAIRED"
| "VOICE_OVER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Ac3CodingMode =
| "CODING_MODE_1_0"
| "CODING_MODE_1_1"
| "CODING_MODE_2_0"
| "CODING_MODE_3_2_LFE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Ac3DynamicRangeCompressionProfile =
| "FILM_STANDARD"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Ac3LfeFilter =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Ac3MetadataControl =
| "FOLLOW_INPUT"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface AiffSettings {
  BitDepth?: number | null;
  Channels?: number | null;
  SampleRate?: number | null;
}
function fromAiffSettings(input?: AiffSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitDepth: input["BitDepth"],
    channels: input["Channels"],
    sampleRate: input["SampleRate"],
  }
}
function toAiffSettings(root: jsonP.JSONValue): AiffSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BitDepth": "n",
      "Channels": "n",
      "SampleRate": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type AudioCodec =
| "AAC"
| "MP2"
| "MP3"
| "WAV"
| "AIFF"
| "AC3"
| "EAC3"
| "EAC3_ATMOS"
| "VORBIS"
| "OPUS"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Eac3AtmosSettings {
  Bitrate?: number | null;
  BitstreamMode?: Eac3AtmosBitstreamMode | null;
  CodingMode?: Eac3AtmosCodingMode | null;
  DialogueIntelligence?: Eac3AtmosDialogueIntelligence | null;
  DynamicRangeCompressionLine?: Eac3AtmosDynamicRangeCompressionLine | null;
  DynamicRangeCompressionRf?: Eac3AtmosDynamicRangeCompressionRf | null;
  LoRoCenterMixLevel?: number | null;
  LoRoSurroundMixLevel?: number | null;
  LtRtCenterMixLevel?: number | null;
  LtRtSurroundMixLevel?: number | null;
  MeteringMode?: Eac3AtmosMeteringMode | null;
  SampleRate?: number | null;
  SpeechThreshold?: number | null;
  StereoDownmix?: Eac3AtmosStereoDownmix | null;
  SurroundExMode?: Eac3AtmosSurroundExMode | null;
}
function fromEac3AtmosSettings(input?: Eac3AtmosSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dialogueIntelligence: input["DialogueIntelligence"],
    dynamicRangeCompressionLine: input["DynamicRangeCompressionLine"],
    dynamicRangeCompressionRf: input["DynamicRangeCompressionRf"],
    loRoCenterMixLevel: input["LoRoCenterMixLevel"],
    loRoSurroundMixLevel: input["LoRoSurroundMixLevel"],
    ltRtCenterMixLevel: input["LtRtCenterMixLevel"],
    ltRtSurroundMixLevel: input["LtRtSurroundMixLevel"],
    meteringMode: input["MeteringMode"],
    sampleRate: input["SampleRate"],
    speechThreshold: input["SpeechThreshold"],
    stereoDownmix: input["StereoDownmix"],
    surroundExMode: input["SurroundExMode"],
  }
}
function toEac3AtmosSettings(root: jsonP.JSONValue): Eac3AtmosSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AtmosBitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AtmosCodingMode>(x),
      "DialogueIntelligence": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AtmosDialogueIntelligence>(x),
      "DynamicRangeCompressionLine": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AtmosDynamicRangeCompressionLine>(x),
      "DynamicRangeCompressionRf": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AtmosDynamicRangeCompressionRf>(x),
      "LoRoCenterMixLevel": "n",
      "LoRoSurroundMixLevel": "n",
      "LtRtCenterMixLevel": "n",
      "LtRtSurroundMixLevel": "n",
      "MeteringMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AtmosMeteringMode>(x),
      "SampleRate": "n",
      "SpeechThreshold": "n",
      "StereoDownmix": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AtmosStereoDownmix>(x),
      "SurroundExMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AtmosSurroundExMode>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Eac3AtmosBitstreamMode =
| "COMPLETE_MAIN"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3AtmosCodingMode =
| "CODING_MODE_9_1_6"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3AtmosDialogueIntelligence =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3AtmosDynamicRangeCompressionLine =
| "NONE"
| "FILM_STANDARD"
| "FILM_LIGHT"
| "MUSIC_STANDARD"
| "MUSIC_LIGHT"
| "SPEECH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3AtmosDynamicRangeCompressionRf =
| "NONE"
| "FILM_STANDARD"
| "FILM_LIGHT"
| "MUSIC_STANDARD"
| "MUSIC_LIGHT"
| "SPEECH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3AtmosMeteringMode =
| "LEQ_A"
| "ITU_BS_1770_1"
| "ITU_BS_1770_2"
| "ITU_BS_1770_3"
| "ITU_BS_1770_4"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3AtmosStereoDownmix =
| "NOT_INDICATED"
| "STEREO"
| "SURROUND"
| "DPL2"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3AtmosSurroundExMode =
| "NOT_INDICATED"
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Eac3Settings {
  AttenuationControl?: Eac3AttenuationControl | null;
  Bitrate?: number | null;
  BitstreamMode?: Eac3BitstreamMode | null;
  CodingMode?: Eac3CodingMode | null;
  DcFilter?: Eac3DcFilter | null;
  Dialnorm?: number | null;
  DynamicRangeCompressionLine?: Eac3DynamicRangeCompressionLine | null;
  DynamicRangeCompressionRf?: Eac3DynamicRangeCompressionRf | null;
  LfeControl?: Eac3LfeControl | null;
  LfeFilter?: Eac3LfeFilter | null;
  LoRoCenterMixLevel?: number | null;
  LoRoSurroundMixLevel?: number | null;
  LtRtCenterMixLevel?: number | null;
  LtRtSurroundMixLevel?: number | null;
  MetadataControl?: Eac3MetadataControl | null;
  PassthroughControl?: Eac3PassthroughControl | null;
  PhaseControl?: Eac3PhaseControl | null;
  SampleRate?: number | null;
  StereoDownmix?: Eac3StereoDownmix | null;
  SurroundExMode?: Eac3SurroundExMode | null;
  SurroundMode?: Eac3SurroundMode | null;
}
function fromEac3Settings(input?: Eac3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attenuationControl: input["AttenuationControl"],
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dcFilter: input["DcFilter"],
    dialnorm: input["Dialnorm"],
    dynamicRangeCompressionLine: input["DynamicRangeCompressionLine"],
    dynamicRangeCompressionRf: input["DynamicRangeCompressionRf"],
    lfeControl: input["LfeControl"],
    lfeFilter: input["LfeFilter"],
    loRoCenterMixLevel: input["LoRoCenterMixLevel"],
    loRoSurroundMixLevel: input["LoRoSurroundMixLevel"],
    ltRtCenterMixLevel: input["LtRtCenterMixLevel"],
    ltRtSurroundMixLevel: input["LtRtSurroundMixLevel"],
    metadataControl: input["MetadataControl"],
    passthroughControl: input["PassthroughControl"],
    phaseControl: input["PhaseControl"],
    sampleRate: input["SampleRate"],
    stereoDownmix: input["StereoDownmix"],
    surroundExMode: input["SurroundExMode"],
    surroundMode: input["SurroundMode"],
  }
}
function toEac3Settings(root: jsonP.JSONValue): Eac3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttenuationControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AttenuationControl>(x),
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3BitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3CodingMode>(x),
      "DcFilter": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3DcFilter>(x),
      "Dialnorm": "n",
      "DynamicRangeCompressionLine": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3DynamicRangeCompressionLine>(x),
      "DynamicRangeCompressionRf": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3DynamicRangeCompressionRf>(x),
      "LfeControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3LfeControl>(x),
      "LfeFilter": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3LfeFilter>(x),
      "LoRoCenterMixLevel": "n",
      "LoRoSurroundMixLevel": "n",
      "LtRtCenterMixLevel": "n",
      "LtRtSurroundMixLevel": "n",
      "MetadataControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3MetadataControl>(x),
      "PassthroughControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3PassthroughControl>(x),
      "PhaseControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3PhaseControl>(x),
      "SampleRate": "n",
      "StereoDownmix": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3StereoDownmix>(x),
      "SurroundExMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3SurroundExMode>(x),
      "SurroundMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3SurroundMode>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Eac3AttenuationControl =
| "ATTENUATE_3_DB"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3BitstreamMode =
| "COMPLETE_MAIN"
| "COMMENTARY"
| "EMERGENCY"
| "HEARING_IMPAIRED"
| "VISUALLY_IMPAIRED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3CodingMode =
| "CODING_MODE_1_0"
| "CODING_MODE_2_0"
| "CODING_MODE_3_2"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3DcFilter =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3DynamicRangeCompressionLine =
| "NONE"
| "FILM_STANDARD"
| "FILM_LIGHT"
| "MUSIC_STANDARD"
| "MUSIC_LIGHT"
| "SPEECH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3DynamicRangeCompressionRf =
| "NONE"
| "FILM_STANDARD"
| "FILM_LIGHT"
| "MUSIC_STANDARD"
| "MUSIC_LIGHT"
| "SPEECH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3LfeControl =
| "LFE"
| "NO_LFE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3LfeFilter =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3MetadataControl =
| "FOLLOW_INPUT"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3PassthroughControl =
| "WHEN_POSSIBLE"
| "NO_PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3PhaseControl =
| "SHIFT_90_DEGREES"
| "NO_SHIFT"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3StereoDownmix =
| "NOT_INDICATED"
| "LO_RO"
| "LT_RT"
| "DPL2"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3SurroundExMode =
| "NOT_INDICATED"
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Eac3SurroundMode =
| "NOT_INDICATED"
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Mp2Settings {
  Bitrate?: number | null;
  Channels?: number | null;
  SampleRate?: number | null;
}
function fromMp2Settings(input?: Mp2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    channels: input["Channels"],
    sampleRate: input["SampleRate"],
  }
}
function toMp2Settings(root: jsonP.JSONValue): Mp2Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "Channels": "n",
      "SampleRate": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface Mp3Settings {
  Bitrate?: number | null;
  Channels?: number | null;
  RateControlMode?: Mp3RateControlMode | null;
  SampleRate?: number | null;
  VbrQuality?: number | null;
}
function fromMp3Settings(input?: Mp3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    channels: input["Channels"],
    rateControlMode: input["RateControlMode"],
    sampleRate: input["SampleRate"],
    vbrQuality: input["VbrQuality"],
  }
}
function toMp3Settings(root: jsonP.JSONValue): Mp3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "Channels": "n",
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<Mp3RateControlMode>(x),
      "SampleRate": "n",
      "VbrQuality": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Mp3RateControlMode =
| "CBR"
| "VBR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface OpusSettings {
  Bitrate?: number | null;
  Channels?: number | null;
  SampleRate?: number | null;
}
function fromOpusSettings(input?: OpusSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    channels: input["Channels"],
    sampleRate: input["SampleRate"],
  }
}
function toOpusSettings(root: jsonP.JSONValue): OpusSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "Channels": "n",
      "SampleRate": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface VorbisSettings {
  Channels?: number | null;
  SampleRate?: number | null;
  VbrQuality?: number | null;
}
function fromVorbisSettings(input?: VorbisSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channels: input["Channels"],
    sampleRate: input["SampleRate"],
    vbrQuality: input["VbrQuality"],
  }
}
function toVorbisSettings(root: jsonP.JSONValue): VorbisSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Channels": "n",
      "SampleRate": "n",
      "VbrQuality": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface WavSettings {
  BitDepth?: number | null;
  Channels?: number | null;
  Format?: WavFormat | null;
  SampleRate?: number | null;
}
function fromWavSettings(input?: WavSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitDepth: input["BitDepth"],
    channels: input["Channels"],
    format: input["Format"],
    sampleRate: input["SampleRate"],
  }
}
function toWavSettings(root: jsonP.JSONValue): WavSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BitDepth": "n",
      "Channels": "n",
      "Format": (x: jsonP.JSONValue) => cmnP.readEnum<WavFormat>(x),
      "SampleRate": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type WavFormat =
| "RIFF"
| "RF64"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AudioLanguageCodeControl =
| "FOLLOW_INPUT"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface CaptionDescription {
  CaptionSelectorName?: string | null;
  CustomLanguageCode?: string | null;
  DestinationSettings?: CaptionDestinationSettings | null;
  LanguageCode?: LanguageCode | null;
  LanguageDescription?: string | null;
}
function fromCaptionDescription(input?: CaptionDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captionSelectorName: input["CaptionSelectorName"],
    customLanguageCode: input["CustomLanguageCode"],
    destinationSettings: fromCaptionDestinationSettings(input["DestinationSettings"]),
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
  }
}
function toCaptionDescription(root: jsonP.JSONValue): CaptionDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "CaptionSelectorName": "s",
      "CustomLanguageCode": "s",
      "DestinationSettings": toCaptionDestinationSettings,
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "LanguageDescription": "s",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface CaptionDestinationSettings {
  BurninDestinationSettings?: BurninDestinationSettings | null;
  DestinationType?: CaptionDestinationType | null;
  DvbSubDestinationSettings?: DvbSubDestinationSettings | null;
  EmbeddedDestinationSettings?: EmbeddedDestinationSettings | null;
  ImscDestinationSettings?: ImscDestinationSettings | null;
  SccDestinationSettings?: SccDestinationSettings | null;
  TeletextDestinationSettings?: TeletextDestinationSettings | null;
  TtmlDestinationSettings?: TtmlDestinationSettings | null;
}
function fromCaptionDestinationSettings(input?: CaptionDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    burninDestinationSettings: fromBurninDestinationSettings(input["BurninDestinationSettings"]),
    destinationType: input["DestinationType"],
    dvbSubDestinationSettings: fromDvbSubDestinationSettings(input["DvbSubDestinationSettings"]),
    embeddedDestinationSettings: fromEmbeddedDestinationSettings(input["EmbeddedDestinationSettings"]),
    imscDestinationSettings: fromImscDestinationSettings(input["ImscDestinationSettings"]),
    sccDestinationSettings: fromSccDestinationSettings(input["SccDestinationSettings"]),
    teletextDestinationSettings: fromTeletextDestinationSettings(input["TeletextDestinationSettings"]),
    ttmlDestinationSettings: fromTtmlDestinationSettings(input["TtmlDestinationSettings"]),
  }
}
function toCaptionDestinationSettings(root: jsonP.JSONValue): CaptionDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BurninDestinationSettings": toBurninDestinationSettings,
      "DestinationType": (x: jsonP.JSONValue) => cmnP.readEnum<CaptionDestinationType>(x),
      "DvbSubDestinationSettings": toDvbSubDestinationSettings,
      "EmbeddedDestinationSettings": toEmbeddedDestinationSettings,
      "ImscDestinationSettings": toImscDestinationSettings,
      "SccDestinationSettings": toSccDestinationSettings,
      "TeletextDestinationSettings": toTeletextDestinationSettings,
      "TtmlDestinationSettings": toTtmlDestinationSettings,
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface BurninDestinationSettings {
  Alignment?: BurninSubtitleAlignment | null;
  BackgroundColor?: BurninSubtitleBackgroundColor | null;
  BackgroundOpacity?: number | null;
  FontColor?: BurninSubtitleFontColor | null;
  FontOpacity?: number | null;
  FontResolution?: number | null;
  FontScript?: FontScript | null;
  FontSize?: number | null;
  OutlineColor?: BurninSubtitleOutlineColor | null;
  OutlineSize?: number | null;
  ShadowColor?: BurninSubtitleShadowColor | null;
  ShadowOpacity?: number | null;
  ShadowXOffset?: number | null;
  ShadowYOffset?: number | null;
  TeletextSpacing?: BurninSubtitleTeletextSpacing | null;
  XPosition?: number | null;
  YPosition?: number | null;
}
function fromBurninDestinationSettings(input?: BurninDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alignment: input["Alignment"],
    backgroundColor: input["BackgroundColor"],
    backgroundOpacity: input["BackgroundOpacity"],
    fontColor: input["FontColor"],
    fontOpacity: input["FontOpacity"],
    fontResolution: input["FontResolution"],
    fontScript: input["FontScript"],
    fontSize: input["FontSize"],
    outlineColor: input["OutlineColor"],
    outlineSize: input["OutlineSize"],
    shadowColor: input["ShadowColor"],
    shadowOpacity: input["ShadowOpacity"],
    shadowXOffset: input["ShadowXOffset"],
    shadowYOffset: input["ShadowYOffset"],
    teletextSpacing: input["TeletextSpacing"],
    xPosition: input["XPosition"],
    yPosition: input["YPosition"],
  }
}
function toBurninDestinationSettings(root: jsonP.JSONValue): BurninDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alignment": (x: jsonP.JSONValue) => cmnP.readEnum<BurninSubtitleAlignment>(x),
      "BackgroundColor": (x: jsonP.JSONValue) => cmnP.readEnum<BurninSubtitleBackgroundColor>(x),
      "BackgroundOpacity": "n",
      "FontColor": (x: jsonP.JSONValue) => cmnP.readEnum<BurninSubtitleFontColor>(x),
      "FontOpacity": "n",
      "FontResolution": "n",
      "FontScript": (x: jsonP.JSONValue) => cmnP.readEnum<FontScript>(x),
      "FontSize": "n",
      "OutlineColor": (x: jsonP.JSONValue) => cmnP.readEnum<BurninSubtitleOutlineColor>(x),
      "OutlineSize": "n",
      "ShadowColor": (x: jsonP.JSONValue) => cmnP.readEnum<BurninSubtitleShadowColor>(x),
      "ShadowOpacity": "n",
      "ShadowXOffset": "n",
      "ShadowYOffset": "n",
      "TeletextSpacing": (x: jsonP.JSONValue) => cmnP.readEnum<BurninSubtitleTeletextSpacing>(x),
      "XPosition": "n",
      "YPosition": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type BurninSubtitleAlignment =
| "CENTERED"
| "LEFT"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type BurninSubtitleBackgroundColor =
| "NONE"
| "BLACK"
| "WHITE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type BurninSubtitleFontColor =
| "WHITE"
| "BLACK"
| "YELLOW"
| "RED"
| "GREEN"
| "BLUE"
| cmnP.UnexpectedEnumValue;

// refs: 32 - tags: input, named, enum, output
export type FontScript =
| "AUTOMATIC"
| "HANS"
| "HANT"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type BurninSubtitleOutlineColor =
| "BLACK"
| "WHITE"
| "YELLOW"
| "RED"
| "GREEN"
| "BLUE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type BurninSubtitleShadowColor =
| "NONE"
| "BLACK"
| "WHITE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type BurninSubtitleTeletextSpacing =
| "FIXED_GRID"
| "PROPORTIONAL"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type CaptionDestinationType =
| "BURN_IN"
| "DVB_SUB"
| "EMBEDDED"
| "EMBEDDED_PLUS_SCTE20"
| "IMSC"
| "SCTE20_PLUS_EMBEDDED"
| "SCC"
| "SRT"
| "SMI"
| "TELETEXT"
| "TTML"
| "WEBVTT"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface DvbSubDestinationSettings {
  Alignment?: DvbSubtitleAlignment | null;
  BackgroundColor?: DvbSubtitleBackgroundColor | null;
  BackgroundOpacity?: number | null;
  FontColor?: DvbSubtitleFontColor | null;
  FontOpacity?: number | null;
  FontResolution?: number | null;
  FontScript?: FontScript | null;
  FontSize?: number | null;
  OutlineColor?: DvbSubtitleOutlineColor | null;
  OutlineSize?: number | null;
  ShadowColor?: DvbSubtitleShadowColor | null;
  ShadowOpacity?: number | null;
  ShadowXOffset?: number | null;
  ShadowYOffset?: number | null;
  SubtitlingType?: DvbSubtitlingType | null;
  TeletextSpacing?: DvbSubtitleTeletextSpacing | null;
  XPosition?: number | null;
  YPosition?: number | null;
}
function fromDvbSubDestinationSettings(input?: DvbSubDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alignment: input["Alignment"],
    backgroundColor: input["BackgroundColor"],
    backgroundOpacity: input["BackgroundOpacity"],
    fontColor: input["FontColor"],
    fontOpacity: input["FontOpacity"],
    fontResolution: input["FontResolution"],
    fontScript: input["FontScript"],
    fontSize: input["FontSize"],
    outlineColor: input["OutlineColor"],
    outlineSize: input["OutlineSize"],
    shadowColor: input["ShadowColor"],
    shadowOpacity: input["ShadowOpacity"],
    shadowXOffset: input["ShadowXOffset"],
    shadowYOffset: input["ShadowYOffset"],
    subtitlingType: input["SubtitlingType"],
    teletextSpacing: input["TeletextSpacing"],
    xPosition: input["XPosition"],
    yPosition: input["YPosition"],
  }
}
function toDvbSubDestinationSettings(root: jsonP.JSONValue): DvbSubDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alignment": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubtitleAlignment>(x),
      "BackgroundColor": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubtitleBackgroundColor>(x),
      "BackgroundOpacity": "n",
      "FontColor": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubtitleFontColor>(x),
      "FontOpacity": "n",
      "FontResolution": "n",
      "FontScript": (x: jsonP.JSONValue) => cmnP.readEnum<FontScript>(x),
      "FontSize": "n",
      "OutlineColor": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubtitleOutlineColor>(x),
      "OutlineSize": "n",
      "ShadowColor": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubtitleShadowColor>(x),
      "ShadowOpacity": "n",
      "ShadowXOffset": "n",
      "ShadowYOffset": "n",
      "SubtitlingType": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubtitlingType>(x),
      "TeletextSpacing": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubtitleTeletextSpacing>(x),
      "XPosition": "n",
      "YPosition": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type DvbSubtitleAlignment =
| "CENTERED"
| "LEFT"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DvbSubtitleBackgroundColor =
| "NONE"
| "BLACK"
| "WHITE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DvbSubtitleFontColor =
| "WHITE"
| "BLACK"
| "YELLOW"
| "RED"
| "GREEN"
| "BLUE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DvbSubtitleOutlineColor =
| "BLACK"
| "WHITE"
| "YELLOW"
| "RED"
| "GREEN"
| "BLUE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DvbSubtitleShadowColor =
| "NONE"
| "BLACK"
| "WHITE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DvbSubtitlingType =
| "HEARING_IMPAIRED"
| "STANDARD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DvbSubtitleTeletextSpacing =
| "FIXED_GRID"
| "PROPORTIONAL"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface EmbeddedDestinationSettings {
  Destination608ChannelNumber?: number | null;
  Destination708ServiceNumber?: number | null;
}
function fromEmbeddedDestinationSettings(input?: EmbeddedDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination608ChannelNumber: input["Destination608ChannelNumber"],
    destination708ServiceNumber: input["Destination708ServiceNumber"],
  }
}
function toEmbeddedDestinationSettings(root: jsonP.JSONValue): EmbeddedDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Destination608ChannelNumber": "n",
      "Destination708ServiceNumber": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface ImscDestinationSettings {
  StylePassthrough?: ImscStylePassthrough | null;
}
function fromImscDestinationSettings(input?: ImscDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    stylePassthrough: input["StylePassthrough"],
  }
}
function toImscDestinationSettings(root: jsonP.JSONValue): ImscDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StylePassthrough": (x: jsonP.JSONValue) => cmnP.readEnum<ImscStylePassthrough>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type ImscStylePassthrough =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface SccDestinationSettings {
  Framerate?: SccDestinationFramerate | null;
}
function fromSccDestinationSettings(input?: SccDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerate: input["Framerate"],
  }
}
function toSccDestinationSettings(root: jsonP.JSONValue): SccDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Framerate": (x: jsonP.JSONValue) => cmnP.readEnum<SccDestinationFramerate>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type SccDestinationFramerate =
| "FRAMERATE_23_97"
| "FRAMERATE_24"
| "FRAMERATE_25"
| "FRAMERATE_29_97_DROPFRAME"
| "FRAMERATE_29_97_NON_DROPFRAME"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface TeletextDestinationSettings {
  PageNumber?: string | null;
  PageTypes?: TeletextPageType[] | null;
}
function fromTeletextDestinationSettings(input?: TeletextDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pageNumber: input["PageNumber"],
    pageTypes: input["PageTypes"],
  }
}
function toTeletextDestinationSettings(root: jsonP.JSONValue): TeletextDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PageNumber": "s",
      "PageTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<TeletextPageType>(x)],
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type TeletextPageType =
| "PAGE_TYPE_INITIAL"
| "PAGE_TYPE_SUBTITLE"
| "PAGE_TYPE_ADDL_INFO"
| "PAGE_TYPE_PROGRAM_SCHEDULE"
| "PAGE_TYPE_HEARING_IMPAIRED_SUBTITLE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface TtmlDestinationSettings {
  StylePassthrough?: TtmlStylePassthrough | null;
}
function fromTtmlDestinationSettings(input?: TtmlDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    stylePassthrough: input["StylePassthrough"],
  }
}
function toTtmlDestinationSettings(root: jsonP.JSONValue): TtmlDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StylePassthrough": (x: jsonP.JSONValue) => cmnP.readEnum<TtmlStylePassthrough>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type TtmlStylePassthrough =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface ContainerSettings {
  CmfcSettings?: CmfcSettings | null;
  Container?: ContainerType | null;
  F4vSettings?: F4vSettings | null;
  M2tsSettings?: M2tsSettings | null;
  M3u8Settings?: M3u8Settings | null;
  MovSettings?: MovSettings | null;
  Mp4Settings?: Mp4Settings | null;
  MpdSettings?: MpdSettings | null;
  MxfSettings?: MxfSettings | null;
}
function fromContainerSettings(input?: ContainerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cmfcSettings: fromCmfcSettings(input["CmfcSettings"]),
    container: input["Container"],
    f4vSettings: fromF4vSettings(input["F4vSettings"]),
    m2tsSettings: fromM2tsSettings(input["M2tsSettings"]),
    m3u8Settings: fromM3u8Settings(input["M3u8Settings"]),
    movSettings: fromMovSettings(input["MovSettings"]),
    mp4Settings: fromMp4Settings(input["Mp4Settings"]),
    mpdSettings: fromMpdSettings(input["MpdSettings"]),
    mxfSettings: fromMxfSettings(input["MxfSettings"]),
  }
}
function toContainerSettings(root: jsonP.JSONValue): ContainerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CmfcSettings": toCmfcSettings,
      "Container": (x: jsonP.JSONValue) => cmnP.readEnum<ContainerType>(x),
      "F4vSettings": toF4vSettings,
      "M2tsSettings": toM2tsSettings,
      "M3u8Settings": toM3u8Settings,
      "MovSettings": toMovSettings,
      "Mp4Settings": toMp4Settings,
      "MpdSettings": toMpdSettings,
      "MxfSettings": toMxfSettings,
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface CmfcSettings {
  Scte35Esam?: CmfcScte35Esam | null;
  Scte35Source?: CmfcScte35Source | null;
}
function fromCmfcSettings(input?: CmfcSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scte35Esam: input["Scte35Esam"],
    scte35Source: input["Scte35Source"],
  }
}
function toCmfcSettings(root: jsonP.JSONValue): CmfcSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Scte35Esam": (x: jsonP.JSONValue) => cmnP.readEnum<CmfcScte35Esam>(x),
      "Scte35Source": (x: jsonP.JSONValue) => cmnP.readEnum<CmfcScte35Source>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type CmfcScte35Esam =
| "INSERT"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type CmfcScte35Source =
| "PASSTHROUGH"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type ContainerType =
| "F4V"
| "ISMV"
| "M2TS"
| "M3U8"
| "CMFC"
| "MOV"
| "MP4"
| "MPD"
| "MXF"
| "WEBM"
| "RAW"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface F4vSettings {
  MoovPlacement?: F4vMoovPlacement | null;
}
function fromF4vSettings(input?: F4vSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    moovPlacement: input["MoovPlacement"],
  }
}
function toF4vSettings(root: jsonP.JSONValue): F4vSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MoovPlacement": (x: jsonP.JSONValue) => cmnP.readEnum<F4vMoovPlacement>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type F4vMoovPlacement =
| "PROGRESSIVE_DOWNLOAD"
| "NORMAL"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface M2tsSettings {
  AudioBufferModel?: M2tsAudioBufferModel | null;
  AudioFramesPerPes?: number | null;
  AudioPids?: number[] | null;
  Bitrate?: number | null;
  BufferModel?: M2tsBufferModel | null;
  DvbNitSettings?: DvbNitSettings | null;
  DvbSdtSettings?: DvbSdtSettings | null;
  DvbSubPids?: number[] | null;
  DvbTdtSettings?: DvbTdtSettings | null;
  DvbTeletextPid?: number | null;
  EbpAudioInterval?: M2tsEbpAudioInterval | null;
  EbpPlacement?: M2tsEbpPlacement | null;
  EsRateInPes?: M2tsEsRateInPes | null;
  ForceTsVideoEbpOrder?: M2tsForceTsVideoEbpOrder | null;
  FragmentTime?: number | null;
  MaxPcrInterval?: number | null;
  MinEbpInterval?: number | null;
  NielsenId3?: M2tsNielsenId3 | null;
  NullPacketBitrate?: number | null;
  PatInterval?: number | null;
  PcrControl?: M2tsPcrControl | null;
  PcrPid?: number | null;
  PmtInterval?: number | null;
  PmtPid?: number | null;
  PrivateMetadataPid?: number | null;
  ProgramNumber?: number | null;
  RateMode?: M2tsRateMode | null;
  Scte35Esam?: M2tsScte35Esam | null;
  Scte35Pid?: number | null;
  Scte35Source?: M2tsScte35Source | null;
  SegmentationMarkers?: M2tsSegmentationMarkers | null;
  SegmentationStyle?: M2tsSegmentationStyle | null;
  SegmentationTime?: number | null;
  TimedMetadataPid?: number | null;
  TransportStreamId?: number | null;
  VideoPid?: number | null;
}
function fromM2tsSettings(input?: M2tsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioBufferModel: input["AudioBufferModel"],
    audioFramesPerPes: input["AudioFramesPerPes"],
    audioPids: input["AudioPids"],
    bitrate: input["Bitrate"],
    bufferModel: input["BufferModel"],
    dvbNitSettings: fromDvbNitSettings(input["DvbNitSettings"]),
    dvbSdtSettings: fromDvbSdtSettings(input["DvbSdtSettings"]),
    dvbSubPids: input["DvbSubPids"],
    dvbTdtSettings: fromDvbTdtSettings(input["DvbTdtSettings"]),
    dvbTeletextPid: input["DvbTeletextPid"],
    ebpAudioInterval: input["EbpAudioInterval"],
    ebpPlacement: input["EbpPlacement"],
    esRateInPes: input["EsRateInPes"],
    forceTsVideoEbpOrder: input["ForceTsVideoEbpOrder"],
    fragmentTime: input["FragmentTime"],
    maxPcrInterval: input["MaxPcrInterval"],
    minEbpInterval: input["MinEbpInterval"],
    nielsenId3: input["NielsenId3"],
    nullPacketBitrate: input["NullPacketBitrate"],
    patInterval: input["PatInterval"],
    pcrControl: input["PcrControl"],
    pcrPid: input["PcrPid"],
    pmtInterval: input["PmtInterval"],
    pmtPid: input["PmtPid"],
    privateMetadataPid: input["PrivateMetadataPid"],
    programNumber: input["ProgramNumber"],
    rateMode: input["RateMode"],
    scte35Esam: fromM2tsScte35Esam(input["Scte35Esam"]),
    scte35Pid: input["Scte35Pid"],
    scte35Source: input["Scte35Source"],
    segmentationMarkers: input["SegmentationMarkers"],
    segmentationStyle: input["SegmentationStyle"],
    segmentationTime: input["SegmentationTime"],
    timedMetadataPid: input["TimedMetadataPid"],
    transportStreamId: input["TransportStreamId"],
    videoPid: input["VideoPid"],
  }
}
function toM2tsSettings(root: jsonP.JSONValue): M2tsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioBufferModel": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsAudioBufferModel>(x),
      "AudioFramesPerPes": "n",
      "AudioPids": ["n"],
      "Bitrate": "n",
      "BufferModel": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsBufferModel>(x),
      "DvbNitSettings": toDvbNitSettings,
      "DvbSdtSettings": toDvbSdtSettings,
      "DvbSubPids": ["n"],
      "DvbTdtSettings": toDvbTdtSettings,
      "DvbTeletextPid": "n",
      "EbpAudioInterval": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsEbpAudioInterval>(x),
      "EbpPlacement": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsEbpPlacement>(x),
      "EsRateInPes": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsEsRateInPes>(x),
      "ForceTsVideoEbpOrder": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsForceTsVideoEbpOrder>(x),
      "FragmentTime": "n",
      "MaxPcrInterval": "n",
      "MinEbpInterval": "n",
      "NielsenId3": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsNielsenId3>(x),
      "NullPacketBitrate": "n",
      "PatInterval": "n",
      "PcrControl": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsPcrControl>(x),
      "PcrPid": "n",
      "PmtInterval": "n",
      "PmtPid": "n",
      "PrivateMetadataPid": "n",
      "ProgramNumber": "n",
      "RateMode": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsRateMode>(x),
      "Scte35Esam": toM2tsScte35Esam,
      "Scte35Pid": "n",
      "Scte35Source": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsScte35Source>(x),
      "SegmentationMarkers": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsSegmentationMarkers>(x),
      "SegmentationStyle": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsSegmentationStyle>(x),
      "SegmentationTime": "n",
      "TimedMetadataPid": "n",
      "TransportStreamId": "n",
      "VideoPid": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type M2tsAudioBufferModel =
| "DVB"
| "ATSC"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M2tsBufferModel =
| "MULTIPLEX"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface DvbNitSettings {
  NetworkId?: number | null;
  NetworkName?: string | null;
  NitInterval?: number | null;
}
function fromDvbNitSettings(input?: DvbNitSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    networkId: input["NetworkId"],
    networkName: input["NetworkName"],
    nitInterval: input["NitInterval"],
  }
}
function toDvbNitSettings(root: jsonP.JSONValue): DvbNitSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "NetworkId": "n",
      "NetworkName": "s",
      "NitInterval": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface DvbSdtSettings {
  OutputSdt?: OutputSdt | null;
  SdtInterval?: number | null;
  ServiceName?: string | null;
  ServiceProviderName?: string | null;
}
function fromDvbSdtSettings(input?: DvbSdtSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    outputSdt: input["OutputSdt"],
    sdtInterval: input["SdtInterval"],
    serviceName: input["ServiceName"],
    serviceProviderName: input["ServiceProviderName"],
  }
}
function toDvbSdtSettings(root: jsonP.JSONValue): DvbSdtSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputSdt": (x: jsonP.JSONValue) => cmnP.readEnum<OutputSdt>(x),
      "SdtInterval": "n",
      "ServiceName": "s",
      "ServiceProviderName": "s",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type OutputSdt =
| "SDT_FOLLOW"
| "SDT_FOLLOW_IF_PRESENT"
| "SDT_MANUAL"
| "SDT_NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface DvbTdtSettings {
  TdtInterval?: number | null;
}
function fromDvbTdtSettings(input?: DvbTdtSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tdtInterval: input["TdtInterval"],
  }
}
function toDvbTdtSettings(root: jsonP.JSONValue): DvbTdtSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TdtInterval": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type M2tsEbpAudioInterval =
| "VIDEO_AND_FIXED_INTERVALS"
| "VIDEO_INTERVAL"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M2tsEbpPlacement =
| "VIDEO_AND_AUDIO_PIDS"
| "VIDEO_PID"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M2tsEsRateInPes =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M2tsForceTsVideoEbpOrder =
| "FORCE"
| "DEFAULT"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M2tsNielsenId3 =
| "INSERT"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M2tsPcrControl =
| "PCR_EVERY_PES_PACKET"
| "CONFIGURED_PCR_PERIOD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M2tsRateMode =
| "VBR"
| "CBR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface M2tsScte35Esam {
  Scte35EsamPid?: number | null;
}
function fromM2tsScte35Esam(input?: M2tsScte35Esam | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scte35EsamPid: input["Scte35EsamPid"],
  }
}
function toM2tsScte35Esam(root: jsonP.JSONValue): M2tsScte35Esam {
  return jsonP.readObj({
    required: {},
    optional: {
      "Scte35EsamPid": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type M2tsScte35Source =
| "PASSTHROUGH"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M2tsSegmentationMarkers =
| "NONE"
| "RAI_SEGSTART"
| "RAI_ADAPT"
| "PSI_SEGSTART"
| "EBP"
| "EBP_LEGACY"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M2tsSegmentationStyle =
| "MAINTAIN_CADENCE"
| "RESET_CADENCE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface M3u8Settings {
  AudioFramesPerPes?: number | null;
  AudioPids?: number[] | null;
  NielsenId3?: M3u8NielsenId3 | null;
  PatInterval?: number | null;
  PcrControl?: M3u8PcrControl | null;
  PcrPid?: number | null;
  PmtInterval?: number | null;
  PmtPid?: number | null;
  PrivateMetadataPid?: number | null;
  ProgramNumber?: number | null;
  Scte35Pid?: number | null;
  Scte35Source?: M3u8Scte35Source | null;
  TimedMetadata?: TimedMetadata | null;
  TimedMetadataPid?: number | null;
  TransportStreamId?: number | null;
  VideoPid?: number | null;
}
function fromM3u8Settings(input?: M3u8Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioFramesPerPes: input["AudioFramesPerPes"],
    audioPids: input["AudioPids"],
    nielsenId3: input["NielsenId3"],
    patInterval: input["PatInterval"],
    pcrControl: input["PcrControl"],
    pcrPid: input["PcrPid"],
    pmtInterval: input["PmtInterval"],
    pmtPid: input["PmtPid"],
    privateMetadataPid: input["PrivateMetadataPid"],
    programNumber: input["ProgramNumber"],
    scte35Pid: input["Scte35Pid"],
    scte35Source: input["Scte35Source"],
    timedMetadata: input["TimedMetadata"],
    timedMetadataPid: input["TimedMetadataPid"],
    transportStreamId: input["TransportStreamId"],
    videoPid: input["VideoPid"],
  }
}
function toM3u8Settings(root: jsonP.JSONValue): M3u8Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioFramesPerPes": "n",
      "AudioPids": ["n"],
      "NielsenId3": (x: jsonP.JSONValue) => cmnP.readEnum<M3u8NielsenId3>(x),
      "PatInterval": "n",
      "PcrControl": (x: jsonP.JSONValue) => cmnP.readEnum<M3u8PcrControl>(x),
      "PcrPid": "n",
      "PmtInterval": "n",
      "PmtPid": "n",
      "PrivateMetadataPid": "n",
      "ProgramNumber": "n",
      "Scte35Pid": "n",
      "Scte35Source": (x: jsonP.JSONValue) => cmnP.readEnum<M3u8Scte35Source>(x),
      "TimedMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<TimedMetadata>(x),
      "TimedMetadataPid": "n",
      "TransportStreamId": "n",
      "VideoPid": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type M3u8NielsenId3 =
| "INSERT"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M3u8PcrControl =
| "PCR_EVERY_PES_PACKET"
| "CONFIGURED_PCR_PERIOD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type M3u8Scte35Source =
| "PASSTHROUGH"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type TimedMetadata =
| "PASSTHROUGH"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface MovSettings {
  ClapAtom?: MovClapAtom | null;
  CslgAtom?: MovCslgAtom | null;
  Mpeg2FourCCControl?: MovMpeg2FourCCControl | null;
  PaddingControl?: MovPaddingControl | null;
  Reference?: MovReference | null;
}
function fromMovSettings(input?: MovSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clapAtom: input["ClapAtom"],
    cslgAtom: input["CslgAtom"],
    mpeg2FourCCControl: input["Mpeg2FourCCControl"],
    paddingControl: input["PaddingControl"],
    reference: input["Reference"],
  }
}
function toMovSettings(root: jsonP.JSONValue): MovSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClapAtom": (x: jsonP.JSONValue) => cmnP.readEnum<MovClapAtom>(x),
      "CslgAtom": (x: jsonP.JSONValue) => cmnP.readEnum<MovCslgAtom>(x),
      "Mpeg2FourCCControl": (x: jsonP.JSONValue) => cmnP.readEnum<MovMpeg2FourCCControl>(x),
      "PaddingControl": (x: jsonP.JSONValue) => cmnP.readEnum<MovPaddingControl>(x),
      "Reference": (x: jsonP.JSONValue) => cmnP.readEnum<MovReference>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type MovClapAtom =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type MovCslgAtom =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type MovMpeg2FourCCControl =
| "XDCAM"
| "MPEG"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type MovPaddingControl =
| "OMNEON"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type MovReference =
| "SELF_CONTAINED"
| "EXTERNAL"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Mp4Settings {
  CslgAtom?: Mp4CslgAtom | null;
  CttsVersion?: number | null;
  FreeSpaceBox?: Mp4FreeSpaceBox | null;
  MoovPlacement?: Mp4MoovPlacement | null;
  Mp4MajorBrand?: string | null;
}
function fromMp4Settings(input?: Mp4Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cslgAtom: input["CslgAtom"],
    cttsVersion: input["CttsVersion"],
    freeSpaceBox: input["FreeSpaceBox"],
    moovPlacement: input["MoovPlacement"],
    mp4MajorBrand: input["Mp4MajorBrand"],
  }
}
function toMp4Settings(root: jsonP.JSONValue): Mp4Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CslgAtom": (x: jsonP.JSONValue) => cmnP.readEnum<Mp4CslgAtom>(x),
      "CttsVersion": "n",
      "FreeSpaceBox": (x: jsonP.JSONValue) => cmnP.readEnum<Mp4FreeSpaceBox>(x),
      "MoovPlacement": (x: jsonP.JSONValue) => cmnP.readEnum<Mp4MoovPlacement>(x),
      "Mp4MajorBrand": "s",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Mp4CslgAtom =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mp4FreeSpaceBox =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mp4MoovPlacement =
| "PROGRESSIVE_DOWNLOAD"
| "NORMAL"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface MpdSettings {
  CaptionContainerType?: MpdCaptionContainerType | null;
  Scte35Esam?: MpdScte35Esam | null;
  Scte35Source?: MpdScte35Source | null;
}
function fromMpdSettings(input?: MpdSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captionContainerType: input["CaptionContainerType"],
    scte35Esam: input["Scte35Esam"],
    scte35Source: input["Scte35Source"],
  }
}
function toMpdSettings(root: jsonP.JSONValue): MpdSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CaptionContainerType": (x: jsonP.JSONValue) => cmnP.readEnum<MpdCaptionContainerType>(x),
      "Scte35Esam": (x: jsonP.JSONValue) => cmnP.readEnum<MpdScte35Esam>(x),
      "Scte35Source": (x: jsonP.JSONValue) => cmnP.readEnum<MpdScte35Source>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type MpdCaptionContainerType =
| "RAW"
| "FRAGMENTED_MP4"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type MpdScte35Esam =
| "INSERT"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type MpdScte35Source =
| "PASSTHROUGH"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface MxfSettings {
  AfdSignaling?: MxfAfdSignaling | null;
  Profile?: MxfProfile | null;
}
function fromMxfSettings(input?: MxfSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    afdSignaling: input["AfdSignaling"],
    profile: input["Profile"],
  }
}
function toMxfSettings(root: jsonP.JSONValue): MxfSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<MxfAfdSignaling>(x),
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<MxfProfile>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type MxfAfdSignaling =
| "NO_COPY"
| "COPY_FROM_VIDEO"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type MxfProfile =
| "D_10"
| "XDCAM"
| "OP1A"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface OutputSettings {
  HlsSettings?: HlsSettings | null;
}
function fromOutputSettings(input?: OutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hlsSettings: fromHlsSettings(input["HlsSettings"]),
  }
}
function toOutputSettings(root: jsonP.JSONValue): OutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "HlsSettings": toHlsSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface HlsSettings {
  AudioGroupId?: string | null;
  AudioOnlyContainer?: HlsAudioOnlyContainer | null;
  AudioRenditionSets?: string | null;
  AudioTrackType?: HlsAudioTrackType | null;
  IFrameOnlyManifest?: HlsIFrameOnlyManifest | null;
  SegmentModifier?: string | null;
}
function fromHlsSettings(input?: HlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioGroupId: input["AudioGroupId"],
    audioOnlyContainer: input["AudioOnlyContainer"],
    audioRenditionSets: input["AudioRenditionSets"],
    audioTrackType: input["AudioTrackType"],
    iFrameOnlyManifest: input["IFrameOnlyManifest"],
    segmentModifier: input["SegmentModifier"],
  }
}
function toHlsSettings(root: jsonP.JSONValue): HlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioGroupId": "s",
      "AudioOnlyContainer": (x: jsonP.JSONValue) => cmnP.readEnum<HlsAudioOnlyContainer>(x),
      "AudioRenditionSets": "s",
      "AudioTrackType": (x: jsonP.JSONValue) => cmnP.readEnum<HlsAudioTrackType>(x),
      "IFrameOnlyManifest": (x: jsonP.JSONValue) => cmnP.readEnum<HlsIFrameOnlyManifest>(x),
      "SegmentModifier": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type HlsAudioOnlyContainer =
| "AUTOMATIC"
| "M2TS"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsAudioTrackType =
| "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT"
| "ALTERNATE_AUDIO_AUTO_SELECT"
| "ALTERNATE_AUDIO_NOT_AUTO_SELECT"
| "AUDIO_ONLY_VARIANT_STREAM"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HlsIFrameOnlyManifest =
| "INCLUDE"
| "EXCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface VideoDescription {
  AfdSignaling?: AfdSignaling | null;
  AntiAlias?: AntiAlias | null;
  CodecSettings?: VideoCodecSettings | null;
  ColorMetadata?: ColorMetadata | null;
  Crop?: Rectangle | null;
  DropFrameTimecode?: DropFrameTimecode | null;
  FixedAfd?: number | null;
  Height?: number | null;
  Position?: Rectangle | null;
  RespondToAfd?: RespondToAfd | null;
  ScalingBehavior?: ScalingBehavior | null;
  Sharpness?: number | null;
  TimecodeInsertion?: VideoTimecodeInsertion | null;
  VideoPreprocessors?: VideoPreprocessor | null;
  Width?: number | null;
}
function fromVideoDescription(input?: VideoDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    afdSignaling: input["AfdSignaling"],
    antiAlias: input["AntiAlias"],
    codecSettings: fromVideoCodecSettings(input["CodecSettings"]),
    colorMetadata: input["ColorMetadata"],
    crop: fromRectangle(input["Crop"]),
    dropFrameTimecode: input["DropFrameTimecode"],
    fixedAfd: input["FixedAfd"],
    height: input["Height"],
    position: fromRectangle(input["Position"]),
    respondToAfd: input["RespondToAfd"],
    scalingBehavior: input["ScalingBehavior"],
    sharpness: input["Sharpness"],
    timecodeInsertion: input["TimecodeInsertion"],
    videoPreprocessors: fromVideoPreprocessor(input["VideoPreprocessors"]),
    width: input["Width"],
  }
}
function toVideoDescription(root: jsonP.JSONValue): VideoDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<AfdSignaling>(x),
      "AntiAlias": (x: jsonP.JSONValue) => cmnP.readEnum<AntiAlias>(x),
      "CodecSettings": toVideoCodecSettings,
      "ColorMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<ColorMetadata>(x),
      "Crop": toRectangle,
      "DropFrameTimecode": (x: jsonP.JSONValue) => cmnP.readEnum<DropFrameTimecode>(x),
      "FixedAfd": "n",
      "Height": "n",
      "Position": toRectangle,
      "RespondToAfd": (x: jsonP.JSONValue) => cmnP.readEnum<RespondToAfd>(x),
      "ScalingBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<ScalingBehavior>(x),
      "Sharpness": "n",
      "TimecodeInsertion": (x: jsonP.JSONValue) => cmnP.readEnum<VideoTimecodeInsertion>(x),
      "VideoPreprocessors": toVideoPreprocessor,
      "Width": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type AfdSignaling =
| "NONE"
| "AUTO"
| "FIXED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AntiAlias =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface VideoCodecSettings {
  Av1Settings?: Av1Settings | null;
  AvcIntraSettings?: AvcIntraSettings | null;
  Codec?: VideoCodec | null;
  FrameCaptureSettings?: FrameCaptureSettings | null;
  H264Settings?: H264Settings | null;
  H265Settings?: H265Settings | null;
  Mpeg2Settings?: Mpeg2Settings | null;
  ProresSettings?: ProresSettings | null;
  Vc3Settings?: Vc3Settings | null;
  Vp8Settings?: Vp8Settings | null;
  Vp9Settings?: Vp9Settings | null;
}
function fromVideoCodecSettings(input?: VideoCodecSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    av1Settings: fromAv1Settings(input["Av1Settings"]),
    avcIntraSettings: fromAvcIntraSettings(input["AvcIntraSettings"]),
    codec: input["Codec"],
    frameCaptureSettings: fromFrameCaptureSettings(input["FrameCaptureSettings"]),
    h264Settings: fromH264Settings(input["H264Settings"]),
    h265Settings: fromH265Settings(input["H265Settings"]),
    mpeg2Settings: fromMpeg2Settings(input["Mpeg2Settings"]),
    proresSettings: fromProresSettings(input["ProresSettings"]),
    vc3Settings: fromVc3Settings(input["Vc3Settings"]),
    vp8Settings: fromVp8Settings(input["Vp8Settings"]),
    vp9Settings: fromVp9Settings(input["Vp9Settings"]),
  }
}
function toVideoCodecSettings(root: jsonP.JSONValue): VideoCodecSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Av1Settings": toAv1Settings,
      "AvcIntraSettings": toAvcIntraSettings,
      "Codec": (x: jsonP.JSONValue) => cmnP.readEnum<VideoCodec>(x),
      "FrameCaptureSettings": toFrameCaptureSettings,
      "H264Settings": toH264Settings,
      "H265Settings": toH265Settings,
      "Mpeg2Settings": toMpeg2Settings,
      "ProresSettings": toProresSettings,
      "Vc3Settings": toVc3Settings,
      "Vp8Settings": toVp8Settings,
      "Vp9Settings": toVp9Settings,
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface Av1Settings {
  AdaptiveQuantization?: Av1AdaptiveQuantization | null;
  FramerateControl?: Av1FramerateControl | null;
  FramerateConversionAlgorithm?: Av1FramerateConversionAlgorithm | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  GopSize?: number | null;
  MaxBitrate?: number | null;
  NumberBFramesBetweenReferenceFrames?: number | null;
  QvbrSettings?: Av1QvbrSettings | null;
  RateControlMode?: Av1RateControlMode | null;
  Slices?: number | null;
  SpatialAdaptiveQuantization?: Av1SpatialAdaptiveQuantization | null;
}
function fromAv1Settings(input?: Av1Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopSize: input["GopSize"],
    maxBitrate: input["MaxBitrate"],
    numberBFramesBetweenReferenceFrames: input["NumberBFramesBetweenReferenceFrames"],
    qvbrSettings: fromAv1QvbrSettings(input["QvbrSettings"]),
    rateControlMode: input["RateControlMode"],
    slices: input["Slices"],
    spatialAdaptiveQuantization: input["SpatialAdaptiveQuantization"],
  }
}
function toAv1Settings(root: jsonP.JSONValue): Av1Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<Av1AdaptiveQuantization>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<Av1FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<Av1FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopSize": "n",
      "MaxBitrate": "n",
      "NumberBFramesBetweenReferenceFrames": "n",
      "QvbrSettings": toAv1QvbrSettings,
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<Av1RateControlMode>(x),
      "Slices": "n",
      "SpatialAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<Av1SpatialAdaptiveQuantization>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Av1AdaptiveQuantization =
| "OFF"
| "LOW"
| "MEDIUM"
| "HIGH"
| "HIGHER"
| "MAX"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Av1FramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Av1FramerateConversionAlgorithm =
| "DUPLICATE_DROP"
| "INTERPOLATE"
| "FRAMEFORMER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Av1QvbrSettings {
  QvbrQualityLevel?: number | null;
  QvbrQualityLevelFineTune?: number | null;
}
function fromAv1QvbrSettings(input?: Av1QvbrSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    qvbrQualityLevel: input["QvbrQualityLevel"],
    qvbrQualityLevelFineTune: input["QvbrQualityLevelFineTune"],
  }
}
function toAv1QvbrSettings(root: jsonP.JSONValue): Av1QvbrSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "QvbrQualityLevel": "n",
      "QvbrQualityLevelFineTune": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Av1RateControlMode =
| "QVBR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Av1SpatialAdaptiveQuantization =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface AvcIntraSettings {
  AvcIntraClass?: AvcIntraClass | null;
  FramerateControl?: AvcIntraFramerateControl | null;
  FramerateConversionAlgorithm?: AvcIntraFramerateConversionAlgorithm | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  InterlaceMode?: AvcIntraInterlaceMode | null;
  SlowPal?: AvcIntraSlowPal | null;
  Telecine?: AvcIntraTelecine | null;
}
function fromAvcIntraSettings(input?: AvcIntraSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    avcIntraClass: input["AvcIntraClass"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    interlaceMode: input["InterlaceMode"],
    slowPal: input["SlowPal"],
    telecine: input["Telecine"],
  }
}
function toAvcIntraSettings(root: jsonP.JSONValue): AvcIntraSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvcIntraClass": (x: jsonP.JSONValue) => cmnP.readEnum<AvcIntraClass>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<AvcIntraFramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<AvcIntraFramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<AvcIntraInterlaceMode>(x),
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<AvcIntraSlowPal>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<AvcIntraTelecine>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type AvcIntraClass =
| "CLASS_50"
| "CLASS_100"
| "CLASS_200"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AvcIntraFramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AvcIntraFramerateConversionAlgorithm =
| "DUPLICATE_DROP"
| "INTERPOLATE"
| "FRAMEFORMER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AvcIntraInterlaceMode =
| "PROGRESSIVE"
| "TOP_FIELD"
| "BOTTOM_FIELD"
| "FOLLOW_TOP_FIELD"
| "FOLLOW_BOTTOM_FIELD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AvcIntraSlowPal =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type AvcIntraTelecine =
| "NONE"
| "HARD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type VideoCodec =
| "AV1"
| "AVC_INTRA"
| "FRAME_CAPTURE"
| "H_264"
| "H_265"
| "MPEG2"
| "PRORES"
| "VC3"
| "VP8"
| "VP9"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface FrameCaptureSettings {
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  MaxCaptures?: number | null;
  Quality?: number | null;
}
function fromFrameCaptureSettings(input?: FrameCaptureSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    maxCaptures: input["MaxCaptures"],
    quality: input["Quality"],
  }
}
function toFrameCaptureSettings(root: jsonP.JSONValue): FrameCaptureSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "MaxCaptures": "n",
      "Quality": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface H264Settings {
  AdaptiveQuantization?: H264AdaptiveQuantization | null;
  Bitrate?: number | null;
  CodecLevel?: H264CodecLevel | null;
  CodecProfile?: H264CodecProfile | null;
  DynamicSubGop?: H264DynamicSubGop | null;
  EntropyEncoding?: H264EntropyEncoding | null;
  FieldEncoding?: H264FieldEncoding | null;
  FlickerAdaptiveQuantization?: H264FlickerAdaptiveQuantization | null;
  FramerateControl?: H264FramerateControl | null;
  FramerateConversionAlgorithm?: H264FramerateConversionAlgorithm | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  GopBReference?: H264GopBReference | null;
  GopClosedCadence?: number | null;
  GopSize?: number | null;
  GopSizeUnits?: H264GopSizeUnits | null;
  HrdBufferInitialFillPercentage?: number | null;
  HrdBufferSize?: number | null;
  InterlaceMode?: H264InterlaceMode | null;
  MaxBitrate?: number | null;
  MinIInterval?: number | null;
  NumberBFramesBetweenReferenceFrames?: number | null;
  NumberReferenceFrames?: number | null;
  ParControl?: H264ParControl | null;
  ParDenominator?: number | null;
  ParNumerator?: number | null;
  QualityTuningLevel?: H264QualityTuningLevel | null;
  QvbrSettings?: H264QvbrSettings | null;
  RateControlMode?: H264RateControlMode | null;
  RepeatPps?: H264RepeatPps | null;
  SceneChangeDetect?: H264SceneChangeDetect | null;
  Slices?: number | null;
  SlowPal?: H264SlowPal | null;
  Softness?: number | null;
  SpatialAdaptiveQuantization?: H264SpatialAdaptiveQuantization | null;
  Syntax?: H264Syntax | null;
  Telecine?: H264Telecine | null;
  TemporalAdaptiveQuantization?: H264TemporalAdaptiveQuantization | null;
  UnregisteredSeiTimecode?: H264UnregisteredSeiTimecode | null;
}
function fromH264Settings(input?: H264Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    bitrate: input["Bitrate"],
    codecLevel: input["CodecLevel"],
    codecProfile: input["CodecProfile"],
    dynamicSubGop: input["DynamicSubGop"],
    entropyEncoding: input["EntropyEncoding"],
    fieldEncoding: input["FieldEncoding"],
    flickerAdaptiveQuantization: input["FlickerAdaptiveQuantization"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopBReference: input["GopBReference"],
    gopClosedCadence: input["GopClosedCadence"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    hrdBufferInitialFillPercentage: input["HrdBufferInitialFillPercentage"],
    hrdBufferSize: input["HrdBufferSize"],
    interlaceMode: input["InterlaceMode"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    numberBFramesBetweenReferenceFrames: input["NumberBFramesBetweenReferenceFrames"],
    numberReferenceFrames: input["NumberReferenceFrames"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    qvbrSettings: fromH264QvbrSettings(input["QvbrSettings"]),
    rateControlMode: input["RateControlMode"],
    repeatPps: input["RepeatPps"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slices: input["Slices"],
    slowPal: input["SlowPal"],
    softness: input["Softness"],
    spatialAdaptiveQuantization: input["SpatialAdaptiveQuantization"],
    syntax: input["Syntax"],
    telecine: input["Telecine"],
    temporalAdaptiveQuantization: input["TemporalAdaptiveQuantization"],
    unregisteredSeiTimecode: input["UnregisteredSeiTimecode"],
  }
}
function toH264Settings(root: jsonP.JSONValue): H264Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H264AdaptiveQuantization>(x),
      "Bitrate": "n",
      "CodecLevel": (x: jsonP.JSONValue) => cmnP.readEnum<H264CodecLevel>(x),
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<H264CodecProfile>(x),
      "DynamicSubGop": (x: jsonP.JSONValue) => cmnP.readEnum<H264DynamicSubGop>(x),
      "EntropyEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<H264EntropyEncoding>(x),
      "FieldEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<H264FieldEncoding>(x),
      "FlickerAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H264FlickerAdaptiveQuantization>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<H264FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<H264FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopBReference": (x: jsonP.JSONValue) => cmnP.readEnum<H264GopBReference>(x),
      "GopClosedCadence": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<H264GopSizeUnits>(x),
      "HrdBufferInitialFillPercentage": "n",
      "HrdBufferSize": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<H264InterlaceMode>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "NumberBFramesBetweenReferenceFrames": "n",
      "NumberReferenceFrames": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<H264ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<H264QualityTuningLevel>(x),
      "QvbrSettings": toH264QvbrSettings,
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<H264RateControlMode>(x),
      "RepeatPps": (x: jsonP.JSONValue) => cmnP.readEnum<H264RepeatPps>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<H264SceneChangeDetect>(x),
      "Slices": "n",
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<H264SlowPal>(x),
      "Softness": "n",
      "SpatialAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H264SpatialAdaptiveQuantization>(x),
      "Syntax": (x: jsonP.JSONValue) => cmnP.readEnum<H264Syntax>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<H264Telecine>(x),
      "TemporalAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H264TemporalAdaptiveQuantization>(x),
      "UnregisteredSeiTimecode": (x: jsonP.JSONValue) => cmnP.readEnum<H264UnregisteredSeiTimecode>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type H264AdaptiveQuantization =
| "OFF"
| "LOW"
| "MEDIUM"
| "HIGH"
| "HIGHER"
| "MAX"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264CodecLevel =
| "AUTO"
| "LEVEL_1"
| "LEVEL_1_1"
| "LEVEL_1_2"
| "LEVEL_1_3"
| "LEVEL_2"
| "LEVEL_2_1"
| "LEVEL_2_2"
| "LEVEL_3"
| "LEVEL_3_1"
| "LEVEL_3_2"
| "LEVEL_4"
| "LEVEL_4_1"
| "LEVEL_4_2"
| "LEVEL_5"
| "LEVEL_5_1"
| "LEVEL_5_2"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264CodecProfile =
| "BASELINE"
| "HIGH"
| "HIGH_10BIT"
| "HIGH_422"
| "HIGH_422_10BIT"
| "MAIN"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264DynamicSubGop =
| "ADAPTIVE"
| "STATIC"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264EntropyEncoding =
| "CABAC"
| "CAVLC"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264FieldEncoding =
| "PAFF"
| "FORCE_FIELD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264FlickerAdaptiveQuantization =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264FramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264FramerateConversionAlgorithm =
| "DUPLICATE_DROP"
| "INTERPOLATE"
| "FRAMEFORMER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264GopBReference =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264GopSizeUnits =
| "FRAMES"
| "SECONDS"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264InterlaceMode =
| "PROGRESSIVE"
| "TOP_FIELD"
| "BOTTOM_FIELD"
| "FOLLOW_TOP_FIELD"
| "FOLLOW_BOTTOM_FIELD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264ParControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264QualityTuningLevel =
| "SINGLE_PASS"
| "SINGLE_PASS_HQ"
| "MULTI_PASS_HQ"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface H264QvbrSettings {
  MaxAverageBitrate?: number | null;
  QvbrQualityLevel?: number | null;
  QvbrQualityLevelFineTune?: number | null;
}
function fromH264QvbrSettings(input?: H264QvbrSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxAverageBitrate: input["MaxAverageBitrate"],
    qvbrQualityLevel: input["QvbrQualityLevel"],
    qvbrQualityLevelFineTune: input["QvbrQualityLevelFineTune"],
  }
}
function toH264QvbrSettings(root: jsonP.JSONValue): H264QvbrSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxAverageBitrate": "n",
      "QvbrQualityLevel": "n",
      "QvbrQualityLevelFineTune": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type H264RateControlMode =
| "VBR"
| "CBR"
| "QVBR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264RepeatPps =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264SceneChangeDetect =
| "DISABLED"
| "ENABLED"
| "TRANSITION_DETECTION"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264SlowPal =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264SpatialAdaptiveQuantization =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264Syntax =
| "DEFAULT"
| "RP2027"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264Telecine =
| "NONE"
| "SOFT"
| "HARD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264TemporalAdaptiveQuantization =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H264UnregisteredSeiTimecode =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface H265Settings {
  AdaptiveQuantization?: H265AdaptiveQuantization | null;
  AlternateTransferFunctionSei?: H265AlternateTransferFunctionSei | null;
  Bitrate?: number | null;
  CodecLevel?: H265CodecLevel | null;
  CodecProfile?: H265CodecProfile | null;
  DynamicSubGop?: H265DynamicSubGop | null;
  FlickerAdaptiveQuantization?: H265FlickerAdaptiveQuantization | null;
  FramerateControl?: H265FramerateControl | null;
  FramerateConversionAlgorithm?: H265FramerateConversionAlgorithm | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  GopBReference?: H265GopBReference | null;
  GopClosedCadence?: number | null;
  GopSize?: number | null;
  GopSizeUnits?: H265GopSizeUnits | null;
  HrdBufferInitialFillPercentage?: number | null;
  HrdBufferSize?: number | null;
  InterlaceMode?: H265InterlaceMode | null;
  MaxBitrate?: number | null;
  MinIInterval?: number | null;
  NumberBFramesBetweenReferenceFrames?: number | null;
  NumberReferenceFrames?: number | null;
  ParControl?: H265ParControl | null;
  ParDenominator?: number | null;
  ParNumerator?: number | null;
  QualityTuningLevel?: H265QualityTuningLevel | null;
  QvbrSettings?: H265QvbrSettings | null;
  RateControlMode?: H265RateControlMode | null;
  SampleAdaptiveOffsetFilterMode?: H265SampleAdaptiveOffsetFilterMode | null;
  SceneChangeDetect?: H265SceneChangeDetect | null;
  Slices?: number | null;
  SlowPal?: H265SlowPal | null;
  SpatialAdaptiveQuantization?: H265SpatialAdaptiveQuantization | null;
  Telecine?: H265Telecine | null;
  TemporalAdaptiveQuantization?: H265TemporalAdaptiveQuantization | null;
  TemporalIds?: H265TemporalIds | null;
  Tiles?: H265Tiles | null;
  UnregisteredSeiTimecode?: H265UnregisteredSeiTimecode | null;
  WriteMp4PackagingType?: H265WriteMp4PackagingType | null;
}
function fromH265Settings(input?: H265Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    alternateTransferFunctionSei: input["AlternateTransferFunctionSei"],
    bitrate: input["Bitrate"],
    codecLevel: input["CodecLevel"],
    codecProfile: input["CodecProfile"],
    dynamicSubGop: input["DynamicSubGop"],
    flickerAdaptiveQuantization: input["FlickerAdaptiveQuantization"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopBReference: input["GopBReference"],
    gopClosedCadence: input["GopClosedCadence"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    hrdBufferInitialFillPercentage: input["HrdBufferInitialFillPercentage"],
    hrdBufferSize: input["HrdBufferSize"],
    interlaceMode: input["InterlaceMode"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    numberBFramesBetweenReferenceFrames: input["NumberBFramesBetweenReferenceFrames"],
    numberReferenceFrames: input["NumberReferenceFrames"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    qvbrSettings: fromH265QvbrSettings(input["QvbrSettings"]),
    rateControlMode: input["RateControlMode"],
    sampleAdaptiveOffsetFilterMode: input["SampleAdaptiveOffsetFilterMode"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slices: input["Slices"],
    slowPal: input["SlowPal"],
    spatialAdaptiveQuantization: input["SpatialAdaptiveQuantization"],
    telecine: input["Telecine"],
    temporalAdaptiveQuantization: input["TemporalAdaptiveQuantization"],
    temporalIds: input["TemporalIds"],
    tiles: input["Tiles"],
    unregisteredSeiTimecode: input["UnregisteredSeiTimecode"],
    writeMp4PackagingType: input["WriteMp4PackagingType"],
  }
}
function toH265Settings(root: jsonP.JSONValue): H265Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H265AdaptiveQuantization>(x),
      "AlternateTransferFunctionSei": (x: jsonP.JSONValue) => cmnP.readEnum<H265AlternateTransferFunctionSei>(x),
      "Bitrate": "n",
      "CodecLevel": (x: jsonP.JSONValue) => cmnP.readEnum<H265CodecLevel>(x),
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<H265CodecProfile>(x),
      "DynamicSubGop": (x: jsonP.JSONValue) => cmnP.readEnum<H265DynamicSubGop>(x),
      "FlickerAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H265FlickerAdaptiveQuantization>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<H265FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<H265FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopBReference": (x: jsonP.JSONValue) => cmnP.readEnum<H265GopBReference>(x),
      "GopClosedCadence": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<H265GopSizeUnits>(x),
      "HrdBufferInitialFillPercentage": "n",
      "HrdBufferSize": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<H265InterlaceMode>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "NumberBFramesBetweenReferenceFrames": "n",
      "NumberReferenceFrames": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<H265ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<H265QualityTuningLevel>(x),
      "QvbrSettings": toH265QvbrSettings,
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<H265RateControlMode>(x),
      "SampleAdaptiveOffsetFilterMode": (x: jsonP.JSONValue) => cmnP.readEnum<H265SampleAdaptiveOffsetFilterMode>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<H265SceneChangeDetect>(x),
      "Slices": "n",
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<H265SlowPal>(x),
      "SpatialAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H265SpatialAdaptiveQuantization>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<H265Telecine>(x),
      "TemporalAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H265TemporalAdaptiveQuantization>(x),
      "TemporalIds": (x: jsonP.JSONValue) => cmnP.readEnum<H265TemporalIds>(x),
      "Tiles": (x: jsonP.JSONValue) => cmnP.readEnum<H265Tiles>(x),
      "UnregisteredSeiTimecode": (x: jsonP.JSONValue) => cmnP.readEnum<H265UnregisteredSeiTimecode>(x),
      "WriteMp4PackagingType": (x: jsonP.JSONValue) => cmnP.readEnum<H265WriteMp4PackagingType>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type H265AdaptiveQuantization =
| "OFF"
| "LOW"
| "MEDIUM"
| "HIGH"
| "HIGHER"
| "MAX"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265AlternateTransferFunctionSei =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265CodecLevel =
| "AUTO"
| "LEVEL_1"
| "LEVEL_2"
| "LEVEL_2_1"
| "LEVEL_3"
| "LEVEL_3_1"
| "LEVEL_4"
| "LEVEL_4_1"
| "LEVEL_5"
| "LEVEL_5_1"
| "LEVEL_5_2"
| "LEVEL_6"
| "LEVEL_6_1"
| "LEVEL_6_2"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265CodecProfile =
| "MAIN_MAIN"
| "MAIN_HIGH"
| "MAIN10_MAIN"
| "MAIN10_HIGH"
| "MAIN_422_8BIT_MAIN"
| "MAIN_422_8BIT_HIGH"
| "MAIN_422_10BIT_MAIN"
| "MAIN_422_10BIT_HIGH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265DynamicSubGop =
| "ADAPTIVE"
| "STATIC"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265FlickerAdaptiveQuantization =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265FramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265FramerateConversionAlgorithm =
| "DUPLICATE_DROP"
| "INTERPOLATE"
| "FRAMEFORMER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265GopBReference =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265GopSizeUnits =
| "FRAMES"
| "SECONDS"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265InterlaceMode =
| "PROGRESSIVE"
| "TOP_FIELD"
| "BOTTOM_FIELD"
| "FOLLOW_TOP_FIELD"
| "FOLLOW_BOTTOM_FIELD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265ParControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265QualityTuningLevel =
| "SINGLE_PASS"
| "SINGLE_PASS_HQ"
| "MULTI_PASS_HQ"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface H265QvbrSettings {
  MaxAverageBitrate?: number | null;
  QvbrQualityLevel?: number | null;
  QvbrQualityLevelFineTune?: number | null;
}
function fromH265QvbrSettings(input?: H265QvbrSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxAverageBitrate: input["MaxAverageBitrate"],
    qvbrQualityLevel: input["QvbrQualityLevel"],
    qvbrQualityLevelFineTune: input["QvbrQualityLevelFineTune"],
  }
}
function toH265QvbrSettings(root: jsonP.JSONValue): H265QvbrSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxAverageBitrate": "n",
      "QvbrQualityLevel": "n",
      "QvbrQualityLevelFineTune": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type H265RateControlMode =
| "VBR"
| "CBR"
| "QVBR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265SampleAdaptiveOffsetFilterMode =
| "DEFAULT"
| "ADAPTIVE"
| "OFF"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265SceneChangeDetect =
| "DISABLED"
| "ENABLED"
| "TRANSITION_DETECTION"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265SlowPal =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265SpatialAdaptiveQuantization =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265Telecine =
| "NONE"
| "SOFT"
| "HARD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265TemporalAdaptiveQuantization =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265TemporalIds =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265Tiles =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265UnregisteredSeiTimecode =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type H265WriteMp4PackagingType =
| "HVC1"
| "HEV1"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Mpeg2Settings {
  AdaptiveQuantization?: Mpeg2AdaptiveQuantization | null;
  Bitrate?: number | null;
  CodecLevel?: Mpeg2CodecLevel | null;
  CodecProfile?: Mpeg2CodecProfile | null;
  DynamicSubGop?: Mpeg2DynamicSubGop | null;
  FramerateControl?: Mpeg2FramerateControl | null;
  FramerateConversionAlgorithm?: Mpeg2FramerateConversionAlgorithm | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  GopClosedCadence?: number | null;
  GopSize?: number | null;
  GopSizeUnits?: Mpeg2GopSizeUnits | null;
  HrdBufferInitialFillPercentage?: number | null;
  HrdBufferSize?: number | null;
  InterlaceMode?: Mpeg2InterlaceMode | null;
  IntraDcPrecision?: Mpeg2IntraDcPrecision | null;
  MaxBitrate?: number | null;
  MinIInterval?: number | null;
  NumberBFramesBetweenReferenceFrames?: number | null;
  ParControl?: Mpeg2ParControl | null;
  ParDenominator?: number | null;
  ParNumerator?: number | null;
  QualityTuningLevel?: Mpeg2QualityTuningLevel | null;
  RateControlMode?: Mpeg2RateControlMode | null;
  SceneChangeDetect?: Mpeg2SceneChangeDetect | null;
  SlowPal?: Mpeg2SlowPal | null;
  Softness?: number | null;
  SpatialAdaptiveQuantization?: Mpeg2SpatialAdaptiveQuantization | null;
  Syntax?: Mpeg2Syntax | null;
  Telecine?: Mpeg2Telecine | null;
  TemporalAdaptiveQuantization?: Mpeg2TemporalAdaptiveQuantization | null;
}
function fromMpeg2Settings(input?: Mpeg2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    bitrate: input["Bitrate"],
    codecLevel: input["CodecLevel"],
    codecProfile: input["CodecProfile"],
    dynamicSubGop: input["DynamicSubGop"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopClosedCadence: input["GopClosedCadence"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    hrdBufferInitialFillPercentage: input["HrdBufferInitialFillPercentage"],
    hrdBufferSize: input["HrdBufferSize"],
    interlaceMode: input["InterlaceMode"],
    intraDcPrecision: input["IntraDcPrecision"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    numberBFramesBetweenReferenceFrames: input["NumberBFramesBetweenReferenceFrames"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    rateControlMode: input["RateControlMode"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slowPal: input["SlowPal"],
    softness: input["Softness"],
    spatialAdaptiveQuantization: input["SpatialAdaptiveQuantization"],
    syntax: input["Syntax"],
    telecine: input["Telecine"],
    temporalAdaptiveQuantization: input["TemporalAdaptiveQuantization"],
  }
}
function toMpeg2Settings(root: jsonP.JSONValue): Mpeg2Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2AdaptiveQuantization>(x),
      "Bitrate": "n",
      "CodecLevel": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2CodecLevel>(x),
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2CodecProfile>(x),
      "DynamicSubGop": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2DynamicSubGop>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopClosedCadence": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2GopSizeUnits>(x),
      "HrdBufferInitialFillPercentage": "n",
      "HrdBufferSize": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2InterlaceMode>(x),
      "IntraDcPrecision": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2IntraDcPrecision>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "NumberBFramesBetweenReferenceFrames": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2QualityTuningLevel>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2RateControlMode>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2SceneChangeDetect>(x),
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2SlowPal>(x),
      "Softness": "n",
      "SpatialAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2SpatialAdaptiveQuantization>(x),
      "Syntax": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2Syntax>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2Telecine>(x),
      "TemporalAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2TemporalAdaptiveQuantization>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Mpeg2AdaptiveQuantization =
| "OFF"
| "LOW"
| "MEDIUM"
| "HIGH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2CodecLevel =
| "AUTO"
| "LOW"
| "MAIN"
| "HIGH1440"
| "HIGH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2CodecProfile =
| "MAIN"
| "PROFILE_422"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2DynamicSubGop =
| "ADAPTIVE"
| "STATIC"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2FramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2FramerateConversionAlgorithm =
| "DUPLICATE_DROP"
| "INTERPOLATE"
| "FRAMEFORMER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2GopSizeUnits =
| "FRAMES"
| "SECONDS"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2InterlaceMode =
| "PROGRESSIVE"
| "TOP_FIELD"
| "BOTTOM_FIELD"
| "FOLLOW_TOP_FIELD"
| "FOLLOW_BOTTOM_FIELD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2IntraDcPrecision =
| "AUTO"
| "INTRA_DC_PRECISION_8"
| "INTRA_DC_PRECISION_9"
| "INTRA_DC_PRECISION_10"
| "INTRA_DC_PRECISION_11"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2ParControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2QualityTuningLevel =
| "SINGLE_PASS"
| "MULTI_PASS"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2RateControlMode =
| "VBR"
| "CBR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2SceneChangeDetect =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2SlowPal =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2SpatialAdaptiveQuantization =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2Syntax =
| "DEFAULT"
| "D_10"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2Telecine =
| "NONE"
| "SOFT"
| "HARD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Mpeg2TemporalAdaptiveQuantization =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface ProresSettings {
  CodecProfile?: ProresCodecProfile | null;
  FramerateControl?: ProresFramerateControl | null;
  FramerateConversionAlgorithm?: ProresFramerateConversionAlgorithm | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  InterlaceMode?: ProresInterlaceMode | null;
  ParControl?: ProresParControl | null;
  ParDenominator?: number | null;
  ParNumerator?: number | null;
  SlowPal?: ProresSlowPal | null;
  Telecine?: ProresTelecine | null;
}
function fromProresSettings(input?: ProresSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    codecProfile: input["CodecProfile"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    interlaceMode: input["InterlaceMode"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    slowPal: input["SlowPal"],
    telecine: input["Telecine"],
  }
}
function toProresSettings(root: jsonP.JSONValue): ProresSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<ProresCodecProfile>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<ProresFramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<ProresFramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<ProresInterlaceMode>(x),
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<ProresParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<ProresSlowPal>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<ProresTelecine>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type ProresCodecProfile =
| "APPLE_PRORES_422"
| "APPLE_PRORES_422_HQ"
| "APPLE_PRORES_422_LT"
| "APPLE_PRORES_422_PROXY"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type ProresFramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type ProresFramerateConversionAlgorithm =
| "DUPLICATE_DROP"
| "INTERPOLATE"
| "FRAMEFORMER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type ProresInterlaceMode =
| "PROGRESSIVE"
| "TOP_FIELD"
| "BOTTOM_FIELD"
| "FOLLOW_TOP_FIELD"
| "FOLLOW_BOTTOM_FIELD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type ProresParControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type ProresSlowPal =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type ProresTelecine =
| "NONE"
| "HARD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Vc3Settings {
  FramerateControl?: Vc3FramerateControl | null;
  FramerateConversionAlgorithm?: Vc3FramerateConversionAlgorithm | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  InterlaceMode?: Vc3InterlaceMode | null;
  SlowPal?: Vc3SlowPal | null;
  Telecine?: Vc3Telecine | null;
  Vc3Class?: Vc3Class | null;
}
function fromVc3Settings(input?: Vc3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    interlaceMode: input["InterlaceMode"],
    slowPal: input["SlowPal"],
    telecine: input["Telecine"],
    vc3Class: input["Vc3Class"],
  }
}
function toVc3Settings(root: jsonP.JSONValue): Vc3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<Vc3FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<Vc3FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<Vc3InterlaceMode>(x),
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<Vc3SlowPal>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<Vc3Telecine>(x),
      "Vc3Class": (x: jsonP.JSONValue) => cmnP.readEnum<Vc3Class>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Vc3FramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vc3FramerateConversionAlgorithm =
| "DUPLICATE_DROP"
| "INTERPOLATE"
| "FRAMEFORMER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vc3InterlaceMode =
| "INTERLACED"
| "PROGRESSIVE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vc3SlowPal =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vc3Telecine =
| "NONE"
| "HARD"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vc3Class =
| "CLASS_145_8BIT"
| "CLASS_220_8BIT"
| "CLASS_220_10BIT"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Vp8Settings {
  Bitrate?: number | null;
  FramerateControl?: Vp8FramerateControl | null;
  FramerateConversionAlgorithm?: Vp8FramerateConversionAlgorithm | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  GopSize?: number | null;
  HrdBufferSize?: number | null;
  MaxBitrate?: number | null;
  ParControl?: Vp8ParControl | null;
  ParDenominator?: number | null;
  ParNumerator?: number | null;
  QualityTuningLevel?: Vp8QualityTuningLevel | null;
  RateControlMode?: Vp8RateControlMode | null;
}
function fromVp8Settings(input?: Vp8Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopSize: input["GopSize"],
    hrdBufferSize: input["HrdBufferSize"],
    maxBitrate: input["MaxBitrate"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    rateControlMode: input["RateControlMode"],
  }
}
function toVp8Settings(root: jsonP.JSONValue): Vp8Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<Vp8FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<Vp8FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopSize": "n",
      "HrdBufferSize": "n",
      "MaxBitrate": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<Vp8ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<Vp8QualityTuningLevel>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<Vp8RateControlMode>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Vp8FramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vp8FramerateConversionAlgorithm =
| "DUPLICATE_DROP"
| "INTERPOLATE"
| "FRAMEFORMER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vp8ParControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vp8QualityTuningLevel =
| "MULTI_PASS"
| "MULTI_PASS_HQ"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vp8RateControlMode =
| "VBR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Vp9Settings {
  Bitrate?: number | null;
  FramerateControl?: Vp9FramerateControl | null;
  FramerateConversionAlgorithm?: Vp9FramerateConversionAlgorithm | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  GopSize?: number | null;
  HrdBufferSize?: number | null;
  MaxBitrate?: number | null;
  ParControl?: Vp9ParControl | null;
  ParDenominator?: number | null;
  ParNumerator?: number | null;
  QualityTuningLevel?: Vp9QualityTuningLevel | null;
  RateControlMode?: Vp9RateControlMode | null;
}
function fromVp9Settings(input?: Vp9Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopSize: input["GopSize"],
    hrdBufferSize: input["HrdBufferSize"],
    maxBitrate: input["MaxBitrate"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    rateControlMode: input["RateControlMode"],
  }
}
function toVp9Settings(root: jsonP.JSONValue): Vp9Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<Vp9FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<Vp9FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopSize": "n",
      "HrdBufferSize": "n",
      "MaxBitrate": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<Vp9ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<Vp9QualityTuningLevel>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<Vp9RateControlMode>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type Vp9FramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vp9FramerateConversionAlgorithm =
| "DUPLICATE_DROP"
| "INTERPOLATE"
| "FRAMEFORMER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vp9ParControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vp9QualityTuningLevel =
| "MULTI_PASS"
| "MULTI_PASS_HQ"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type Vp9RateControlMode =
| "VBR"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type ColorMetadata =
| "IGNORE"
| "INSERT"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DropFrameTimecode =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type RespondToAfd =
| "NONE"
| "RESPOND"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type ScalingBehavior =
| "DEFAULT"
| "STRETCH_TO_OUTPUT"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type VideoTimecodeInsertion =
| "DISABLED"
| "PIC_TIMING_SEI"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface VideoPreprocessor {
  ColorCorrector?: ColorCorrector | null;
  Deinterlacer?: Deinterlacer | null;
  DolbyVision?: DolbyVision | null;
  ImageInserter?: ImageInserter | null;
  NoiseReducer?: NoiseReducer | null;
  PartnerWatermarking?: PartnerWatermarking | null;
  TimecodeBurnin?: TimecodeBurnin | null;
}
function fromVideoPreprocessor(input?: VideoPreprocessor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    colorCorrector: fromColorCorrector(input["ColorCorrector"]),
    deinterlacer: fromDeinterlacer(input["Deinterlacer"]),
    dolbyVision: fromDolbyVision(input["DolbyVision"]),
    imageInserter: fromImageInserter(input["ImageInserter"]),
    noiseReducer: fromNoiseReducer(input["NoiseReducer"]),
    partnerWatermarking: fromPartnerWatermarking(input["PartnerWatermarking"]),
    timecodeBurnin: fromTimecodeBurnin(input["TimecodeBurnin"]),
  }
}
function toVideoPreprocessor(root: jsonP.JSONValue): VideoPreprocessor {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColorCorrector": toColorCorrector,
      "Deinterlacer": toDeinterlacer,
      "DolbyVision": toDolbyVision,
      "ImageInserter": toImageInserter,
      "NoiseReducer": toNoiseReducer,
      "PartnerWatermarking": toPartnerWatermarking,
      "TimecodeBurnin": toTimecodeBurnin,
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface ColorCorrector {
  Brightness?: number | null;
  ColorSpaceConversion?: ColorSpaceConversion | null;
  Contrast?: number | null;
  Hdr10Metadata?: Hdr10Metadata | null;
  Hue?: number | null;
  Saturation?: number | null;
}
function fromColorCorrector(input?: ColorCorrector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    brightness: input["Brightness"],
    colorSpaceConversion: input["ColorSpaceConversion"],
    contrast: input["Contrast"],
    hdr10Metadata: fromHdr10Metadata(input["Hdr10Metadata"]),
    hue: input["Hue"],
    saturation: input["Saturation"],
  }
}
function toColorCorrector(root: jsonP.JSONValue): ColorCorrector {
  return jsonP.readObj({
    required: {},
    optional: {
      "Brightness": "n",
      "ColorSpaceConversion": (x: jsonP.JSONValue) => cmnP.readEnum<ColorSpaceConversion>(x),
      "Contrast": "n",
      "Hdr10Metadata": toHdr10Metadata,
      "Hue": "n",
      "Saturation": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type ColorSpaceConversion =
| "NONE"
| "FORCE_601"
| "FORCE_709"
| "FORCE_HDR10"
| "FORCE_HLG_2020"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Deinterlacer {
  Algorithm?: DeinterlaceAlgorithm | null;
  Control?: DeinterlacerControl | null;
  Mode?: DeinterlacerMode | null;
}
function fromDeinterlacer(input?: Deinterlacer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    algorithm: input["Algorithm"],
    control: input["Control"],
    mode: input["Mode"],
  }
}
function toDeinterlacer(root: jsonP.JSONValue): Deinterlacer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Algorithm": (x: jsonP.JSONValue) => cmnP.readEnum<DeinterlaceAlgorithm>(x),
      "Control": (x: jsonP.JSONValue) => cmnP.readEnum<DeinterlacerControl>(x),
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<DeinterlacerMode>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type DeinterlaceAlgorithm =
| "INTERPOLATE"
| "INTERPOLATE_TICKER"
| "BLEND"
| "BLEND_TICKER"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DeinterlacerControl =
| "FORCE_ALL_FRAMES"
| "NORMAL"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DeinterlacerMode =
| "DEINTERLACE"
| "INVERSE_TELECINE"
| "ADAPTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface DolbyVision {
  L6Metadata?: DolbyVisionLevel6Metadata | null;
  L6Mode?: DolbyVisionLevel6Mode | null;
  Profile?: DolbyVisionProfile | null;
}
function fromDolbyVision(input?: DolbyVision | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    l6Metadata: fromDolbyVisionLevel6Metadata(input["L6Metadata"]),
    l6Mode: input["L6Mode"],
    profile: input["Profile"],
  }
}
function toDolbyVision(root: jsonP.JSONValue): DolbyVision {
  return jsonP.readObj({
    required: {},
    optional: {
      "L6Metadata": toDolbyVisionLevel6Metadata,
      "L6Mode": (x: jsonP.JSONValue) => cmnP.readEnum<DolbyVisionLevel6Mode>(x),
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<DolbyVisionProfile>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface DolbyVisionLevel6Metadata {
  MaxCll?: number | null;
  MaxFall?: number | null;
}
function fromDolbyVisionLevel6Metadata(input?: DolbyVisionLevel6Metadata | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxCll: input["MaxCll"],
    maxFall: input["MaxFall"],
  }
}
function toDolbyVisionLevel6Metadata(root: jsonP.JSONValue): DolbyVisionLevel6Metadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxCll": "n",
      "MaxFall": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type DolbyVisionLevel6Mode =
| "PASSTHROUGH"
| "RECALCULATE"
| "SPECIFY"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, enum, output
export type DolbyVisionProfile =
| "PROFILE_5"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface NoiseReducer {
  Filter?: NoiseReducerFilter | null;
  FilterSettings?: NoiseReducerFilterSettings | null;
  SpatialFilterSettings?: NoiseReducerSpatialFilterSettings | null;
  TemporalFilterSettings?: NoiseReducerTemporalFilterSettings | null;
}
function fromNoiseReducer(input?: NoiseReducer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filter: input["Filter"],
    filterSettings: fromNoiseReducerFilterSettings(input["FilterSettings"]),
    spatialFilterSettings: fromNoiseReducerSpatialFilterSettings(input["SpatialFilterSettings"]),
    temporalFilterSettings: fromNoiseReducerTemporalFilterSettings(input["TemporalFilterSettings"]),
  }
}
function toNoiseReducer(root: jsonP.JSONValue): NoiseReducer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Filter": (x: jsonP.JSONValue) => cmnP.readEnum<NoiseReducerFilter>(x),
      "FilterSettings": toNoiseReducerFilterSettings,
      "SpatialFilterSettings": toNoiseReducerSpatialFilterSettings,
      "TemporalFilterSettings": toNoiseReducerTemporalFilterSettings,
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type NoiseReducerFilter =
| "BILATERAL"
| "MEAN"
| "GAUSSIAN"
| "LANCZOS"
| "SHARPEN"
| "CONSERVE"
| "SPATIAL"
| "TEMPORAL"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface NoiseReducerFilterSettings {
  Strength?: number | null;
}
function fromNoiseReducerFilterSettings(input?: NoiseReducerFilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    strength: input["Strength"],
  }
}
function toNoiseReducerFilterSettings(root: jsonP.JSONValue): NoiseReducerFilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Strength": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface NoiseReducerSpatialFilterSettings {
  PostFilterSharpenStrength?: number | null;
  Speed?: number | null;
  Strength?: number | null;
}
function fromNoiseReducerSpatialFilterSettings(input?: NoiseReducerSpatialFilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    postFilterSharpenStrength: input["PostFilterSharpenStrength"],
    speed: input["Speed"],
    strength: input["Strength"],
  }
}
function toNoiseReducerSpatialFilterSettings(root: jsonP.JSONValue): NoiseReducerSpatialFilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PostFilterSharpenStrength": "n",
      "Speed": "n",
      "Strength": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface NoiseReducerTemporalFilterSettings {
  AggressiveMode?: number | null;
  PostTemporalSharpening?: NoiseFilterPostTemporalSharpening | null;
  Speed?: number | null;
  Strength?: number | null;
}
function fromNoiseReducerTemporalFilterSettings(input?: NoiseReducerTemporalFilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    aggressiveMode: input["AggressiveMode"],
    postTemporalSharpening: input["PostTemporalSharpening"],
    speed: input["Speed"],
    strength: input["Strength"],
  }
}
function toNoiseReducerTemporalFilterSettings(root: jsonP.JSONValue): NoiseReducerTemporalFilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AggressiveMode": "n",
      "PostTemporalSharpening": (x: jsonP.JSONValue) => cmnP.readEnum<NoiseFilterPostTemporalSharpening>(x),
      "Speed": "n",
      "Strength": "n",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type NoiseFilterPostTemporalSharpening =
| "DISABLED"
| "ENABLED"
| "AUTO"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface PartnerWatermarking {
  NexguardFileMarkerSettings?: NexGuardFileMarkerSettings | null;
}
function fromPartnerWatermarking(input?: PartnerWatermarking | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    nexguardFileMarkerSettings: fromNexGuardFileMarkerSettings(input["NexguardFileMarkerSettings"]),
  }
}
function toPartnerWatermarking(root: jsonP.JSONValue): PartnerWatermarking {
  return jsonP.readObj({
    required: {},
    optional: {
      "NexguardFileMarkerSettings": toNexGuardFileMarkerSettings,
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface NexGuardFileMarkerSettings {
  License?: string | null;
  Payload?: number | null;
  Preset?: string | null;
  Strength?: WatermarkingStrength | null;
}
function fromNexGuardFileMarkerSettings(input?: NexGuardFileMarkerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    license: input["License"],
    payload: input["Payload"],
    preset: input["Preset"],
    strength: input["Strength"],
  }
}
function toNexGuardFileMarkerSettings(root: jsonP.JSONValue): NexGuardFileMarkerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "License": "s",
      "Payload": "n",
      "Preset": "s",
      "Strength": (x: jsonP.JSONValue) => cmnP.readEnum<WatermarkingStrength>(x),
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type WatermarkingStrength =
| "LIGHTEST"
| "LIGHTER"
| "DEFAULT"
| "STRONGER"
| "STRONGEST"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface TimecodeBurnin {
  FontSize?: number | null;
  Position?: TimecodeBurninPosition | null;
  Prefix?: string | null;
}
function fromTimecodeBurnin(input?: TimecodeBurnin | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fontSize: input["FontSize"],
    position: input["Position"],
    prefix: input["Prefix"],
  }
}
function toTimecodeBurnin(root: jsonP.JSONValue): TimecodeBurnin {
  return jsonP.readObj({
    required: {},
    optional: {
      "FontSize": "n",
      "Position": (x: jsonP.JSONValue) => cmnP.readEnum<TimecodeBurninPosition>(x),
      "Prefix": "s",
    },
  }, root);
}

// refs: 16 - tags: input, named, enum, output
export type TimecodeBurninPosition =
| "TOP_CENTER"
| "TOP_LEFT"
| "TOP_RIGHT"
| "MIDDLE_LEFT"
| "MIDDLE_CENTER"
| "MIDDLE_RIGHT"
| "BOTTOM_LEFT"
| "BOTTOM_CENTER"
| "BOTTOM_RIGHT"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface TimecodeConfig {
  Anchor?: string | null;
  Source?: TimecodeSource | null;
  Start?: string | null;
  TimestampOffset?: string | null;
}
function fromTimecodeConfig(input?: TimecodeConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    anchor: input["Anchor"],
    source: input["Source"],
    start: input["Start"],
    timestampOffset: input["TimestampOffset"],
  }
}
function toTimecodeConfig(root: jsonP.JSONValue): TimecodeConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "Anchor": "s",
      "Source": (x: jsonP.JSONValue) => cmnP.readEnum<TimecodeSource>(x),
      "Start": "s",
      "TimestampOffset": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type TimecodeSource =
| "EMBEDDED"
| "ZEROBASED"
| "SPECIFIEDSTART"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface TimedMetadataInsertion {
  Id3Insertions?: Id3Insertion[] | null;
}
function fromTimedMetadataInsertion(input?: TimedMetadataInsertion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id3Insertions: input["Id3Insertions"]?.map(x => fromId3Insertion(x)),
  }
}
function toTimedMetadataInsertion(root: jsonP.JSONValue): TimedMetadataInsertion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id3Insertions": [toId3Insertion],
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface Id3Insertion {
  Id3?: string | null;
  Timecode?: string | null;
}
function fromId3Insertion(input?: Id3Insertion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id3: input["Id3"],
    timecode: input["Timecode"],
  }
}
function toId3Insertion(root: jsonP.JSONValue): Id3Insertion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id3": "s",
      "Timecode": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type SimulateReservedQueue =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type StatusUpdateInterval =
| "SECONDS_10"
| "SECONDS_12"
| "SECONDS_15"
| "SECONDS_20"
| "SECONDS_30"
| "SECONDS_60"
| "SECONDS_120"
| "SECONDS_180"
| "SECONDS_240"
| "SECONDS_300"
| "SECONDS_360"
| "SECONDS_420"
| "SECONDS_480"
| "SECONDS_540"
| "SECONDS_600"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface JobTemplateSettings {
  AdAvailOffset?: number | null;
  AvailBlanking?: AvailBlanking | null;
  Esam?: EsamSettings | null;
  Inputs?: InputTemplate[] | null;
  MotionImageInserter?: MotionImageInserter | null;
  NielsenConfiguration?: NielsenConfiguration | null;
  NielsenNonLinearWatermark?: NielsenNonLinearWatermarkSettings | null;
  OutputGroups?: OutputGroup[] | null;
  TimecodeConfig?: TimecodeConfig | null;
  TimedMetadataInsertion?: TimedMetadataInsertion | null;
}
function fromJobTemplateSettings(input?: JobTemplateSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adAvailOffset: input["AdAvailOffset"],
    availBlanking: fromAvailBlanking(input["AvailBlanking"]),
    esam: fromEsamSettings(input["Esam"]),
    inputs: input["Inputs"]?.map(x => fromInputTemplate(x)),
    motionImageInserter: fromMotionImageInserter(input["MotionImageInserter"]),
    nielsenConfiguration: fromNielsenConfiguration(input["NielsenConfiguration"]),
    nielsenNonLinearWatermark: fromNielsenNonLinearWatermarkSettings(input["NielsenNonLinearWatermark"]),
    outputGroups: input["OutputGroups"]?.map(x => fromOutputGroup(x)),
    timecodeConfig: fromTimecodeConfig(input["TimecodeConfig"]),
    timedMetadataInsertion: fromTimedMetadataInsertion(input["TimedMetadataInsertion"]),
  }
}
function toJobTemplateSettings(root: jsonP.JSONValue): JobTemplateSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdAvailOffset": "n",
      "AvailBlanking": toAvailBlanking,
      "Esam": toEsamSettings,
      "Inputs": [toInputTemplate],
      "MotionImageInserter": toMotionImageInserter,
      "NielsenConfiguration": toNielsenConfiguration,
      "NielsenNonLinearWatermark": toNielsenNonLinearWatermarkSettings,
      "OutputGroups": [toOutputGroup],
      "TimecodeConfig": toTimecodeConfig,
      "TimedMetadataInsertion": toTimedMetadataInsertion,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface InputTemplate {
  AudioSelectorGroups?: { [key: string]: AudioSelectorGroup | null | undefined } | null;
  AudioSelectors?: { [key: string]: AudioSelector | null | undefined } | null;
  CaptionSelectors?: { [key: string]: CaptionSelector | null | undefined } | null;
  Crop?: Rectangle | null;
  DeblockFilter?: InputDeblockFilter | null;
  DenoiseFilter?: InputDenoiseFilter | null;
  FilterEnable?: InputFilterEnable | null;
  FilterStrength?: number | null;
  ImageInserter?: ImageInserter | null;
  InputClippings?: InputClipping[] | null;
  InputScanType?: InputScanType | null;
  Position?: Rectangle | null;
  ProgramNumber?: number | null;
  PsiControl?: InputPsiControl | null;
  TimecodeSource?: InputTimecodeSource | null;
  TimecodeStart?: string | null;
  VideoSelector?: VideoSelector | null;
}
function fromInputTemplate(input?: InputTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectorGroups: jsonP.serializeMap(input["AudioSelectorGroups"], x => fromAudioSelectorGroup(x)),
    audioSelectors: jsonP.serializeMap(input["AudioSelectors"], x => fromAudioSelector(x)),
    captionSelectors: jsonP.serializeMap(input["CaptionSelectors"], x => fromCaptionSelector(x)),
    crop: fromRectangle(input["Crop"]),
    deblockFilter: input["DeblockFilter"],
    denoiseFilter: input["DenoiseFilter"],
    filterEnable: input["FilterEnable"],
    filterStrength: input["FilterStrength"],
    imageInserter: fromImageInserter(input["ImageInserter"]),
    inputClippings: input["InputClippings"]?.map(x => fromInputClipping(x)),
    inputScanType: input["InputScanType"],
    position: fromRectangle(input["Position"]),
    programNumber: input["ProgramNumber"],
    psiControl: input["PsiControl"],
    timecodeSource: input["TimecodeSource"],
    timecodeStart: input["TimecodeStart"],
    videoSelector: fromVideoSelector(input["VideoSelector"]),
  }
}
function toInputTemplate(root: jsonP.JSONValue): InputTemplate {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSelectorGroups": x => jsonP.readMap(String, toAudioSelectorGroup, x),
      "AudioSelectors": x => jsonP.readMap(String, toAudioSelector, x),
      "CaptionSelectors": x => jsonP.readMap(String, toCaptionSelector, x),
      "Crop": toRectangle,
      "DeblockFilter": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeblockFilter>(x),
      "DenoiseFilter": (x: jsonP.JSONValue) => cmnP.readEnum<InputDenoiseFilter>(x),
      "FilterEnable": (x: jsonP.JSONValue) => cmnP.readEnum<InputFilterEnable>(x),
      "FilterStrength": "n",
      "ImageInserter": toImageInserter,
      "InputClippings": [toInputClipping],
      "InputScanType": (x: jsonP.JSONValue) => cmnP.readEnum<InputScanType>(x),
      "Position": toRectangle,
      "ProgramNumber": "n",
      "PsiControl": (x: jsonP.JSONValue) => cmnP.readEnum<InputPsiControl>(x),
      "TimecodeSource": (x: jsonP.JSONValue) => cmnP.readEnum<InputTimecodeSource>(x),
      "TimecodeStart": "s",
      "VideoSelector": toVideoSelector,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface PresetSettings {
  AudioDescriptions?: AudioDescription[] | null;
  CaptionDescriptions?: CaptionDescriptionPreset[] | null;
  ContainerSettings?: ContainerSettings | null;
  VideoDescription?: VideoDescription | null;
}
function fromPresetSettings(input?: PresetSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptions: input["AudioDescriptions"]?.map(x => fromAudioDescription(x)),
    captionDescriptions: input["CaptionDescriptions"]?.map(x => fromCaptionDescriptionPreset(x)),
    containerSettings: fromContainerSettings(input["ContainerSettings"]),
    videoDescription: fromVideoDescription(input["VideoDescription"]),
  }
}
function toPresetSettings(root: jsonP.JSONValue): PresetSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioDescriptions": [toAudioDescription],
      "CaptionDescriptions": [toCaptionDescriptionPreset],
      "ContainerSettings": toContainerSettings,
      "VideoDescription": toVideoDescription,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface CaptionDescriptionPreset {
  CustomLanguageCode?: string | null;
  DestinationSettings?: CaptionDestinationSettings | null;
  LanguageCode?: LanguageCode | null;
  LanguageDescription?: string | null;
}
function fromCaptionDescriptionPreset(input?: CaptionDescriptionPreset | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    customLanguageCode: input["CustomLanguageCode"],
    destinationSettings: fromCaptionDestinationSettings(input["DestinationSettings"]),
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
  }
}
function toCaptionDescriptionPreset(root: jsonP.JSONValue): CaptionDescriptionPreset {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomLanguageCode": "s",
      "DestinationSettings": toCaptionDestinationSettings,
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "LanguageDescription": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type PricingPlan =
| "ON_DEMAND"
| "RESERVED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface ReservationPlanSettings {
  Commitment: Commitment;
  RenewalType: RenewalType;
  ReservedSlots: number;
}
function fromReservationPlanSettings(input?: ReservationPlanSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    commitment: input["Commitment"],
    renewalType: input["RenewalType"],
    reservedSlots: input["ReservedSlots"],
  }
}

// refs: 6 - tags: input, named, enum, output
export type Commitment =
| "ONE_YEAR"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type RenewalType =
| "AUTO_RENEW"
| "EXPIRE"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type QueueStatus =
| "ACTIVE"
| "PAUSED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type DescribeEndpointsMode =
| "DEFAULT"
| "GET_ONLY"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type JobTemplateListBy =
| "NAME"
| "CREATION_DATE"
| "SYSTEM"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum
export type Order =
| "ASCENDING"
| "DESCENDING"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type JobStatus =
| "SUBMITTED"
| "PROGRESSING"
| "COMPLETE"
| "CANCELED"
| "ERROR"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type PresetListBy =
| "NAME"
| "CREATION_DATE"
| "SYSTEM"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type QueueListBy =
| "NAME"
| "CREATION_DATE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface Job {
  AccelerationSettings?: AccelerationSettings | null;
  AccelerationStatus?: AccelerationStatus | null;
  Arn?: string | null;
  BillingTagsSource?: BillingTagsSource | null;
  CreatedAt?: Date | number | null;
  CurrentPhase?: JobPhase | null;
  ErrorCode?: number | null;
  ErrorMessage?: string | null;
  HopDestinations?: HopDestination[] | null;
  Id?: string | null;
  JobPercentComplete?: number | null;
  JobTemplate?: string | null;
  Messages?: JobMessages | null;
  OutputGroupDetails?: OutputGroupDetail[] | null;
  Priority?: number | null;
  Queue?: string | null;
  QueueTransitions?: QueueTransition[] | null;
  RetryCount?: number | null;
  Role: string;
  Settings: JobSettings;
  SimulateReservedQueue?: SimulateReservedQueue | null;
  Status?: JobStatus | null;
  StatusUpdateInterval?: StatusUpdateInterval | null;
  Timing?: Timing | null;
  UserMetadata?: { [key: string]: string | null | undefined } | null;
}
function toJob(root: jsonP.JSONValue): Job {
  return jsonP.readObj({
    required: {
      "Role": "s",
      "Settings": toJobSettings,
    },
    optional: {
      "AccelerationSettings": toAccelerationSettings,
      "AccelerationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AccelerationStatus>(x),
      "Arn": "s",
      "BillingTagsSource": (x: jsonP.JSONValue) => cmnP.readEnum<BillingTagsSource>(x),
      "CreatedAt": "d",
      "CurrentPhase": (x: jsonP.JSONValue) => cmnP.readEnum<JobPhase>(x),
      "ErrorCode": "n",
      "ErrorMessage": "s",
      "HopDestinations": [toHopDestination],
      "Id": "s",
      "JobPercentComplete": "n",
      "JobTemplate": "s",
      "Messages": toJobMessages,
      "OutputGroupDetails": [toOutputGroupDetail],
      "Priority": "n",
      "Queue": "s",
      "QueueTransitions": [toQueueTransition],
      "RetryCount": "n",
      "SimulateReservedQueue": (x: jsonP.JSONValue) => cmnP.readEnum<SimulateReservedQueue>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<JobStatus>(x),
      "StatusUpdateInterval": (x: jsonP.JSONValue) => cmnP.readEnum<StatusUpdateInterval>(x),
      "Timing": toTiming,
      "UserMetadata": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type AccelerationStatus =
| "NOT_APPLICABLE"
| "IN_PROGRESS"
| "ACCELERATED"
| "NOT_ACCELERATED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type JobPhase =
| "PROBING"
| "TRANSCODING"
| "UPLOADING"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface JobMessages {
  Info?: string[] | null;
  Warning?: string[] | null;
}
function toJobMessages(root: jsonP.JSONValue): JobMessages {
  return jsonP.readObj({
    required: {},
    optional: {
      "Info": ["s"],
      "Warning": ["s"],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface OutputGroupDetail {
  OutputDetails?: OutputDetail[] | null;
}
function toOutputGroupDetail(root: jsonP.JSONValue): OutputGroupDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputDetails": [toOutputDetail],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface OutputDetail {
  DurationInMs?: number | null;
  VideoDetails?: VideoDetail | null;
}
function toOutputDetail(root: jsonP.JSONValue): OutputDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInMs": "n",
      "VideoDetails": toVideoDetail,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface VideoDetail {
  HeightInPx?: number | null;
  WidthInPx?: number | null;
}
function toVideoDetail(root: jsonP.JSONValue): VideoDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "HeightInPx": "n",
      "WidthInPx": "n",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface QueueTransition {
  DestinationQueue?: string | null;
  SourceQueue?: string | null;
  Timestamp?: Date | number | null;
}
function toQueueTransition(root: jsonP.JSONValue): QueueTransition {
  return jsonP.readObj({
    required: {},
    optional: {
      "DestinationQueue": "s",
      "SourceQueue": "s",
      "Timestamp": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Timing {
  FinishTime?: Date | number | null;
  StartTime?: Date | number | null;
  SubmitTime?: Date | number | null;
}
function toTiming(root: jsonP.JSONValue): Timing {
  return jsonP.readObj({
    required: {},
    optional: {
      "FinishTime": "d",
      "StartTime": "d",
      "SubmitTime": "d",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface JobTemplate {
  AccelerationSettings?: AccelerationSettings | null;
  Arn?: string | null;
  Category?: string | null;
  CreatedAt?: Date | number | null;
  Description?: string | null;
  HopDestinations?: HopDestination[] | null;
  LastUpdated?: Date | number | null;
  Name: string;
  Priority?: number | null;
  Queue?: string | null;
  Settings: JobTemplateSettings;
  StatusUpdateInterval?: StatusUpdateInterval | null;
  Type?: Type | null;
}
function toJobTemplate(root: jsonP.JSONValue): JobTemplate {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Settings": toJobTemplateSettings,
    },
    optional: {
      "AccelerationSettings": toAccelerationSettings,
      "Arn": "s",
      "Category": "s",
      "CreatedAt": "d",
      "Description": "s",
      "HopDestinations": [toHopDestination],
      "LastUpdated": "d",
      "Priority": "n",
      "Queue": "s",
      "StatusUpdateInterval": (x: jsonP.JSONValue) => cmnP.readEnum<StatusUpdateInterval>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<Type>(x),
    },
  }, root);
}

// refs: 12 - tags: output, named, enum
export type Type =
| "SYSTEM"
| "CUSTOM"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Preset {
  Arn?: string | null;
  Category?: string | null;
  CreatedAt?: Date | number | null;
  Description?: string | null;
  LastUpdated?: Date | number | null;
  Name: string;
  Settings: PresetSettings;
  Type?: Type | null;
}
function toPreset(root: jsonP.JSONValue): Preset {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Settings": toPresetSettings,
    },
    optional: {
      "Arn": "s",
      "Category": "s",
      "CreatedAt": "d",
      "Description": "s",
      "LastUpdated": "d",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<Type>(x),
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Queue {
  Arn?: string | null;
  CreatedAt?: Date | number | null;
  Description?: string | null;
  LastUpdated?: Date | number | null;
  Name: string;
  PricingPlan?: PricingPlan | null;
  ProgressingJobsCount?: number | null;
  ReservationPlan?: ReservationPlan | null;
  Status?: QueueStatus | null;
  SubmittedJobsCount?: number | null;
  Type?: Type | null;
}
function toQueue(root: jsonP.JSONValue): Queue {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Arn": "s",
      "CreatedAt": "d",
      "Description": "s",
      "LastUpdated": "d",
      "PricingPlan": (x: jsonP.JSONValue) => cmnP.readEnum<PricingPlan>(x),
      "ProgressingJobsCount": "n",
      "ReservationPlan": toReservationPlan,
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<QueueStatus>(x),
      "SubmittedJobsCount": "n",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<Type>(x),
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface ReservationPlan {
  Commitment?: Commitment | null;
  ExpiresAt?: Date | number | null;
  PurchasedAt?: Date | number | null;
  RenewalType?: RenewalType | null;
  ReservedSlots?: number | null;
  Status?: ReservationPlanStatus | null;
}
function toReservationPlan(root: jsonP.JSONValue): ReservationPlan {
  return jsonP.readObj({
    required: {},
    optional: {
      "Commitment": (x: jsonP.JSONValue) => cmnP.readEnum<Commitment>(x),
      "ExpiresAt": "d",
      "PurchasedAt": "d",
      "RenewalType": (x: jsonP.JSONValue) => cmnP.readEnum<RenewalType>(x),
      "ReservedSlots": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationPlanStatus>(x),
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type ReservationPlanStatus =
| "ACTIVE"
| "EXPIRED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Endpoint {
  Url?: string | null;
}
function toEndpoint(root: jsonP.JSONValue): Endpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "Url": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResourceTags {
  Arn?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}
function toResourceTags(root: jsonP.JSONValue): ResourceTags {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
