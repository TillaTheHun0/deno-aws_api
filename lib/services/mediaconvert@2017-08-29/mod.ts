// Autogenerated API client for: AWS Elemental MediaConvert

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.91.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class MediaConvert {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaConvert.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-08-29",
    "endpointPrefix": "mediaconvert",
    "signingName": "mediaconvert",
    "serviceFullName": "AWS Elemental MediaConvert",
    "serviceId": "MediaConvert",
    "protocol": "rest-json",
    "jsonVersion": "1.1",
    "uid": "mediaconvert-2017-08-29",
    "signatureVersion": "v4",
    "serviceAbbreviation": "MediaConvert"
  };

  async associateCertificate(
    {abortSignal, ...params}: RequestConfig & s.AssociateCertificateRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      arn: params["Arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateCertificate",
      requestUri: "/2017-08-29/certificates",
      responseCode: 201,
    });
    await resp.text();
  }

  async cancelJob(
    {abortSignal, ...params}: RequestConfig & s.CancelJobRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelJob",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/jobs/${params["Id"]}`,
      responseCode: 202,
    });
    await resp.text();
  }

  async createJob(
    {abortSignal, ...params}: RequestConfig & s.CreateJobRequest,
  ): Promise<s.CreateJobResponse> {
    const body: jsonP.JSONObject = {
      accelerationSettings: fromAccelerationSettings(params["AccelerationSettings"]),
      billingTagsSource: params["BillingTagsSource"],
      clientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      hopDestinations: params["HopDestinations"]?.map(x => fromHopDestination(x)),
      jobTemplate: params["JobTemplate"],
      priority: params["Priority"],
      queue: params["Queue"],
      role: params["Role"],
      settings: fromJobSettings(params["Settings"]),
      simulateReservedQueue: params["SimulateReservedQueue"],
      statusUpdateInterval: params["StatusUpdateInterval"],
      tags: params["Tags"],
      userMetadata: params["UserMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJob",
      requestUri: "/2017-08-29/jobs",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Job": toJob,
      },
    }, await resp.json());
  }

  async createJobTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateJobTemplateRequest,
  ): Promise<s.CreateJobTemplateResponse> {
    const body: jsonP.JSONObject = {
      accelerationSettings: fromAccelerationSettings(params["AccelerationSettings"]),
      category: params["Category"],
      description: params["Description"],
      hopDestinations: params["HopDestinations"]?.map(x => fromHopDestination(x)),
      name: params["Name"],
      priority: params["Priority"],
      queue: params["Queue"],
      settings: fromJobTemplateSettings(params["Settings"]),
      statusUpdateInterval: params["StatusUpdateInterval"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJobTemplate",
      requestUri: "/2017-08-29/jobTemplates",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobTemplate": toJobTemplate,
      },
    }, await resp.json());
  }

  async createPreset(
    {abortSignal, ...params}: RequestConfig & s.CreatePresetRequest,
  ): Promise<s.CreatePresetResponse> {
    const body: jsonP.JSONObject = {
      category: params["Category"],
      description: params["Description"],
      name: params["Name"],
      settings: fromPresetSettings(params["Settings"]),
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePreset",
      requestUri: "/2017-08-29/presets",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Preset": toPreset,
      },
    }, await resp.json());
  }

  async createQueue(
    {abortSignal, ...params}: RequestConfig & s.CreateQueueRequest,
  ): Promise<s.CreateQueueResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      name: params["Name"],
      pricingPlan: params["PricingPlan"],
      reservationPlanSettings: fromReservationPlanSettings(params["ReservationPlanSettings"]),
      status: params["Status"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateQueue",
      requestUri: "/2017-08-29/queues",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Queue": toQueue,
      },
    }, await resp.json());
  }

  async deleteJobTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteJobTemplateRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteJobTemplate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/jobTemplates/${params["Name"]}`,
      responseCode: 202,
    });
    await resp.text();
  }

  async deletePreset(
    {abortSignal, ...params}: RequestConfig & s.DeletePresetRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePreset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/presets/${params["Name"]}`,
      responseCode: 202,
    });
    await resp.text();
  }

  async deleteQueue(
    {abortSignal, ...params}: RequestConfig & s.DeleteQueueRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteQueue",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/queues/${params["Name"]}`,
      responseCode: 202,
    });
    await resp.text();
  }

  async describeEndpoints(
    {abortSignal, ...params}: RequestConfig & s.DescribeEndpointsRequest = {},
  ): Promise<s.DescribeEndpointsResponse> {
    const body: jsonP.JSONObject = {
      maxResults: params["MaxResults"],
      mode: params["Mode"],
      nextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoints",
      requestUri: "/2017-08-29/endpoints",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Endpoints": [toEndpoint],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async disassociateCertificate(
    {abortSignal, ...params}: RequestConfig & s.DisassociateCertificateRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DisassociateCertificate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-08-29/certificates/${params["Arn"]}`,
      responseCode: 202,
    });
    await resp.text();
  }

  async getJob(
    {abortSignal, ...params}: RequestConfig & s.GetJobRequest,
  ): Promise<s.GetJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetJob",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/jobs/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Job": toJob,
      },
    }, await resp.json());
  }

  async getJobTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetJobTemplateRequest,
  ): Promise<s.GetJobTemplateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetJobTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/jobTemplates/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobTemplate": toJobTemplate,
      },
    }, await resp.json());
  }

  async getPreset(
    {abortSignal, ...params}: RequestConfig & s.GetPresetRequest,
  ): Promise<s.GetPresetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetPreset",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/presets/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Preset": toPreset,
      },
    }, await resp.json());
  }

  async getQueue(
    {abortSignal, ...params}: RequestConfig & s.GetQueueRequest,
  ): Promise<s.GetQueueResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetQueue",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/queues/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Queue": toQueue,
      },
    }, await resp.json());
  }

  async listJobTemplates(
    {abortSignal, ...params}: RequestConfig & s.ListJobTemplatesRequest = {},
  ): Promise<s.ListJobTemplatesResponse> {
    const query = new URLSearchParams;
    if (params["Category"] != null) query.set("category", params["Category"]?.toString() ?? "");
    if (params["ListBy"] != null) query.set("listBy", params["ListBy"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobTemplates",
      method: "GET",
      requestUri: "/2017-08-29/jobTemplates",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobTemplates": [toJobTemplate],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & s.ListJobsRequest = {},
  ): Promise<s.ListJobsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    if (params["Queue"] != null) query.set("queue", params["Queue"]?.toString() ?? "");
    if (params["Status"] != null) query.set("status", params["Status"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobs",
      method: "GET",
      requestUri: "/2017-08-29/jobs",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Jobs": [toJob],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPresets(
    {abortSignal, ...params}: RequestConfig & s.ListPresetsRequest = {},
  ): Promise<s.ListPresetsResponse> {
    const query = new URLSearchParams;
    if (params["Category"] != null) query.set("category", params["Category"]?.toString() ?? "");
    if (params["ListBy"] != null) query.set("listBy", params["ListBy"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPresets",
      method: "GET",
      requestUri: "/2017-08-29/presets",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Presets": [toPreset],
      },
    }, await resp.json());
  }

  async listQueues(
    {abortSignal, ...params}: RequestConfig & s.ListQueuesRequest = {},
  ): Promise<s.ListQueuesResponse> {
    const query = new URLSearchParams;
    if (params["ListBy"] != null) query.set("listBy", params["ListBy"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListQueues",
      method: "GET",
      requestUri: "/2017-08-29/queues",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Queues": [toQueue],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-08-29/tags/${params["Arn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceTags": toResourceTags,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      arn: params["Arn"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: "/2017-08-29/tags",
      responseCode: 200,
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-08-29/tags/${params["Arn"]}`,
      responseCode: 200,
    });
    await resp.text();
  }

  async updateJobTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateJobTemplateRequest,
  ): Promise<s.UpdateJobTemplateResponse> {
    const body: jsonP.JSONObject = {
      accelerationSettings: fromAccelerationSettings(params["AccelerationSettings"]),
      category: params["Category"],
      description: params["Description"],
      hopDestinations: params["HopDestinations"]?.map(x => fromHopDestination(x)),
      priority: params["Priority"],
      queue: params["Queue"],
      settings: fromJobTemplateSettings(params["Settings"]),
      statusUpdateInterval: params["StatusUpdateInterval"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateJobTemplate",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-08-29/jobTemplates/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobTemplate": toJobTemplate,
      },
    }, await resp.json());
  }

  async updatePreset(
    {abortSignal, ...params}: RequestConfig & s.UpdatePresetRequest,
  ): Promise<s.UpdatePresetResponse> {
    const body: jsonP.JSONObject = {
      category: params["Category"],
      description: params["Description"],
      settings: fromPresetSettings(params["Settings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePreset",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-08-29/presets/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Preset": toPreset,
      },
    }, await resp.json());
  }

  async updateQueue(
    {abortSignal, ...params}: RequestConfig & s.UpdateQueueRequest,
  ): Promise<s.UpdateQueueResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      reservationPlanSettings: fromReservationPlanSettings(params["ReservationPlanSettings"]),
      status: params["Status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateQueue",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-08-29/queues/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Queue": toQueue,
      },
    }, await resp.json());
  }

}

function fromAccelerationSettings(input?: s.AccelerationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    mode: input["Mode"],
  }
}
function toAccelerationSettings(root: jsonP.JSONValue): s.AccelerationSettings {
  return jsonP.readObj({
    required: {
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccelerationMode>(x),
    },
    optional: {},
  }, root);
}

function fromHopDestination(input?: s.HopDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    priority: input["Priority"],
    queue: input["Queue"],
    waitMinutes: input["WaitMinutes"],
  }
}
function toHopDestination(root: jsonP.JSONValue): s.HopDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "Priority": "n",
      "Queue": "s",
      "WaitMinutes": "n",
    },
  }, root);
}

function fromJobSettings(input?: s.JobSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adAvailOffset: input["AdAvailOffset"],
    availBlanking: fromAvailBlanking(input["AvailBlanking"]),
    esam: fromEsamSettings(input["Esam"]),
    inputs: input["Inputs"]?.map(x => fromInput(x)),
    motionImageInserter: fromMotionImageInserter(input["MotionImageInserter"]),
    nielsenConfiguration: fromNielsenConfiguration(input["NielsenConfiguration"]),
    nielsenNonLinearWatermark: fromNielsenNonLinearWatermarkSettings(input["NielsenNonLinearWatermark"]),
    outputGroups: input["OutputGroups"]?.map(x => fromOutputGroup(x)),
    timecodeConfig: fromTimecodeConfig(input["TimecodeConfig"]),
    timedMetadataInsertion: fromTimedMetadataInsertion(input["TimedMetadataInsertion"]),
  }
}
function toJobSettings(root: jsonP.JSONValue): s.JobSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdAvailOffset": "n",
      "AvailBlanking": toAvailBlanking,
      "Esam": toEsamSettings,
      "Inputs": [toInput],
      "MotionImageInserter": toMotionImageInserter,
      "NielsenConfiguration": toNielsenConfiguration,
      "NielsenNonLinearWatermark": toNielsenNonLinearWatermarkSettings,
      "OutputGroups": [toOutputGroup],
      "TimecodeConfig": toTimecodeConfig,
      "TimedMetadataInsertion": toTimedMetadataInsertion,
    },
  }, root);
}

function fromAvailBlanking(input?: s.AvailBlanking | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    availBlankingImage: input["AvailBlankingImage"],
  }
}
function toAvailBlanking(root: jsonP.JSONValue): s.AvailBlanking {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailBlankingImage": "s",
    },
  }, root);
}

function fromEsamSettings(input?: s.EsamSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestConfirmConditionNotification: fromEsamManifestConfirmConditionNotification(input["ManifestConfirmConditionNotification"]),
    responseSignalPreroll: input["ResponseSignalPreroll"],
    signalProcessingNotification: fromEsamSignalProcessingNotification(input["SignalProcessingNotification"]),
  }
}
function toEsamSettings(root: jsonP.JSONValue): s.EsamSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestConfirmConditionNotification": toEsamManifestConfirmConditionNotification,
      "ResponseSignalPreroll": "n",
      "SignalProcessingNotification": toEsamSignalProcessingNotification,
    },
  }, root);
}

function fromEsamManifestConfirmConditionNotification(input?: s.EsamManifestConfirmConditionNotification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    mccXml: input["MccXml"],
  }
}
function toEsamManifestConfirmConditionNotification(root: jsonP.JSONValue): s.EsamManifestConfirmConditionNotification {
  return jsonP.readObj({
    required: {},
    optional: {
      "MccXml": "s",
    },
  }, root);
}

function fromEsamSignalProcessingNotification(input?: s.EsamSignalProcessingNotification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sccXml: input["SccXml"],
  }
}
function toEsamSignalProcessingNotification(root: jsonP.JSONValue): s.EsamSignalProcessingNotification {
  return jsonP.readObj({
    required: {},
    optional: {
      "SccXml": "s",
    },
  }, root);
}

function fromInput(input?: s.Input | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectorGroups: jsonP.serializeMap(input["AudioSelectorGroups"], x => fromAudioSelectorGroup(x)),
    audioSelectors: jsonP.serializeMap(input["AudioSelectors"], x => fromAudioSelector(x)),
    captionSelectors: jsonP.serializeMap(input["CaptionSelectors"], x => fromCaptionSelector(x)),
    crop: fromRectangle(input["Crop"]),
    deblockFilter: input["DeblockFilter"],
    decryptionSettings: fromInputDecryptionSettings(input["DecryptionSettings"]),
    denoiseFilter: input["DenoiseFilter"],
    fileInput: input["FileInput"],
    filterEnable: input["FilterEnable"],
    filterStrength: input["FilterStrength"],
    imageInserter: fromImageInserter(input["ImageInserter"]),
    inputClippings: input["InputClippings"]?.map(x => fromInputClipping(x)),
    inputScanType: input["InputScanType"],
    position: fromRectangle(input["Position"]),
    programNumber: input["ProgramNumber"],
    psiControl: input["PsiControl"],
    supplementalImps: input["SupplementalImps"],
    timecodeSource: input["TimecodeSource"],
    timecodeStart: input["TimecodeStart"],
    videoSelector: fromVideoSelector(input["VideoSelector"]),
  }
}
function toInput(root: jsonP.JSONValue): s.Input {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSelectorGroups": x => jsonP.readMap(String, toAudioSelectorGroup, x),
      "AudioSelectors": x => jsonP.readMap(String, toAudioSelector, x),
      "CaptionSelectors": x => jsonP.readMap(String, toCaptionSelector, x),
      "Crop": toRectangle,
      "DeblockFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeblockFilter>(x),
      "DecryptionSettings": toInputDecryptionSettings,
      "DenoiseFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDenoiseFilter>(x),
      "FileInput": "s",
      "FilterEnable": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputFilterEnable>(x),
      "FilterStrength": "n",
      "ImageInserter": toImageInserter,
      "InputClippings": [toInputClipping],
      "InputScanType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputScanType>(x),
      "Position": toRectangle,
      "ProgramNumber": "n",
      "PsiControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputPsiControl>(x),
      "SupplementalImps": ["s"],
      "TimecodeSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputTimecodeSource>(x),
      "TimecodeStart": "s",
      "VideoSelector": toVideoSelector,
    },
  }, root);
}

function fromAudioSelectorGroup(input?: s.AudioSelectorGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectorNames: input["AudioSelectorNames"],
  }
}
function toAudioSelectorGroup(root: jsonP.JSONValue): s.AudioSelectorGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSelectorNames": ["s"],
    },
  }, root);
}

function fromAudioSelector(input?: s.AudioSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    customLanguageCode: input["CustomLanguageCode"],
    defaultSelection: input["DefaultSelection"],
    externalAudioFileInput: input["ExternalAudioFileInput"],
    languageCode: input["LanguageCode"],
    offset: input["Offset"],
    pids: input["Pids"],
    programSelection: input["ProgramSelection"],
    remixSettings: fromRemixSettings(input["RemixSettings"]),
    selectorType: input["SelectorType"],
    tracks: input["Tracks"],
  }
}
function toAudioSelector(root: jsonP.JSONValue): s.AudioSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomLanguageCode": "s",
      "DefaultSelection": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioDefaultSelection>(x),
      "ExternalAudioFileInput": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "Offset": "n",
      "Pids": ["n"],
      "ProgramSelection": "n",
      "RemixSettings": toRemixSettings,
      "SelectorType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioSelectorType>(x),
      "Tracks": ["n"],
    },
  }, root);
}

function fromRemixSettings(input?: s.RemixSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channelMapping: fromChannelMapping(input["ChannelMapping"]),
    channelsIn: input["ChannelsIn"],
    channelsOut: input["ChannelsOut"],
  }
}
function toRemixSettings(root: jsonP.JSONValue): s.RemixSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelMapping": toChannelMapping,
      "ChannelsIn": "n",
      "ChannelsOut": "n",
    },
  }, root);
}

function fromChannelMapping(input?: s.ChannelMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    outputChannels: input["OutputChannels"]?.map(x => fromOutputChannelMapping(x)),
  }
}
function toChannelMapping(root: jsonP.JSONValue): s.ChannelMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputChannels": [toOutputChannelMapping],
    },
  }, root);
}

function fromOutputChannelMapping(input?: s.OutputChannelMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputChannels: input["InputChannels"],
    inputChannelsFineTune: input["InputChannelsFineTune"],
  }
}
function toOutputChannelMapping(root: jsonP.JSONValue): s.OutputChannelMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputChannels": ["n"],
      "InputChannelsFineTune": ["n"],
    },
  }, root);
}

function fromCaptionSelector(input?: s.CaptionSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    customLanguageCode: input["CustomLanguageCode"],
    languageCode: input["LanguageCode"],
    sourceSettings: fromCaptionSourceSettings(input["SourceSettings"]),
  }
}
function toCaptionSelector(root: jsonP.JSONValue): s.CaptionSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomLanguageCode": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "SourceSettings": toCaptionSourceSettings,
    },
  }, root);
}

function fromCaptionSourceSettings(input?: s.CaptionSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ancillarySourceSettings: fromAncillarySourceSettings(input["AncillarySourceSettings"]),
    dvbSubSourceSettings: fromDvbSubSourceSettings(input["DvbSubSourceSettings"]),
    embeddedSourceSettings: fromEmbeddedSourceSettings(input["EmbeddedSourceSettings"]),
    fileSourceSettings: fromFileSourceSettings(input["FileSourceSettings"]),
    sourceType: input["SourceType"],
    teletextSourceSettings: fromTeletextSourceSettings(input["TeletextSourceSettings"]),
    trackSourceSettings: fromTrackSourceSettings(input["TrackSourceSettings"]),
  }
}
function toCaptionSourceSettings(root: jsonP.JSONValue): s.CaptionSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AncillarySourceSettings": toAncillarySourceSettings,
      "DvbSubSourceSettings": toDvbSubSourceSettings,
      "EmbeddedSourceSettings": toEmbeddedSourceSettings,
      "FileSourceSettings": toFileSourceSettings,
      "SourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CaptionSourceType>(x),
      "TeletextSourceSettings": toTeletextSourceSettings,
      "TrackSourceSettings": toTrackSourceSettings,
    },
  }, root);
}

function fromAncillarySourceSettings(input?: s.AncillarySourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    sourceAncillaryChannelNumber: input["SourceAncillaryChannelNumber"],
    terminateCaptions: input["TerminateCaptions"],
  }
}
function toAncillarySourceSettings(root: jsonP.JSONValue): s.AncillarySourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<s.AncillaryConvert608To708>(x),
      "SourceAncillaryChannelNumber": "n",
      "TerminateCaptions": (x: jsonP.JSONValue) => cmnP.readEnum<s.AncillaryTerminateCaptions>(x),
    },
  }, root);
}

function fromDvbSubSourceSettings(input?: s.DvbSubSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toDvbSubSourceSettings(root: jsonP.JSONValue): s.DvbSubSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pid": "n",
    },
  }, root);
}

function fromEmbeddedSourceSettings(input?: s.EmbeddedSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    source608ChannelNumber: input["Source608ChannelNumber"],
    source608TrackNumber: input["Source608TrackNumber"],
    terminateCaptions: input["TerminateCaptions"],
  }
}
function toEmbeddedSourceSettings(root: jsonP.JSONValue): s.EmbeddedSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<s.EmbeddedConvert608To708>(x),
      "Source608ChannelNumber": "n",
      "Source608TrackNumber": "n",
      "TerminateCaptions": (x: jsonP.JSONValue) => cmnP.readEnum<s.EmbeddedTerminateCaptions>(x),
    },
  }, root);
}

function fromFileSourceSettings(input?: s.FileSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    framerate: fromCaptionSourceFramerate(input["Framerate"]),
    sourceFile: input["SourceFile"],
    timeDelta: input["TimeDelta"],
  }
}
function toFileSourceSettings(root: jsonP.JSONValue): s.FileSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileSourceConvert608To708>(x),
      "Framerate": toCaptionSourceFramerate,
      "SourceFile": "s",
      "TimeDelta": "n",
    },
  }, root);
}

function fromCaptionSourceFramerate(input?: s.CaptionSourceFramerate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
  }
}
function toCaptionSourceFramerate(root: jsonP.JSONValue): s.CaptionSourceFramerate {
  return jsonP.readObj({
    required: {},
    optional: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
    },
  }, root);
}

function fromTeletextSourceSettings(input?: s.TeletextSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pageNumber: input["PageNumber"],
  }
}
function toTeletextSourceSettings(root: jsonP.JSONValue): s.TeletextSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PageNumber": "s",
    },
  }, root);
}

function fromTrackSourceSettings(input?: s.TrackSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    trackNumber: input["TrackNumber"],
  }
}
function toTrackSourceSettings(root: jsonP.JSONValue): s.TrackSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrackNumber": "n",
    },
  }, root);
}

function fromRectangle(input?: s.Rectangle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    height: input["Height"],
    width: input["Width"],
    x: input["X"],
    y: input["Y"],
  }
}
function toRectangle(root: jsonP.JSONValue): s.Rectangle {
  return jsonP.readObj({
    required: {},
    optional: {
      "Height": "n",
      "Width": "n",
      "X": "n",
      "Y": "n",
    },
  }, root);
}

function fromInputDecryptionSettings(input?: s.InputDecryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    decryptionMode: input["DecryptionMode"],
    encryptedDecryptionKey: input["EncryptedDecryptionKey"],
    initializationVector: input["InitializationVector"],
    kmsKeyRegion: input["KmsKeyRegion"],
  }
}
function toInputDecryptionSettings(root: jsonP.JSONValue): s.InputDecryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DecryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DecryptionMode>(x),
      "EncryptedDecryptionKey": "s",
      "InitializationVector": "s",
      "KmsKeyRegion": "s",
    },
  }, root);
}

function fromImageInserter(input?: s.ImageInserter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    insertableImages: input["InsertableImages"]?.map(x => fromInsertableImage(x)),
  }
}
function toImageInserter(root: jsonP.JSONValue): s.ImageInserter {
  return jsonP.readObj({
    required: {},
    optional: {
      "InsertableImages": [toInsertableImage],
    },
  }, root);
}

function fromInsertableImage(input?: s.InsertableImage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    duration: input["Duration"],
    fadeIn: input["FadeIn"],
    fadeOut: input["FadeOut"],
    height: input["Height"],
    imageInserterInput: input["ImageInserterInput"],
    imageX: input["ImageX"],
    imageY: input["ImageY"],
    layer: input["Layer"],
    opacity: input["Opacity"],
    startTime: input["StartTime"],
    width: input["Width"],
  }
}
function toInsertableImage(root: jsonP.JSONValue): s.InsertableImage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Duration": "n",
      "FadeIn": "n",
      "FadeOut": "n",
      "Height": "n",
      "ImageInserterInput": "s",
      "ImageX": "n",
      "ImageY": "n",
      "Layer": "n",
      "Opacity": "n",
      "StartTime": "s",
      "Width": "n",
    },
  }, root);
}

function fromInputClipping(input?: s.InputClipping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    endTimecode: input["EndTimecode"],
    startTimecode: input["StartTimecode"],
  }
}
function toInputClipping(root: jsonP.JSONValue): s.InputClipping {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndTimecode": "s",
      "StartTimecode": "s",
    },
  }, root);
}

function fromVideoSelector(input?: s.VideoSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alphaBehavior: input["AlphaBehavior"],
    colorSpace: input["ColorSpace"],
    colorSpaceUsage: input["ColorSpaceUsage"],
    hdr10Metadata: fromHdr10Metadata(input["Hdr10Metadata"]),
    pid: input["Pid"],
    programNumber: input["ProgramNumber"],
    rotate: input["Rotate"],
  }
}
function toVideoSelector(root: jsonP.JSONValue): s.VideoSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "AlphaBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.AlphaBehavior>(x),
      "ColorSpace": (x: jsonP.JSONValue) => cmnP.readEnum<s.ColorSpace>(x),
      "ColorSpaceUsage": (x: jsonP.JSONValue) => cmnP.readEnum<s.ColorSpaceUsage>(x),
      "Hdr10Metadata": toHdr10Metadata,
      "Pid": "n",
      "ProgramNumber": "n",
      "Rotate": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputRotate>(x),
    },
  }, root);
}

function fromHdr10Metadata(input?: s.Hdr10Metadata | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bluePrimaryX: input["BluePrimaryX"],
    bluePrimaryY: input["BluePrimaryY"],
    greenPrimaryX: input["GreenPrimaryX"],
    greenPrimaryY: input["GreenPrimaryY"],
    maxContentLightLevel: input["MaxContentLightLevel"],
    maxFrameAverageLightLevel: input["MaxFrameAverageLightLevel"],
    maxLuminance: input["MaxLuminance"],
    minLuminance: input["MinLuminance"],
    redPrimaryX: input["RedPrimaryX"],
    redPrimaryY: input["RedPrimaryY"],
    whitePointX: input["WhitePointX"],
    whitePointY: input["WhitePointY"],
  }
}
function toHdr10Metadata(root: jsonP.JSONValue): s.Hdr10Metadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "BluePrimaryX": "n",
      "BluePrimaryY": "n",
      "GreenPrimaryX": "n",
      "GreenPrimaryY": "n",
      "MaxContentLightLevel": "n",
      "MaxFrameAverageLightLevel": "n",
      "MaxLuminance": "n",
      "MinLuminance": "n",
      "RedPrimaryX": "n",
      "RedPrimaryY": "n",
      "WhitePointX": "n",
      "WhitePointY": "n",
    },
  }, root);
}

function fromMotionImageInserter(input?: s.MotionImageInserter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerate: fromMotionImageInsertionFramerate(input["Framerate"]),
    input: input["Input"],
    insertionMode: input["InsertionMode"],
    offset: fromMotionImageInsertionOffset(input["Offset"]),
    playback: input["Playback"],
    startTime: input["StartTime"],
  }
}
function toMotionImageInserter(root: jsonP.JSONValue): s.MotionImageInserter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Framerate": toMotionImageInsertionFramerate,
      "Input": "s",
      "InsertionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.MotionImageInsertionMode>(x),
      "Offset": toMotionImageInsertionOffset,
      "Playback": (x: jsonP.JSONValue) => cmnP.readEnum<s.MotionImagePlayback>(x),
      "StartTime": "s",
    },
  }, root);
}

function fromMotionImageInsertionFramerate(input?: s.MotionImageInsertionFramerate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
  }
}
function toMotionImageInsertionFramerate(root: jsonP.JSONValue): s.MotionImageInsertionFramerate {
  return jsonP.readObj({
    required: {},
    optional: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
    },
  }, root);
}

function fromMotionImageInsertionOffset(input?: s.MotionImageInsertionOffset | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    imageX: input["ImageX"],
    imageY: input["ImageY"],
  }
}
function toMotionImageInsertionOffset(root: jsonP.JSONValue): s.MotionImageInsertionOffset {
  return jsonP.readObj({
    required: {},
    optional: {
      "ImageX": "n",
      "ImageY": "n",
    },
  }, root);
}

function fromNielsenConfiguration(input?: s.NielsenConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    breakoutCode: input["BreakoutCode"],
    distributorId: input["DistributorId"],
  }
}
function toNielsenConfiguration(root: jsonP.JSONValue): s.NielsenConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "BreakoutCode": "n",
      "DistributorId": "s",
    },
  }, root);
}

function fromNielsenNonLinearWatermarkSettings(input?: s.NielsenNonLinearWatermarkSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    activeWatermarkProcess: input["ActiveWatermarkProcess"],
    adiFilename: input["AdiFilename"],
    assetId: input["AssetId"],
    assetName: input["AssetName"],
    cbetSourceId: input["CbetSourceId"],
    episodeId: input["EpisodeId"],
    metadataDestination: input["MetadataDestination"],
    sourceId: input["SourceId"],
    sourceWatermarkStatus: input["SourceWatermarkStatus"],
    ticServerUrl: input["TicServerUrl"],
    uniqueTicPerAudioTrack: input["UniqueTicPerAudioTrack"],
  }
}
function toNielsenNonLinearWatermarkSettings(root: jsonP.JSONValue): s.NielsenNonLinearWatermarkSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveWatermarkProcess": (x: jsonP.JSONValue) => cmnP.readEnum<s.NielsenActiveWatermarkProcessType>(x),
      "AdiFilename": "s",
      "AssetId": "s",
      "AssetName": "s",
      "CbetSourceId": "s",
      "EpisodeId": "s",
      "MetadataDestination": "s",
      "SourceId": "n",
      "SourceWatermarkStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.NielsenSourceWatermarkStatusType>(x),
      "TicServerUrl": "s",
      "UniqueTicPerAudioTrack": (x: jsonP.JSONValue) => cmnP.readEnum<s.NielsenUniqueTicPerAudioTrackType>(x),
    },
  }, root);
}

function fromOutputGroup(input?: s.OutputGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    automatedEncodingSettings: fromAutomatedEncodingSettings(input["AutomatedEncodingSettings"]),
    customName: input["CustomName"],
    name: input["Name"],
    outputGroupSettings: fromOutputGroupSettings(input["OutputGroupSettings"]),
    outputs: input["Outputs"]?.map(x => fromOutput(x)),
  }
}
function toOutputGroup(root: jsonP.JSONValue): s.OutputGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomatedEncodingSettings": toAutomatedEncodingSettings,
      "CustomName": "s",
      "Name": "s",
      "OutputGroupSettings": toOutputGroupSettings,
      "Outputs": [toOutput],
    },
  }, root);
}

function fromAutomatedEncodingSettings(input?: s.AutomatedEncodingSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    abrSettings: fromAutomatedAbrSettings(input["AbrSettings"]),
  }
}
function toAutomatedEncodingSettings(root: jsonP.JSONValue): s.AutomatedEncodingSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AbrSettings": toAutomatedAbrSettings,
    },
  }, root);
}

function fromAutomatedAbrSettings(input?: s.AutomatedAbrSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxAbrBitrate: input["MaxAbrBitrate"],
    maxRenditions: input["MaxRenditions"],
    minAbrBitrate: input["MinAbrBitrate"],
  }
}
function toAutomatedAbrSettings(root: jsonP.JSONValue): s.AutomatedAbrSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxAbrBitrate": "n",
      "MaxRenditions": "n",
      "MinAbrBitrate": "n",
    },
  }, root);
}

function fromOutputGroupSettings(input?: s.OutputGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cmafGroupSettings: fromCmafGroupSettings(input["CmafGroupSettings"]),
    dashIsoGroupSettings: fromDashIsoGroupSettings(input["DashIsoGroupSettings"]),
    fileGroupSettings: fromFileGroupSettings(input["FileGroupSettings"]),
    hlsGroupSettings: fromHlsGroupSettings(input["HlsGroupSettings"]),
    msSmoothGroupSettings: fromMsSmoothGroupSettings(input["MsSmoothGroupSettings"]),
    type: input["Type"],
  }
}
function toOutputGroupSettings(root: jsonP.JSONValue): s.OutputGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CmafGroupSettings": toCmafGroupSettings,
      "DashIsoGroupSettings": toDashIsoGroupSettings,
      "FileGroupSettings": toFileGroupSettings,
      "HlsGroupSettings": toHlsGroupSettings,
      "MsSmoothGroupSettings": toMsSmoothGroupSettings,
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.OutputGroupType>(x),
    },
  }, root);
}

function fromCmafGroupSettings(input?: s.CmafGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    additionalManifests: input["AdditionalManifests"]?.map(x => fromCmafAdditionalManifest(x)),
    baseUrl: input["BaseUrl"],
    clientCache: input["ClientCache"],
    codecSpecification: input["CodecSpecification"],
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
    encryption: fromCmafEncryptionSettings(input["Encryption"]),
    fragmentLength: input["FragmentLength"],
    manifestCompression: input["ManifestCompression"],
    manifestDurationFormat: input["ManifestDurationFormat"],
    minBufferTime: input["MinBufferTime"],
    minFinalSegmentLength: input["MinFinalSegmentLength"],
    mpdProfile: input["MpdProfile"],
    segmentControl: input["SegmentControl"],
    segmentLength: input["SegmentLength"],
    streamInfResolution: input["StreamInfResolution"],
    writeDashManifest: input["WriteDashManifest"],
    writeHlsManifest: input["WriteHlsManifest"],
    writeSegmentTimelineInRepresentation: input["WriteSegmentTimelineInRepresentation"],
  }
}
function toCmafGroupSettings(root: jsonP.JSONValue): s.CmafGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdditionalManifests": [toCmafAdditionalManifest],
      "BaseUrl": "s",
      "ClientCache": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafClientCache>(x),
      "CodecSpecification": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafCodecSpecification>(x),
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
      "Encryption": toCmafEncryptionSettings,
      "FragmentLength": "n",
      "ManifestCompression": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafManifestCompression>(x),
      "ManifestDurationFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafManifestDurationFormat>(x),
      "MinBufferTime": "n",
      "MinFinalSegmentLength": "n",
      "MpdProfile": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafMpdProfile>(x),
      "SegmentControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafSegmentControl>(x),
      "SegmentLength": "n",
      "StreamInfResolution": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafStreamInfResolution>(x),
      "WriteDashManifest": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafWriteDASHManifest>(x),
      "WriteHlsManifest": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafWriteHLSManifest>(x),
      "WriteSegmentTimelineInRepresentation": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafWriteSegmentTimelineInRepresentation>(x),
    },
  }, root);
}

function fromCmafAdditionalManifest(input?: s.CmafAdditionalManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestNameModifier: input["ManifestNameModifier"],
    selectedOutputs: input["SelectedOutputs"],
  }
}
function toCmafAdditionalManifest(root: jsonP.JSONValue): s.CmafAdditionalManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestNameModifier": "s",
      "SelectedOutputs": ["s"],
    },
  }, root);
}

function fromDestinationSettings(input?: s.DestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Settings: fromS3DestinationSettings(input["S3Settings"]),
  }
}
function toDestinationSettings(root: jsonP.JSONValue): s.DestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Settings": toS3DestinationSettings,
    },
  }, root);
}

function fromS3DestinationSettings(input?: s.S3DestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessControl: fromS3DestinationAccessControl(input["AccessControl"]),
    encryption: fromS3EncryptionSettings(input["Encryption"]),
  }
}
function toS3DestinationSettings(root: jsonP.JSONValue): s.S3DestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccessControl": toS3DestinationAccessControl,
      "Encryption": toS3EncryptionSettings,
    },
  }, root);
}

function fromS3DestinationAccessControl(input?: s.S3DestinationAccessControl | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cannedAcl: input["CannedAcl"],
  }
}
function toS3DestinationAccessControl(root: jsonP.JSONValue): s.S3DestinationAccessControl {
  return jsonP.readObj({
    required: {},
    optional: {
      "CannedAcl": (x: jsonP.JSONValue) => cmnP.readEnum<s.S3ObjectCannedAcl>(x),
    },
  }, root);
}

function fromS3EncryptionSettings(input?: s.S3EncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryptionType: input["EncryptionType"],
    kmsKeyArn: input["KmsKeyArn"],
  }
}
function toS3EncryptionSettings(root: jsonP.JSONValue): s.S3EncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.S3ServerSideEncryptionType>(x),
      "KmsKeyArn": "s",
    },
  }, root);
}

function fromCmafEncryptionSettings(input?: s.CmafEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constantInitializationVector: input["ConstantInitializationVector"],
    encryptionMethod: input["EncryptionMethod"],
    initializationVectorInManifest: input["InitializationVectorInManifest"],
    spekeKeyProvider: fromSpekeKeyProviderCmaf(input["SpekeKeyProvider"]),
    staticKeyProvider: fromStaticKeyProvider(input["StaticKeyProvider"]),
    type: input["Type"],
  }
}
function toCmafEncryptionSettings(root: jsonP.JSONValue): s.CmafEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConstantInitializationVector": "s",
      "EncryptionMethod": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafEncryptionType>(x),
      "InitializationVectorInManifest": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafInitializationVectorInManifest>(x),
      "SpekeKeyProvider": toSpekeKeyProviderCmaf,
      "StaticKeyProvider": toStaticKeyProvider,
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmafKeyProviderType>(x),
    },
  }, root);
}

function fromSpekeKeyProviderCmaf(input?: s.SpekeKeyProviderCmaf | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["CertificateArn"],
    dashSignaledSystemIds: input["DashSignaledSystemIds"],
    hlsSignaledSystemIds: input["HlsSignaledSystemIds"],
    resourceId: input["ResourceId"],
    url: input["Url"],
  }
}
function toSpekeKeyProviderCmaf(root: jsonP.JSONValue): s.SpekeKeyProviderCmaf {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateArn": "s",
      "DashSignaledSystemIds": ["s"],
      "HlsSignaledSystemIds": ["s"],
      "ResourceId": "s",
      "Url": "s",
    },
  }, root);
}

function fromStaticKeyProvider(input?: s.StaticKeyProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyFormat: input["KeyFormat"],
    keyFormatVersions: input["KeyFormatVersions"],
    staticKeyValue: input["StaticKeyValue"],
    url: input["Url"],
  }
}
function toStaticKeyProvider(root: jsonP.JSONValue): s.StaticKeyProvider {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyFormat": "s",
      "KeyFormatVersions": "s",
      "StaticKeyValue": "s",
      "Url": "s",
    },
  }, root);
}

function fromDashIsoGroupSettings(input?: s.DashIsoGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    additionalManifests: input["AdditionalManifests"]?.map(x => fromDashAdditionalManifest(x)),
    baseUrl: input["BaseUrl"],
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
    encryption: fromDashIsoEncryptionSettings(input["Encryption"]),
    fragmentLength: input["FragmentLength"],
    hbbtvCompliance: input["HbbtvCompliance"],
    minBufferTime: input["MinBufferTime"],
    minFinalSegmentLength: input["MinFinalSegmentLength"],
    mpdProfile: input["MpdProfile"],
    segmentControl: input["SegmentControl"],
    segmentLength: input["SegmentLength"],
    writeSegmentTimelineInRepresentation: input["WriteSegmentTimelineInRepresentation"],
  }
}
function toDashIsoGroupSettings(root: jsonP.JSONValue): s.DashIsoGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdditionalManifests": [toDashAdditionalManifest],
      "BaseUrl": "s",
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
      "Encryption": toDashIsoEncryptionSettings,
      "FragmentLength": "n",
      "HbbtvCompliance": (x: jsonP.JSONValue) => cmnP.readEnum<s.DashIsoHbbtvCompliance>(x),
      "MinBufferTime": "n",
      "MinFinalSegmentLength": "n",
      "MpdProfile": (x: jsonP.JSONValue) => cmnP.readEnum<s.DashIsoMpdProfile>(x),
      "SegmentControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.DashIsoSegmentControl>(x),
      "SegmentLength": "n",
      "WriteSegmentTimelineInRepresentation": (x: jsonP.JSONValue) => cmnP.readEnum<s.DashIsoWriteSegmentTimelineInRepresentation>(x),
    },
  }, root);
}

function fromDashAdditionalManifest(input?: s.DashAdditionalManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestNameModifier: input["ManifestNameModifier"],
    selectedOutputs: input["SelectedOutputs"],
  }
}
function toDashAdditionalManifest(root: jsonP.JSONValue): s.DashAdditionalManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestNameModifier": "s",
      "SelectedOutputs": ["s"],
    },
  }, root);
}

function fromDashIsoEncryptionSettings(input?: s.DashIsoEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    playbackDeviceCompatibility: input["PlaybackDeviceCompatibility"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toDashIsoEncryptionSettings(root: jsonP.JSONValue): s.DashIsoEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlaybackDeviceCompatibility": (x: jsonP.JSONValue) => cmnP.readEnum<s.DashIsoPlaybackDeviceCompatibility>(x),
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
  }, root);
}

function fromSpekeKeyProvider(input?: s.SpekeKeyProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["CertificateArn"],
    resourceId: input["ResourceId"],
    systemIds: input["SystemIds"],
    url: input["Url"],
  }
}
function toSpekeKeyProvider(root: jsonP.JSONValue): s.SpekeKeyProvider {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateArn": "s",
      "ResourceId": "s",
      "SystemIds": ["s"],
      "Url": "s",
    },
  }, root);
}

function fromFileGroupSettings(input?: s.FileGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
  }
}
function toFileGroupSettings(root: jsonP.JSONValue): s.FileGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
    },
  }, root);
}

function fromHlsGroupSettings(input?: s.HlsGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    additionalManifests: input["AdditionalManifests"]?.map(x => fromHlsAdditionalManifest(x)),
    audioOnlyHeader: input["AudioOnlyHeader"],
    baseUrl: input["BaseUrl"],
    captionLanguageMappings: input["CaptionLanguageMappings"]?.map(x => fromHlsCaptionLanguageMapping(x)),
    captionLanguageSetting: input["CaptionLanguageSetting"],
    clientCache: input["ClientCache"],
    codecSpecification: input["CodecSpecification"],
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
    directoryStructure: input["DirectoryStructure"],
    encryption: fromHlsEncryptionSettings(input["Encryption"]),
    manifestCompression: input["ManifestCompression"],
    manifestDurationFormat: input["ManifestDurationFormat"],
    minFinalSegmentLength: input["MinFinalSegmentLength"],
    minSegmentLength: input["MinSegmentLength"],
    outputSelection: input["OutputSelection"],
    programDateTime: input["ProgramDateTime"],
    programDateTimePeriod: input["ProgramDateTimePeriod"],
    segmentControl: input["SegmentControl"],
    segmentLength: input["SegmentLength"],
    segmentsPerSubdirectory: input["SegmentsPerSubdirectory"],
    streamInfResolution: input["StreamInfResolution"],
    timedMetadataId3Frame: input["TimedMetadataId3Frame"],
    timedMetadataId3Period: input["TimedMetadataId3Period"],
    timestampDeltaMilliseconds: input["TimestampDeltaMilliseconds"],
  }
}
function toHlsGroupSettings(root: jsonP.JSONValue): s.HlsGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdMarkers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.HlsAdMarkers>(x)],
      "AdditionalManifests": [toHlsAdditionalManifest],
      "AudioOnlyHeader": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsAudioOnlyHeader>(x),
      "BaseUrl": "s",
      "CaptionLanguageMappings": [toHlsCaptionLanguageMapping],
      "CaptionLanguageSetting": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsCaptionLanguageSetting>(x),
      "ClientCache": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsClientCache>(x),
      "CodecSpecification": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsCodecSpecification>(x),
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
      "DirectoryStructure": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsDirectoryStructure>(x),
      "Encryption": toHlsEncryptionSettings,
      "ManifestCompression": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsManifestCompression>(x),
      "ManifestDurationFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsManifestDurationFormat>(x),
      "MinFinalSegmentLength": "n",
      "MinSegmentLength": "n",
      "OutputSelection": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsOutputSelection>(x),
      "ProgramDateTime": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsProgramDateTime>(x),
      "ProgramDateTimePeriod": "n",
      "SegmentControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsSegmentControl>(x),
      "SegmentLength": "n",
      "SegmentsPerSubdirectory": "n",
      "StreamInfResolution": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsStreamInfResolution>(x),
      "TimedMetadataId3Frame": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsTimedMetadataId3Frame>(x),
      "TimedMetadataId3Period": "n",
      "TimestampDeltaMilliseconds": "n",
    },
  }, root);
}

function fromHlsAdditionalManifest(input?: s.HlsAdditionalManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestNameModifier: input["ManifestNameModifier"],
    selectedOutputs: input["SelectedOutputs"],
  }
}
function toHlsAdditionalManifest(root: jsonP.JSONValue): s.HlsAdditionalManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestNameModifier": "s",
      "SelectedOutputs": ["s"],
    },
  }, root);
}

function fromHlsCaptionLanguageMapping(input?: s.HlsCaptionLanguageMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captionChannel: input["CaptionChannel"],
    customLanguageCode: input["CustomLanguageCode"],
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
  }
}
function toHlsCaptionLanguageMapping(root: jsonP.JSONValue): s.HlsCaptionLanguageMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "CaptionChannel": "n",
      "CustomLanguageCode": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "LanguageDescription": "s",
    },
  }, root);
}

function fromHlsEncryptionSettings(input?: s.HlsEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constantInitializationVector: input["ConstantInitializationVector"],
    encryptionMethod: input["EncryptionMethod"],
    initializationVectorInManifest: input["InitializationVectorInManifest"],
    offlineEncrypted: input["OfflineEncrypted"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
    staticKeyProvider: fromStaticKeyProvider(input["StaticKeyProvider"]),
    type: input["Type"],
  }
}
function toHlsEncryptionSettings(root: jsonP.JSONValue): s.HlsEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConstantInitializationVector": "s",
      "EncryptionMethod": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsEncryptionType>(x),
      "InitializationVectorInManifest": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsInitializationVectorInManifest>(x),
      "OfflineEncrypted": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsOfflineEncrypted>(x),
      "SpekeKeyProvider": toSpekeKeyProvider,
      "StaticKeyProvider": toStaticKeyProvider,
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsKeyProviderType>(x),
    },
  }, root);
}

function fromMsSmoothGroupSettings(input?: s.MsSmoothGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    additionalManifests: input["AdditionalManifests"]?.map(x => fromMsSmoothAdditionalManifest(x)),
    audioDeduplication: input["AudioDeduplication"],
    destination: input["Destination"],
    destinationSettings: fromDestinationSettings(input["DestinationSettings"]),
    encryption: fromMsSmoothEncryptionSettings(input["Encryption"]),
    fragmentLength: input["FragmentLength"],
    manifestEncoding: input["ManifestEncoding"],
  }
}
function toMsSmoothGroupSettings(root: jsonP.JSONValue): s.MsSmoothGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdditionalManifests": [toMsSmoothAdditionalManifest],
      "AudioDeduplication": (x: jsonP.JSONValue) => cmnP.readEnum<s.MsSmoothAudioDeduplication>(x),
      "Destination": "s",
      "DestinationSettings": toDestinationSettings,
      "Encryption": toMsSmoothEncryptionSettings,
      "FragmentLength": "n",
      "ManifestEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<s.MsSmoothManifestEncoding>(x),
    },
  }, root);
}

function fromMsSmoothAdditionalManifest(input?: s.MsSmoothAdditionalManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestNameModifier: input["ManifestNameModifier"],
    selectedOutputs: input["SelectedOutputs"],
  }
}
function toMsSmoothAdditionalManifest(root: jsonP.JSONValue): s.MsSmoothAdditionalManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestNameModifier": "s",
      "SelectedOutputs": ["s"],
    },
  }, root);
}

function fromMsSmoothEncryptionSettings(input?: s.MsSmoothEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toMsSmoothEncryptionSettings(root: jsonP.JSONValue): s.MsSmoothEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
  }, root);
}

function fromOutput(input?: s.Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptions: input["AudioDescriptions"]?.map(x => fromAudioDescription(x)),
    captionDescriptions: input["CaptionDescriptions"]?.map(x => fromCaptionDescription(x)),
    containerSettings: fromContainerSettings(input["ContainerSettings"]),
    extension: input["Extension"],
    nameModifier: input["NameModifier"],
    outputSettings: fromOutputSettings(input["OutputSettings"]),
    preset: input["Preset"],
    videoDescription: fromVideoDescription(input["VideoDescription"]),
  }
}
function toOutput(root: jsonP.JSONValue): s.Output {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioDescriptions": [toAudioDescription],
      "CaptionDescriptions": [toCaptionDescription],
      "ContainerSettings": toContainerSettings,
      "Extension": "s",
      "NameModifier": "s",
      "OutputSettings": toOutputSettings,
      "Preset": "s",
      "VideoDescription": toVideoDescription,
    },
  }, root);
}

function fromAudioDescription(input?: s.AudioDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioChannelTaggingSettings: fromAudioChannelTaggingSettings(input["AudioChannelTaggingSettings"]),
    audioNormalizationSettings: fromAudioNormalizationSettings(input["AudioNormalizationSettings"]),
    audioSourceName: input["AudioSourceName"],
    audioType: input["AudioType"],
    audioTypeControl: input["AudioTypeControl"],
    codecSettings: fromAudioCodecSettings(input["CodecSettings"]),
    customLanguageCode: input["CustomLanguageCode"],
    languageCode: input["LanguageCode"],
    languageCodeControl: input["LanguageCodeControl"],
    remixSettings: fromRemixSettings(input["RemixSettings"]),
    streamName: input["StreamName"],
  }
}
function toAudioDescription(root: jsonP.JSONValue): s.AudioDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioChannelTaggingSettings": toAudioChannelTaggingSettings,
      "AudioNormalizationSettings": toAudioNormalizationSettings,
      "AudioSourceName": "s",
      "AudioType": "n",
      "AudioTypeControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioTypeControl>(x),
      "CodecSettings": toAudioCodecSettings,
      "CustomLanguageCode": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "LanguageCodeControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioLanguageCodeControl>(x),
      "RemixSettings": toRemixSettings,
      "StreamName": "s",
    },
  }, root);
}

function fromAudioChannelTaggingSettings(input?: s.AudioChannelTaggingSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channelTag: input["ChannelTag"],
  }
}
function toAudioChannelTaggingSettings(root: jsonP.JSONValue): s.AudioChannelTaggingSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelTag": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioChannelTag>(x),
    },
  }, root);
}

function fromAudioNormalizationSettings(input?: s.AudioNormalizationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    algorithm: input["Algorithm"],
    algorithmControl: input["AlgorithmControl"],
    correctionGateLevel: input["CorrectionGateLevel"],
    loudnessLogging: input["LoudnessLogging"],
    peakCalculation: input["PeakCalculation"],
    targetLkfs: input["TargetLkfs"],
  }
}
function toAudioNormalizationSettings(root: jsonP.JSONValue): s.AudioNormalizationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Algorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioNormalizationAlgorithm>(x),
      "AlgorithmControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioNormalizationAlgorithmControl>(x),
      "CorrectionGateLevel": "n",
      "LoudnessLogging": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioNormalizationLoudnessLogging>(x),
      "PeakCalculation": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioNormalizationPeakCalculation>(x),
      "TargetLkfs": "n",
    },
  }, root);
}

function fromAudioCodecSettings(input?: s.AudioCodecSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    aacSettings: fromAacSettings(input["AacSettings"]),
    ac3Settings: fromAc3Settings(input["Ac3Settings"]),
    aiffSettings: fromAiffSettings(input["AiffSettings"]),
    codec: input["Codec"],
    eac3AtmosSettings: fromEac3AtmosSettings(input["Eac3AtmosSettings"]),
    eac3Settings: fromEac3Settings(input["Eac3Settings"]),
    mp2Settings: fromMp2Settings(input["Mp2Settings"]),
    mp3Settings: fromMp3Settings(input["Mp3Settings"]),
    opusSettings: fromOpusSettings(input["OpusSettings"]),
    vorbisSettings: fromVorbisSettings(input["VorbisSettings"]),
    wavSettings: fromWavSettings(input["WavSettings"]),
  }
}
function toAudioCodecSettings(root: jsonP.JSONValue): s.AudioCodecSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AacSettings": toAacSettings,
      "Ac3Settings": toAc3Settings,
      "AiffSettings": toAiffSettings,
      "Codec": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioCodec>(x),
      "Eac3AtmosSettings": toEac3AtmosSettings,
      "Eac3Settings": toEac3Settings,
      "Mp2Settings": toMp2Settings,
      "Mp3Settings": toMp3Settings,
      "OpusSettings": toOpusSettings,
      "VorbisSettings": toVorbisSettings,
      "WavSettings": toWavSettings,
    },
  }, root);
}

function fromAacSettings(input?: s.AacSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptionBroadcasterMix: input["AudioDescriptionBroadcasterMix"],
    bitrate: input["Bitrate"],
    codecProfile: input["CodecProfile"],
    codingMode: input["CodingMode"],
    rateControlMode: input["RateControlMode"],
    rawFormat: input["RawFormat"],
    sampleRate: input["SampleRate"],
    specification: input["Specification"],
    vbrQuality: input["VbrQuality"],
  }
}
function toAacSettings(root: jsonP.JSONValue): s.AacSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioDescriptionBroadcasterMix": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacAudioDescriptionBroadcasterMix>(x),
      "Bitrate": "n",
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacCodecProfile>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacCodingMode>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacRateControlMode>(x),
      "RawFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacRawFormat>(x),
      "SampleRate": "n",
      "Specification": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacSpecification>(x),
      "VbrQuality": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacVbrQuality>(x),
    },
  }, root);
}

function fromAc3Settings(input?: s.Ac3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dialnorm: input["Dialnorm"],
    dynamicRangeCompressionProfile: input["DynamicRangeCompressionProfile"],
    lfeFilter: input["LfeFilter"],
    metadataControl: input["MetadataControl"],
    sampleRate: input["SampleRate"],
  }
}
function toAc3Settings(root: jsonP.JSONValue): s.Ac3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3BitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3CodingMode>(x),
      "Dialnorm": "n",
      "DynamicRangeCompressionProfile": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3DynamicRangeCompressionProfile>(x),
      "LfeFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3LfeFilter>(x),
      "MetadataControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3MetadataControl>(x),
      "SampleRate": "n",
    },
  }, root);
}

function fromAiffSettings(input?: s.AiffSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitDepth: input["BitDepth"],
    channels: input["Channels"],
    sampleRate: input["SampleRate"],
  }
}
function toAiffSettings(root: jsonP.JSONValue): s.AiffSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BitDepth": "n",
      "Channels": "n",
      "SampleRate": "n",
    },
  }, root);
}

function fromEac3AtmosSettings(input?: s.Eac3AtmosSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dialogueIntelligence: input["DialogueIntelligence"],
    dynamicRangeCompressionLine: input["DynamicRangeCompressionLine"],
    dynamicRangeCompressionRf: input["DynamicRangeCompressionRf"],
    loRoCenterMixLevel: input["LoRoCenterMixLevel"],
    loRoSurroundMixLevel: input["LoRoSurroundMixLevel"],
    ltRtCenterMixLevel: input["LtRtCenterMixLevel"],
    ltRtSurroundMixLevel: input["LtRtSurroundMixLevel"],
    meteringMode: input["MeteringMode"],
    sampleRate: input["SampleRate"],
    speechThreshold: input["SpeechThreshold"],
    stereoDownmix: input["StereoDownmix"],
    surroundExMode: input["SurroundExMode"],
  }
}
function toEac3AtmosSettings(root: jsonP.JSONValue): s.Eac3AtmosSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AtmosBitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AtmosCodingMode>(x),
      "DialogueIntelligence": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AtmosDialogueIntelligence>(x),
      "DynamicRangeCompressionLine": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AtmosDynamicRangeCompressionLine>(x),
      "DynamicRangeCompressionRf": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AtmosDynamicRangeCompressionRf>(x),
      "LoRoCenterMixLevel": "n",
      "LoRoSurroundMixLevel": "n",
      "LtRtCenterMixLevel": "n",
      "LtRtSurroundMixLevel": "n",
      "MeteringMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AtmosMeteringMode>(x),
      "SampleRate": "n",
      "SpeechThreshold": "n",
      "StereoDownmix": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AtmosStereoDownmix>(x),
      "SurroundExMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AtmosSurroundExMode>(x),
    },
  }, root);
}

function fromEac3Settings(input?: s.Eac3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attenuationControl: input["AttenuationControl"],
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dcFilter: input["DcFilter"],
    dialnorm: input["Dialnorm"],
    dynamicRangeCompressionLine: input["DynamicRangeCompressionLine"],
    dynamicRangeCompressionRf: input["DynamicRangeCompressionRf"],
    lfeControl: input["LfeControl"],
    lfeFilter: input["LfeFilter"],
    loRoCenterMixLevel: input["LoRoCenterMixLevel"],
    loRoSurroundMixLevel: input["LoRoSurroundMixLevel"],
    ltRtCenterMixLevel: input["LtRtCenterMixLevel"],
    ltRtSurroundMixLevel: input["LtRtSurroundMixLevel"],
    metadataControl: input["MetadataControl"],
    passthroughControl: input["PassthroughControl"],
    phaseControl: input["PhaseControl"],
    sampleRate: input["SampleRate"],
    stereoDownmix: input["StereoDownmix"],
    surroundExMode: input["SurroundExMode"],
    surroundMode: input["SurroundMode"],
  }
}
function toEac3Settings(root: jsonP.JSONValue): s.Eac3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttenuationControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AttenuationControl>(x),
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3BitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3CodingMode>(x),
      "DcFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3DcFilter>(x),
      "Dialnorm": "n",
      "DynamicRangeCompressionLine": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3DynamicRangeCompressionLine>(x),
      "DynamicRangeCompressionRf": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3DynamicRangeCompressionRf>(x),
      "LfeControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3LfeControl>(x),
      "LfeFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3LfeFilter>(x),
      "LoRoCenterMixLevel": "n",
      "LoRoSurroundMixLevel": "n",
      "LtRtCenterMixLevel": "n",
      "LtRtSurroundMixLevel": "n",
      "MetadataControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3MetadataControl>(x),
      "PassthroughControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3PassthroughControl>(x),
      "PhaseControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3PhaseControl>(x),
      "SampleRate": "n",
      "StereoDownmix": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3StereoDownmix>(x),
      "SurroundExMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3SurroundExMode>(x),
      "SurroundMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3SurroundMode>(x),
    },
  }, root);
}

function fromMp2Settings(input?: s.Mp2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    channels: input["Channels"],
    sampleRate: input["SampleRate"],
  }
}
function toMp2Settings(root: jsonP.JSONValue): s.Mp2Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "Channels": "n",
      "SampleRate": "n",
    },
  }, root);
}

function fromMp3Settings(input?: s.Mp3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    channels: input["Channels"],
    rateControlMode: input["RateControlMode"],
    sampleRate: input["SampleRate"],
    vbrQuality: input["VbrQuality"],
  }
}
function toMp3Settings(root: jsonP.JSONValue): s.Mp3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "Channels": "n",
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mp3RateControlMode>(x),
      "SampleRate": "n",
      "VbrQuality": "n",
    },
  }, root);
}

function fromOpusSettings(input?: s.OpusSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    channels: input["Channels"],
    sampleRate: input["SampleRate"],
  }
}
function toOpusSettings(root: jsonP.JSONValue): s.OpusSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "Channels": "n",
      "SampleRate": "n",
    },
  }, root);
}

function fromVorbisSettings(input?: s.VorbisSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channels: input["Channels"],
    sampleRate: input["SampleRate"],
    vbrQuality: input["VbrQuality"],
  }
}
function toVorbisSettings(root: jsonP.JSONValue): s.VorbisSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Channels": "n",
      "SampleRate": "n",
      "VbrQuality": "n",
    },
  }, root);
}

function fromWavSettings(input?: s.WavSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitDepth: input["BitDepth"],
    channels: input["Channels"],
    format: input["Format"],
    sampleRate: input["SampleRate"],
  }
}
function toWavSettings(root: jsonP.JSONValue): s.WavSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BitDepth": "n",
      "Channels": "n",
      "Format": (x: jsonP.JSONValue) => cmnP.readEnum<s.WavFormat>(x),
      "SampleRate": "n",
    },
  }, root);
}

function fromCaptionDescription(input?: s.CaptionDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captionSelectorName: input["CaptionSelectorName"],
    customLanguageCode: input["CustomLanguageCode"],
    destinationSettings: fromCaptionDestinationSettings(input["DestinationSettings"]),
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
  }
}
function toCaptionDescription(root: jsonP.JSONValue): s.CaptionDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "CaptionSelectorName": "s",
      "CustomLanguageCode": "s",
      "DestinationSettings": toCaptionDestinationSettings,
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "LanguageDescription": "s",
    },
  }, root);
}

function fromCaptionDestinationSettings(input?: s.CaptionDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    burninDestinationSettings: fromBurninDestinationSettings(input["BurninDestinationSettings"]),
    destinationType: input["DestinationType"],
    dvbSubDestinationSettings: fromDvbSubDestinationSettings(input["DvbSubDestinationSettings"]),
    embeddedDestinationSettings: fromEmbeddedDestinationSettings(input["EmbeddedDestinationSettings"]),
    imscDestinationSettings: fromImscDestinationSettings(input["ImscDestinationSettings"]),
    sccDestinationSettings: fromSccDestinationSettings(input["SccDestinationSettings"]),
    teletextDestinationSettings: fromTeletextDestinationSettings(input["TeletextDestinationSettings"]),
    ttmlDestinationSettings: fromTtmlDestinationSettings(input["TtmlDestinationSettings"]),
  }
}
function toCaptionDestinationSettings(root: jsonP.JSONValue): s.CaptionDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BurninDestinationSettings": toBurninDestinationSettings,
      "DestinationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CaptionDestinationType>(x),
      "DvbSubDestinationSettings": toDvbSubDestinationSettings,
      "EmbeddedDestinationSettings": toEmbeddedDestinationSettings,
      "ImscDestinationSettings": toImscDestinationSettings,
      "SccDestinationSettings": toSccDestinationSettings,
      "TeletextDestinationSettings": toTeletextDestinationSettings,
      "TtmlDestinationSettings": toTtmlDestinationSettings,
    },
  }, root);
}

function fromBurninDestinationSettings(input?: s.BurninDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alignment: input["Alignment"],
    backgroundColor: input["BackgroundColor"],
    backgroundOpacity: input["BackgroundOpacity"],
    fontColor: input["FontColor"],
    fontOpacity: input["FontOpacity"],
    fontResolution: input["FontResolution"],
    fontScript: input["FontScript"],
    fontSize: input["FontSize"],
    outlineColor: input["OutlineColor"],
    outlineSize: input["OutlineSize"],
    shadowColor: input["ShadowColor"],
    shadowOpacity: input["ShadowOpacity"],
    shadowXOffset: input["ShadowXOffset"],
    shadowYOffset: input["ShadowYOffset"],
    teletextSpacing: input["TeletextSpacing"],
    xPosition: input["XPosition"],
    yPosition: input["YPosition"],
  }
}
function toBurninDestinationSettings(root: jsonP.JSONValue): s.BurninDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alignment": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurninSubtitleAlignment>(x),
      "BackgroundColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurninSubtitleBackgroundColor>(x),
      "BackgroundOpacity": "n",
      "FontColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurninSubtitleFontColor>(x),
      "FontOpacity": "n",
      "FontResolution": "n",
      "FontScript": (x: jsonP.JSONValue) => cmnP.readEnum<s.FontScript>(x),
      "FontSize": "n",
      "OutlineColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurninSubtitleOutlineColor>(x),
      "OutlineSize": "n",
      "ShadowColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurninSubtitleShadowColor>(x),
      "ShadowOpacity": "n",
      "ShadowXOffset": "n",
      "ShadowYOffset": "n",
      "TeletextSpacing": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurninSubtitleTeletextSpacing>(x),
      "XPosition": "n",
      "YPosition": "n",
    },
  }, root);
}

function fromDvbSubDestinationSettings(input?: s.DvbSubDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alignment: input["Alignment"],
    backgroundColor: input["BackgroundColor"],
    backgroundOpacity: input["BackgroundOpacity"],
    fontColor: input["FontColor"],
    fontOpacity: input["FontOpacity"],
    fontResolution: input["FontResolution"],
    fontScript: input["FontScript"],
    fontSize: input["FontSize"],
    outlineColor: input["OutlineColor"],
    outlineSize: input["OutlineSize"],
    shadowColor: input["ShadowColor"],
    shadowOpacity: input["ShadowOpacity"],
    shadowXOffset: input["ShadowXOffset"],
    shadowYOffset: input["ShadowYOffset"],
    subtitlingType: input["SubtitlingType"],
    teletextSpacing: input["TeletextSpacing"],
    xPosition: input["XPosition"],
    yPosition: input["YPosition"],
  }
}
function toDvbSubDestinationSettings(root: jsonP.JSONValue): s.DvbSubDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alignment": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubtitleAlignment>(x),
      "BackgroundColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubtitleBackgroundColor>(x),
      "BackgroundOpacity": "n",
      "FontColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubtitleFontColor>(x),
      "FontOpacity": "n",
      "FontResolution": "n",
      "FontScript": (x: jsonP.JSONValue) => cmnP.readEnum<s.FontScript>(x),
      "FontSize": "n",
      "OutlineColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubtitleOutlineColor>(x),
      "OutlineSize": "n",
      "ShadowColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubtitleShadowColor>(x),
      "ShadowOpacity": "n",
      "ShadowXOffset": "n",
      "ShadowYOffset": "n",
      "SubtitlingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubtitlingType>(x),
      "TeletextSpacing": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubtitleTeletextSpacing>(x),
      "XPosition": "n",
      "YPosition": "n",
    },
  }, root);
}

function fromEmbeddedDestinationSettings(input?: s.EmbeddedDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination608ChannelNumber: input["Destination608ChannelNumber"],
    destination708ServiceNumber: input["Destination708ServiceNumber"],
  }
}
function toEmbeddedDestinationSettings(root: jsonP.JSONValue): s.EmbeddedDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Destination608ChannelNumber": "n",
      "Destination708ServiceNumber": "n",
    },
  }, root);
}

function fromImscDestinationSettings(input?: s.ImscDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    stylePassthrough: input["StylePassthrough"],
  }
}
function toImscDestinationSettings(root: jsonP.JSONValue): s.ImscDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StylePassthrough": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImscStylePassthrough>(x),
    },
  }, root);
}

function fromSccDestinationSettings(input?: s.SccDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerate: input["Framerate"],
  }
}
function toSccDestinationSettings(root: jsonP.JSONValue): s.SccDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Framerate": (x: jsonP.JSONValue) => cmnP.readEnum<s.SccDestinationFramerate>(x),
    },
  }, root);
}

function fromTeletextDestinationSettings(input?: s.TeletextDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pageNumber: input["PageNumber"],
    pageTypes: input["PageTypes"],
  }
}
function toTeletextDestinationSettings(root: jsonP.JSONValue): s.TeletextDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PageNumber": "s",
      "PageTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.TeletextPageType>(x)],
    },
  }, root);
}

function fromTtmlDestinationSettings(input?: s.TtmlDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    stylePassthrough: input["StylePassthrough"],
  }
}
function toTtmlDestinationSettings(root: jsonP.JSONValue): s.TtmlDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StylePassthrough": (x: jsonP.JSONValue) => cmnP.readEnum<s.TtmlStylePassthrough>(x),
    },
  }, root);
}

function fromContainerSettings(input?: s.ContainerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cmfcSettings: fromCmfcSettings(input["CmfcSettings"]),
    container: input["Container"],
    f4vSettings: fromF4vSettings(input["F4vSettings"]),
    m2tsSettings: fromM2tsSettings(input["M2tsSettings"]),
    m3u8Settings: fromM3u8Settings(input["M3u8Settings"]),
    movSettings: fromMovSettings(input["MovSettings"]),
    mp4Settings: fromMp4Settings(input["Mp4Settings"]),
    mpdSettings: fromMpdSettings(input["MpdSettings"]),
    mxfSettings: fromMxfSettings(input["MxfSettings"]),
  }
}
function toContainerSettings(root: jsonP.JSONValue): s.ContainerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CmfcSettings": toCmfcSettings,
      "Container": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerType>(x),
      "F4vSettings": toF4vSettings,
      "M2tsSettings": toM2tsSettings,
      "M3u8Settings": toM3u8Settings,
      "MovSettings": toMovSettings,
      "Mp4Settings": toMp4Settings,
      "MpdSettings": toMpdSettings,
      "MxfSettings": toMxfSettings,
    },
  }, root);
}

function fromCmfcSettings(input?: s.CmfcSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDuration: input["AudioDuration"],
    iFrameOnlyManifest: input["IFrameOnlyManifest"],
    scte35Esam: input["Scte35Esam"],
    scte35Source: input["Scte35Source"],
  }
}
function toCmfcSettings(root: jsonP.JSONValue): s.CmfcSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioDuration": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmfcAudioDuration>(x),
      "IFrameOnlyManifest": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmfcIFrameOnlyManifest>(x),
      "Scte35Esam": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmfcScte35Esam>(x),
      "Scte35Source": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmfcScte35Source>(x),
    },
  }, root);
}

function fromF4vSettings(input?: s.F4vSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    moovPlacement: input["MoovPlacement"],
  }
}
function toF4vSettings(root: jsonP.JSONValue): s.F4vSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MoovPlacement": (x: jsonP.JSONValue) => cmnP.readEnum<s.F4vMoovPlacement>(x),
    },
  }, root);
}

function fromM2tsSettings(input?: s.M2tsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioBufferModel: input["AudioBufferModel"],
    audioDuration: input["AudioDuration"],
    audioFramesPerPes: input["AudioFramesPerPes"],
    audioPids: input["AudioPids"],
    bitrate: input["Bitrate"],
    bufferModel: input["BufferModel"],
    dvbNitSettings: fromDvbNitSettings(input["DvbNitSettings"]),
    dvbSdtSettings: fromDvbSdtSettings(input["DvbSdtSettings"]),
    dvbSubPids: input["DvbSubPids"],
    dvbTdtSettings: fromDvbTdtSettings(input["DvbTdtSettings"]),
    dvbTeletextPid: input["DvbTeletextPid"],
    ebpAudioInterval: input["EbpAudioInterval"],
    ebpPlacement: input["EbpPlacement"],
    esRateInPes: input["EsRateInPes"],
    forceTsVideoEbpOrder: input["ForceTsVideoEbpOrder"],
    fragmentTime: input["FragmentTime"],
    maxPcrInterval: input["MaxPcrInterval"],
    minEbpInterval: input["MinEbpInterval"],
    nielsenId3: input["NielsenId3"],
    nullPacketBitrate: input["NullPacketBitrate"],
    patInterval: input["PatInterval"],
    pcrControl: input["PcrControl"],
    pcrPid: input["PcrPid"],
    pmtInterval: input["PmtInterval"],
    pmtPid: input["PmtPid"],
    privateMetadataPid: input["PrivateMetadataPid"],
    programNumber: input["ProgramNumber"],
    rateMode: input["RateMode"],
    scte35Esam: fromM2tsScte35Esam(input["Scte35Esam"]),
    scte35Pid: input["Scte35Pid"],
    scte35Source: input["Scte35Source"],
    segmentationMarkers: input["SegmentationMarkers"],
    segmentationStyle: input["SegmentationStyle"],
    segmentationTime: input["SegmentationTime"],
    timedMetadataPid: input["TimedMetadataPid"],
    transportStreamId: input["TransportStreamId"],
    videoPid: input["VideoPid"],
  }
}
function toM2tsSettings(root: jsonP.JSONValue): s.M2tsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioBufferModel": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsAudioBufferModel>(x),
      "AudioDuration": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsAudioDuration>(x),
      "AudioFramesPerPes": "n",
      "AudioPids": ["n"],
      "Bitrate": "n",
      "BufferModel": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsBufferModel>(x),
      "DvbNitSettings": toDvbNitSettings,
      "DvbSdtSettings": toDvbSdtSettings,
      "DvbSubPids": ["n"],
      "DvbTdtSettings": toDvbTdtSettings,
      "DvbTeletextPid": "n",
      "EbpAudioInterval": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsEbpAudioInterval>(x),
      "EbpPlacement": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsEbpPlacement>(x),
      "EsRateInPes": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsEsRateInPes>(x),
      "ForceTsVideoEbpOrder": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsForceTsVideoEbpOrder>(x),
      "FragmentTime": "n",
      "MaxPcrInterval": "n",
      "MinEbpInterval": "n",
      "NielsenId3": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsNielsenId3>(x),
      "NullPacketBitrate": "n",
      "PatInterval": "n",
      "PcrControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsPcrControl>(x),
      "PcrPid": "n",
      "PmtInterval": "n",
      "PmtPid": "n",
      "PrivateMetadataPid": "n",
      "ProgramNumber": "n",
      "RateMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsRateMode>(x),
      "Scte35Esam": toM2tsScte35Esam,
      "Scte35Pid": "n",
      "Scte35Source": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsScte35Source>(x),
      "SegmentationMarkers": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsSegmentationMarkers>(x),
      "SegmentationStyle": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsSegmentationStyle>(x),
      "SegmentationTime": "n",
      "TimedMetadataPid": "n",
      "TransportStreamId": "n",
      "VideoPid": "n",
    },
  }, root);
}

function fromDvbNitSettings(input?: s.DvbNitSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    networkId: input["NetworkId"],
    networkName: input["NetworkName"],
    nitInterval: input["NitInterval"],
  }
}
function toDvbNitSettings(root: jsonP.JSONValue): s.DvbNitSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "NetworkId": "n",
      "NetworkName": "s",
      "NitInterval": "n",
    },
  }, root);
}

function fromDvbSdtSettings(input?: s.DvbSdtSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    outputSdt: input["OutputSdt"],
    sdtInterval: input["SdtInterval"],
    serviceName: input["ServiceName"],
    serviceProviderName: input["ServiceProviderName"],
  }
}
function toDvbSdtSettings(root: jsonP.JSONValue): s.DvbSdtSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputSdt": (x: jsonP.JSONValue) => cmnP.readEnum<s.OutputSdt>(x),
      "SdtInterval": "n",
      "ServiceName": "s",
      "ServiceProviderName": "s",
    },
  }, root);
}

function fromDvbTdtSettings(input?: s.DvbTdtSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tdtInterval: input["TdtInterval"],
  }
}
function toDvbTdtSettings(root: jsonP.JSONValue): s.DvbTdtSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TdtInterval": "n",
    },
  }, root);
}

function fromM2tsScte35Esam(input?: s.M2tsScte35Esam | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scte35EsamPid: input["Scte35EsamPid"],
  }
}
function toM2tsScte35Esam(root: jsonP.JSONValue): s.M2tsScte35Esam {
  return jsonP.readObj({
    required: {},
    optional: {
      "Scte35EsamPid": "n",
    },
  }, root);
}

function fromM3u8Settings(input?: s.M3u8Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDuration: input["AudioDuration"],
    audioFramesPerPes: input["AudioFramesPerPes"],
    audioPids: input["AudioPids"],
    nielsenId3: input["NielsenId3"],
    patInterval: input["PatInterval"],
    pcrControl: input["PcrControl"],
    pcrPid: input["PcrPid"],
    pmtInterval: input["PmtInterval"],
    pmtPid: input["PmtPid"],
    privateMetadataPid: input["PrivateMetadataPid"],
    programNumber: input["ProgramNumber"],
    scte35Pid: input["Scte35Pid"],
    scte35Source: input["Scte35Source"],
    timedMetadata: input["TimedMetadata"],
    timedMetadataPid: input["TimedMetadataPid"],
    transportStreamId: input["TransportStreamId"],
    videoPid: input["VideoPid"],
  }
}
function toM3u8Settings(root: jsonP.JSONValue): s.M3u8Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioDuration": (x: jsonP.JSONValue) => cmnP.readEnum<s.M3u8AudioDuration>(x),
      "AudioFramesPerPes": "n",
      "AudioPids": ["n"],
      "NielsenId3": (x: jsonP.JSONValue) => cmnP.readEnum<s.M3u8NielsenId3>(x),
      "PatInterval": "n",
      "PcrControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.M3u8PcrControl>(x),
      "PcrPid": "n",
      "PmtInterval": "n",
      "PmtPid": "n",
      "PrivateMetadataPid": "n",
      "ProgramNumber": "n",
      "Scte35Pid": "n",
      "Scte35Source": (x: jsonP.JSONValue) => cmnP.readEnum<s.M3u8Scte35Source>(x),
      "TimedMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimedMetadata>(x),
      "TimedMetadataPid": "n",
      "TransportStreamId": "n",
      "VideoPid": "n",
    },
  }, root);
}

function fromMovSettings(input?: s.MovSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clapAtom: input["ClapAtom"],
    cslgAtom: input["CslgAtom"],
    mpeg2FourCCControl: input["Mpeg2FourCCControl"],
    paddingControl: input["PaddingControl"],
    reference: input["Reference"],
  }
}
function toMovSettings(root: jsonP.JSONValue): s.MovSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClapAtom": (x: jsonP.JSONValue) => cmnP.readEnum<s.MovClapAtom>(x),
      "CslgAtom": (x: jsonP.JSONValue) => cmnP.readEnum<s.MovCslgAtom>(x),
      "Mpeg2FourCCControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.MovMpeg2FourCCControl>(x),
      "PaddingControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.MovPaddingControl>(x),
      "Reference": (x: jsonP.JSONValue) => cmnP.readEnum<s.MovReference>(x),
    },
  }, root);
}

function fromMp4Settings(input?: s.Mp4Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDuration: input["AudioDuration"],
    cslgAtom: input["CslgAtom"],
    cttsVersion: input["CttsVersion"],
    freeSpaceBox: input["FreeSpaceBox"],
    moovPlacement: input["MoovPlacement"],
    mp4MajorBrand: input["Mp4MajorBrand"],
  }
}
function toMp4Settings(root: jsonP.JSONValue): s.Mp4Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioDuration": (x: jsonP.JSONValue) => cmnP.readEnum<s.CmfcAudioDuration>(x),
      "CslgAtom": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mp4CslgAtom>(x),
      "CttsVersion": "n",
      "FreeSpaceBox": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mp4FreeSpaceBox>(x),
      "MoovPlacement": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mp4MoovPlacement>(x),
      "Mp4MajorBrand": "s",
    },
  }, root);
}

function fromMpdSettings(input?: s.MpdSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessibilityCaptionHints: input["AccessibilityCaptionHints"],
    audioDuration: input["AudioDuration"],
    captionContainerType: input["CaptionContainerType"],
    scte35Esam: input["Scte35Esam"],
    scte35Source: input["Scte35Source"],
  }
}
function toMpdSettings(root: jsonP.JSONValue): s.MpdSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccessibilityCaptionHints": (x: jsonP.JSONValue) => cmnP.readEnum<s.MpdAccessibilityCaptionHints>(x),
      "AudioDuration": (x: jsonP.JSONValue) => cmnP.readEnum<s.MpdAudioDuration>(x),
      "CaptionContainerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MpdCaptionContainerType>(x),
      "Scte35Esam": (x: jsonP.JSONValue) => cmnP.readEnum<s.MpdScte35Esam>(x),
      "Scte35Source": (x: jsonP.JSONValue) => cmnP.readEnum<s.MpdScte35Source>(x),
    },
  }, root);
}

function fromMxfSettings(input?: s.MxfSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    afdSignaling: input["AfdSignaling"],
    profile: input["Profile"],
  }
}
function toMxfSettings(root: jsonP.JSONValue): s.MxfSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<s.MxfAfdSignaling>(x),
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<s.MxfProfile>(x),
    },
  }, root);
}

function fromOutputSettings(input?: s.OutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hlsSettings: fromHlsSettings(input["HlsSettings"]),
  }
}
function toOutputSettings(root: jsonP.JSONValue): s.OutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "HlsSettings": toHlsSettings,
    },
  }, root);
}

function fromHlsSettings(input?: s.HlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioGroupId: input["AudioGroupId"],
    audioOnlyContainer: input["AudioOnlyContainer"],
    audioRenditionSets: input["AudioRenditionSets"],
    audioTrackType: input["AudioTrackType"],
    iFrameOnlyManifest: input["IFrameOnlyManifest"],
    segmentModifier: input["SegmentModifier"],
  }
}
function toHlsSettings(root: jsonP.JSONValue): s.HlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioGroupId": "s",
      "AudioOnlyContainer": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsAudioOnlyContainer>(x),
      "AudioRenditionSets": "s",
      "AudioTrackType": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsAudioTrackType>(x),
      "IFrameOnlyManifest": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsIFrameOnlyManifest>(x),
      "SegmentModifier": "s",
    },
  }, root);
}

function fromVideoDescription(input?: s.VideoDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    afdSignaling: input["AfdSignaling"],
    antiAlias: input["AntiAlias"],
    codecSettings: fromVideoCodecSettings(input["CodecSettings"]),
    colorMetadata: input["ColorMetadata"],
    crop: fromRectangle(input["Crop"]),
    dropFrameTimecode: input["DropFrameTimecode"],
    fixedAfd: input["FixedAfd"],
    height: input["Height"],
    position: fromRectangle(input["Position"]),
    respondToAfd: input["RespondToAfd"],
    scalingBehavior: input["ScalingBehavior"],
    sharpness: input["Sharpness"],
    timecodeInsertion: input["TimecodeInsertion"],
    videoPreprocessors: fromVideoPreprocessor(input["VideoPreprocessors"]),
    width: input["Width"],
  }
}
function toVideoDescription(root: jsonP.JSONValue): s.VideoDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<s.AfdSignaling>(x),
      "AntiAlias": (x: jsonP.JSONValue) => cmnP.readEnum<s.AntiAlias>(x),
      "CodecSettings": toVideoCodecSettings,
      "ColorMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<s.ColorMetadata>(x),
      "Crop": toRectangle,
      "DropFrameTimecode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DropFrameTimecode>(x),
      "FixedAfd": "n",
      "Height": "n",
      "Position": toRectangle,
      "RespondToAfd": (x: jsonP.JSONValue) => cmnP.readEnum<s.RespondToAfd>(x),
      "ScalingBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScalingBehavior>(x),
      "Sharpness": "n",
      "TimecodeInsertion": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoTimecodeInsertion>(x),
      "VideoPreprocessors": toVideoPreprocessor,
      "Width": "n",
    },
  }, root);
}

function fromVideoCodecSettings(input?: s.VideoCodecSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    av1Settings: fromAv1Settings(input["Av1Settings"]),
    avcIntraSettings: fromAvcIntraSettings(input["AvcIntraSettings"]),
    codec: input["Codec"],
    frameCaptureSettings: fromFrameCaptureSettings(input["FrameCaptureSettings"]),
    h264Settings: fromH264Settings(input["H264Settings"]),
    h265Settings: fromH265Settings(input["H265Settings"]),
    mpeg2Settings: fromMpeg2Settings(input["Mpeg2Settings"]),
    proresSettings: fromProresSettings(input["ProresSettings"]),
    vc3Settings: fromVc3Settings(input["Vc3Settings"]),
    vp8Settings: fromVp8Settings(input["Vp8Settings"]),
    vp9Settings: fromVp9Settings(input["Vp9Settings"]),
  }
}
function toVideoCodecSettings(root: jsonP.JSONValue): s.VideoCodecSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Av1Settings": toAv1Settings,
      "AvcIntraSettings": toAvcIntraSettings,
      "Codec": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoCodec>(x),
      "FrameCaptureSettings": toFrameCaptureSettings,
      "H264Settings": toH264Settings,
      "H265Settings": toH265Settings,
      "Mpeg2Settings": toMpeg2Settings,
      "ProresSettings": toProresSettings,
      "Vc3Settings": toVc3Settings,
      "Vp8Settings": toVp8Settings,
      "Vp9Settings": toVp9Settings,
    },
  }, root);
}

function fromAv1Settings(input?: s.Av1Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopSize: input["GopSize"],
    maxBitrate: input["MaxBitrate"],
    numberBFramesBetweenReferenceFrames: input["NumberBFramesBetweenReferenceFrames"],
    qvbrSettings: fromAv1QvbrSettings(input["QvbrSettings"]),
    rateControlMode: input["RateControlMode"],
    slices: input["Slices"],
    spatialAdaptiveQuantization: input["SpatialAdaptiveQuantization"],
  }
}
function toAv1Settings(root: jsonP.JSONValue): s.Av1Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.Av1AdaptiveQuantization>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Av1FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.Av1FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopSize": "n",
      "MaxBitrate": "n",
      "NumberBFramesBetweenReferenceFrames": "n",
      "QvbrSettings": toAv1QvbrSettings,
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Av1RateControlMode>(x),
      "Slices": "n",
      "SpatialAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.Av1SpatialAdaptiveQuantization>(x),
    },
  }, root);
}

function fromAv1QvbrSettings(input?: s.Av1QvbrSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    qvbrQualityLevel: input["QvbrQualityLevel"],
    qvbrQualityLevelFineTune: input["QvbrQualityLevelFineTune"],
  }
}
function toAv1QvbrSettings(root: jsonP.JSONValue): s.Av1QvbrSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "QvbrQualityLevel": "n",
      "QvbrQualityLevelFineTune": "n",
    },
  }, root);
}

function fromAvcIntraSettings(input?: s.AvcIntraSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    avcIntraClass: input["AvcIntraClass"],
    avcIntraUhdSettings: fromAvcIntraUhdSettings(input["AvcIntraUhdSettings"]),
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    interlaceMode: input["InterlaceMode"],
    scanTypeConversionMode: input["ScanTypeConversionMode"],
    slowPal: input["SlowPal"],
    telecine: input["Telecine"],
  }
}
function toAvcIntraSettings(root: jsonP.JSONValue): s.AvcIntraSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvcIntraClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvcIntraClass>(x),
      "AvcIntraUhdSettings": toAvcIntraUhdSettings,
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvcIntraFramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvcIntraFramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvcIntraInterlaceMode>(x),
      "ScanTypeConversionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvcIntraScanTypeConversionMode>(x),
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvcIntraSlowPal>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvcIntraTelecine>(x),
    },
  }, root);
}

function fromAvcIntraUhdSettings(input?: s.AvcIntraUhdSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    qualityTuningLevel: input["QualityTuningLevel"],
  }
}
function toAvcIntraUhdSettings(root: jsonP.JSONValue): s.AvcIntraUhdSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvcIntraUhdQualityTuningLevel>(x),
    },
  }, root);
}

function fromFrameCaptureSettings(input?: s.FrameCaptureSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    maxCaptures: input["MaxCaptures"],
    quality: input["Quality"],
  }
}
function toFrameCaptureSettings(root: jsonP.JSONValue): s.FrameCaptureSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "MaxCaptures": "n",
      "Quality": "n",
    },
  }, root);
}

function fromH264Settings(input?: s.H264Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    bitrate: input["Bitrate"],
    codecLevel: input["CodecLevel"],
    codecProfile: input["CodecProfile"],
    dynamicSubGop: input["DynamicSubGop"],
    entropyEncoding: input["EntropyEncoding"],
    fieldEncoding: input["FieldEncoding"],
    flickerAdaptiveQuantization: input["FlickerAdaptiveQuantization"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopBReference: input["GopBReference"],
    gopClosedCadence: input["GopClosedCadence"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    hrdBufferInitialFillPercentage: input["HrdBufferInitialFillPercentage"],
    hrdBufferSize: input["HrdBufferSize"],
    interlaceMode: input["InterlaceMode"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    numberBFramesBetweenReferenceFrames: input["NumberBFramesBetweenReferenceFrames"],
    numberReferenceFrames: input["NumberReferenceFrames"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    qvbrSettings: fromH264QvbrSettings(input["QvbrSettings"]),
    rateControlMode: input["RateControlMode"],
    repeatPps: input["RepeatPps"],
    scanTypeConversionMode: input["ScanTypeConversionMode"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slices: input["Slices"],
    slowPal: input["SlowPal"],
    softness: input["Softness"],
    spatialAdaptiveQuantization: input["SpatialAdaptiveQuantization"],
    syntax: input["Syntax"],
    telecine: input["Telecine"],
    temporalAdaptiveQuantization: input["TemporalAdaptiveQuantization"],
    unregisteredSeiTimecode: input["UnregisteredSeiTimecode"],
  }
}
function toH264Settings(root: jsonP.JSONValue): s.H264Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264AdaptiveQuantization>(x),
      "Bitrate": "n",
      "CodecLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264CodecLevel>(x),
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264CodecProfile>(x),
      "DynamicSubGop": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264DynamicSubGop>(x),
      "EntropyEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264EntropyEncoding>(x),
      "FieldEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264FieldEncoding>(x),
      "FlickerAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264FlickerAdaptiveQuantization>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopBReference": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264GopBReference>(x),
      "GopClosedCadence": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264GopSizeUnits>(x),
      "HrdBufferInitialFillPercentage": "n",
      "HrdBufferSize": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264InterlaceMode>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "NumberBFramesBetweenReferenceFrames": "n",
      "NumberReferenceFrames": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264QualityTuningLevel>(x),
      "QvbrSettings": toH264QvbrSettings,
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264RateControlMode>(x),
      "RepeatPps": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264RepeatPps>(x),
      "ScanTypeConversionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264ScanTypeConversionMode>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264SceneChangeDetect>(x),
      "Slices": "n",
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264SlowPal>(x),
      "Softness": "n",
      "SpatialAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264SpatialAdaptiveQuantization>(x),
      "Syntax": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264Syntax>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264Telecine>(x),
      "TemporalAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264TemporalAdaptiveQuantization>(x),
      "UnregisteredSeiTimecode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264UnregisteredSeiTimecode>(x),
    },
  }, root);
}

function fromH264QvbrSettings(input?: s.H264QvbrSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxAverageBitrate: input["MaxAverageBitrate"],
    qvbrQualityLevel: input["QvbrQualityLevel"],
    qvbrQualityLevelFineTune: input["QvbrQualityLevelFineTune"],
  }
}
function toH264QvbrSettings(root: jsonP.JSONValue): s.H264QvbrSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxAverageBitrate": "n",
      "QvbrQualityLevel": "n",
      "QvbrQualityLevelFineTune": "n",
    },
  }, root);
}

function fromH265Settings(input?: s.H265Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    alternateTransferFunctionSei: input["AlternateTransferFunctionSei"],
    bitrate: input["Bitrate"],
    codecLevel: input["CodecLevel"],
    codecProfile: input["CodecProfile"],
    dynamicSubGop: input["DynamicSubGop"],
    flickerAdaptiveQuantization: input["FlickerAdaptiveQuantization"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopBReference: input["GopBReference"],
    gopClosedCadence: input["GopClosedCadence"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    hrdBufferInitialFillPercentage: input["HrdBufferInitialFillPercentage"],
    hrdBufferSize: input["HrdBufferSize"],
    interlaceMode: input["InterlaceMode"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    numberBFramesBetweenReferenceFrames: input["NumberBFramesBetweenReferenceFrames"],
    numberReferenceFrames: input["NumberReferenceFrames"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    qvbrSettings: fromH265QvbrSettings(input["QvbrSettings"]),
    rateControlMode: input["RateControlMode"],
    sampleAdaptiveOffsetFilterMode: input["SampleAdaptiveOffsetFilterMode"],
    scanTypeConversionMode: input["ScanTypeConversionMode"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slices: input["Slices"],
    slowPal: input["SlowPal"],
    spatialAdaptiveQuantization: input["SpatialAdaptiveQuantization"],
    telecine: input["Telecine"],
    temporalAdaptiveQuantization: input["TemporalAdaptiveQuantization"],
    temporalIds: input["TemporalIds"],
    tiles: input["Tiles"],
    unregisteredSeiTimecode: input["UnregisteredSeiTimecode"],
    writeMp4PackagingType: input["WriteMp4PackagingType"],
  }
}
function toH265Settings(root: jsonP.JSONValue): s.H265Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265AdaptiveQuantization>(x),
      "AlternateTransferFunctionSei": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265AlternateTransferFunctionSei>(x),
      "Bitrate": "n",
      "CodecLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265CodecLevel>(x),
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265CodecProfile>(x),
      "DynamicSubGop": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265DynamicSubGop>(x),
      "FlickerAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265FlickerAdaptiveQuantization>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopBReference": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265GopBReference>(x),
      "GopClosedCadence": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265GopSizeUnits>(x),
      "HrdBufferInitialFillPercentage": "n",
      "HrdBufferSize": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265InterlaceMode>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "NumberBFramesBetweenReferenceFrames": "n",
      "NumberReferenceFrames": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265QualityTuningLevel>(x),
      "QvbrSettings": toH265QvbrSettings,
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265RateControlMode>(x),
      "SampleAdaptiveOffsetFilterMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265SampleAdaptiveOffsetFilterMode>(x),
      "ScanTypeConversionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265ScanTypeConversionMode>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265SceneChangeDetect>(x),
      "Slices": "n",
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265SlowPal>(x),
      "SpatialAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265SpatialAdaptiveQuantization>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265Telecine>(x),
      "TemporalAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265TemporalAdaptiveQuantization>(x),
      "TemporalIds": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265TemporalIds>(x),
      "Tiles": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265Tiles>(x),
      "UnregisteredSeiTimecode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265UnregisteredSeiTimecode>(x),
      "WriteMp4PackagingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265WriteMp4PackagingType>(x),
    },
  }, root);
}

function fromH265QvbrSettings(input?: s.H265QvbrSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxAverageBitrate: input["MaxAverageBitrate"],
    qvbrQualityLevel: input["QvbrQualityLevel"],
    qvbrQualityLevelFineTune: input["QvbrQualityLevelFineTune"],
  }
}
function toH265QvbrSettings(root: jsonP.JSONValue): s.H265QvbrSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxAverageBitrate": "n",
      "QvbrQualityLevel": "n",
      "QvbrQualityLevelFineTune": "n",
    },
  }, root);
}

function fromMpeg2Settings(input?: s.Mpeg2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    bitrate: input["Bitrate"],
    codecLevel: input["CodecLevel"],
    codecProfile: input["CodecProfile"],
    dynamicSubGop: input["DynamicSubGop"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopClosedCadence: input["GopClosedCadence"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    hrdBufferInitialFillPercentage: input["HrdBufferInitialFillPercentage"],
    hrdBufferSize: input["HrdBufferSize"],
    interlaceMode: input["InterlaceMode"],
    intraDcPrecision: input["IntraDcPrecision"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    numberBFramesBetweenReferenceFrames: input["NumberBFramesBetweenReferenceFrames"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    rateControlMode: input["RateControlMode"],
    scanTypeConversionMode: input["ScanTypeConversionMode"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slowPal: input["SlowPal"],
    softness: input["Softness"],
    spatialAdaptiveQuantization: input["SpatialAdaptiveQuantization"],
    syntax: input["Syntax"],
    telecine: input["Telecine"],
    temporalAdaptiveQuantization: input["TemporalAdaptiveQuantization"],
  }
}
function toMpeg2Settings(root: jsonP.JSONValue): s.Mpeg2Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2AdaptiveQuantization>(x),
      "Bitrate": "n",
      "CodecLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2CodecLevel>(x),
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2CodecProfile>(x),
      "DynamicSubGop": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2DynamicSubGop>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopClosedCadence": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2GopSizeUnits>(x),
      "HrdBufferInitialFillPercentage": "n",
      "HrdBufferSize": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2InterlaceMode>(x),
      "IntraDcPrecision": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2IntraDcPrecision>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "NumberBFramesBetweenReferenceFrames": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2QualityTuningLevel>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2RateControlMode>(x),
      "ScanTypeConversionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2ScanTypeConversionMode>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2SceneChangeDetect>(x),
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2SlowPal>(x),
      "Softness": "n",
      "SpatialAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2SpatialAdaptiveQuantization>(x),
      "Syntax": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2Syntax>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2Telecine>(x),
      "TemporalAdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2TemporalAdaptiveQuantization>(x),
    },
  }, root);
}

function fromProresSettings(input?: s.ProresSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    codecProfile: input["CodecProfile"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    interlaceMode: input["InterlaceMode"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    scanTypeConversionMode: input["ScanTypeConversionMode"],
    slowPal: input["SlowPal"],
    telecine: input["Telecine"],
  }
}
function toProresSettings(root: jsonP.JSONValue): s.ProresSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CodecProfile": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProresCodecProfile>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProresFramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProresFramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProresInterlaceMode>(x),
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProresParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "ScanTypeConversionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProresScanTypeConversionMode>(x),
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProresSlowPal>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProresTelecine>(x),
    },
  }, root);
}

function fromVc3Settings(input?: s.Vc3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    interlaceMode: input["InterlaceMode"],
    scanTypeConversionMode: input["ScanTypeConversionMode"],
    slowPal: input["SlowPal"],
    telecine: input["Telecine"],
    vc3Class: input["Vc3Class"],
  }
}
function toVc3Settings(root: jsonP.JSONValue): s.Vc3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vc3FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vc3FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "InterlaceMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vc3InterlaceMode>(x),
      "ScanTypeConversionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vc3ScanTypeConversionMode>(x),
      "SlowPal": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vc3SlowPal>(x),
      "Telecine": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vc3Telecine>(x),
      "Vc3Class": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vc3Class>(x),
    },
  }, root);
}

function fromVp8Settings(input?: s.Vp8Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopSize: input["GopSize"],
    hrdBufferSize: input["HrdBufferSize"],
    maxBitrate: input["MaxBitrate"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    rateControlMode: input["RateControlMode"],
  }
}
function toVp8Settings(root: jsonP.JSONValue): s.Vp8Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp8FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp8FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopSize": "n",
      "HrdBufferSize": "n",
      "MaxBitrate": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp8ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp8QualityTuningLevel>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp8RateControlMode>(x),
    },
  }, root);
}

function fromVp9Settings(input?: s.Vp9Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    framerateControl: input["FramerateControl"],
    framerateConversionAlgorithm: input["FramerateConversionAlgorithm"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopSize: input["GopSize"],
    hrdBufferSize: input["HrdBufferSize"],
    maxBitrate: input["MaxBitrate"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    qualityTuningLevel: input["QualityTuningLevel"],
    rateControlMode: input["RateControlMode"],
  }
}
function toVp9Settings(root: jsonP.JSONValue): s.Vp9Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp9FramerateControl>(x),
      "FramerateConversionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp9FramerateConversionAlgorithm>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopSize": "n",
      "HrdBufferSize": "n",
      "MaxBitrate": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp9ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "QualityTuningLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp9QualityTuningLevel>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Vp9RateControlMode>(x),
    },
  }, root);
}

function fromVideoPreprocessor(input?: s.VideoPreprocessor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    colorCorrector: fromColorCorrector(input["ColorCorrector"]),
    deinterlacer: fromDeinterlacer(input["Deinterlacer"]),
    dolbyVision: fromDolbyVision(input["DolbyVision"]),
    imageInserter: fromImageInserter(input["ImageInserter"]),
    noiseReducer: fromNoiseReducer(input["NoiseReducer"]),
    partnerWatermarking: fromPartnerWatermarking(input["PartnerWatermarking"]),
    timecodeBurnin: fromTimecodeBurnin(input["TimecodeBurnin"]),
  }
}
function toVideoPreprocessor(root: jsonP.JSONValue): s.VideoPreprocessor {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColorCorrector": toColorCorrector,
      "Deinterlacer": toDeinterlacer,
      "DolbyVision": toDolbyVision,
      "ImageInserter": toImageInserter,
      "NoiseReducer": toNoiseReducer,
      "PartnerWatermarking": toPartnerWatermarking,
      "TimecodeBurnin": toTimecodeBurnin,
    },
  }, root);
}

function fromColorCorrector(input?: s.ColorCorrector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    brightness: input["Brightness"],
    colorSpaceConversion: input["ColorSpaceConversion"],
    contrast: input["Contrast"],
    hdr10Metadata: fromHdr10Metadata(input["Hdr10Metadata"]),
    hue: input["Hue"],
    saturation: input["Saturation"],
  }
}
function toColorCorrector(root: jsonP.JSONValue): s.ColorCorrector {
  return jsonP.readObj({
    required: {},
    optional: {
      "Brightness": "n",
      "ColorSpaceConversion": (x: jsonP.JSONValue) => cmnP.readEnum<s.ColorSpaceConversion>(x),
      "Contrast": "n",
      "Hdr10Metadata": toHdr10Metadata,
      "Hue": "n",
      "Saturation": "n",
    },
  }, root);
}

function fromDeinterlacer(input?: s.Deinterlacer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    algorithm: input["Algorithm"],
    control: input["Control"],
    mode: input["Mode"],
  }
}
function toDeinterlacer(root: jsonP.JSONValue): s.Deinterlacer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Algorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeinterlaceAlgorithm>(x),
      "Control": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeinterlacerControl>(x),
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeinterlacerMode>(x),
    },
  }, root);
}

function fromDolbyVision(input?: s.DolbyVision | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    l6Metadata: fromDolbyVisionLevel6Metadata(input["L6Metadata"]),
    l6Mode: input["L6Mode"],
    profile: input["Profile"],
  }
}
function toDolbyVision(root: jsonP.JSONValue): s.DolbyVision {
  return jsonP.readObj({
    required: {},
    optional: {
      "L6Metadata": toDolbyVisionLevel6Metadata,
      "L6Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DolbyVisionLevel6Mode>(x),
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<s.DolbyVisionProfile>(x),
    },
  }, root);
}

function fromDolbyVisionLevel6Metadata(input?: s.DolbyVisionLevel6Metadata | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxCll: input["MaxCll"],
    maxFall: input["MaxFall"],
  }
}
function toDolbyVisionLevel6Metadata(root: jsonP.JSONValue): s.DolbyVisionLevel6Metadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxCll": "n",
      "MaxFall": "n",
    },
  }, root);
}

function fromNoiseReducer(input?: s.NoiseReducer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filter: input["Filter"],
    filterSettings: fromNoiseReducerFilterSettings(input["FilterSettings"]),
    spatialFilterSettings: fromNoiseReducerSpatialFilterSettings(input["SpatialFilterSettings"]),
    temporalFilterSettings: fromNoiseReducerTemporalFilterSettings(input["TemporalFilterSettings"]),
  }
}
function toNoiseReducer(root: jsonP.JSONValue): s.NoiseReducer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Filter": (x: jsonP.JSONValue) => cmnP.readEnum<s.NoiseReducerFilter>(x),
      "FilterSettings": toNoiseReducerFilterSettings,
      "SpatialFilterSettings": toNoiseReducerSpatialFilterSettings,
      "TemporalFilterSettings": toNoiseReducerTemporalFilterSettings,
    },
  }, root);
}

function fromNoiseReducerFilterSettings(input?: s.NoiseReducerFilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    strength: input["Strength"],
  }
}
function toNoiseReducerFilterSettings(root: jsonP.JSONValue): s.NoiseReducerFilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Strength": "n",
    },
  }, root);
}

function fromNoiseReducerSpatialFilterSettings(input?: s.NoiseReducerSpatialFilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    postFilterSharpenStrength: input["PostFilterSharpenStrength"],
    speed: input["Speed"],
    strength: input["Strength"],
  }
}
function toNoiseReducerSpatialFilterSettings(root: jsonP.JSONValue): s.NoiseReducerSpatialFilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PostFilterSharpenStrength": "n",
      "Speed": "n",
      "Strength": "n",
    },
  }, root);
}

function fromNoiseReducerTemporalFilterSettings(input?: s.NoiseReducerTemporalFilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    aggressiveMode: input["AggressiveMode"],
    postTemporalSharpening: input["PostTemporalSharpening"],
    speed: input["Speed"],
    strength: input["Strength"],
  }
}
function toNoiseReducerTemporalFilterSettings(root: jsonP.JSONValue): s.NoiseReducerTemporalFilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AggressiveMode": "n",
      "PostTemporalSharpening": (x: jsonP.JSONValue) => cmnP.readEnum<s.NoiseFilterPostTemporalSharpening>(x),
      "Speed": "n",
      "Strength": "n",
    },
  }, root);
}

function fromPartnerWatermarking(input?: s.PartnerWatermarking | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    nexguardFileMarkerSettings: fromNexGuardFileMarkerSettings(input["NexguardFileMarkerSettings"]),
  }
}
function toPartnerWatermarking(root: jsonP.JSONValue): s.PartnerWatermarking {
  return jsonP.readObj({
    required: {},
    optional: {
      "NexguardFileMarkerSettings": toNexGuardFileMarkerSettings,
    },
  }, root);
}

function fromNexGuardFileMarkerSettings(input?: s.NexGuardFileMarkerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    license: input["License"],
    payload: input["Payload"],
    preset: input["Preset"],
    strength: input["Strength"],
  }
}
function toNexGuardFileMarkerSettings(root: jsonP.JSONValue): s.NexGuardFileMarkerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "License": "s",
      "Payload": "n",
      "Preset": "s",
      "Strength": (x: jsonP.JSONValue) => cmnP.readEnum<s.WatermarkingStrength>(x),
    },
  }, root);
}

function fromTimecodeBurnin(input?: s.TimecodeBurnin | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fontSize: input["FontSize"],
    position: input["Position"],
    prefix: input["Prefix"],
  }
}
function toTimecodeBurnin(root: jsonP.JSONValue): s.TimecodeBurnin {
  return jsonP.readObj({
    required: {},
    optional: {
      "FontSize": "n",
      "Position": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimecodeBurninPosition>(x),
      "Prefix": "s",
    },
  }, root);
}

function fromTimecodeConfig(input?: s.TimecodeConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    anchor: input["Anchor"],
    source: input["Source"],
    start: input["Start"],
    timestampOffset: input["TimestampOffset"],
  }
}
function toTimecodeConfig(root: jsonP.JSONValue): s.TimecodeConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "Anchor": "s",
      "Source": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimecodeSource>(x),
      "Start": "s",
      "TimestampOffset": "s",
    },
  }, root);
}

function fromTimedMetadataInsertion(input?: s.TimedMetadataInsertion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id3Insertions: input["Id3Insertions"]?.map(x => fromId3Insertion(x)),
  }
}
function toTimedMetadataInsertion(root: jsonP.JSONValue): s.TimedMetadataInsertion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id3Insertions": [toId3Insertion],
    },
  }, root);
}

function fromId3Insertion(input?: s.Id3Insertion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id3: input["Id3"],
    timecode: input["Timecode"],
  }
}
function toId3Insertion(root: jsonP.JSONValue): s.Id3Insertion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id3": "s",
      "Timecode": "s",
    },
  }, root);
}

function fromJobTemplateSettings(input?: s.JobTemplateSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adAvailOffset: input["AdAvailOffset"],
    availBlanking: fromAvailBlanking(input["AvailBlanking"]),
    esam: fromEsamSettings(input["Esam"]),
    inputs: input["Inputs"]?.map(x => fromInputTemplate(x)),
    motionImageInserter: fromMotionImageInserter(input["MotionImageInserter"]),
    nielsenConfiguration: fromNielsenConfiguration(input["NielsenConfiguration"]),
    nielsenNonLinearWatermark: fromNielsenNonLinearWatermarkSettings(input["NielsenNonLinearWatermark"]),
    outputGroups: input["OutputGroups"]?.map(x => fromOutputGroup(x)),
    timecodeConfig: fromTimecodeConfig(input["TimecodeConfig"]),
    timedMetadataInsertion: fromTimedMetadataInsertion(input["TimedMetadataInsertion"]),
  }
}
function toJobTemplateSettings(root: jsonP.JSONValue): s.JobTemplateSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdAvailOffset": "n",
      "AvailBlanking": toAvailBlanking,
      "Esam": toEsamSettings,
      "Inputs": [toInputTemplate],
      "MotionImageInserter": toMotionImageInserter,
      "NielsenConfiguration": toNielsenConfiguration,
      "NielsenNonLinearWatermark": toNielsenNonLinearWatermarkSettings,
      "OutputGroups": [toOutputGroup],
      "TimecodeConfig": toTimecodeConfig,
      "TimedMetadataInsertion": toTimedMetadataInsertion,
    },
  }, root);
}

function fromInputTemplate(input?: s.InputTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectorGroups: jsonP.serializeMap(input["AudioSelectorGroups"], x => fromAudioSelectorGroup(x)),
    audioSelectors: jsonP.serializeMap(input["AudioSelectors"], x => fromAudioSelector(x)),
    captionSelectors: jsonP.serializeMap(input["CaptionSelectors"], x => fromCaptionSelector(x)),
    crop: fromRectangle(input["Crop"]),
    deblockFilter: input["DeblockFilter"],
    denoiseFilter: input["DenoiseFilter"],
    filterEnable: input["FilterEnable"],
    filterStrength: input["FilterStrength"],
    imageInserter: fromImageInserter(input["ImageInserter"]),
    inputClippings: input["InputClippings"]?.map(x => fromInputClipping(x)),
    inputScanType: input["InputScanType"],
    position: fromRectangle(input["Position"]),
    programNumber: input["ProgramNumber"],
    psiControl: input["PsiControl"],
    timecodeSource: input["TimecodeSource"],
    timecodeStart: input["TimecodeStart"],
    videoSelector: fromVideoSelector(input["VideoSelector"]),
  }
}
function toInputTemplate(root: jsonP.JSONValue): s.InputTemplate {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSelectorGroups": x => jsonP.readMap(String, toAudioSelectorGroup, x),
      "AudioSelectors": x => jsonP.readMap(String, toAudioSelector, x),
      "CaptionSelectors": x => jsonP.readMap(String, toCaptionSelector, x),
      "Crop": toRectangle,
      "DeblockFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeblockFilter>(x),
      "DenoiseFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDenoiseFilter>(x),
      "FilterEnable": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputFilterEnable>(x),
      "FilterStrength": "n",
      "ImageInserter": toImageInserter,
      "InputClippings": [toInputClipping],
      "InputScanType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputScanType>(x),
      "Position": toRectangle,
      "ProgramNumber": "n",
      "PsiControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputPsiControl>(x),
      "TimecodeSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputTimecodeSource>(x),
      "TimecodeStart": "s",
      "VideoSelector": toVideoSelector,
    },
  }, root);
}

function fromPresetSettings(input?: s.PresetSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptions: input["AudioDescriptions"]?.map(x => fromAudioDescription(x)),
    captionDescriptions: input["CaptionDescriptions"]?.map(x => fromCaptionDescriptionPreset(x)),
    containerSettings: fromContainerSettings(input["ContainerSettings"]),
    videoDescription: fromVideoDescription(input["VideoDescription"]),
  }
}
function toPresetSettings(root: jsonP.JSONValue): s.PresetSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioDescriptions": [toAudioDescription],
      "CaptionDescriptions": [toCaptionDescriptionPreset],
      "ContainerSettings": toContainerSettings,
      "VideoDescription": toVideoDescription,
    },
  }, root);
}

function fromCaptionDescriptionPreset(input?: s.CaptionDescriptionPreset | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    customLanguageCode: input["CustomLanguageCode"],
    destinationSettings: fromCaptionDestinationSettings(input["DestinationSettings"]),
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
  }
}
function toCaptionDescriptionPreset(root: jsonP.JSONValue): s.CaptionDescriptionPreset {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomLanguageCode": "s",
      "DestinationSettings": toCaptionDestinationSettings,
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "LanguageDescription": "s",
    },
  }, root);
}

function fromReservationPlanSettings(input?: s.ReservationPlanSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    commitment: input["Commitment"],
    renewalType: input["RenewalType"],
    reservedSlots: input["ReservedSlots"],
  }
}

function toJob(root: jsonP.JSONValue): s.Job {
  return jsonP.readObj({
    required: {
      "Role": "s",
      "Settings": toJobSettings,
    },
    optional: {
      "AccelerationSettings": toAccelerationSettings,
      "AccelerationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccelerationStatus>(x),
      "Arn": "s",
      "BillingTagsSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.BillingTagsSource>(x),
      "CreatedAt": "d",
      "CurrentPhase": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobPhase>(x),
      "ErrorCode": "n",
      "ErrorMessage": "s",
      "HopDestinations": [toHopDestination],
      "Id": "s",
      "JobPercentComplete": "n",
      "JobTemplate": "s",
      "Messages": toJobMessages,
      "OutputGroupDetails": [toOutputGroupDetail],
      "Priority": "n",
      "Queue": "s",
      "QueueTransitions": [toQueueTransition],
      "RetryCount": "n",
      "SimulateReservedQueue": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulateReservedQueue>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "StatusUpdateInterval": (x: jsonP.JSONValue) => cmnP.readEnum<s.StatusUpdateInterval>(x),
      "Timing": toTiming,
      "UserMetadata": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toJobMessages(root: jsonP.JSONValue): s.JobMessages {
  return jsonP.readObj({
    required: {},
    optional: {
      "Info": ["s"],
      "Warning": ["s"],
    },
  }, root);
}

function toOutputGroupDetail(root: jsonP.JSONValue): s.OutputGroupDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputDetails": [toOutputDetail],
    },
  }, root);
}

function toOutputDetail(root: jsonP.JSONValue): s.OutputDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInMs": "n",
      "VideoDetails": toVideoDetail,
    },
  }, root);
}

function toVideoDetail(root: jsonP.JSONValue): s.VideoDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "HeightInPx": "n",
      "WidthInPx": "n",
    },
  }, root);
}

function toQueueTransition(root: jsonP.JSONValue): s.QueueTransition {
  return jsonP.readObj({
    required: {},
    optional: {
      "DestinationQueue": "s",
      "SourceQueue": "s",
      "Timestamp": "d",
    },
  }, root);
}

function toTiming(root: jsonP.JSONValue): s.Timing {
  return jsonP.readObj({
    required: {},
    optional: {
      "FinishTime": "d",
      "StartTime": "d",
      "SubmitTime": "d",
    },
  }, root);
}

function toJobTemplate(root: jsonP.JSONValue): s.JobTemplate {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Settings": toJobTemplateSettings,
    },
    optional: {
      "AccelerationSettings": toAccelerationSettings,
      "Arn": "s",
      "Category": "s",
      "CreatedAt": "d",
      "Description": "s",
      "HopDestinations": [toHopDestination],
      "LastUpdated": "d",
      "Priority": "n",
      "Queue": "s",
      "StatusUpdateInterval": (x: jsonP.JSONValue) => cmnP.readEnum<s.StatusUpdateInterval>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.Type>(x),
    },
  }, root);
}

function toPreset(root: jsonP.JSONValue): s.Preset {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Settings": toPresetSettings,
    },
    optional: {
      "Arn": "s",
      "Category": "s",
      "CreatedAt": "d",
      "Description": "s",
      "LastUpdated": "d",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.Type>(x),
    },
  }, root);
}

function toQueue(root: jsonP.JSONValue): s.Queue {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Arn": "s",
      "CreatedAt": "d",
      "Description": "s",
      "LastUpdated": "d",
      "PricingPlan": (x: jsonP.JSONValue) => cmnP.readEnum<s.PricingPlan>(x),
      "ProgressingJobsCount": "n",
      "ReservationPlan": toReservationPlan,
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.QueueStatus>(x),
      "SubmittedJobsCount": "n",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.Type>(x),
    },
  }, root);
}

function toReservationPlan(root: jsonP.JSONValue): s.ReservationPlan {
  return jsonP.readObj({
    required: {},
    optional: {
      "Commitment": (x: jsonP.JSONValue) => cmnP.readEnum<s.Commitment>(x),
      "ExpiresAt": "d",
      "PurchasedAt": "d",
      "RenewalType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RenewalType>(x),
      "ReservedSlots": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationPlanStatus>(x),
    },
  }, root);
}

function toEndpoint(root: jsonP.JSONValue): s.Endpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "Url": "s",
    },
  }, root);
}

function toResourceTags(root: jsonP.JSONValue): s.ResourceTags {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
