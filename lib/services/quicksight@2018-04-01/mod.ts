// Autogenerated API client for: Amazon QuickSight

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class QuickSight {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(QuickSight.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-04-01",
    "endpointPrefix": "quicksight",
    "jsonVersion": "1.0",
    "protocol": "rest-json",
    "serviceFullName": "Amazon QuickSight",
    "serviceId": "QuickSight",
    "signatureVersion": "v4",
    "uid": "quicksight-2018-04-01"
  };

  async cancelIngestion(
    {abortSignal, ...params}: RequestConfig & s.CancelIngestionRequest,
  ): Promise<s.CancelIngestionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelIngestion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets/${params["DataSetId"]}/ingestions/${params["IngestionId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "IngestionId": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createAccountCustomization(
    {abortSignal, ...params}: RequestConfig & s.CreateAccountCustomizationRequest,
  ): Promise<s.CreateAccountCustomizationResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      AccountCustomization: fromAccountCustomization(params["AccountCustomization"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    if (params["Namespace"] != null) query.set("namespace", params["Namespace"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateAccountCustomization",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/customizations`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "AwsAccountId": "s",
          "Namespace": "s",
          "AccountCustomization": toAccountCustomization,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createAnalysis(
    {abortSignal, ...params}: RequestConfig & s.CreateAnalysisRequest,
  ): Promise<s.CreateAnalysisResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Parameters: fromParameters(params["Parameters"]),
      Permissions: params["Permissions"]?.map(x => fromResourcePermission(x)),
      SourceEntity: fromAnalysisSourceEntity(params["SourceEntity"]),
      ThemeArn: params["ThemeArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAnalysis",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/analyses/${params["AnalysisId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "AnalysisId": "s",
          "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createDashboard(
    {abortSignal, ...params}: RequestConfig & s.CreateDashboardRequest,
  ): Promise<s.CreateDashboardResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Parameters: fromParameters(params["Parameters"]),
      Permissions: params["Permissions"]?.map(x => fromResourcePermission(x)),
      SourceEntity: fromDashboardSourceEntity(params["SourceEntity"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
      VersionDescription: params["VersionDescription"],
      DashboardPublishOptions: fromDashboardPublishOptions(params["DashboardPublishOptions"]),
      ThemeArn: params["ThemeArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDashboard",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards/${params["DashboardId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "VersionArn": "s",
          "DashboardId": "s",
          "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createDataSet(
    {abortSignal, ...params}: RequestConfig & s.CreateDataSetRequest,
  ): Promise<s.CreateDataSetResponse> {
    const body: jsonP.JSONObject = {
      DataSetId: params["DataSetId"],
      Name: params["Name"],
      PhysicalTableMap: jsonP.serializeMap(params["PhysicalTableMap"], x => fromPhysicalTable(x)),
      LogicalTableMap: jsonP.serializeMap(params["LogicalTableMap"], x => fromLogicalTable(x)),
      ImportMode: params["ImportMode"],
      ColumnGroups: params["ColumnGroups"]?.map(x => fromColumnGroup(x)),
      FieldFolders: jsonP.serializeMap(params["FieldFolders"], x => fromFieldFolder(x)),
      Permissions: params["Permissions"]?.map(x => fromResourcePermission(x)),
      RowLevelPermissionDataSet: fromRowLevelPermissionDataSet(params["RowLevelPermissionDataSet"]),
      ColumnLevelPermissionRules: params["ColumnLevelPermissionRules"]?.map(x => fromColumnLevelPermissionRule(x)),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataSet",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "DataSetId": "s",
          "IngestionArn": "s",
          "IngestionId": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createDataSource(
    {abortSignal, ...params}: RequestConfig & s.CreateDataSourceRequest,
  ): Promise<s.CreateDataSourceResponse> {
    const body: jsonP.JSONObject = {
      DataSourceId: params["DataSourceId"],
      Name: params["Name"],
      Type: params["Type"],
      DataSourceParameters: fromDataSourceParameters(params["DataSourceParameters"]),
      Credentials: fromDataSourceCredentials(params["Credentials"]),
      Permissions: params["Permissions"]?.map(x => fromResourcePermission(x)),
      VpcConnectionProperties: fromVpcConnectionProperties(params["VpcConnectionProperties"]),
      SslProperties: fromSslProperties(params["SslProperties"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataSource",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sources`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "DataSourceId": "s",
          "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateGroupRequest,
  ): Promise<s.CreateGroupResponse> {
    const body: jsonP.JSONObject = {
      GroupName: params["GroupName"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGroup",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/groups`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Group": toGroup,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createGroupMembership(
    {abortSignal, ...params}: RequestConfig & s.CreateGroupMembershipRequest,
  ): Promise<s.CreateGroupMembershipResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CreateGroupMembership",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/groups/${params["GroupName"]}/members/${params["MemberName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "GroupMember": toGroupMember,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createIAMPolicyAssignment(
    {abortSignal, ...params}: RequestConfig & s.CreateIAMPolicyAssignmentRequest,
  ): Promise<s.CreateIAMPolicyAssignmentResponse> {
    const body: jsonP.JSONObject = {
      AssignmentName: params["AssignmentName"],
      AssignmentStatus: params["AssignmentStatus"],
      PolicyArn: params["PolicyArn"],
      Identities: params["Identities"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateIAMPolicyAssignment",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/iam-policy-assignments/`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "AssignmentName": "s",
          "AssignmentId": "s",
          "AssignmentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssignmentStatus>(x),
          "PolicyArn": "s",
          "Identities": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createIngestion(
    {abortSignal, ...params}: RequestConfig & s.CreateIngestionRequest,
  ): Promise<s.CreateIngestionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CreateIngestion",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets/${params["DataSetId"]}/ingestions/${params["IngestionId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "IngestionId": "s",
          "IngestionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.IngestionStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createNamespace(
    {abortSignal, ...params}: RequestConfig & s.CreateNamespaceRequest,
  ): Promise<s.CreateNamespaceResponse> {
    const body: jsonP.JSONObject = {
      Namespace: params["Namespace"],
      IdentityStore: params["IdentityStore"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNamespace",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "Name": "s",
          "CapacityRegion": "s",
          "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.NamespaceStatus>(x),
          "IdentityStore": (x: jsonP.JSONValue) => cmnP.readEnum<s.IdentityStore>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateTemplateRequest,
  ): Promise<s.CreateTemplateResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Permissions: params["Permissions"]?.map(x => fromResourcePermission(x)),
      SourceEntity: fromTemplateSourceEntity(params["SourceEntity"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
      VersionDescription: params["VersionDescription"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTemplate",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "VersionArn": "s",
          "TemplateId": "s",
          "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createTemplateAlias(
    {abortSignal, ...params}: RequestConfig & s.CreateTemplateAliasRequest,
  ): Promise<s.CreateTemplateAliasResponse> {
    const body: jsonP.JSONObject = {
      TemplateVersionNumber: params["TemplateVersionNumber"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTemplateAlias",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}/aliases/${params["AliasName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateAlias": toTemplateAlias,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createTheme(
    {abortSignal, ...params}: RequestConfig & s.CreateThemeRequest,
  ): Promise<s.CreateThemeResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      BaseThemeId: params["BaseThemeId"],
      VersionDescription: params["VersionDescription"],
      Configuration: fromThemeConfiguration(params["Configuration"]),
      Permissions: params["Permissions"]?.map(x => fromResourcePermission(x)),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTheme",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "VersionArn": "s",
          "ThemeId": "s",
          "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async createThemeAlias(
    {abortSignal, ...params}: RequestConfig & s.CreateThemeAliasRequest,
  ): Promise<s.CreateThemeAliasResponse> {
    const body: jsonP.JSONObject = {
      ThemeVersionNumber: params["ThemeVersionNumber"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateThemeAlias",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}/aliases/${params["AliasName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ThemeAlias": toThemeAlias,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteAccountCustomization(
    {abortSignal, ...params}: RequestConfig & s.DeleteAccountCustomizationRequest,
  ): Promise<s.DeleteAccountCustomizationResponse> {
    const query = new URLSearchParams;
    if (params["Namespace"] != null) query.set("namespace", params["Namespace"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteAccountCustomization",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/customizations`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteAnalysis(
    {abortSignal, ...params}: RequestConfig & s.DeleteAnalysisRequest,
  ): Promise<s.DeleteAnalysisResponse> {
    const query = new URLSearchParams;
    if (params["RecoveryWindowInDays"] != null) query.set("recovery-window-in-days", params["RecoveryWindowInDays"]?.toString() ?? "");
    if (params["ForceDeleteWithoutRecovery"] != null) query.set("force-delete-without-recovery", params["ForceDeleteWithoutRecovery"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteAnalysis",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/analyses/${params["AnalysisId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "AnalysisId": "s",
          "DeletionTime": "d",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteDashboard(
    {abortSignal, ...params}: RequestConfig & s.DeleteDashboardRequest,
  ): Promise<s.DeleteDashboardResponse> {
    const query = new URLSearchParams;
    if (params["VersionNumber"] != null) query.set("version-number", params["VersionNumber"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteDashboard",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards/${params["DashboardId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "DashboardId": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteDataSet(
    {abortSignal, ...params}: RequestConfig & s.DeleteDataSetRequest,
  ): Promise<s.DeleteDataSetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDataSet",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets/${params["DataSetId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "DataSetId": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteDataSource(
    {abortSignal, ...params}: RequestConfig & s.DeleteDataSourceRequest,
  ): Promise<s.DeleteDataSourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDataSource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sources/${params["DataSourceId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "DataSourceId": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteGroupRequest,
  ): Promise<s.DeleteGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteGroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/groups/${params["GroupName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteGroupMembership(
    {abortSignal, ...params}: RequestConfig & s.DeleteGroupMembershipRequest,
  ): Promise<s.DeleteGroupMembershipResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteGroupMembership",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/groups/${params["GroupName"]}/members/${params["MemberName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteIAMPolicyAssignment(
    {abortSignal, ...params}: RequestConfig & s.DeleteIAMPolicyAssignmentRequest,
  ): Promise<s.DeleteIAMPolicyAssignmentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIAMPolicyAssignment",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespace/${params["Namespace"]}/iam-policy-assignments/${params["AssignmentName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "AssignmentName": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteNamespace(
    {abortSignal, ...params}: RequestConfig & s.DeleteNamespaceRequest,
  ): Promise<s.DeleteNamespaceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteNamespace",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteTemplateRequest,
  ): Promise<s.DeleteTemplateResponse> {
    const query = new URLSearchParams;
    if (params["VersionNumber"] != null) query.set("version-number", params["VersionNumber"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteTemplate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
          "Arn": "s",
          "TemplateId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteTemplateAlias(
    {abortSignal, ...params}: RequestConfig & s.DeleteTemplateAliasRequest,
  ): Promise<s.DeleteTemplateAliasResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteTemplateAlias",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}/aliases/${params["AliasName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateId": "s",
          "AliasName": "s",
          "Arn": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteTheme(
    {abortSignal, ...params}: RequestConfig & s.DeleteThemeRequest,
  ): Promise<s.DeleteThemeResponse> {
    const query = new URLSearchParams;
    if (params["VersionNumber"] != null) query.set("version-number", params["VersionNumber"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteTheme",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "RequestId": "s",
          "ThemeId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteThemeAlias(
    {abortSignal, ...params}: RequestConfig & s.DeleteThemeAliasRequest,
  ): Promise<s.DeleteThemeAliasResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteThemeAlias",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}/aliases/${params["AliasName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "AliasName": "s",
          "Arn": "s",
          "RequestId": "s",
          "ThemeId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteUser(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserRequest,
  ): Promise<s.DeleteUserResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteUser",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/users/${params["UserName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async deleteUserByPrincipalId(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserByPrincipalIdRequest,
  ): Promise<s.DeleteUserByPrincipalIdResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteUserByPrincipalId",
      method: "DELETE",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/user-principals/${params["PrincipalId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeAccountCustomization(
    {abortSignal, ...params}: RequestConfig & s.DescribeAccountCustomizationRequest,
  ): Promise<s.DescribeAccountCustomizationResponse> {
    const query = new URLSearchParams;
    if (params["Namespace"] != null) query.set("namespace", params["Namespace"]?.toString() ?? "");
    if (params["Resolved"] != null) query.set("resolved", params["Resolved"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeAccountCustomization",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/customizations`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "AwsAccountId": "s",
          "Namespace": "s",
          "AccountCustomization": toAccountCustomization,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeAccountSettings(
    {abortSignal, ...params}: RequestConfig & s.DescribeAccountSettingsRequest,
  ): Promise<s.DescribeAccountSettingsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAccountSettings",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/settings`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "AccountSettings": toAccountSettings,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeAnalysis(
    {abortSignal, ...params}: RequestConfig & s.DescribeAnalysisRequest,
  ): Promise<s.DescribeAnalysisResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAnalysis",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/analyses/${params["AnalysisId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Analysis": toAnalysis,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeAnalysisPermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeAnalysisPermissionsRequest,
  ): Promise<s.DescribeAnalysisPermissionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAnalysisPermissions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/analyses/${params["AnalysisId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "AnalysisId": "s",
          "AnalysisArn": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeDashboard(
    {abortSignal, ...params}: RequestConfig & s.DescribeDashboardRequest,
  ): Promise<s.DescribeDashboardResponse> {
    const query = new URLSearchParams;
    if (params["VersionNumber"] != null) query.set("version-number", params["VersionNumber"]?.toString() ?? "");
    if (params["AliasName"] != null) query.set("alias-name", params["AliasName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeDashboard",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards/${params["DashboardId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Dashboard": toDashboard,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeDashboardPermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeDashboardPermissionsRequest,
  ): Promise<s.DescribeDashboardPermissionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDashboardPermissions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards/${params["DashboardId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DashboardId": "s",
          "DashboardArn": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeDataSet(
    {abortSignal, ...params}: RequestConfig & s.DescribeDataSetRequest,
  ): Promise<s.DescribeDataSetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDataSet",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets/${params["DataSetId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DataSet": toDataSet,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeDataSetPermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeDataSetPermissionsRequest,
  ): Promise<s.DescribeDataSetPermissionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDataSetPermissions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets/${params["DataSetId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DataSetArn": "s",
          "DataSetId": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeDataSource(
    {abortSignal, ...params}: RequestConfig & s.DescribeDataSourceRequest,
  ): Promise<s.DescribeDataSourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDataSource",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sources/${params["DataSourceId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DataSource": toDataSource,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeDataSourcePermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeDataSourcePermissionsRequest,
  ): Promise<s.DescribeDataSourcePermissionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDataSourcePermissions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sources/${params["DataSourceId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DataSourceArn": "s",
          "DataSourceId": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeGroupRequest,
  ): Promise<s.DescribeGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeGroup",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/groups/${params["GroupName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Group": toGroup,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeIAMPolicyAssignment(
    {abortSignal, ...params}: RequestConfig & s.DescribeIAMPolicyAssignmentRequest,
  ): Promise<s.DescribeIAMPolicyAssignmentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeIAMPolicyAssignment",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/iam-policy-assignments/${params["AssignmentName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "IAMPolicyAssignment": toIAMPolicyAssignment,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeIngestion(
    {abortSignal, ...params}: RequestConfig & s.DescribeIngestionRequest,
  ): Promise<s.DescribeIngestionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeIngestion",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets/${params["DataSetId"]}/ingestions/${params["IngestionId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Ingestion": toIngestion,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeNamespace(
    {abortSignal, ...params}: RequestConfig & s.DescribeNamespaceRequest,
  ): Promise<s.DescribeNamespaceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeNamespace",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Namespace": toNamespaceInfoV2,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeTemplate(
    {abortSignal, ...params}: RequestConfig & s.DescribeTemplateRequest,
  ): Promise<s.DescribeTemplateResponse> {
    const query = new URLSearchParams;
    if (params["VersionNumber"] != null) query.set("version-number", params["VersionNumber"]?.toString() ?? "");
    if (params["AliasName"] != null) query.set("alias-name", params["AliasName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Template": toTemplate,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeTemplateAlias(
    {abortSignal, ...params}: RequestConfig & s.DescribeTemplateAliasRequest,
  ): Promise<s.DescribeTemplateAliasResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeTemplateAlias",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}/aliases/${params["AliasName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateAlias": toTemplateAlias,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeTemplatePermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeTemplatePermissionsRequest,
  ): Promise<s.DescribeTemplatePermissionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeTemplatePermissions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateId": "s",
          "TemplateArn": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeTheme(
    {abortSignal, ...params}: RequestConfig & s.DescribeThemeRequest,
  ): Promise<s.DescribeThemeResponse> {
    const query = new URLSearchParams;
    if (params["VersionNumber"] != null) query.set("version-number", params["VersionNumber"]?.toString() ?? "");
    if (params["AliasName"] != null) query.set("alias-name", params["AliasName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeTheme",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Theme": toTheme,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeThemeAlias(
    {abortSignal, ...params}: RequestConfig & s.DescribeThemeAliasRequest,
  ): Promise<s.DescribeThemeAliasResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeThemeAlias",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}/aliases/${params["AliasName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ThemeAlias": toThemeAlias,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeThemePermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeThemePermissionsRequest,
  ): Promise<s.DescribeThemePermissionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeThemePermissions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ThemeId": "s",
          "ThemeArn": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async describeUser(
    {abortSignal, ...params}: RequestConfig & s.DescribeUserRequest,
  ): Promise<s.DescribeUserResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeUser",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/users/${params["UserName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "User": toUser,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async getDashboardEmbedUrl(
    {abortSignal, ...params}: RequestConfig & s.GetDashboardEmbedUrlRequest,
  ): Promise<s.GetDashboardEmbedUrlResponse> {
    const query = new URLSearchParams;
    query.set("creds-type", params["IdentityType"]?.toString() ?? "");
    if (params["SessionLifetimeInMinutes"] != null) query.set("session-lifetime", params["SessionLifetimeInMinutes"]?.toString() ?? "");
    if (params["UndoRedoDisabled"] != null) query.set("undo-redo-disabled", params["UndoRedoDisabled"]?.toString() ?? "");
    if (params["ResetDisabled"] != null) query.set("reset-disabled", params["ResetDisabled"]?.toString() ?? "");
    if (params["StatePersistenceEnabled"] != null) query.set("state-persistence-enabled", params["StatePersistenceEnabled"]?.toString() ?? "");
    if (params["UserArn"] != null) query.set("user-arn", params["UserArn"]?.toString() ?? "");
    if (params["Namespace"] != null) query.set("namespace", params["Namespace"]?.toString() ?? "");
    for (const item of params["AdditionalDashboardIds"] ?? []) {
      query.append("additional-dashboard-ids", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDashboardEmbedUrl",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards/${params["DashboardId"]}/embed-url`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "EmbedUrl": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async getSessionEmbedUrl(
    {abortSignal, ...params}: RequestConfig & s.GetSessionEmbedUrlRequest,
  ): Promise<s.GetSessionEmbedUrlResponse> {
    const query = new URLSearchParams;
    if (params["EntryPoint"] != null) query.set("entry-point", params["EntryPoint"]?.toString() ?? "");
    if (params["SessionLifetimeInMinutes"] != null) query.set("session-lifetime", params["SessionLifetimeInMinutes"]?.toString() ?? "");
    if (params["UserArn"] != null) query.set("user-arn", params["UserArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSessionEmbedUrl",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/session-embed-url`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "EmbedUrl": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listAnalyses(
    {abortSignal, ...params}: RequestConfig & s.ListAnalysesRequest,
  ): Promise<s.ListAnalysesResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAnalyses",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/analyses`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "AnalysisSummaryList": [toAnalysisSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listDashboardVersions(
    {abortSignal, ...params}: RequestConfig & s.ListDashboardVersionsRequest,
  ): Promise<s.ListDashboardVersionsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDashboardVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards/${params["DashboardId"]}/versions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DashboardVersionSummaryList": [toDashboardVersionSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listDashboards(
    {abortSignal, ...params}: RequestConfig & s.ListDashboardsRequest,
  ): Promise<s.ListDashboardsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDashboards",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DashboardSummaryList": [toDashboardSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listDataSets(
    {abortSignal, ...params}: RequestConfig & s.ListDataSetsRequest,
  ): Promise<s.ListDataSetsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDataSets",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DataSetSummaries": [toDataSetSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listDataSources(
    {abortSignal, ...params}: RequestConfig & s.ListDataSourcesRequest,
  ): Promise<s.ListDataSourcesResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDataSources",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sources`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DataSources": [toDataSource],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listGroupMemberships(
    {abortSignal, ...params}: RequestConfig & s.ListGroupMembershipsRequest,
  ): Promise<s.ListGroupMembershipsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListGroupMemberships",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/groups/${params["GroupName"]}/members`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "GroupMemberList": [toGroupMember],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listGroups(
    {abortSignal, ...params}: RequestConfig & s.ListGroupsRequest,
  ): Promise<s.ListGroupsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListGroups",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/groups`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "GroupList": [toGroup],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listIAMPolicyAssignments(
    {abortSignal, ...params}: RequestConfig & s.ListIAMPolicyAssignmentsRequest,
  ): Promise<s.ListIAMPolicyAssignmentsResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      AssignmentStatus: params["AssignmentStatus"],
    };
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ListIAMPolicyAssignments",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/iam-policy-assignments`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "IAMPolicyAssignments": [toIAMPolicyAssignmentSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listIAMPolicyAssignmentsForUser(
    {abortSignal, ...params}: RequestConfig & s.ListIAMPolicyAssignmentsForUserRequest,
  ): Promise<s.ListIAMPolicyAssignmentsForUserResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListIAMPolicyAssignmentsForUser",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/users/${params["UserName"]}/iam-policy-assignments`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ActiveAssignments": [toActiveIAMPolicyAssignment],
          "RequestId": "s",
          "NextToken": "s",
        },
      }, await resp.json()),
    };
  }

  async listIngestions(
    {abortSignal, ...params}: RequestConfig & s.ListIngestionsRequest,
  ): Promise<s.ListIngestionsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListIngestions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets/${params["DataSetId"]}/ingestions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Ingestions": [toIngestion],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listNamespaces(
    {abortSignal, ...params}: RequestConfig & s.ListNamespacesRequest,
  ): Promise<s.ListNamespacesResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListNamespaces",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Namespaces": [toNamespaceInfoV2],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/resources/${params["ResourceArn"]}/tags`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Tags": [toTag],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listTemplateAliases(
    {abortSignal, ...params}: RequestConfig & s.ListTemplateAliasesRequest,
  ): Promise<s.ListTemplateAliasesResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-result", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTemplateAliases",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}/aliases`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateAliasList": [toTemplateAlias],
          "RequestId": "s",
          "NextToken": "s",
        },
      }, await resp.json()),
    };
  }

  async listTemplateVersions(
    {abortSignal, ...params}: RequestConfig & s.ListTemplateVersionsRequest,
  ): Promise<s.ListTemplateVersionsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTemplateVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}/versions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateVersionSummaryList": [toTemplateVersionSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listTemplates(
    {abortSignal, ...params}: RequestConfig & s.ListTemplatesRequest,
  ): Promise<s.ListTemplatesResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-result", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTemplates",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateSummaryList": [toTemplateSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listThemeAliases(
    {abortSignal, ...params}: RequestConfig & s.ListThemeAliasesRequest,
  ): Promise<s.ListThemeAliasesResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-result", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThemeAliases",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}/aliases`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ThemeAliasList": [toThemeAlias],
          "RequestId": "s",
          "NextToken": "s",
        },
      }, await resp.json()),
    };
  }

  async listThemeVersions(
    {abortSignal, ...params}: RequestConfig & s.ListThemeVersionsRequest,
  ): Promise<s.ListThemeVersionsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThemeVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}/versions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ThemeVersionSummaryList": [toThemeVersionSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listThemes(
    {abortSignal, ...params}: RequestConfig & s.ListThemesRequest,
  ): Promise<s.ListThemesResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    if (params["Type"] != null) query.set("type", params["Type"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThemes",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ThemeSummaryList": [toThemeSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listUserGroups(
    {abortSignal, ...params}: RequestConfig & s.ListUserGroupsRequest,
  ): Promise<s.ListUserGroupsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListUserGroups",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/users/${params["UserName"]}/groups`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "GroupList": [toGroup],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async listUsers(
    {abortSignal, ...params}: RequestConfig & s.ListUsersRequest,
  ): Promise<s.ListUsersResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("max-results", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListUsers",
      method: "GET",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/users`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "UserList": [toUser],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async registerUser(
    {abortSignal, ...params}: RequestConfig & s.RegisterUserRequest,
  ): Promise<s.RegisterUserResponse> {
    const body: jsonP.JSONObject = {
      IdentityType: params["IdentityType"],
      Email: params["Email"],
      UserRole: params["UserRole"],
      IamArn: params["IamArn"],
      SessionName: params["SessionName"],
      UserName: params["UserName"],
      CustomPermissionsName: params["CustomPermissionsName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterUser",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/users`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "User": toUser,
          "UserInvitationUrl": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async restoreAnalysis(
    {abortSignal, ...params}: RequestConfig & s.RestoreAnalysisRequest,
  ): Promise<s.RestoreAnalysisResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RestoreAnalysis",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/restore/analyses/${params["AnalysisId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "AnalysisId": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async searchAnalyses(
    {abortSignal, ...params}: RequestConfig & s.SearchAnalysesRequest,
  ): Promise<s.SearchAnalysesResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromAnalysisSearchFilter(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchAnalyses",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/search/analyses`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "AnalysisSummaryList": [toAnalysisSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async searchDashboards(
    {abortSignal, ...params}: RequestConfig & s.SearchDashboardsRequest,
  ): Promise<s.SearchDashboardsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromDashboardSearchFilter(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchDashboards",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/search/dashboards`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DashboardSummaryList": [toDashboardSummary],
          "NextToken": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/resources/${params["ResourceArn"]}/tags`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("keys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/resources/${params["ResourceArn"]}/tags`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateAccountCustomization(
    {abortSignal, ...params}: RequestConfig & s.UpdateAccountCustomizationRequest,
  ): Promise<s.UpdateAccountCustomizationResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      AccountCustomization: fromAccountCustomization(params["AccountCustomization"]),
    };
    if (params["Namespace"] != null) query.set("namespace", params["Namespace"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateAccountCustomization",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/customizations`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "AwsAccountId": "s",
          "Namespace": "s",
          "AccountCustomization": toAccountCustomization,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateAccountSettings(
    {abortSignal, ...params}: RequestConfig & s.UpdateAccountSettingsRequest,
  ): Promise<s.UpdateAccountSettingsResponse> {
    const body: jsonP.JSONObject = {
      DefaultNamespace: params["DefaultNamespace"],
      NotificationEmail: params["NotificationEmail"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccountSettings",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/settings`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateAnalysis(
    {abortSignal, ...params}: RequestConfig & s.UpdateAnalysisRequest,
  ): Promise<s.UpdateAnalysisResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Parameters: fromParameters(params["Parameters"]),
      SourceEntity: fromAnalysisSourceEntity(params["SourceEntity"]),
      ThemeArn: params["ThemeArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAnalysis",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/analyses/${params["AnalysisId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "AnalysisId": "s",
          "UpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateAnalysisPermissions(
    {abortSignal, ...params}: RequestConfig & s.UpdateAnalysisPermissionsRequest,
  ): Promise<s.UpdateAnalysisPermissionsResponse> {
    const body: jsonP.JSONObject = {
      GrantPermissions: params["GrantPermissions"]?.map(x => fromResourcePermission(x)),
      RevokePermissions: params["RevokePermissions"]?.map(x => fromResourcePermission(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAnalysisPermissions",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/analyses/${params["AnalysisId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "AnalysisArn": "s",
          "AnalysisId": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateDashboard(
    {abortSignal, ...params}: RequestConfig & s.UpdateDashboardRequest,
  ): Promise<s.UpdateDashboardResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      SourceEntity: fromDashboardSourceEntity(params["SourceEntity"]),
      Parameters: fromParameters(params["Parameters"]),
      VersionDescription: params["VersionDescription"],
      DashboardPublishOptions: fromDashboardPublishOptions(params["DashboardPublishOptions"]),
      ThemeArn: params["ThemeArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDashboard",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards/${params["DashboardId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "VersionArn": "s",
        "DashboardId": "s",
        "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
        "Status": "n",
        "RequestId": "s",
      },
    }, await resp.json());
  }

  async updateDashboardPermissions(
    {abortSignal, ...params}: RequestConfig & s.UpdateDashboardPermissionsRequest,
  ): Promise<s.UpdateDashboardPermissionsResponse> {
    const body: jsonP.JSONObject = {
      GrantPermissions: params["GrantPermissions"]?.map(x => fromResourcePermission(x)),
      RevokePermissions: params["RevokePermissions"]?.map(x => fromResourcePermission(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDashboardPermissions",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards/${params["DashboardId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DashboardArn": "s",
          "DashboardId": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateDashboardPublishedVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateDashboardPublishedVersionRequest,
  ): Promise<s.UpdateDashboardPublishedVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "UpdateDashboardPublishedVersion",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/dashboards/${params["DashboardId"]}/versions/${params["VersionNumber"].toString()}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DashboardId": "s",
          "DashboardArn": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateDataSet(
    {abortSignal, ...params}: RequestConfig & s.UpdateDataSetRequest,
  ): Promise<s.UpdateDataSetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      PhysicalTableMap: jsonP.serializeMap(params["PhysicalTableMap"], x => fromPhysicalTable(x)),
      LogicalTableMap: jsonP.serializeMap(params["LogicalTableMap"], x => fromLogicalTable(x)),
      ImportMode: params["ImportMode"],
      ColumnGroups: params["ColumnGroups"]?.map(x => fromColumnGroup(x)),
      FieldFolders: jsonP.serializeMap(params["FieldFolders"], x => fromFieldFolder(x)),
      RowLevelPermissionDataSet: fromRowLevelPermissionDataSet(params["RowLevelPermissionDataSet"]),
      ColumnLevelPermissionRules: params["ColumnLevelPermissionRules"]?.map(x => fromColumnLevelPermissionRule(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataSet",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets/${params["DataSetId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "DataSetId": "s",
          "IngestionArn": "s",
          "IngestionId": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateDataSetPermissions(
    {abortSignal, ...params}: RequestConfig & s.UpdateDataSetPermissionsRequest,
  ): Promise<s.UpdateDataSetPermissionsResponse> {
    const body: jsonP.JSONObject = {
      GrantPermissions: params["GrantPermissions"]?.map(x => fromResourcePermission(x)),
      RevokePermissions: params["RevokePermissions"]?.map(x => fromResourcePermission(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataSetPermissions",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sets/${params["DataSetId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DataSetArn": "s",
          "DataSetId": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateDataSource(
    {abortSignal, ...params}: RequestConfig & s.UpdateDataSourceRequest,
  ): Promise<s.UpdateDataSourceResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      DataSourceParameters: fromDataSourceParameters(params["DataSourceParameters"]),
      Credentials: fromDataSourceCredentials(params["Credentials"]),
      VpcConnectionProperties: fromVpcConnectionProperties(params["VpcConnectionProperties"]),
      SslProperties: fromSslProperties(params["SslProperties"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataSource",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sources/${params["DataSourceId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
          "DataSourceId": "s",
          "UpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateDataSourcePermissions(
    {abortSignal, ...params}: RequestConfig & s.UpdateDataSourcePermissionsRequest,
  ): Promise<s.UpdateDataSourcePermissionsResponse> {
    const body: jsonP.JSONObject = {
      GrantPermissions: params["GrantPermissions"]?.map(x => fromResourcePermission(x)),
      RevokePermissions: params["RevokePermissions"]?.map(x => fromResourcePermission(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataSourcePermissions",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/data-sources/${params["DataSourceId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "DataSourceArn": "s",
          "DataSourceId": "s",
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateGroupRequest,
  ): Promise<s.UpdateGroupResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGroup",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/groups/${params["GroupName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "Group": toGroup,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateIAMPolicyAssignment(
    {abortSignal, ...params}: RequestConfig & s.UpdateIAMPolicyAssignmentRequest,
  ): Promise<s.UpdateIAMPolicyAssignmentResponse> {
    const body: jsonP.JSONObject = {
      AssignmentStatus: params["AssignmentStatus"],
      PolicyArn: params["PolicyArn"],
      Identities: params["Identities"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIAMPolicyAssignment",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/iam-policy-assignments/${params["AssignmentName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "AssignmentName": "s",
          "AssignmentId": "s",
          "PolicyArn": "s",
          "Identities": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
          "AssignmentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssignmentStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateTemplateRequest,
  ): Promise<s.UpdateTemplateResponse> {
    const body: jsonP.JSONObject = {
      SourceEntity: fromTemplateSourceEntity(params["SourceEntity"]),
      VersionDescription: params["VersionDescription"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTemplate",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateId": "s",
          "Arn": "s",
          "VersionArn": "s",
          "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateTemplateAlias(
    {abortSignal, ...params}: RequestConfig & s.UpdateTemplateAliasRequest,
  ): Promise<s.UpdateTemplateAliasResponse> {
    const body: jsonP.JSONObject = {
      TemplateVersionNumber: params["TemplateVersionNumber"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTemplateAlias",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}/aliases/${params["AliasName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateAlias": toTemplateAlias,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateTemplatePermissions(
    {abortSignal, ...params}: RequestConfig & s.UpdateTemplatePermissionsRequest,
  ): Promise<s.UpdateTemplatePermissionsResponse> {
    const body: jsonP.JSONObject = {
      GrantPermissions: params["GrantPermissions"]?.map(x => fromResourcePermission(x)),
      RevokePermissions: params["RevokePermissions"]?.map(x => fromResourcePermission(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTemplatePermissions",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/templates/${params["TemplateId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "TemplateId": "s",
          "TemplateArn": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateTheme(
    {abortSignal, ...params}: RequestConfig & s.UpdateThemeRequest,
  ): Promise<s.UpdateThemeResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      BaseThemeId: params["BaseThemeId"],
      VersionDescription: params["VersionDescription"],
      Configuration: fromThemeConfiguration(params["Configuration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTheme",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ThemeId": "s",
          "Arn": "s",
          "VersionArn": "s",
          "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateThemeAlias(
    {abortSignal, ...params}: RequestConfig & s.UpdateThemeAliasRequest,
  ): Promise<s.UpdateThemeAliasResponse> {
    const body: jsonP.JSONObject = {
      ThemeVersionNumber: params["ThemeVersionNumber"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateThemeAlias",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}/aliases/${params["AliasName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ThemeAlias": toThemeAlias,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateThemePermissions(
    {abortSignal, ...params}: RequestConfig & s.UpdateThemePermissionsRequest,
  ): Promise<s.UpdateThemePermissionsResponse> {
    const body: jsonP.JSONObject = {
      GrantPermissions: params["GrantPermissions"]?.map(x => fromResourcePermission(x)),
      RevokePermissions: params["RevokePermissions"]?.map(x => fromResourcePermission(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateThemePermissions",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/themes/${params["ThemeId"]}/permissions`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "ThemeId": "s",
          "ThemeArn": "s",
          "Permissions": [toResourcePermission],
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

  async updateUser(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserRequest,
  ): Promise<s.UpdateUserResponse> {
    const body: jsonP.JSONObject = {
      Email: params["Email"],
      Role: params["Role"],
      CustomPermissionsName: params["CustomPermissionsName"],
      UnapplyCustomPermissions: params["UnapplyCustomPermissions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUser",
      method: "PUT",
      requestUri: cmnP.encodePath`/accounts/${params["AwsAccountId"]}/namespaces/${params["Namespace"]}/users/${params["UserName"]}`,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {
          "User": toUser,
          "RequestId": "s",
        },
      }, await resp.json()),
    };
  }

}

function fromAccountCustomization(input?: s.AccountCustomization | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefaultTheme: input["DefaultTheme"],
  }
}
function toAccountCustomization(root: jsonP.JSONValue): s.AccountCustomization {
  return jsonP.readObj({
    required: {},
    optional: {
      "DefaultTheme": "s",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromParameters(input?: s.Parameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StringParameters: input["StringParameters"]?.map(x => fromStringParameter(x)),
    IntegerParameters: input["IntegerParameters"]?.map(x => fromIntegerParameter(x)),
    DecimalParameters: input["DecimalParameters"]?.map(x => fromDecimalParameter(x)),
    DateTimeParameters: input["DateTimeParameters"]?.map(x => fromDateTimeParameter(x)),
  }
}

function fromStringParameter(input?: s.StringParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}

function fromIntegerParameter(input?: s.IntegerParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}

function fromDecimalParameter(input?: s.DecimalParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}

function fromDateTimeParameter(input?: s.DateTimeParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"]?.map(x => jsonP.serializeDate_unixTimestamp(x)),
  }
}

function fromResourcePermission(input?: s.ResourcePermission | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Principal: input["Principal"],
    Actions: input["Actions"],
  }
}
function toResourcePermission(root: jsonP.JSONValue): s.ResourcePermission {
  return jsonP.readObj({
    required: {
      "Principal": "s",
      "Actions": ["s"],
    },
    optional: {},
  }, root);
}

function fromAnalysisSourceEntity(input?: s.AnalysisSourceEntity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceTemplate: fromAnalysisSourceTemplate(input["SourceTemplate"]),
  }
}

function fromAnalysisSourceTemplate(input?: s.AnalysisSourceTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSetReferences: input["DataSetReferences"]?.map(x => fromDataSetReference(x)),
    Arn: input["Arn"],
  }
}

function fromDataSetReference(input?: s.DataSetReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSetPlaceholder: input["DataSetPlaceholder"],
    DataSetArn: input["DataSetArn"],
  }
}

function fromDashboardSourceEntity(input?: s.DashboardSourceEntity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceTemplate: fromDashboardSourceTemplate(input["SourceTemplate"]),
  }
}

function fromDashboardSourceTemplate(input?: s.DashboardSourceTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSetReferences: input["DataSetReferences"]?.map(x => fromDataSetReference(x)),
    Arn: input["Arn"],
  }
}

function fromDashboardPublishOptions(input?: s.DashboardPublishOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AdHocFilteringOption: fromAdHocFilteringOption(input["AdHocFilteringOption"]),
    ExportToCSVOption: fromExportToCSVOption(input["ExportToCSVOption"]),
    SheetControlsOption: fromSheetControlsOption(input["SheetControlsOption"]),
  }
}

function fromAdHocFilteringOption(input?: s.AdHocFilteringOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityStatus: input["AvailabilityStatus"],
  }
}

function fromExportToCSVOption(input?: s.ExportToCSVOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityStatus: input["AvailabilityStatus"],
  }
}

function fromSheetControlsOption(input?: s.SheetControlsOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VisibilityState: input["VisibilityState"],
  }
}

function fromPhysicalTable(input?: s.PhysicalTable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RelationalTable: fromRelationalTable(input["RelationalTable"]),
    CustomSql: fromCustomSql(input["CustomSql"]),
    S3Source: fromS3Source(input["S3Source"]),
  }
}
function toPhysicalTable(root: jsonP.JSONValue): s.PhysicalTable {
  return jsonP.readObj({
    required: {},
    optional: {
      "RelationalTable": toRelationalTable,
      "CustomSql": toCustomSql,
      "S3Source": toS3Source,
    },
  }, root);
}

function fromRelationalTable(input?: s.RelationalTable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSourceArn: input["DataSourceArn"],
    Catalog: input["Catalog"],
    Schema: input["Schema"],
    Name: input["Name"],
    InputColumns: input["InputColumns"]?.map(x => fromInputColumn(x)),
  }
}
function toRelationalTable(root: jsonP.JSONValue): s.RelationalTable {
  return jsonP.readObj({
    required: {
      "DataSourceArn": "s",
      "Name": "s",
      "InputColumns": [toInputColumn],
    },
    optional: {
      "Catalog": "s",
      "Schema": "s",
    },
  }, root);
}

function fromInputColumn(input?: s.InputColumn | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Type: input["Type"],
  }
}
function toInputColumn(root: jsonP.JSONValue): s.InputColumn {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputColumnDataType>(x),
    },
    optional: {},
  }, root);
}

function fromCustomSql(input?: s.CustomSql | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSourceArn: input["DataSourceArn"],
    Name: input["Name"],
    SqlQuery: input["SqlQuery"],
    Columns: input["Columns"]?.map(x => fromInputColumn(x)),
  }
}
function toCustomSql(root: jsonP.JSONValue): s.CustomSql {
  return jsonP.readObj({
    required: {
      "DataSourceArn": "s",
      "Name": "s",
      "SqlQuery": "s",
    },
    optional: {
      "Columns": [toInputColumn],
    },
  }, root);
}

function fromS3Source(input?: s.S3Source | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSourceArn: input["DataSourceArn"],
    UploadSettings: fromUploadSettings(input["UploadSettings"]),
    InputColumns: input["InputColumns"]?.map(x => fromInputColumn(x)),
  }
}
function toS3Source(root: jsonP.JSONValue): s.S3Source {
  return jsonP.readObj({
    required: {
      "DataSourceArn": "s",
      "InputColumns": [toInputColumn],
    },
    optional: {
      "UploadSettings": toUploadSettings,
    },
  }, root);
}

function fromUploadSettings(input?: s.UploadSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Format: input["Format"],
    StartFromRow: input["StartFromRow"],
    ContainsHeader: input["ContainsHeader"],
    TextQualifier: input["TextQualifier"],
    Delimiter: input["Delimiter"],
  }
}
function toUploadSettings(root: jsonP.JSONValue): s.UploadSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Format": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileFormat>(x),
      "StartFromRow": "n",
      "ContainsHeader": "b",
      "TextQualifier": (x: jsonP.JSONValue) => cmnP.readEnum<s.TextQualifier>(x),
      "Delimiter": "s",
    },
  }, root);
}

function fromLogicalTable(input?: s.LogicalTable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Alias: input["Alias"],
    DataTransforms: input["DataTransforms"]?.map(x => fromTransformOperation(x)),
    Source: fromLogicalTableSource(input["Source"]),
  }
}
function toLogicalTable(root: jsonP.JSONValue): s.LogicalTable {
  return jsonP.readObj({
    required: {
      "Alias": "s",
      "Source": toLogicalTableSource,
    },
    optional: {
      "DataTransforms": [toTransformOperation],
    },
  }, root);
}

function fromTransformOperation(input?: s.TransformOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProjectOperation: fromProjectOperation(input["ProjectOperation"]),
    FilterOperation: fromFilterOperation(input["FilterOperation"]),
    CreateColumnsOperation: fromCreateColumnsOperation(input["CreateColumnsOperation"]),
    RenameColumnOperation: fromRenameColumnOperation(input["RenameColumnOperation"]),
    CastColumnTypeOperation: fromCastColumnTypeOperation(input["CastColumnTypeOperation"]),
    TagColumnOperation: fromTagColumnOperation(input["TagColumnOperation"]),
  }
}
function toTransformOperation(root: jsonP.JSONValue): s.TransformOperation {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProjectOperation": toProjectOperation,
      "FilterOperation": toFilterOperation,
      "CreateColumnsOperation": toCreateColumnsOperation,
      "RenameColumnOperation": toRenameColumnOperation,
      "CastColumnTypeOperation": toCastColumnTypeOperation,
      "TagColumnOperation": toTagColumnOperation,
    },
  }, root);
}

function fromProjectOperation(input?: s.ProjectOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProjectedColumns: input["ProjectedColumns"],
  }
}
function toProjectOperation(root: jsonP.JSONValue): s.ProjectOperation {
  return jsonP.readObj({
    required: {
      "ProjectedColumns": ["s"],
    },
    optional: {},
  }, root);
}

function fromFilterOperation(input?: s.FilterOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConditionExpression: input["ConditionExpression"],
  }
}
function toFilterOperation(root: jsonP.JSONValue): s.FilterOperation {
  return jsonP.readObj({
    required: {
      "ConditionExpression": "s",
    },
    optional: {},
  }, root);
}

function fromCreateColumnsOperation(input?: s.CreateColumnsOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Columns: input["Columns"]?.map(x => fromCalculatedColumn(x)),
  }
}
function toCreateColumnsOperation(root: jsonP.JSONValue): s.CreateColumnsOperation {
  return jsonP.readObj({
    required: {
      "Columns": [toCalculatedColumn],
    },
    optional: {},
  }, root);
}

function fromCalculatedColumn(input?: s.CalculatedColumn | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ColumnName: input["ColumnName"],
    ColumnId: input["ColumnId"],
    Expression: input["Expression"],
  }
}
function toCalculatedColumn(root: jsonP.JSONValue): s.CalculatedColumn {
  return jsonP.readObj({
    required: {
      "ColumnName": "s",
      "ColumnId": "s",
      "Expression": "s",
    },
    optional: {},
  }, root);
}

function fromRenameColumnOperation(input?: s.RenameColumnOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ColumnName: input["ColumnName"],
    NewColumnName: input["NewColumnName"],
  }
}
function toRenameColumnOperation(root: jsonP.JSONValue): s.RenameColumnOperation {
  return jsonP.readObj({
    required: {
      "ColumnName": "s",
      "NewColumnName": "s",
    },
    optional: {},
  }, root);
}

function fromCastColumnTypeOperation(input?: s.CastColumnTypeOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ColumnName: input["ColumnName"],
    NewColumnType: input["NewColumnType"],
    Format: input["Format"],
  }
}
function toCastColumnTypeOperation(root: jsonP.JSONValue): s.CastColumnTypeOperation {
  return jsonP.readObj({
    required: {
      "ColumnName": "s",
      "NewColumnType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ColumnDataType>(x),
    },
    optional: {
      "Format": "s",
    },
  }, root);
}

function fromTagColumnOperation(input?: s.TagColumnOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ColumnName: input["ColumnName"],
    Tags: input["Tags"]?.map(x => fromColumnTag(x)),
  }
}
function toTagColumnOperation(root: jsonP.JSONValue): s.TagColumnOperation {
  return jsonP.readObj({
    required: {
      "ColumnName": "s",
      "Tags": [toColumnTag],
    },
    optional: {},
  }, root);
}

function fromColumnTag(input?: s.ColumnTag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ColumnGeographicRole: input["ColumnGeographicRole"],
    ColumnDescription: fromColumnDescription(input["ColumnDescription"]),
  }
}
function toColumnTag(root: jsonP.JSONValue): s.ColumnTag {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnGeographicRole": (x: jsonP.JSONValue) => cmnP.readEnum<s.GeoSpatialDataRole>(x),
      "ColumnDescription": toColumnDescription,
    },
  }, root);
}

function fromColumnDescription(input?: s.ColumnDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Text: input["Text"],
  }
}
function toColumnDescription(root: jsonP.JSONValue): s.ColumnDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Text": "s",
    },
  }, root);
}

function fromLogicalTableSource(input?: s.LogicalTableSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JoinInstruction: fromJoinInstruction(input["JoinInstruction"]),
    PhysicalTableId: input["PhysicalTableId"],
  }
}
function toLogicalTableSource(root: jsonP.JSONValue): s.LogicalTableSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "JoinInstruction": toJoinInstruction,
      "PhysicalTableId": "s",
    },
  }, root);
}

function fromJoinInstruction(input?: s.JoinInstruction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LeftOperand: input["LeftOperand"],
    RightOperand: input["RightOperand"],
    LeftJoinKeyProperties: fromJoinKeyProperties(input["LeftJoinKeyProperties"]),
    RightJoinKeyProperties: fromJoinKeyProperties(input["RightJoinKeyProperties"]),
    Type: input["Type"],
    OnClause: input["OnClause"],
  }
}
function toJoinInstruction(root: jsonP.JSONValue): s.JoinInstruction {
  return jsonP.readObj({
    required: {
      "LeftOperand": "s",
      "RightOperand": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.JoinType>(x),
      "OnClause": "s",
    },
    optional: {
      "LeftJoinKeyProperties": toJoinKeyProperties,
      "RightJoinKeyProperties": toJoinKeyProperties,
    },
  }, root);
}

function fromJoinKeyProperties(input?: s.JoinKeyProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UniqueKey: input["UniqueKey"],
  }
}
function toJoinKeyProperties(root: jsonP.JSONValue): s.JoinKeyProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "UniqueKey": "b",
    },
  }, root);
}

function fromColumnGroup(input?: s.ColumnGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GeoSpatialColumnGroup: fromGeoSpatialColumnGroup(input["GeoSpatialColumnGroup"]),
  }
}
function toColumnGroup(root: jsonP.JSONValue): s.ColumnGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "GeoSpatialColumnGroup": toGeoSpatialColumnGroup,
    },
  }, root);
}

function fromGeoSpatialColumnGroup(input?: s.GeoSpatialColumnGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    CountryCode: input["CountryCode"],
    Columns: input["Columns"],
  }
}
function toGeoSpatialColumnGroup(root: jsonP.JSONValue): s.GeoSpatialColumnGroup {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "CountryCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.GeoSpatialCountryCode>(x),
      "Columns": ["s"],
    },
    optional: {},
  }, root);
}

function fromFieldFolder(input?: s.FieldFolder | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    description: input["description"],
    columns: input["columns"],
  }
}
function toFieldFolder(root: jsonP.JSONValue): s.FieldFolder {
  return jsonP.readObj({
    required: {},
    optional: {
      "description": "s",
      "columns": ["s"],
    },
  }, root);
}

function fromRowLevelPermissionDataSet(input?: s.RowLevelPermissionDataSet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Namespace: input["Namespace"],
    Arn: input["Arn"],
    PermissionPolicy: input["PermissionPolicy"],
  }
}
function toRowLevelPermissionDataSet(root: jsonP.JSONValue): s.RowLevelPermissionDataSet {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "PermissionPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.RowLevelPermissionPolicy>(x),
    },
    optional: {
      "Namespace": "s",
    },
  }, root);
}

function fromColumnLevelPermissionRule(input?: s.ColumnLevelPermissionRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Principals: input["Principals"],
    ColumnNames: input["ColumnNames"],
  }
}
function toColumnLevelPermissionRule(root: jsonP.JSONValue): s.ColumnLevelPermissionRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Principals": ["s"],
      "ColumnNames": ["s"],
    },
  }, root);
}

function fromDataSourceParameters(input?: s.DataSourceParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AmazonElasticsearchParameters: fromAmazonElasticsearchParameters(input["AmazonElasticsearchParameters"]),
    AthenaParameters: fromAthenaParameters(input["AthenaParameters"]),
    AuroraParameters: fromAuroraParameters(input["AuroraParameters"]),
    AuroraPostgreSqlParameters: fromAuroraPostgreSqlParameters(input["AuroraPostgreSqlParameters"]),
    AwsIotAnalyticsParameters: fromAwsIotAnalyticsParameters(input["AwsIotAnalyticsParameters"]),
    JiraParameters: fromJiraParameters(input["JiraParameters"]),
    MariaDbParameters: fromMariaDbParameters(input["MariaDbParameters"]),
    MySqlParameters: fromMySqlParameters(input["MySqlParameters"]),
    OracleParameters: fromOracleParameters(input["OracleParameters"]),
    PostgreSqlParameters: fromPostgreSqlParameters(input["PostgreSqlParameters"]),
    PrestoParameters: fromPrestoParameters(input["PrestoParameters"]),
    RdsParameters: fromRdsParameters(input["RdsParameters"]),
    RedshiftParameters: fromRedshiftParameters(input["RedshiftParameters"]),
    S3Parameters: fromS3Parameters(input["S3Parameters"]),
    ServiceNowParameters: fromServiceNowParameters(input["ServiceNowParameters"]),
    SnowflakeParameters: fromSnowflakeParameters(input["SnowflakeParameters"]),
    SparkParameters: fromSparkParameters(input["SparkParameters"]),
    SqlServerParameters: fromSqlServerParameters(input["SqlServerParameters"]),
    TeradataParameters: fromTeradataParameters(input["TeradataParameters"]),
    TwitterParameters: fromTwitterParameters(input["TwitterParameters"]),
  }
}
function toDataSourceParameters(root: jsonP.JSONValue): s.DataSourceParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "AmazonElasticsearchParameters": toAmazonElasticsearchParameters,
      "AthenaParameters": toAthenaParameters,
      "AuroraParameters": toAuroraParameters,
      "AuroraPostgreSqlParameters": toAuroraPostgreSqlParameters,
      "AwsIotAnalyticsParameters": toAwsIotAnalyticsParameters,
      "JiraParameters": toJiraParameters,
      "MariaDbParameters": toMariaDbParameters,
      "MySqlParameters": toMySqlParameters,
      "OracleParameters": toOracleParameters,
      "PostgreSqlParameters": toPostgreSqlParameters,
      "PrestoParameters": toPrestoParameters,
      "RdsParameters": toRdsParameters,
      "RedshiftParameters": toRedshiftParameters,
      "S3Parameters": toS3Parameters,
      "ServiceNowParameters": toServiceNowParameters,
      "SnowflakeParameters": toSnowflakeParameters,
      "SparkParameters": toSparkParameters,
      "SqlServerParameters": toSqlServerParameters,
      "TeradataParameters": toTeradataParameters,
      "TwitterParameters": toTwitterParameters,
    },
  }, root);
}

function fromAmazonElasticsearchParameters(input?: s.AmazonElasticsearchParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Domain: input["Domain"],
  }
}
function toAmazonElasticsearchParameters(root: jsonP.JSONValue): s.AmazonElasticsearchParameters {
  return jsonP.readObj({
    required: {
      "Domain": "s",
    },
    optional: {},
  }, root);
}

function fromAthenaParameters(input?: s.AthenaParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    WorkGroup: input["WorkGroup"],
  }
}
function toAthenaParameters(root: jsonP.JSONValue): s.AthenaParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "WorkGroup": "s",
    },
  }, root);
}

function fromAuroraParameters(input?: s.AuroraParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Database: input["Database"],
  }
}
function toAuroraParameters(root: jsonP.JSONValue): s.AuroraParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromAuroraPostgreSqlParameters(input?: s.AuroraPostgreSqlParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Database: input["Database"],
  }
}
function toAuroraPostgreSqlParameters(root: jsonP.JSONValue): s.AuroraPostgreSqlParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromAwsIotAnalyticsParameters(input?: s.AwsIotAnalyticsParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSetName: input["DataSetName"],
  }
}
function toAwsIotAnalyticsParameters(root: jsonP.JSONValue): s.AwsIotAnalyticsParameters {
  return jsonP.readObj({
    required: {
      "DataSetName": "s",
    },
    optional: {},
  }, root);
}

function fromJiraParameters(input?: s.JiraParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SiteBaseUrl: input["SiteBaseUrl"],
  }
}
function toJiraParameters(root: jsonP.JSONValue): s.JiraParameters {
  return jsonP.readObj({
    required: {
      "SiteBaseUrl": "s",
    },
    optional: {},
  }, root);
}

function fromMariaDbParameters(input?: s.MariaDbParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Database: input["Database"],
  }
}
function toMariaDbParameters(root: jsonP.JSONValue): s.MariaDbParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromMySqlParameters(input?: s.MySqlParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Database: input["Database"],
  }
}
function toMySqlParameters(root: jsonP.JSONValue): s.MySqlParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromOracleParameters(input?: s.OracleParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Database: input["Database"],
  }
}
function toOracleParameters(root: jsonP.JSONValue): s.OracleParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromPostgreSqlParameters(input?: s.PostgreSqlParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Database: input["Database"],
  }
}
function toPostgreSqlParameters(root: jsonP.JSONValue): s.PostgreSqlParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromPrestoParameters(input?: s.PrestoParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Catalog: input["Catalog"],
  }
}
function toPrestoParameters(root: jsonP.JSONValue): s.PrestoParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
      "Catalog": "s",
    },
    optional: {},
  }, root);
}

function fromRdsParameters(input?: s.RdsParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceId: input["InstanceId"],
    Database: input["Database"],
  }
}
function toRdsParameters(root: jsonP.JSONValue): s.RdsParameters {
  return jsonP.readObj({
    required: {
      "InstanceId": "s",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromRedshiftParameters(input?: s.RedshiftParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Database: input["Database"],
    ClusterId: input["ClusterId"],
  }
}
function toRedshiftParameters(root: jsonP.JSONValue): s.RedshiftParameters {
  return jsonP.readObj({
    required: {
      "Database": "s",
    },
    optional: {
      "Host": "s",
      "Port": "n",
      "ClusterId": "s",
    },
  }, root);
}

function fromS3Parameters(input?: s.S3Parameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ManifestFileLocation: fromManifestFileLocation(input["ManifestFileLocation"]),
  }
}
function toS3Parameters(root: jsonP.JSONValue): s.S3Parameters {
  return jsonP.readObj({
    required: {
      "ManifestFileLocation": toManifestFileLocation,
    },
    optional: {},
  }, root);
}

function fromManifestFileLocation(input?: s.ManifestFileLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Key: input["Key"],
  }
}
function toManifestFileLocation(root: jsonP.JSONValue): s.ManifestFileLocation {
  return jsonP.readObj({
    required: {
      "Bucket": "s",
      "Key": "s",
    },
    optional: {},
  }, root);
}

function fromServiceNowParameters(input?: s.ServiceNowParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SiteBaseUrl: input["SiteBaseUrl"],
  }
}
function toServiceNowParameters(root: jsonP.JSONValue): s.ServiceNowParameters {
  return jsonP.readObj({
    required: {
      "SiteBaseUrl": "s",
    },
    optional: {},
  }, root);
}

function fromSnowflakeParameters(input?: s.SnowflakeParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Database: input["Database"],
    Warehouse: input["Warehouse"],
  }
}
function toSnowflakeParameters(root: jsonP.JSONValue): s.SnowflakeParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Database": "s",
      "Warehouse": "s",
    },
    optional: {},
  }, root);
}

function fromSparkParameters(input?: s.SparkParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
  }
}
function toSparkParameters(root: jsonP.JSONValue): s.SparkParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
    },
    optional: {},
  }, root);
}

function fromSqlServerParameters(input?: s.SqlServerParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Database: input["Database"],
  }
}
function toSqlServerParameters(root: jsonP.JSONValue): s.SqlServerParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromTeradataParameters(input?: s.TeradataParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Host: input["Host"],
    Port: input["Port"],
    Database: input["Database"],
  }
}
function toTeradataParameters(root: jsonP.JSONValue): s.TeradataParameters {
  return jsonP.readObj({
    required: {
      "Host": "s",
      "Port": "n",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromTwitterParameters(input?: s.TwitterParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Query: input["Query"],
    MaxRows: input["MaxRows"],
  }
}
function toTwitterParameters(root: jsonP.JSONValue): s.TwitterParameters {
  return jsonP.readObj({
    required: {
      "Query": "s",
      "MaxRows": "n",
    },
    optional: {},
  }, root);
}

function fromDataSourceCredentials(input?: s.DataSourceCredentials | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CredentialPair: fromCredentialPair(input["CredentialPair"]),
    CopySourceArn: input["CopySourceArn"],
  }
}

function fromCredentialPair(input?: s.CredentialPair | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Username: input["Username"],
    Password: input["Password"],
    AlternateDataSourceParameters: input["AlternateDataSourceParameters"]?.map(x => fromDataSourceParameters(x)),
  }
}

function fromVpcConnectionProperties(input?: s.VpcConnectionProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VpcConnectionArn: input["VpcConnectionArn"],
  }
}
function toVpcConnectionProperties(root: jsonP.JSONValue): s.VpcConnectionProperties {
  return jsonP.readObj({
    required: {
      "VpcConnectionArn": "s",
    },
    optional: {},
  }, root);
}

function fromSslProperties(input?: s.SslProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DisableSsl: input["DisableSsl"],
  }
}
function toSslProperties(root: jsonP.JSONValue): s.SslProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "DisableSsl": "b",
    },
  }, root);
}

function fromTemplateSourceEntity(input?: s.TemplateSourceEntity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceAnalysis: fromTemplateSourceAnalysis(input["SourceAnalysis"]),
    SourceTemplate: fromTemplateSourceTemplate(input["SourceTemplate"]),
  }
}

function fromTemplateSourceAnalysis(input?: s.TemplateSourceAnalysis | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
    DataSetReferences: input["DataSetReferences"]?.map(x => fromDataSetReference(x)),
  }
}

function fromTemplateSourceTemplate(input?: s.TemplateSourceTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
  }
}

function fromThemeConfiguration(input?: s.ThemeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataColorPalette: fromDataColorPalette(input["DataColorPalette"]),
    UIColorPalette: fromUIColorPalette(input["UIColorPalette"]),
    Sheet: fromSheetStyle(input["Sheet"]),
  }
}
function toThemeConfiguration(root: jsonP.JSONValue): s.ThemeConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "DataColorPalette": toDataColorPalette,
      "UIColorPalette": toUIColorPalette,
      "Sheet": toSheetStyle,
    },
  }, root);
}

function fromDataColorPalette(input?: s.DataColorPalette | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Colors: input["Colors"],
    MinMaxGradient: input["MinMaxGradient"],
    EmptyFillColor: input["EmptyFillColor"],
  }
}
function toDataColorPalette(root: jsonP.JSONValue): s.DataColorPalette {
  return jsonP.readObj({
    required: {},
    optional: {
      "Colors": ["s"],
      "MinMaxGradient": ["s"],
      "EmptyFillColor": "s",
    },
  }, root);
}

function fromUIColorPalette(input?: s.UIColorPalette | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PrimaryForeground: input["PrimaryForeground"],
    PrimaryBackground: input["PrimaryBackground"],
    SecondaryForeground: input["SecondaryForeground"],
    SecondaryBackground: input["SecondaryBackground"],
    Accent: input["Accent"],
    AccentForeground: input["AccentForeground"],
    Danger: input["Danger"],
    DangerForeground: input["DangerForeground"],
    Warning: input["Warning"],
    WarningForeground: input["WarningForeground"],
    Success: input["Success"],
    SuccessForeground: input["SuccessForeground"],
    Dimension: input["Dimension"],
    DimensionForeground: input["DimensionForeground"],
    Measure: input["Measure"],
    MeasureForeground: input["MeasureForeground"],
  }
}
function toUIColorPalette(root: jsonP.JSONValue): s.UIColorPalette {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrimaryForeground": "s",
      "PrimaryBackground": "s",
      "SecondaryForeground": "s",
      "SecondaryBackground": "s",
      "Accent": "s",
      "AccentForeground": "s",
      "Danger": "s",
      "DangerForeground": "s",
      "Warning": "s",
      "WarningForeground": "s",
      "Success": "s",
      "SuccessForeground": "s",
      "Dimension": "s",
      "DimensionForeground": "s",
      "Measure": "s",
      "MeasureForeground": "s",
    },
  }, root);
}

function fromSheetStyle(input?: s.SheetStyle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Tile: fromTileStyle(input["Tile"]),
    TileLayout: fromTileLayoutStyle(input["TileLayout"]),
  }
}
function toSheetStyle(root: jsonP.JSONValue): s.SheetStyle {
  return jsonP.readObj({
    required: {},
    optional: {
      "Tile": toTileStyle,
      "TileLayout": toTileLayoutStyle,
    },
  }, root);
}

function fromTileStyle(input?: s.TileStyle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Border: fromBorderStyle(input["Border"]),
  }
}
function toTileStyle(root: jsonP.JSONValue): s.TileStyle {
  return jsonP.readObj({
    required: {},
    optional: {
      "Border": toBorderStyle,
    },
  }, root);
}

function fromBorderStyle(input?: s.BorderStyle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Show: input["Show"],
  }
}
function toBorderStyle(root: jsonP.JSONValue): s.BorderStyle {
  return jsonP.readObj({
    required: {},
    optional: {
      "Show": "b",
    },
  }, root);
}

function fromTileLayoutStyle(input?: s.TileLayoutStyle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Gutter: fromGutterStyle(input["Gutter"]),
    Margin: fromMarginStyle(input["Margin"]),
  }
}
function toTileLayoutStyle(root: jsonP.JSONValue): s.TileLayoutStyle {
  return jsonP.readObj({
    required: {},
    optional: {
      "Gutter": toGutterStyle,
      "Margin": toMarginStyle,
    },
  }, root);
}

function fromGutterStyle(input?: s.GutterStyle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Show: input["Show"],
  }
}
function toGutterStyle(root: jsonP.JSONValue): s.GutterStyle {
  return jsonP.readObj({
    required: {},
    optional: {
      "Show": "b",
    },
  }, root);
}

function fromMarginStyle(input?: s.MarginStyle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Show: input["Show"],
  }
}
function toMarginStyle(root: jsonP.JSONValue): s.MarginStyle {
  return jsonP.readObj({
    required: {},
    optional: {
      "Show": "b",
    },
  }, root);
}

function fromAnalysisSearchFilter(input?: s.AnalysisSearchFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Operator: input["Operator"],
    Name: input["Name"],
    Value: input["Value"],
  }
}

function fromDashboardSearchFilter(input?: s.DashboardSearchFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Operator: input["Operator"],
    Name: input["Name"],
    Value: input["Value"],
  }
}

function toGroup(root: jsonP.JSONValue): s.Group {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "GroupName": "s",
      "Description": "s",
      "PrincipalId": "s",
    },
  }, root);
}

function toGroupMember(root: jsonP.JSONValue): s.GroupMember {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "MemberName": "s",
    },
  }, root);
}

function toTemplateAlias(root: jsonP.JSONValue): s.TemplateAlias {
  return jsonP.readObj({
    required: {},
    optional: {
      "AliasName": "s",
      "Arn": "s",
      "TemplateVersionNumber": "n",
    },
  }, root);
}

function toThemeAlias(root: jsonP.JSONValue): s.ThemeAlias {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "AliasName": "s",
      "ThemeVersionNumber": "n",
    },
  }, root);
}

function toAccountSettings(root: jsonP.JSONValue): s.AccountSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountName": "s",
      "Edition": (x: jsonP.JSONValue) => cmnP.readEnum<s.Edition>(x),
      "DefaultNamespace": "s",
      "NotificationEmail": "s",
    },
  }, root);
}

function toAnalysis(root: jsonP.JSONValue): s.Analysis {
  return jsonP.readObj({
    required: {},
    optional: {
      "AnalysisId": "s",
      "Arn": "s",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
      "Errors": [toAnalysisError],
      "DataSetArns": ["s"],
      "ThemeArn": "s",
      "CreatedTime": "d",
      "LastUpdatedTime": "d",
      "Sheets": [toSheet],
    },
  }, root);
}

function toAnalysisError(root: jsonP.JSONValue): s.AnalysisError {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.AnalysisErrorType>(x),
      "Message": "s",
    },
  }, root);
}

function toSheet(root: jsonP.JSONValue): s.Sheet {
  return jsonP.readObj({
    required: {},
    optional: {
      "SheetId": "s",
      "Name": "s",
    },
  }, root);
}

function toDashboard(root: jsonP.JSONValue): s.Dashboard {
  return jsonP.readObj({
    required: {},
    optional: {
      "DashboardId": "s",
      "Arn": "s",
      "Name": "s",
      "Version": toDashboardVersion,
      "CreatedTime": "d",
      "LastPublishedTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}

function toDashboardVersion(root: jsonP.JSONValue): s.DashboardVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreatedTime": "d",
      "Errors": [toDashboardError],
      "VersionNumber": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
      "Arn": "s",
      "SourceEntityArn": "s",
      "DataSetArns": ["s"],
      "Description": "s",
      "ThemeArn": "s",
      "Sheets": [toSheet],
    },
  }, root);
}

function toDashboardError(root: jsonP.JSONValue): s.DashboardError {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DashboardErrorType>(x),
      "Message": "s",
    },
  }, root);
}

function toDataSet(root: jsonP.JSONValue): s.DataSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "DataSetId": "s",
      "Name": "s",
      "CreatedTime": "d",
      "LastUpdatedTime": "d",
      "PhysicalTableMap": x => jsonP.readMap(String, toPhysicalTable, x),
      "LogicalTableMap": x => jsonP.readMap(String, toLogicalTable, x),
      "OutputColumns": [toOutputColumn],
      "ImportMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataSetImportMode>(x),
      "ConsumedSpiceCapacityInBytes": "n",
      "ColumnGroups": [toColumnGroup],
      "FieldFolders": x => jsonP.readMap(String, toFieldFolder, x),
      "RowLevelPermissionDataSet": toRowLevelPermissionDataSet,
      "ColumnLevelPermissionRules": [toColumnLevelPermissionRule],
    },
  }, root);
}

function toOutputColumn(root: jsonP.JSONValue): s.OutputColumn {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Description": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ColumnDataType>(x),
    },
  }, root);
}

function toDataSource(root: jsonP.JSONValue): s.DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "DataSourceId": "s",
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataSourceType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
      "CreatedTime": "d",
      "LastUpdatedTime": "d",
      "DataSourceParameters": toDataSourceParameters,
      "AlternateDataSourceParameters": [toDataSourceParameters],
      "VpcConnectionProperties": toVpcConnectionProperties,
      "SslProperties": toSslProperties,
      "ErrorInfo": toDataSourceErrorInfo,
    },
  }, root);
}

function toDataSourceErrorInfo(root: jsonP.JSONValue): s.DataSourceErrorInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataSourceErrorInfoType>(x),
      "Message": "s",
    },
  }, root);
}

function toIAMPolicyAssignment(root: jsonP.JSONValue): s.IAMPolicyAssignment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AwsAccountId": "s",
      "AssignmentId": "s",
      "AssignmentName": "s",
      "PolicyArn": "s",
      "Identities": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "AssignmentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssignmentStatus>(x),
    },
  }, root);
}

function toIngestion(root: jsonP.JSONValue): s.Ingestion {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "IngestionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.IngestionStatus>(x),
      "CreatedTime": "d",
    },
    optional: {
      "IngestionId": "s",
      "ErrorInfo": toErrorInfo,
      "RowInfo": toRowInfo,
      "QueueInfo": toQueueInfo,
      "IngestionTimeInSeconds": "n",
      "IngestionSizeInBytes": "n",
      "RequestSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.IngestionRequestSource>(x),
      "RequestType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IngestionRequestType>(x),
    },
  }, root);
}

function toErrorInfo(root: jsonP.JSONValue): s.ErrorInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.IngestionErrorType>(x),
      "Message": "s",
    },
  }, root);
}

function toRowInfo(root: jsonP.JSONValue): s.RowInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "RowsIngested": "n",
      "RowsDropped": "n",
    },
  }, root);
}

function toQueueInfo(root: jsonP.JSONValue): s.QueueInfo {
  return jsonP.readObj({
    required: {
      "WaitingOnIngestion": "s",
      "QueuedIngestion": "s",
    },
    optional: {},
  }, root);
}

function toNamespaceInfoV2(root: jsonP.JSONValue): s.NamespaceInfoV2 {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Arn": "s",
      "CapacityRegion": "s",
      "CreationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.NamespaceStatus>(x),
      "IdentityStore": (x: jsonP.JSONValue) => cmnP.readEnum<s.IdentityStore>(x),
      "NamespaceError": toNamespaceError,
    },
  }, root);
}

function toNamespaceError(root: jsonP.JSONValue): s.NamespaceError {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.NamespaceErrorType>(x),
      "Message": "s",
    },
  }, root);
}

function toTemplate(root: jsonP.JSONValue): s.Template {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Name": "s",
      "Version": toTemplateVersion,
      "TemplateId": "s",
      "LastUpdatedTime": "d",
      "CreatedTime": "d",
    },
  }, root);
}

function toTemplateVersion(root: jsonP.JSONValue): s.TemplateVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreatedTime": "d",
      "Errors": [toTemplateError],
      "VersionNumber": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
      "DataSetConfigurations": [toDataSetConfiguration],
      "Description": "s",
      "SourceEntityArn": "s",
      "ThemeArn": "s",
      "Sheets": [toSheet],
    },
  }, root);
}

function toTemplateError(root: jsonP.JSONValue): s.TemplateError {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateErrorType>(x),
      "Message": "s",
    },
  }, root);
}

function toDataSetConfiguration(root: jsonP.JSONValue): s.DataSetConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Placeholder": "s",
      "DataSetSchema": toDataSetSchema,
      "ColumnGroupSchemaList": [toColumnGroupSchema],
    },
  }, root);
}

function toDataSetSchema(root: jsonP.JSONValue): s.DataSetSchema {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnSchemaList": [toColumnSchema],
    },
  }, root);
}

function toColumnSchema(root: jsonP.JSONValue): s.ColumnSchema {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "DataType": "s",
      "GeographicRole": "s",
    },
  }, root);
}

function toColumnGroupSchema(root: jsonP.JSONValue): s.ColumnGroupSchema {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ColumnGroupColumnSchemaList": [toColumnGroupColumnSchema],
    },
  }, root);
}

function toColumnGroupColumnSchema(root: jsonP.JSONValue): s.ColumnGroupColumnSchema {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
    },
  }, root);
}

function toTheme(root: jsonP.JSONValue): s.Theme {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Name": "s",
      "ThemeId": "s",
      "Version": toThemeVersion,
      "CreatedTime": "d",
      "LastUpdatedTime": "d",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThemeType>(x),
    },
  }, root);
}

function toThemeVersion(root: jsonP.JSONValue): s.ThemeVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "VersionNumber": "n",
      "Arn": "s",
      "Description": "s",
      "BaseThemeId": "s",
      "CreatedTime": "d",
      "Configuration": toThemeConfiguration,
      "Errors": [toThemeError],
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
    },
  }, root);
}

function toThemeError(root: jsonP.JSONValue): s.ThemeError {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThemeErrorType>(x),
      "Message": "s",
    },
  }, root);
}

function toUser(root: jsonP.JSONValue): s.User {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "UserName": "s",
      "Email": "s",
      "Role": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserRole>(x),
      "IdentityType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IdentityType>(x),
      "Active": "b",
      "PrincipalId": "s",
      "CustomPermissionsName": "s",
    },
  }, root);
}

function toAnalysisSummary(root: jsonP.JSONValue): s.AnalysisSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "AnalysisId": "s",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
      "CreatedTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}

function toDashboardVersionSummary(root: jsonP.JSONValue): s.DashboardVersionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CreatedTime": "d",
      "VersionNumber": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
      "SourceEntityArn": "s",
      "Description": "s",
    },
  }, root);
}

function toDashboardSummary(root: jsonP.JSONValue): s.DashboardSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "DashboardId": "s",
      "Name": "s",
      "CreatedTime": "d",
      "LastUpdatedTime": "d",
      "PublishedVersionNumber": "n",
      "LastPublishedTime": "d",
    },
  }, root);
}

function toDataSetSummary(root: jsonP.JSONValue): s.DataSetSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "DataSetId": "s",
      "Name": "s",
      "CreatedTime": "d",
      "LastUpdatedTime": "d",
      "ImportMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataSetImportMode>(x),
      "RowLevelPermissionDataSet": toRowLevelPermissionDataSet,
      "ColumnLevelPermissionRulesApplied": "b",
    },
  }, root);
}

function toIAMPolicyAssignmentSummary(root: jsonP.JSONValue): s.IAMPolicyAssignmentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssignmentName": "s",
      "AssignmentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssignmentStatus>(x),
    },
  }, root);
}

function toActiveIAMPolicyAssignment(root: jsonP.JSONValue): s.ActiveIAMPolicyAssignment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssignmentName": "s",
      "PolicyArn": "s",
    },
  }, root);
}

function toTemplateVersionSummary(root: jsonP.JSONValue): s.TemplateVersionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "VersionNumber": "n",
      "CreatedTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
      "Description": "s",
    },
  }, root);
}

function toTemplateSummary(root: jsonP.JSONValue): s.TemplateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "TemplateId": "s",
      "Name": "s",
      "LatestVersionNumber": "n",
      "CreatedTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}

function toThemeVersionSummary(root: jsonP.JSONValue): s.ThemeVersionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "VersionNumber": "n",
      "Arn": "s",
      "Description": "s",
      "CreatedTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStatus>(x),
    },
  }, root);
}

function toThemeSummary(root: jsonP.JSONValue): s.ThemeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Name": "s",
      "ThemeId": "s",
      "LatestVersionNumber": "n",
      "CreatedTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}
