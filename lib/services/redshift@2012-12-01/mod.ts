// Autogenerated API client for: Amazon Redshift

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";

export default class Redshift {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Redshift.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2012-12-01",
    "endpointPrefix": "redshift",
    "protocol": "query",
    "serviceFullName": "Amazon Redshift",
    "serviceId": "Redshift",
    "signatureVersion": "v4",
    "uid": "redshift-2012-12-01",
    "xmlNamespace": "http://redshift.amazonaws.com/doc/2012-12-01/"
  };

  async acceptReservedNodeExchange(
    {abortSignal, ...params}: RequestConfig & AcceptReservedNodeExchangeInputMessage,
  ): Promise<AcceptReservedNodeExchangeOutputMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedNodeId", (params["ReservedNodeId"] ?? '').toString());
    body.append(prefix+"TargetReservedNodeOfferingId", (params["TargetReservedNodeOfferingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptReservedNodeExchange",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AcceptReservedNodeExchangeResult");
    return {
      ExchangedReservedNode: xml.first("ExchangedReservedNode", false, ReservedNode_Parse),
    };
  }

  async authorizeClusterSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & AuthorizeClusterSecurityGroupIngressMessage,
  ): Promise<AuthorizeClusterSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeClusterSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AuthorizeClusterSecurityGroupIngressResult");
    return {
      ClusterSecurityGroup: xml.first("ClusterSecurityGroup", false, ClusterSecurityGroup_Parse),
    };
  }

  async authorizeSnapshotAccess(
    {abortSignal, ...params}: RequestConfig & AuthorizeSnapshotAccessMessage,
  ): Promise<AuthorizeSnapshotAccessResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+"SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
    body.append(prefix+"AccountWithRestoreAccess", (params["AccountWithRestoreAccess"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeSnapshotAccess",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AuthorizeSnapshotAccessResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async batchDeleteClusterSnapshots(
    {abortSignal, ...params}: RequestConfig & BatchDeleteClusterSnapshotsRequest,
  ): Promise<BatchDeleteClusterSnapshotsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identifiers"]) qsP.appendList(body, prefix+"Identifiers", params["Identifiers"], {"appender":DeleteClusterSnapshotMessage_Serialize,"entryPrefix":".DeleteClusterSnapshotMessage."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteClusterSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchDeleteClusterSnapshotsResult");
    return {
      Resources: xml.getList("Resources", "String").map(x => x.content ?? ''),
      Errors: xml.getList("Errors", "SnapshotErrorMessage").map(SnapshotErrorMessage_Parse),
    };
  }

  async batchModifyClusterSnapshots(
    {abortSignal, ...params}: RequestConfig & BatchModifyClusterSnapshotsMessage,
  ): Promise<BatchModifyClusterSnapshotsOutputMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["SnapshotIdentifierList"]) qsP.appendList(body, prefix+"SnapshotIdentifierList", params["SnapshotIdentifierList"], {"entryPrefix":".String."})
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchModifyClusterSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchModifyClusterSnapshotsResult");
    return {
      Resources: xml.getList("Resources", "String").map(x => x.content ?? ''),
      Errors: xml.getList("Errors", "SnapshotErrorMessage").map(SnapshotErrorMessage_Parse),
    };
  }

  async cancelResize(
    {abortSignal, ...params}: RequestConfig & CancelResizeMessage,
  ): Promise<ResizeProgressMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelResize",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CancelResizeResult");
    return {
      ...xml.strings({
        optional: {"TargetNodeType":true,"TargetClusterType":true,"Status":true,"ResizeType":true,"Message":true,"TargetEncryptionType":true},
      }),
      TargetNumberOfNodes: xml.first("TargetNumberOfNodes", false, x => parseInt(x.content ?? '0')),
      ImportTablesCompleted: xml.getList("ImportTablesCompleted", "member").map(x => x.content ?? ''),
      ImportTablesInProgress: xml.getList("ImportTablesInProgress", "member").map(x => x.content ?? ''),
      ImportTablesNotStarted: xml.getList("ImportTablesNotStarted", "member").map(x => x.content ?? ''),
      AvgResizeRateInMegaBytesPerSecond: xml.first("AvgResizeRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
      TotalResizeDataInMegaBytes: xml.first("TotalResizeDataInMegaBytes", false, x => parseInt(x.content ?? '0')),
      ProgressInMegaBytes: xml.first("ProgressInMegaBytes", false, x => parseInt(x.content ?? '0')),
      ElapsedTimeInSeconds: xml.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
      EstimatedTimeToCompletionInSeconds: xml.first("EstimatedTimeToCompletionInSeconds", false, x => parseInt(x.content ?? '0')),
      DataTransferProgressPercent: xml.first("DataTransferProgressPercent", false, x => parseFloat(x.content ?? '0')),
    };
  }

  async copyClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & CopyClusterSnapshotMessage,
  ): Promise<CopyClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceSnapshotIdentifier", (params["SourceSnapshotIdentifier"] ?? '').toString());
    if ("SourceSnapshotClusterIdentifier" in params) body.append(prefix+"SourceSnapshotClusterIdentifier", (params["SourceSnapshotClusterIdentifier"] ?? '').toString());
    body.append(prefix+"TargetSnapshotIdentifier", (params["TargetSnapshotIdentifier"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CopyClusterSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async createCluster(
    {abortSignal, ...params}: RequestConfig & CreateClusterMessage,
  ): Promise<CreateClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ClusterType" in params) body.append(prefix+"ClusterType", (params["ClusterType"] ?? '').toString());
    body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    body.append(prefix+"MasterUsername", (params["MasterUsername"] ?? '').toString());
    body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if (params["ClusterSecurityGroups"]) qsP.appendList(body, prefix+"ClusterSecurityGroups", params["ClusterSecurityGroups"], {"entryPrefix":".ClusterSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("ClusterSubnetGroupName" in params) body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("ClusterParameterGroupName" in params) body.append(prefix+"ClusterParameterGroupName", (params["ClusterParameterGroupName"] ?? '').toString());
    if ("AutomatedSnapshotRetentionPeriod" in params) body.append(prefix+"AutomatedSnapshotRetentionPeriod", (params["AutomatedSnapshotRetentionPeriod"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("ClusterVersion" in params) body.append(prefix+"ClusterVersion", (params["ClusterVersion"] ?? '').toString());
    if ("AllowVersionUpgrade" in params) body.append(prefix+"AllowVersionUpgrade", (params["AllowVersionUpgrade"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+"NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("HsmClientCertificateIdentifier" in params) body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if ("HsmConfigurationIdentifier" in params) body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    if ("ElasticIp" in params) body.append(prefix+"ElasticIp", (params["ElasticIp"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("EnhancedVpcRouting" in params) body.append(prefix+"EnhancedVpcRouting", (params["EnhancedVpcRouting"] ?? '').toString());
    if ("AdditionalInfo" in params) body.append(prefix+"AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    if (params["IamRoles"]) qsP.appendList(body, prefix+"IamRoles", params["IamRoles"], {"entryPrefix":".IamRoleArn."})
    if ("MaintenanceTrackName" in params) body.append(prefix+"MaintenanceTrackName", (params["MaintenanceTrackName"] ?? '').toString());
    if ("SnapshotScheduleIdentifier" in params) body.append(prefix+"SnapshotScheduleIdentifier", (params["SnapshotScheduleIdentifier"] ?? '').toString());
    if ("AvailabilityZoneRelocation" in params) body.append(prefix+"AvailabilityZoneRelocation", (params["AvailabilityZoneRelocation"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async createClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & CreateClusterParameterGroupMessage,
  ): Promise<CreateClusterParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    body.append(prefix+"ParameterGroupFamily", (params["ParameterGroupFamily"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterParameterGroupResult");
    return {
      ClusterParameterGroup: xml.first("ClusterParameterGroup", false, ClusterParameterGroup_Parse),
    };
  }

  async createClusterSecurityGroup(
    {abortSignal, ...params}: RequestConfig & CreateClusterSecurityGroupMessage,
  ): Promise<CreateClusterSecurityGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClusterSecurityGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterSecurityGroupResult");
    return {
      ClusterSecurityGroup: xml.first("ClusterSecurityGroup", false, ClusterSecurityGroup_Parse),
    };
  }

  async createClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & CreateClusterSnapshotMessage,
  ): Promise<CreateClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async createClusterSubnetGroup(
    {abortSignal, ...params}: RequestConfig & CreateClusterSubnetGroupMessage,
  ): Promise<CreateClusterSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClusterSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterSubnetGroupResult");
    return {
      ClusterSubnetGroup: xml.first("ClusterSubnetGroup", false, ClusterSubnetGroup_Parse),
    };
  }

  async createEventSubscription(
    {abortSignal, ...params}: RequestConfig & CreateEventSubscriptionMessage,
  ): Promise<CreateEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["SourceIds"]) qsP.appendList(body, prefix+"SourceIds", params["SourceIds"], {"entryPrefix":".SourceId."})
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if ("Severity" in params) body.append(prefix+"Severity", (params["Severity"] ?? '').toString());
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async createHsmClientCertificate(
    {abortSignal, ...params}: RequestConfig & CreateHsmClientCertificateMessage,
  ): Promise<CreateHsmClientCertificateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHsmClientCertificate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateHsmClientCertificateResult");
    return {
      HsmClientCertificate: xml.first("HsmClientCertificate", false, HsmClientCertificate_Parse),
    };
  }

  async createHsmConfiguration(
    {abortSignal, ...params}: RequestConfig & CreateHsmConfigurationMessage,
  ): Promise<CreateHsmConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    body.append(prefix+"HsmIpAddress", (params["HsmIpAddress"] ?? '').toString());
    body.append(prefix+"HsmPartitionName", (params["HsmPartitionName"] ?? '').toString());
    body.append(prefix+"HsmPartitionPassword", (params["HsmPartitionPassword"] ?? '').toString());
    body.append(prefix+"HsmServerPublicCertificate", (params["HsmServerPublicCertificate"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHsmConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateHsmConfigurationResult");
    return {
      HsmConfiguration: xml.first("HsmConfiguration", false, HsmConfiguration_Parse),
    };
  }

  async createScheduledAction(
    {abortSignal, ...params}: RequestConfig & CreateScheduledActionMessage,
  ): Promise<ScheduledAction> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    ScheduledActionType_Serialize(body, prefix+"TargetAction", params["TargetAction"]);
    body.append(prefix+"Schedule", (params["Schedule"] ?? '').toString());
    body.append(prefix+"IamRole", (params["IamRole"] ?? '').toString());
    if ("ScheduledActionDescription" in params) body.append(prefix+"ScheduledActionDescription", (params["ScheduledActionDescription"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Enable" in params) body.append(prefix+"Enable", (params["Enable"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateScheduledAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateScheduledActionResult");
    return ScheduledAction_Parse(xml);
  }

  async createSnapshotCopyGrant(
    {abortSignal, ...params}: RequestConfig & CreateSnapshotCopyGrantMessage,
  ): Promise<CreateSnapshotCopyGrantResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotCopyGrantName", (params["SnapshotCopyGrantName"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshotCopyGrant",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateSnapshotCopyGrantResult");
    return {
      SnapshotCopyGrant: xml.first("SnapshotCopyGrant", false, SnapshotCopyGrant_Parse),
    };
  }

  async createSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & CreateSnapshotScheduleMessage = {},
  ): Promise<SnapshotSchedule> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ScheduleDefinitions"]) qsP.appendList(body, prefix+"ScheduleDefinitions", params["ScheduleDefinitions"], {"entryPrefix":".ScheduleDefinition."})
    if ("ScheduleIdentifier" in params) body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    if ("ScheduleDescription" in params) body.append(prefix+"ScheduleDescription", (params["ScheduleDescription"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextInvocations" in params) body.append(prefix+"NextInvocations", (params["NextInvocations"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshotSchedule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateSnapshotScheduleResult");
    return SnapshotSchedule_Parse(xml);
  }

  async createTags(
    {abortSignal, ...params}: RequestConfig & CreateTagsMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTags",
    });
  }

  async createUsageLimit(
    {abortSignal, ...params}: RequestConfig & CreateUsageLimitMessage,
  ): Promise<UsageLimit> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"FeatureType", (params["FeatureType"] ?? '').toString());
    body.append(prefix+"LimitType", (params["LimitType"] ?? '').toString());
    body.append(prefix+"Amount", (params["Amount"] ?? '').toString());
    if ("Period" in params) body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if ("BreachAction" in params) body.append(prefix+"BreachAction", (params["BreachAction"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUsageLimit",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateUsageLimitResult");
    return UsageLimit_Parse(xml);
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & DeleteClusterMessage,
  ): Promise<DeleteClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("SkipFinalClusterSnapshot" in params) body.append(prefix+"SkipFinalClusterSnapshot", (params["SkipFinalClusterSnapshot"] ?? '').toString());
    if ("FinalClusterSnapshotIdentifier" in params) body.append(prefix+"FinalClusterSnapshotIdentifier", (params["FinalClusterSnapshotIdentifier"] ?? '').toString());
    if ("FinalClusterSnapshotRetentionPeriod" in params) body.append(prefix+"FinalClusterSnapshotRetentionPeriod", (params["FinalClusterSnapshotRetentionPeriod"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async deleteClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & DeleteClusterParameterGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClusterParameterGroup",
    });
  }

  async deleteClusterSecurityGroup(
    {abortSignal, ...params}: RequestConfig & DeleteClusterSecurityGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClusterSecurityGroup",
    });
  }

  async deleteClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & DeleteClusterSnapshotMessage,
  ): Promise<DeleteClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+"SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteClusterSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async deleteClusterSubnetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteClusterSubnetGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClusterSubnetGroup",
    });
  }

  async deleteEventSubscription(
    {abortSignal, ...params}: RequestConfig & DeleteEventSubscriptionMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventSubscription",
    });
  }

  async deleteHsmClientCertificate(
    {abortSignal, ...params}: RequestConfig & DeleteHsmClientCertificateMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteHsmClientCertificate",
    });
  }

  async deleteHsmConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteHsmConfigurationMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteHsmConfiguration",
    });
  }

  async deleteScheduledAction(
    {abortSignal, ...params}: RequestConfig & DeleteScheduledActionMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteScheduledAction",
    });
  }

  async deleteSnapshotCopyGrant(
    {abortSignal, ...params}: RequestConfig & DeleteSnapshotCopyGrantMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotCopyGrantName", (params["SnapshotCopyGrantName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshotCopyGrant",
    });
  }

  async deleteSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & DeleteSnapshotScheduleMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshotSchedule",
    });
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & DeleteTagsMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
  }

  async deleteUsageLimit(
    {abortSignal, ...params}: RequestConfig & DeleteUsageLimitMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UsageLimitId", (params["UsageLimitId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUsageLimit",
    });
  }

  async describeAccountAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeAccountAttributesMessage = {},
  ): Promise<AccountAttributeList> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AttributeNames"]) qsP.appendList(body, prefix+"AttributeNames", params["AttributeNames"], {"entryPrefix":".AttributeName."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAccountAttributesResult");
    return {
      AccountAttributes: xml.getList("AccountAttributes", "AccountAttribute").map(AccountAttribute_Parse),
    };
  }

  async describeClusterDbRevisions(
    {abortSignal, ...params}: RequestConfig & DescribeClusterDbRevisionsMessage = {},
  ): Promise<ClusterDbRevisionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterDbRevisions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterDbRevisionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ClusterDbRevisions: xml.getList("ClusterDbRevisions", "ClusterDbRevision").map(ClusterDbRevision_Parse),
    };
  }

  async describeClusterParameterGroups(
    {abortSignal, ...params}: RequestConfig & DescribeClusterParameterGroupsMessage = {},
  ): Promise<ClusterParameterGroupsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ParameterGroupName" in params) body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterParameterGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterParameterGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ParameterGroups: xml.getList("ParameterGroups", "ClusterParameterGroup").map(ClusterParameterGroup_Parse),
    };
  }

  async describeClusterParameters(
    {abortSignal, ...params}: RequestConfig & DescribeClusterParametersMessage,
  ): Promise<ClusterParameterGroupDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterParametersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Parameters: xml.getList("Parameters", "Parameter").map(Parameter_Parse),
    };
  }

  async describeClusterSecurityGroups(
    {abortSignal, ...params}: RequestConfig & DescribeClusterSecurityGroupsMessage = {},
  ): Promise<ClusterSecurityGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterSecurityGroupName" in params) body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterSecurityGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ClusterSecurityGroups: xml.getList("ClusterSecurityGroups", "ClusterSecurityGroup").map(ClusterSecurityGroup_Parse),
    };
  }

  async describeClusterSnapshots(
    {abortSignal, ...params}: RequestConfig & DescribeClusterSnapshotsMessage = {},
  ): Promise<SnapshotMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("SnapshotIdentifier" in params) body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotType" in params) body.append(prefix+"SnapshotType", (params["SnapshotType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("OwnerAccount" in params) body.append(prefix+"OwnerAccount", (params["OwnerAccount"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    if ("ClusterExists" in params) body.append(prefix+"ClusterExists", (params["ClusterExists"] ?? '').toString());
    if (params["SortingEntities"]) qsP.appendList(body, prefix+"SortingEntities", params["SortingEntities"], {"appender":SnapshotSortingEntity_Serialize,"entryPrefix":".SnapshotSortingEntity."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterSnapshotsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Snapshots: xml.getList("Snapshots", "Snapshot").map(Snapshot_Parse),
    };
  }

  async describeClusterSubnetGroups(
    {abortSignal, ...params}: RequestConfig & DescribeClusterSubnetGroupsMessage = {},
  ): Promise<ClusterSubnetGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterSubnetGroupName" in params) body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterSubnetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterSubnetGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ClusterSubnetGroups: xml.getList("ClusterSubnetGroups", "ClusterSubnetGroup").map(ClusterSubnetGroup_Parse),
    };
  }

  async describeClusterTracks(
    {abortSignal, ...params}: RequestConfig & DescribeClusterTracksMessage = {},
  ): Promise<TrackListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("MaintenanceTrackName" in params) body.append(prefix+"MaintenanceTrackName", (params["MaintenanceTrackName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterTracks",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterTracksResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      MaintenanceTracks: xml.getList("MaintenanceTracks", "MaintenanceTrack").map(MaintenanceTrack_Parse),
    };
  }

  async describeClusterVersions(
    {abortSignal, ...params}: RequestConfig & DescribeClusterVersionsMessage = {},
  ): Promise<ClusterVersionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterVersion" in params) body.append(prefix+"ClusterVersion", (params["ClusterVersion"] ?? '').toString());
    if ("ClusterParameterGroupFamily" in params) body.append(prefix+"ClusterParameterGroupFamily", (params["ClusterParameterGroupFamily"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ClusterVersions: xml.getList("ClusterVersions", "ClusterVersion").map(ClusterVersion_Parse),
    };
  }

  async describeClusters(
    {abortSignal, ...params}: RequestConfig & DescribeClustersMessage = {},
  ): Promise<ClustersMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClustersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Clusters: xml.getList("Clusters", "Cluster").map(Cluster_Parse),
    };
  }

  async describeDefaultClusterParameters(
    {abortSignal, ...params}: RequestConfig & DescribeDefaultClusterParametersMessage,
  ): Promise<DescribeDefaultClusterParametersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupFamily", (params["ParameterGroupFamily"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDefaultClusterParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDefaultClusterParametersResult");
    return {
      DefaultClusterParameters: xml.first("DefaultClusterParameters", false, DefaultClusterParameters_Parse),
    };
  }

  async describeEventCategories(
    {abortSignal, ...params}: RequestConfig & DescribeEventCategoriesMessage = {},
  ): Promise<EventCategoriesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventCategories",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventCategoriesResult");
    return {
      EventCategoriesMapList: xml.getList("EventCategoriesMapList", "EventCategoriesMap").map(EventCategoriesMap_Parse),
    };
  }

  async describeEventSubscriptions(
    {abortSignal, ...params}: RequestConfig & DescribeEventSubscriptionsMessage = {},
  ): Promise<EventSubscriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SubscriptionName" in params) body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventSubscriptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventSubscriptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      EventSubscriptionsList: xml.getList("EventSubscriptionsList", "EventSubscription").map(EventSubscription_Parse),
    };
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & DescribeEventsMessage = {},
  ): Promise<EventsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceIdentifier" in params) body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Events: xml.getList("Events", "Event").map(Event_Parse),
    };
  }

  async describeHsmClientCertificates(
    {abortSignal, ...params}: RequestConfig & DescribeHsmClientCertificatesMessage = {},
  ): Promise<HsmClientCertificateMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("HsmClientCertificateIdentifier" in params) body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHsmClientCertificates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeHsmClientCertificatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      HsmClientCertificates: xml.getList("HsmClientCertificates", "HsmClientCertificate").map(HsmClientCertificate_Parse),
    };
  }

  async describeHsmConfigurations(
    {abortSignal, ...params}: RequestConfig & DescribeHsmConfigurationsMessage = {},
  ): Promise<HsmConfigurationMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("HsmConfigurationIdentifier" in params) body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHsmConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeHsmConfigurationsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      HsmConfigurations: xml.getList("HsmConfigurations", "HsmConfiguration").map(HsmConfiguration_Parse),
    };
  }

  async describeLoggingStatus(
    {abortSignal, ...params}: RequestConfig & DescribeLoggingStatusMessage,
  ): Promise<LoggingStatus> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoggingStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLoggingStatusResult");
    return {
      ...xml.strings({
        optional: {"BucketName":true,"S3KeyPrefix":true,"LastFailureMessage":true},
      }),
      LoggingEnabled: xml.first("LoggingEnabled", false, x => x.content === 'true'),
      LastSuccessfulDeliveryTime: xml.first("LastSuccessfulDeliveryTime", false, x => xmlP.parseTimestamp(x.content)),
      LastFailureTime: xml.first("LastFailureTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeNodeConfigurationOptions(
    {abortSignal, ...params}: RequestConfig & DescribeNodeConfigurationOptionsMessage,
  ): Promise<NodeConfigurationOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ActionType", (params["ActionType"] ?? '').toString());
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("SnapshotIdentifier" in params) body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("OwnerAccount" in params) body.append(prefix+"OwnerAccount", (params["OwnerAccount"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":NodeConfigurationOptionsFilter_Serialize,"entryPrefix":".NodeConfigurationOptionsFilter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNodeConfigurationOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeNodeConfigurationOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      NodeConfigurationOptionList: xml.getList("NodeConfigurationOptionList", "NodeConfigurationOption").map(NodeConfigurationOption_Parse),
    };
  }

  async describeOrderableClusterOptions(
    {abortSignal, ...params}: RequestConfig & DescribeOrderableClusterOptionsMessage = {},
  ): Promise<OrderableClusterOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterVersion" in params) body.append(prefix+"ClusterVersion", (params["ClusterVersion"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOrderableClusterOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeOrderableClusterOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OrderableClusterOptions: xml.getList("OrderableClusterOptions", "OrderableClusterOption").map(OrderableClusterOption_Parse),
    };
  }

  async describeReservedNodeOfferings(
    {abortSignal, ...params}: RequestConfig & DescribeReservedNodeOfferingsMessage = {},
  ): Promise<ReservedNodeOfferingsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedNodeOfferingId" in params) body.append(prefix+"ReservedNodeOfferingId", (params["ReservedNodeOfferingId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedNodeOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedNodeOfferingsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedNodeOfferings: xml.getList("ReservedNodeOfferings", "ReservedNodeOffering").map(ReservedNodeOffering_Parse),
    };
  }

  async describeReservedNodes(
    {abortSignal, ...params}: RequestConfig & DescribeReservedNodesMessage = {},
  ): Promise<ReservedNodesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedNodeId" in params) body.append(prefix+"ReservedNodeId", (params["ReservedNodeId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedNodes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedNodesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedNodes: xml.getList("ReservedNodes", "ReservedNode").map(ReservedNode_Parse),
    };
  }

  async describeResize(
    {abortSignal, ...params}: RequestConfig & DescribeResizeMessage,
  ): Promise<ResizeProgressMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeResize",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeResizeResult");
    return {
      ...xml.strings({
        optional: {"TargetNodeType":true,"TargetClusterType":true,"Status":true,"ResizeType":true,"Message":true,"TargetEncryptionType":true},
      }),
      TargetNumberOfNodes: xml.first("TargetNumberOfNodes", false, x => parseInt(x.content ?? '0')),
      ImportTablesCompleted: xml.getList("ImportTablesCompleted", "member").map(x => x.content ?? ''),
      ImportTablesInProgress: xml.getList("ImportTablesInProgress", "member").map(x => x.content ?? ''),
      ImportTablesNotStarted: xml.getList("ImportTablesNotStarted", "member").map(x => x.content ?? ''),
      AvgResizeRateInMegaBytesPerSecond: xml.first("AvgResizeRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
      TotalResizeDataInMegaBytes: xml.first("TotalResizeDataInMegaBytes", false, x => parseInt(x.content ?? '0')),
      ProgressInMegaBytes: xml.first("ProgressInMegaBytes", false, x => parseInt(x.content ?? '0')),
      ElapsedTimeInSeconds: xml.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
      EstimatedTimeToCompletionInSeconds: xml.first("EstimatedTimeToCompletionInSeconds", false, x => parseInt(x.content ?? '0')),
      DataTransferProgressPercent: xml.first("DataTransferProgressPercent", false, x => parseFloat(x.content ?? '0')),
    };
  }

  async describeScheduledActions(
    {abortSignal, ...params}: RequestConfig & DescribeScheduledActionsMessage = {},
  ): Promise<ScheduledActionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ScheduledActionName" in params) body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    if ("TargetActionType" in params) body.append(prefix+"TargetActionType", (params["TargetActionType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Active" in params) body.append(prefix+"Active", (params["Active"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":ScheduledActionFilter_Serialize,"entryPrefix":".ScheduledActionFilter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScheduledActions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeScheduledActionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ScheduledActions: xml.getList("ScheduledActions", "ScheduledAction").map(ScheduledAction_Parse),
    };
  }

  async describeSnapshotCopyGrants(
    {abortSignal, ...params}: RequestConfig & DescribeSnapshotCopyGrantsMessage = {},
  ): Promise<SnapshotCopyGrantMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SnapshotCopyGrantName" in params) body.append(prefix+"SnapshotCopyGrantName", (params["SnapshotCopyGrantName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshotCopyGrants",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeSnapshotCopyGrantsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      SnapshotCopyGrants: xml.getList("SnapshotCopyGrants", "SnapshotCopyGrant").map(SnapshotCopyGrant_Parse),
    };
  }

  async describeSnapshotSchedules(
    {abortSignal, ...params}: RequestConfig & DescribeSnapshotSchedulesMessage = {},
  ): Promise<DescribeSnapshotSchedulesOutputMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ScheduleIdentifier" in params) body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshotSchedules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeSnapshotSchedulesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      SnapshotSchedules: xml.getList("SnapshotSchedules", "SnapshotSchedule").map(SnapshotSchedule_Parse),
    };
  }

  async describeStorage(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<CustomerStorageMessage> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeStorage",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStorageResult");
    return {
      TotalBackupSizeInMegaBytes: xml.first("TotalBackupSizeInMegaBytes", false, x => parseFloat(x.content ?? '0')),
      TotalProvisionedStorageInMegaBytes: xml.first("TotalProvisionedStorageInMegaBytes", false, x => parseFloat(x.content ?? '0')),
    };
  }

  async describeTableRestoreStatus(
    {abortSignal, ...params}: RequestConfig & DescribeTableRestoreStatusMessage = {},
  ): Promise<TableRestoreStatusMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("TableRestoreRequestId" in params) body.append(prefix+"TableRestoreRequestId", (params["TableRestoreRequestId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTableRestoreStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTableRestoreStatusResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      TableRestoreStatusDetails: xml.getList("TableRestoreStatusDetails", "TableRestoreStatus").map(TableRestoreStatus_Parse),
    };
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & DescribeTagsMessage = {},
  ): Promise<TaggedResourceListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ResourceName" in params) body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if ("ResourceType" in params) body.append(prefix+"ResourceType", (params["ResourceType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTagsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      TaggedResources: xml.getList("TaggedResources", "TaggedResource").map(TaggedResource_Parse),
    };
  }

  async describeUsageLimits(
    {abortSignal, ...params}: RequestConfig & DescribeUsageLimitsMessage = {},
  ): Promise<UsageLimitList> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UsageLimitId" in params) body.append(prefix+"UsageLimitId", (params["UsageLimitId"] ?? '').toString());
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("FeatureType" in params) body.append(prefix+"FeatureType", (params["FeatureType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUsageLimits",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeUsageLimitsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      UsageLimits: xml.getList("UsageLimits", "member").map(UsageLimit_Parse),
    };
  }

  async disableLogging(
    {abortSignal, ...params}: RequestConfig & DisableLoggingMessage,
  ): Promise<LoggingStatus> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableLogging",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DisableLoggingResult");
    return {
      ...xml.strings({
        optional: {"BucketName":true,"S3KeyPrefix":true,"LastFailureMessage":true},
      }),
      LoggingEnabled: xml.first("LoggingEnabled", false, x => x.content === 'true'),
      LastSuccessfulDeliveryTime: xml.first("LastSuccessfulDeliveryTime", false, x => xmlP.parseTimestamp(x.content)),
      LastFailureTime: xml.first("LastFailureTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async disableSnapshotCopy(
    {abortSignal, ...params}: RequestConfig & DisableSnapshotCopyMessage,
  ): Promise<DisableSnapshotCopyResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableSnapshotCopy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DisableSnapshotCopyResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async enableLogging(
    {abortSignal, ...params}: RequestConfig & EnableLoggingMessage,
  ): Promise<LoggingStatus> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"BucketName", (params["BucketName"] ?? '').toString());
    if ("S3KeyPrefix" in params) body.append(prefix+"S3KeyPrefix", (params["S3KeyPrefix"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableLogging",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EnableLoggingResult");
    return {
      ...xml.strings({
        optional: {"BucketName":true,"S3KeyPrefix":true,"LastFailureMessage":true},
      }),
      LoggingEnabled: xml.first("LoggingEnabled", false, x => x.content === 'true'),
      LastSuccessfulDeliveryTime: xml.first("LastSuccessfulDeliveryTime", false, x => xmlP.parseTimestamp(x.content)),
      LastFailureTime: xml.first("LastFailureTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async enableSnapshotCopy(
    {abortSignal, ...params}: RequestConfig & EnableSnapshotCopyMessage,
  ): Promise<EnableSnapshotCopyResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"DestinationRegion", (params["DestinationRegion"] ?? '').toString());
    if ("RetentionPeriod" in params) body.append(prefix+"RetentionPeriod", (params["RetentionPeriod"] ?? '').toString());
    if ("SnapshotCopyGrantName" in params) body.append(prefix+"SnapshotCopyGrantName", (params["SnapshotCopyGrantName"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableSnapshotCopy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EnableSnapshotCopyResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async getClusterCredentials(
    {abortSignal, ...params}: RequestConfig & GetClusterCredentialsMessage,
  ): Promise<ClusterCredentials> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DbUser", (params["DbUser"] ?? '').toString());
    if ("DbName" in params) body.append(prefix+"DbName", (params["DbName"] ?? '').toString());
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("DurationSeconds" in params) body.append(prefix+"DurationSeconds", (params["DurationSeconds"] ?? '').toString());
    if ("AutoCreate" in params) body.append(prefix+"AutoCreate", (params["AutoCreate"] ?? '').toString());
    if (params["DbGroups"]) qsP.appendList(body, prefix+"DbGroups", params["DbGroups"], {"entryPrefix":".DbGroup."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetClusterCredentials",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetClusterCredentialsResult");
    return {
      ...xml.strings({
        optional: {"DbUser":true,"DbPassword":true},
      }),
      Expiration: xml.first("Expiration", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getReservedNodeExchangeOfferings(
    {abortSignal, ...params}: RequestConfig & GetReservedNodeExchangeOfferingsInputMessage,
  ): Promise<GetReservedNodeExchangeOfferingsOutputMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedNodeId", (params["ReservedNodeId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservedNodeExchangeOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetReservedNodeExchangeOfferingsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedNodeOfferings: xml.getList("ReservedNodeOfferings", "ReservedNodeOffering").map(ReservedNodeOffering_Parse),
    };
  }

  async modifyCluster(
    {abortSignal, ...params}: RequestConfig & ModifyClusterMessage,
  ): Promise<ModifyClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ClusterType" in params) body.append(prefix+"ClusterType", (params["ClusterType"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+"NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if (params["ClusterSecurityGroups"]) qsP.appendList(body, prefix+"ClusterSecurityGroups", params["ClusterSecurityGroups"], {"entryPrefix":".ClusterSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("ClusterParameterGroupName" in params) body.append(prefix+"ClusterParameterGroupName", (params["ClusterParameterGroupName"] ?? '').toString());
    if ("AutomatedSnapshotRetentionPeriod" in params) body.append(prefix+"AutomatedSnapshotRetentionPeriod", (params["AutomatedSnapshotRetentionPeriod"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("ClusterVersion" in params) body.append(prefix+"ClusterVersion", (params["ClusterVersion"] ?? '').toString());
    if ("AllowVersionUpgrade" in params) body.append(prefix+"AllowVersionUpgrade", (params["AllowVersionUpgrade"] ?? '').toString());
    if ("HsmClientCertificateIdentifier" in params) body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if ("HsmConfigurationIdentifier" in params) body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    if ("NewClusterIdentifier" in params) body.append(prefix+"NewClusterIdentifier", (params["NewClusterIdentifier"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("ElasticIp" in params) body.append(prefix+"ElasticIp", (params["ElasticIp"] ?? '').toString());
    if ("EnhancedVpcRouting" in params) body.append(prefix+"EnhancedVpcRouting", (params["EnhancedVpcRouting"] ?? '').toString());
    if ("MaintenanceTrackName" in params) body.append(prefix+"MaintenanceTrackName", (params["MaintenanceTrackName"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("AvailabilityZoneRelocation" in params) body.append(prefix+"AvailabilityZoneRelocation", (params["AvailabilityZoneRelocation"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifyClusterDbRevision(
    {abortSignal, ...params}: RequestConfig & ModifyClusterDbRevisionMessage,
  ): Promise<ModifyClusterDbRevisionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"RevisionTarget", (params["RevisionTarget"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterDbRevision",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterDbRevisionResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifyClusterIamRoles(
    {abortSignal, ...params}: RequestConfig & ModifyClusterIamRolesMessage,
  ): Promise<ModifyClusterIamRolesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if (params["AddIamRoles"]) qsP.appendList(body, prefix+"AddIamRoles", params["AddIamRoles"], {"entryPrefix":".IamRoleArn."})
    if (params["RemoveIamRoles"]) qsP.appendList(body, prefix+"RemoveIamRoles", params["RemoveIamRoles"], {"entryPrefix":".IamRoleArn."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterIamRoles",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterIamRolesResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifyClusterMaintenance(
    {abortSignal, ...params}: RequestConfig & ModifyClusterMaintenanceMessage,
  ): Promise<ModifyClusterMaintenanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("DeferMaintenance" in params) body.append(prefix+"DeferMaintenance", (params["DeferMaintenance"] ?? '').toString());
    if ("DeferMaintenanceIdentifier" in params) body.append(prefix+"DeferMaintenanceIdentifier", (params["DeferMaintenanceIdentifier"] ?? '').toString());
    if ("DeferMaintenanceStartTime" in params) body.append(prefix+"DeferMaintenanceStartTime", qsP.encodeDate_iso8601(params["DeferMaintenanceStartTime"]));
    if ("DeferMaintenanceEndTime" in params) body.append(prefix+"DeferMaintenanceEndTime", qsP.encodeDate_iso8601(params["DeferMaintenanceEndTime"]));
    if ("DeferMaintenanceDuration" in params) body.append(prefix+"DeferMaintenanceDuration", (params["DeferMaintenanceDuration"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterMaintenance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterMaintenanceResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifyClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & ModifyClusterParameterGroupMessage,
  ): Promise<ClusterParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterParameterGroupResult");
    return xml.strings({
      optional: {"ParameterGroupName":true,"ParameterGroupStatus":true},
    });
  }

  async modifyClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & ModifyClusterSnapshotMessage,
  ): Promise<ModifyClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async modifyClusterSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & ModifyClusterSnapshotScheduleMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ScheduleIdentifier" in params) body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    if ("DisassociateSchedule" in params) body.append(prefix+"DisassociateSchedule", (params["DisassociateSchedule"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterSnapshotSchedule",
    });
  }

  async modifyClusterSubnetGroup(
    {abortSignal, ...params}: RequestConfig & ModifyClusterSubnetGroupMessage,
  ): Promise<ModifyClusterSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterSubnetGroupResult");
    return {
      ClusterSubnetGroup: xml.first("ClusterSubnetGroup", false, ClusterSubnetGroup_Parse),
    };
  }

  async modifyEventSubscription(
    {abortSignal, ...params}: RequestConfig & ModifyEventSubscriptionMessage,
  ): Promise<ModifyEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if ("SnsTopicArn" in params) body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["SourceIds"]) qsP.appendList(body, prefix+"SourceIds", params["SourceIds"], {"entryPrefix":".SourceId."})
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if ("Severity" in params) body.append(prefix+"Severity", (params["Severity"] ?? '').toString());
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async modifyScheduledAction(
    {abortSignal, ...params}: RequestConfig & ModifyScheduledActionMessage,
  ): Promise<ScheduledAction> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    if (params["TargetAction"] != null) ScheduledActionType_Serialize(body, prefix+"TargetAction", params["TargetAction"]);
    if ("Schedule" in params) body.append(prefix+"Schedule", (params["Schedule"] ?? '').toString());
    if ("IamRole" in params) body.append(prefix+"IamRole", (params["IamRole"] ?? '').toString());
    if ("ScheduledActionDescription" in params) body.append(prefix+"ScheduledActionDescription", (params["ScheduledActionDescription"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Enable" in params) body.append(prefix+"Enable", (params["Enable"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyScheduledAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyScheduledActionResult");
    return ScheduledAction_Parse(xml);
  }

  async modifySnapshotCopyRetentionPeriod(
    {abortSignal, ...params}: RequestConfig & ModifySnapshotCopyRetentionPeriodMessage,
  ): Promise<ModifySnapshotCopyRetentionPeriodResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"RetentionPeriod", (params["RetentionPeriod"] ?? '').toString());
    if ("Manual" in params) body.append(prefix+"Manual", (params["Manual"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySnapshotCopyRetentionPeriod",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifySnapshotCopyRetentionPeriodResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifySnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & ModifySnapshotScheduleMessage,
  ): Promise<SnapshotSchedule> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    if (params["ScheduleDefinitions"]) qsP.appendList(body, prefix+"ScheduleDefinitions", params["ScheduleDefinitions"], {"entryPrefix":".ScheduleDefinition."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySnapshotSchedule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifySnapshotScheduleResult");
    return SnapshotSchedule_Parse(xml);
  }

  async modifyUsageLimit(
    {abortSignal, ...params}: RequestConfig & ModifyUsageLimitMessage,
  ): Promise<UsageLimit> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UsageLimitId", (params["UsageLimitId"] ?? '').toString());
    if ("Amount" in params) body.append(prefix+"Amount", (params["Amount"] ?? '').toString());
    if ("BreachAction" in params) body.append(prefix+"BreachAction", (params["BreachAction"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyUsageLimit",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyUsageLimitResult");
    return UsageLimit_Parse(xml);
  }

  async pauseCluster(
    {abortSignal, ...params}: RequestConfig & PauseClusterMessage,
  ): Promise<PauseClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PauseCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PauseClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async purchaseReservedNodeOffering(
    {abortSignal, ...params}: RequestConfig & PurchaseReservedNodeOfferingMessage,
  ): Promise<PurchaseReservedNodeOfferingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedNodeOfferingId", (params["ReservedNodeOfferingId"] ?? '').toString());
    if ("NodeCount" in params) body.append(prefix+"NodeCount", (params["NodeCount"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedNodeOffering",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PurchaseReservedNodeOfferingResult");
    return {
      ReservedNode: xml.first("ReservedNode", false, ReservedNode_Parse),
    };
  }

  async rebootCluster(
    {abortSignal, ...params}: RequestConfig & RebootClusterMessage,
  ): Promise<RebootClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RebootClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async resetClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & ResetClusterParameterGroupMessage,
  ): Promise<ClusterParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    if ("ResetAllParameters" in params) body.append(prefix+"ResetAllParameters", (params["ResetAllParameters"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResetClusterParameterGroupResult");
    return xml.strings({
      optional: {"ParameterGroupName":true,"ParameterGroupStatus":true},
    });
  }

  async resizeCluster(
    {abortSignal, ...params}: RequestConfig & ResizeClusterMessage,
  ): Promise<ResizeClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ClusterType" in params) body.append(prefix+"ClusterType", (params["ClusterType"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+"NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if ("Classic" in params) body.append(prefix+"Classic", (params["Classic"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResizeCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResizeClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async restoreFromClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & RestoreFromClusterSnapshotMessage,
  ): Promise<RestoreFromClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+"SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("AllowVersionUpgrade" in params) body.append(prefix+"AllowVersionUpgrade", (params["AllowVersionUpgrade"] ?? '').toString());
    if ("ClusterSubnetGroupName" in params) body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("OwnerAccount" in params) body.append(prefix+"OwnerAccount", (params["OwnerAccount"] ?? '').toString());
    if ("HsmClientCertificateIdentifier" in params) body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if ("HsmConfigurationIdentifier" in params) body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    if ("ElasticIp" in params) body.append(prefix+"ElasticIp", (params["ElasticIp"] ?? '').toString());
    if ("ClusterParameterGroupName" in params) body.append(prefix+"ClusterParameterGroupName", (params["ClusterParameterGroupName"] ?? '').toString());
    if (params["ClusterSecurityGroups"]) qsP.appendList(body, prefix+"ClusterSecurityGroups", params["ClusterSecurityGroups"], {"entryPrefix":".ClusterSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("AutomatedSnapshotRetentionPeriod" in params) body.append(prefix+"AutomatedSnapshotRetentionPeriod", (params["AutomatedSnapshotRetentionPeriod"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    if ("EnhancedVpcRouting" in params) body.append(prefix+"EnhancedVpcRouting", (params["EnhancedVpcRouting"] ?? '').toString());
    if ("AdditionalInfo" in params) body.append(prefix+"AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    if (params["IamRoles"]) qsP.appendList(body, prefix+"IamRoles", params["IamRoles"], {"entryPrefix":".IamRoleArn."})
    if ("MaintenanceTrackName" in params) body.append(prefix+"MaintenanceTrackName", (params["MaintenanceTrackName"] ?? '').toString());
    if ("SnapshotScheduleIdentifier" in params) body.append(prefix+"SnapshotScheduleIdentifier", (params["SnapshotScheduleIdentifier"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+"NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if ("AvailabilityZoneRelocation" in params) body.append(prefix+"AvailabilityZoneRelocation", (params["AvailabilityZoneRelocation"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreFromClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreFromClusterSnapshotResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async restoreTableFromClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & RestoreTableFromClusterSnapshotMessage,
  ): Promise<RestoreTableFromClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"SourceDatabaseName", (params["SourceDatabaseName"] ?? '').toString());
    if ("SourceSchemaName" in params) body.append(prefix+"SourceSchemaName", (params["SourceSchemaName"] ?? '').toString());
    body.append(prefix+"SourceTableName", (params["SourceTableName"] ?? '').toString());
    if ("TargetDatabaseName" in params) body.append(prefix+"TargetDatabaseName", (params["TargetDatabaseName"] ?? '').toString());
    if ("TargetSchemaName" in params) body.append(prefix+"TargetSchemaName", (params["TargetSchemaName"] ?? '').toString());
    body.append(prefix+"NewTableName", (params["NewTableName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreTableFromClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreTableFromClusterSnapshotResult");
    return {
      TableRestoreStatus: xml.first("TableRestoreStatus", false, TableRestoreStatus_Parse),
    };
  }

  async resumeCluster(
    {abortSignal, ...params}: RequestConfig & ResumeClusterMessage,
  ): Promise<ResumeClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResumeCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResumeClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async revokeClusterSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & RevokeClusterSecurityGroupIngressMessage,
  ): Promise<RevokeClusterSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeClusterSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RevokeClusterSecurityGroupIngressResult");
    return {
      ClusterSecurityGroup: xml.first("ClusterSecurityGroup", false, ClusterSecurityGroup_Parse),
    };
  }

  async revokeSnapshotAccess(
    {abortSignal, ...params}: RequestConfig & RevokeSnapshotAccessMessage,
  ): Promise<RevokeSnapshotAccessResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+"SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
    body.append(prefix+"AccountWithRestoreAccess", (params["AccountWithRestoreAccess"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeSnapshotAccess",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RevokeSnapshotAccessResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async rotateEncryptionKey(
    {abortSignal, ...params}: RequestConfig & RotateEncryptionKeyMessage,
  ): Promise<RotateEncryptionKeyResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RotateEncryptionKey",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RotateEncryptionKeyResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 30 times, 60 seconds apart (about 30 minutes max wait time). */
  async waitForClusterAvailable(
    params: RequestConfig & DescribeClustersMessage,
  ): Promise<ClustersMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterAvailable';
    for (let i = 0; i < 30; i++) {
      try {
        const resp = await this.describeClusters(params);
        const field = resp?.Clusters?.flatMap(x => x?.ClusterStatus);
        if (field?.every(x => x === "available")) return resp;
        if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      } catch (err) {
        if (!["ClusterNotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 30 times, 60 seconds apart (about 30 minutes max wait time). */
  async waitForClusterDeleted(
    params: RequestConfig & DescribeClustersMessage,
  ): Promise<Error | ClustersMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterDeleted';
    for (let i = 0; i < 30; i++) {
      try {
        const resp = await this.describeClusters(params);
        const field = resp?.Clusters?.flatMap(x => x?.ClusterStatus);
        if (field?.some(x => x === "creating")) throw new Error(errMessage);
        if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      } catch (err) {
        if (["ClusterNotFound"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 30 times, 60 seconds apart (about 30 minutes max wait time). */
  async waitForClusterRestored(
    params: RequestConfig & DescribeClustersMessage,
  ): Promise<ClustersMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterRestored';
    for (let i = 0; i < 30; i++) {
      const resp = await this.describeClusters(params);
      if (resp?.Clusters?.flatMap(x => x?.RestoreStatus?.Status)?.every(x => x === "completed")) return resp;
      if (resp?.Clusters?.flatMap(x => x?.ClusterStatus)?.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 15 seconds apart (about 5 minutes max wait time). */
  async waitForSnapshotAvailable(
    params: RequestConfig & DescribeClusterSnapshotsMessage,
  ): Promise<SnapshotMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SnapshotAvailable';
    for (let i = 0; i < 20; i++) {
      const resp = await this.describeClusterSnapshots(params);
      const field = resp?.Snapshots?.flatMap(x => x?.Status);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AcceptReservedNodeExchangeInputMessage {
  ReservedNodeId: string;
  TargetReservedNodeOfferingId: string;
}

// refs: 1 - tags: named, input
export interface AuthorizeClusterSecurityGroupIngressMessage {
  ClusterSecurityGroupName: string;
  CIDRIP?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
}

// refs: 1 - tags: named, input
export interface AuthorizeSnapshotAccessMessage {
  SnapshotIdentifier: string;
  SnapshotClusterIdentifier?: string | null;
  AccountWithRestoreAccess: string;
}

// refs: 1 - tags: named, input
export interface BatchDeleteClusterSnapshotsRequest {
  Identifiers: DeleteClusterSnapshotMessage[];
}

// refs: 1 - tags: named, input
export interface BatchModifyClusterSnapshotsMessage {
  SnapshotIdentifierList: string[];
  ManualSnapshotRetentionPeriod?: number | null;
  Force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CancelResizeMessage {
  ClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface CopyClusterSnapshotMessage {
  SourceSnapshotIdentifier: string;
  SourceSnapshotClusterIdentifier?: string | null;
  TargetSnapshotIdentifier: string;
  ManualSnapshotRetentionPeriod?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateClusterMessage {
  DBName?: string | null;
  ClusterIdentifier: string;
  ClusterType?: string | null;
  NodeType: string;
  MasterUsername: string;
  MasterUserPassword: string;
  ClusterSecurityGroups?: string[] | null;
  VpcSecurityGroupIds?: string[] | null;
  ClusterSubnetGroupName?: string | null;
  AvailabilityZone?: string | null;
  PreferredMaintenanceWindow?: string | null;
  ClusterParameterGroupName?: string | null;
  AutomatedSnapshotRetentionPeriod?: number | null;
  ManualSnapshotRetentionPeriod?: number | null;
  Port?: number | null;
  ClusterVersion?: string | null;
  AllowVersionUpgrade?: boolean | null;
  NumberOfNodes?: number | null;
  PubliclyAccessible?: boolean | null;
  Encrypted?: boolean | null;
  HsmClientCertificateIdentifier?: string | null;
  HsmConfigurationIdentifier?: string | null;
  ElasticIp?: string | null;
  Tags?: Tag[] | null;
  KmsKeyId?: string | null;
  EnhancedVpcRouting?: boolean | null;
  AdditionalInfo?: string | null;
  IamRoles?: string[] | null;
  MaintenanceTrackName?: string | null;
  SnapshotScheduleIdentifier?: string | null;
  AvailabilityZoneRelocation?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateClusterParameterGroupMessage {
  ParameterGroupName: string;
  ParameterGroupFamily: string;
  Description: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateClusterSecurityGroupMessage {
  ClusterSecurityGroupName: string;
  Description: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateClusterSnapshotMessage {
  SnapshotIdentifier: string;
  ClusterIdentifier: string;
  ManualSnapshotRetentionPeriod?: number | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateClusterSubnetGroupMessage {
  ClusterSubnetGroupName: string;
  Description: string;
  SubnetIds: string[];
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateEventSubscriptionMessage {
  SubscriptionName: string;
  SnsTopicArn: string;
  SourceType?: string | null;
  SourceIds?: string[] | null;
  EventCategories?: string[] | null;
  Severity?: string | null;
  Enabled?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateHsmClientCertificateMessage {
  HsmClientCertificateIdentifier: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateHsmConfigurationMessage {
  HsmConfigurationIdentifier: string;
  Description: string;
  HsmIpAddress: string;
  HsmPartitionName: string;
  HsmPartitionPassword: string;
  HsmServerPublicCertificate: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateScheduledActionMessage {
  ScheduledActionName: string;
  TargetAction: ScheduledActionType;
  Schedule: string;
  IamRole: string;
  ScheduledActionDescription?: string | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Enable?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateSnapshotCopyGrantMessage {
  SnapshotCopyGrantName: string;
  KmsKeyId?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateSnapshotScheduleMessage {
  ScheduleDefinitions?: string[] | null;
  ScheduleIdentifier?: string | null;
  ScheduleDescription?: string | null;
  Tags?: Tag[] | null;
  DryRun?: boolean | null;
  NextInvocations?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateTagsMessage {
  ResourceName: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface CreateUsageLimitMessage {
  ClusterIdentifier: string;
  FeatureType: UsageLimitFeatureType;
  LimitType: UsageLimitLimitType;
  Amount: number;
  Period?: UsageLimitPeriod | null;
  BreachAction?: UsageLimitBreachAction | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteClusterMessage {
  ClusterIdentifier: string;
  SkipFinalClusterSnapshot?: boolean | null;
  FinalClusterSnapshotIdentifier?: string | null;
  FinalClusterSnapshotRetentionPeriod?: number | null;
}

// refs: 1 - tags: named, input
export interface DeleteClusterParameterGroupMessage {
  ParameterGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteClusterSecurityGroupMessage {
  ClusterSecurityGroupName: string;
}

// refs: 2 - tags: input, named, interface
export interface DeleteClusterSnapshotMessage {
  SnapshotIdentifier: string;
  SnapshotClusterIdentifier?: string | null;
}
function DeleteClusterSnapshotMessage_Serialize(body: URLSearchParams, prefix: string, params: DeleteClusterSnapshotMessage) {
    body.append(prefix+".SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+".SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
}

// refs: 1 - tags: named, input
export interface DeleteClusterSubnetGroupMessage {
  ClusterSubnetGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteEventSubscriptionMessage {
  SubscriptionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteHsmClientCertificateMessage {
  HsmClientCertificateIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteHsmConfigurationMessage {
  HsmConfigurationIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteScheduledActionMessage {
  ScheduledActionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteSnapshotCopyGrantMessage {
  SnapshotCopyGrantName: string;
}

// refs: 1 - tags: named, input
export interface DeleteSnapshotScheduleMessage {
  ScheduleIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteTagsMessage {
  ResourceName: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface DeleteUsageLimitMessage {
  UsageLimitId: string;
}

// refs: 1 - tags: named, input
export interface DescribeAccountAttributesMessage {
  AttributeNames?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeClusterDbRevisionsMessage {
  ClusterIdentifier?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeClusterParameterGroupsMessage {
  ParameterGroupName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeClusterParametersMessage {
  ParameterGroupName: string;
  Source?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeClusterSecurityGroupsMessage {
  ClusterSecurityGroupName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeClusterSnapshotsMessage {
  ClusterIdentifier?: string | null;
  SnapshotIdentifier?: string | null;
  SnapshotType?: string | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  OwnerAccount?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
  ClusterExists?: boolean | null;
  SortingEntities?: SnapshotSortingEntity[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeClusterSubnetGroupsMessage {
  ClusterSubnetGroupName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeClusterTracksMessage {
  MaintenanceTrackName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeClusterVersionsMessage {
  ClusterVersion?: string | null;
  ClusterParameterGroupFamily?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeClustersMessage {
  ClusterIdentifier?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeDefaultClusterParametersMessage {
  ParameterGroupFamily: string;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventCategoriesMessage {
  SourceType?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventSubscriptionsMessage {
  SubscriptionName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventsMessage {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Duration?: number | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeHsmClientCertificatesMessage {
  HsmClientCertificateIdentifier?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeHsmConfigurationsMessage {
  HsmConfigurationIdentifier?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeLoggingStatusMessage {
  ClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DescribeNodeConfigurationOptionsMessage {
  ActionType: ActionType;
  ClusterIdentifier?: string | null;
  SnapshotIdentifier?: string | null;
  OwnerAccount?: string | null;
  Filters?: NodeConfigurationOptionsFilter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeOrderableClusterOptionsMessage {
  ClusterVersion?: string | null;
  NodeType?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedNodeOfferingsMessage {
  ReservedNodeOfferingId?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedNodesMessage {
  ReservedNodeId?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeResizeMessage {
  ClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DescribeScheduledActionsMessage {
  ScheduledActionName?: string | null;
  TargetActionType?: ScheduledActionTypeValues | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Active?: boolean | null;
  Filters?: ScheduledActionFilter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeSnapshotCopyGrantsMessage {
  SnapshotCopyGrantName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeSnapshotSchedulesMessage {
  ClusterIdentifier?: string | null;
  ScheduleIdentifier?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTableRestoreStatusMessage {
  ClusterIdentifier?: string | null;
  TableRestoreRequestId?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeTagsMessage {
  ResourceName?: string | null;
  ResourceType?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeUsageLimitsMessage {
  UsageLimitId?: string | null;
  ClusterIdentifier?: string | null;
  FeatureType?: UsageLimitFeatureType | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  TagKeys?: string[] | null;
  TagValues?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DisableLoggingMessage {
  ClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DisableSnapshotCopyMessage {
  ClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface EnableLoggingMessage {
  ClusterIdentifier: string;
  BucketName: string;
  S3KeyPrefix?: string | null;
}

// refs: 1 - tags: named, input
export interface EnableSnapshotCopyMessage {
  ClusterIdentifier: string;
  DestinationRegion: string;
  RetentionPeriod?: number | null;
  SnapshotCopyGrantName?: string | null;
  ManualSnapshotRetentionPeriod?: number | null;
}

// refs: 1 - tags: named, input
export interface GetClusterCredentialsMessage {
  DbUser: string;
  DbName?: string | null;
  ClusterIdentifier: string;
  DurationSeconds?: number | null;
  AutoCreate?: boolean | null;
  DbGroups?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GetReservedNodeExchangeOfferingsInputMessage {
  ReservedNodeId: string;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyClusterMessage {
  ClusterIdentifier: string;
  ClusterType?: string | null;
  NodeType?: string | null;
  NumberOfNodes?: number | null;
  ClusterSecurityGroups?: string[] | null;
  VpcSecurityGroupIds?: string[] | null;
  MasterUserPassword?: string | null;
  ClusterParameterGroupName?: string | null;
  AutomatedSnapshotRetentionPeriod?: number | null;
  ManualSnapshotRetentionPeriod?: number | null;
  PreferredMaintenanceWindow?: string | null;
  ClusterVersion?: string | null;
  AllowVersionUpgrade?: boolean | null;
  HsmClientCertificateIdentifier?: string | null;
  HsmConfigurationIdentifier?: string | null;
  NewClusterIdentifier?: string | null;
  PubliclyAccessible?: boolean | null;
  ElasticIp?: string | null;
  EnhancedVpcRouting?: boolean | null;
  MaintenanceTrackName?: string | null;
  Encrypted?: boolean | null;
  KmsKeyId?: string | null;
  AvailabilityZoneRelocation?: boolean | null;
  AvailabilityZone?: string | null;
  Port?: number | null;
}

// refs: 1 - tags: named, input
export interface ModifyClusterDbRevisionMessage {
  ClusterIdentifier: string;
  RevisionTarget: string;
}

// refs: 1 - tags: named, input
export interface ModifyClusterIamRolesMessage {
  ClusterIdentifier: string;
  AddIamRoles?: string[] | null;
  RemoveIamRoles?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyClusterMaintenanceMessage {
  ClusterIdentifier: string;
  DeferMaintenance?: boolean | null;
  DeferMaintenanceIdentifier?: string | null;
  DeferMaintenanceStartTime?: Date | number | null;
  DeferMaintenanceEndTime?: Date | number | null;
  DeferMaintenanceDuration?: number | null;
}

// refs: 1 - tags: named, input
export interface ModifyClusterParameterGroupMessage {
  ParameterGroupName: string;
  Parameters: Parameter[];
}

// refs: 1 - tags: named, input
export interface ModifyClusterSnapshotMessage {
  SnapshotIdentifier: string;
  ManualSnapshotRetentionPeriod?: number | null;
  Force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyClusterSnapshotScheduleMessage {
  ClusterIdentifier: string;
  ScheduleIdentifier?: string | null;
  DisassociateSchedule?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyClusterSubnetGroupMessage {
  ClusterSubnetGroupName: string;
  Description?: string | null;
  SubnetIds: string[];
}

// refs: 1 - tags: named, input
export interface ModifyEventSubscriptionMessage {
  SubscriptionName: string;
  SnsTopicArn?: string | null;
  SourceType?: string | null;
  SourceIds?: string[] | null;
  EventCategories?: string[] | null;
  Severity?: string | null;
  Enabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyScheduledActionMessage {
  ScheduledActionName: string;
  TargetAction?: ScheduledActionType | null;
  Schedule?: string | null;
  IamRole?: string | null;
  ScheduledActionDescription?: string | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Enable?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifySnapshotCopyRetentionPeriodMessage {
  ClusterIdentifier: string;
  RetentionPeriod: number;
  Manual?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifySnapshotScheduleMessage {
  ScheduleIdentifier: string;
  ScheduleDefinitions: string[];
}

// refs: 1 - tags: named, input
export interface ModifyUsageLimitMessage {
  UsageLimitId: string;
  Amount?: number | null;
  BreachAction?: UsageLimitBreachAction | null;
}

// refs: 5 - tags: input, named, interface, output
export interface PauseClusterMessage {
  ClusterIdentifier: string;
}
function PauseClusterMessage_Serialize(body: URLSearchParams, prefix: string, params: PauseClusterMessage) {
    body.append(prefix+".ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
}
function PauseClusterMessage_Parse(node: xmlP.XmlNode): PauseClusterMessage {
  return node.strings({
    required: {"ClusterIdentifier":true},
  });
}

// refs: 1 - tags: named, input
export interface PurchaseReservedNodeOfferingMessage {
  ReservedNodeOfferingId: string;
  NodeCount?: number | null;
}

// refs: 1 - tags: named, input
export interface RebootClusterMessage {
  ClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface ResetClusterParameterGroupMessage {
  ParameterGroupName: string;
  ResetAllParameters?: boolean | null;
  Parameters?: Parameter[] | null;
}

// refs: 5 - tags: input, named, interface, output
export interface ResizeClusterMessage {
  ClusterIdentifier: string;
  ClusterType?: string | null;
  NodeType?: string | null;
  NumberOfNodes?: number | null;
  Classic?: boolean | null;
}
function ResizeClusterMessage_Serialize(body: URLSearchParams, prefix: string, params: ResizeClusterMessage) {
    body.append(prefix+".ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ClusterType" in params) body.append(prefix+".ClusterType", (params["ClusterType"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+".NodeType", (params["NodeType"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+".NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if ("Classic" in params) body.append(prefix+".Classic", (params["Classic"] ?? '').toString());
}
function ResizeClusterMessage_Parse(node: xmlP.XmlNode): ResizeClusterMessage {
  return {
    ...node.strings({
      required: {"ClusterIdentifier":true},
      optional: {"ClusterType":true,"NodeType":true},
    }),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    Classic: node.first("Classic", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: named, input
export interface RestoreFromClusterSnapshotMessage {
  ClusterIdentifier: string;
  SnapshotIdentifier: string;
  SnapshotClusterIdentifier?: string | null;
  Port?: number | null;
  AvailabilityZone?: string | null;
  AllowVersionUpgrade?: boolean | null;
  ClusterSubnetGroupName?: string | null;
  PubliclyAccessible?: boolean | null;
  OwnerAccount?: string | null;
  HsmClientCertificateIdentifier?: string | null;
  HsmConfigurationIdentifier?: string | null;
  ElasticIp?: string | null;
  ClusterParameterGroupName?: string | null;
  ClusterSecurityGroups?: string[] | null;
  VpcSecurityGroupIds?: string[] | null;
  PreferredMaintenanceWindow?: string | null;
  AutomatedSnapshotRetentionPeriod?: number | null;
  ManualSnapshotRetentionPeriod?: number | null;
  KmsKeyId?: string | null;
  NodeType?: string | null;
  EnhancedVpcRouting?: boolean | null;
  AdditionalInfo?: string | null;
  IamRoles?: string[] | null;
  MaintenanceTrackName?: string | null;
  SnapshotScheduleIdentifier?: string | null;
  NumberOfNodes?: number | null;
  AvailabilityZoneRelocation?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RestoreTableFromClusterSnapshotMessage {
  ClusterIdentifier: string;
  SnapshotIdentifier: string;
  SourceDatabaseName: string;
  SourceSchemaName?: string | null;
  SourceTableName: string;
  TargetDatabaseName?: string | null;
  TargetSchemaName?: string | null;
  NewTableName: string;
}

// refs: 5 - tags: input, named, interface, output
export interface ResumeClusterMessage {
  ClusterIdentifier: string;
}
function ResumeClusterMessage_Serialize(body: URLSearchParams, prefix: string, params: ResumeClusterMessage) {
    body.append(prefix+".ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
}
function ResumeClusterMessage_Parse(node: xmlP.XmlNode): ResumeClusterMessage {
  return node.strings({
    required: {"ClusterIdentifier":true},
  });
}

// refs: 1 - tags: named, input
export interface RevokeClusterSecurityGroupIngressMessage {
  ClusterSecurityGroupName: string;
  CIDRIP?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
}

// refs: 1 - tags: named, input
export interface RevokeSnapshotAccessMessage {
  SnapshotIdentifier: string;
  SnapshotClusterIdentifier?: string | null;
  AccountWithRestoreAccess: string;
}

// refs: 1 - tags: named, input
export interface RotateEncryptionKeyMessage {
  ClusterIdentifier: string;
}

// refs: 1 - tags: named, output
export interface AcceptReservedNodeExchangeOutputMessage {
  ExchangedReservedNode?: ReservedNode | null;
}

// refs: 1 - tags: named, output
export interface AuthorizeClusterSecurityGroupIngressResult {
  ClusterSecurityGroup?: ClusterSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface AuthorizeSnapshotAccessResult {
  Snapshot?: Snapshot | null;
}

// refs: 1 - tags: named, output
export interface BatchDeleteClusterSnapshotsResult {
  Resources: string[];
  Errors: SnapshotErrorMessage[];
}

// refs: 1 - tags: named, output
export interface BatchModifyClusterSnapshotsOutputMessage {
  Resources: string[];
  Errors: SnapshotErrorMessage[];
}

// refs: 1 - tags: named, output
export interface ResizeProgressMessage {
  TargetNodeType?: string | null;
  TargetNumberOfNodes?: number | null;
  TargetClusterType?: string | null;
  Status?: string | null;
  ImportTablesCompleted: string[];
  ImportTablesInProgress: string[];
  ImportTablesNotStarted: string[];
  AvgResizeRateInMegaBytesPerSecond?: number | null;
  TotalResizeDataInMegaBytes?: number | null;
  ProgressInMegaBytes?: number | null;
  ElapsedTimeInSeconds?: number | null;
  EstimatedTimeToCompletionInSeconds?: number | null;
  ResizeType?: string | null;
  Message?: string | null;
  TargetEncryptionType?: string | null;
  DataTransferProgressPercent?: number | null;
}

// refs: 1 - tags: named, output
export interface CopyClusterSnapshotResult {
  Snapshot?: Snapshot | null;
}

// refs: 1 - tags: named, output
export interface CreateClusterResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface CreateClusterParameterGroupResult {
  ClusterParameterGroup?: ClusterParameterGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateClusterSecurityGroupResult {
  ClusterSecurityGroup?: ClusterSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateClusterSnapshotResult {
  Snapshot?: Snapshot | null;
}

// refs: 1 - tags: named, output
export interface CreateClusterSubnetGroupResult {
  ClusterSubnetGroup?: ClusterSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateEventSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface CreateHsmClientCertificateResult {
  HsmClientCertificate?: HsmClientCertificate | null;
}

// refs: 1 - tags: named, output
export interface CreateHsmConfigurationResult {
  HsmConfiguration?: HsmConfiguration | null;
}

// refs: 2 - tags: named, output, interface
export interface ScheduledAction {
  ScheduledActionName?: string | null;
  TargetAction?: ScheduledActionType | null;
  Schedule?: string | null;
  IamRole?: string | null;
  ScheduledActionDescription?: string | null;
  State?: ScheduledActionState | null;
  NextInvocations: (Date | number)[];
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
}
function ScheduledAction_Parse(node: xmlP.XmlNode): ScheduledAction {
  return {
    ...node.strings({
      optional: {"ScheduledActionName":true,"Schedule":true,"IamRole":true,"ScheduledActionDescription":true},
    }),
    TargetAction: node.first("TargetAction", false, ScheduledActionType_Parse),
    State: node.first("State", false, x => (x.content ?? '') as ScheduledActionState),
    NextInvocations: node.getList("NextInvocations", "ScheduledActionTime").map(x => xmlP.parseTimestamp(x.content)),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: named, output
export interface CreateSnapshotCopyGrantResult {
  SnapshotCopyGrant?: SnapshotCopyGrant | null;
}

// refs: 2 - tags: named, output, interface
export interface SnapshotSchedule {
  ScheduleDefinitions: string[];
  ScheduleIdentifier?: string | null;
  ScheduleDescription?: string | null;
  Tags: Tag[];
  NextInvocations: (Date | number)[];
  AssociatedClusterCount?: number | null;
  AssociatedClusters: ClusterAssociatedToSchedule[];
}
function SnapshotSchedule_Parse(node: xmlP.XmlNode): SnapshotSchedule {
  return {
    ...node.strings({
      optional: {"ScheduleIdentifier":true,"ScheduleDescription":true},
    }),
    ScheduleDefinitions: node.getList("ScheduleDefinitions", "ScheduleDefinition").map(x => x.content ?? ''),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
    NextInvocations: node.getList("NextInvocations", "SnapshotTime").map(x => xmlP.parseTimestamp(x.content)),
    AssociatedClusterCount: node.first("AssociatedClusterCount", false, x => parseInt(x.content ?? '0')),
    AssociatedClusters: node.getList("AssociatedClusters", "ClusterAssociatedToSchedule").map(ClusterAssociatedToSchedule_Parse),
  };
}

// refs: 2 - tags: named, output, interface
export interface UsageLimit {
  UsageLimitId?: string | null;
  ClusterIdentifier?: string | null;
  FeatureType?: UsageLimitFeatureType | null;
  LimitType?: UsageLimitLimitType | null;
  Amount?: number | null;
  Period?: UsageLimitPeriod | null;
  BreachAction?: UsageLimitBreachAction | null;
  Tags: Tag[];
}
function UsageLimit_Parse(node: xmlP.XmlNode): UsageLimit {
  return {
    ...node.strings({
      optional: {"UsageLimitId":true,"ClusterIdentifier":true},
    }),
    FeatureType: node.first("FeatureType", false, x => (x.content ?? '') as UsageLimitFeatureType),
    LimitType: node.first("LimitType", false, x => (x.content ?? '') as UsageLimitLimitType),
    Amount: node.first("Amount", false, x => parseInt(x.content ?? '0')),
    Period: node.first("Period", false, x => (x.content ?? '') as UsageLimitPeriod),
    BreachAction: node.first("BreachAction", false, x => (x.content ?? '') as UsageLimitBreachAction),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 1 - tags: named, output
export interface DeleteClusterResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface DeleteClusterSnapshotResult {
  Snapshot?: Snapshot | null;
}

// refs: 1 - tags: named, output
export interface AccountAttributeList {
  AccountAttributes: AccountAttribute[];
}

// refs: 1 - tags: named, output
export interface ClusterDbRevisionsMessage {
  Marker?: string | null;
  ClusterDbRevisions: ClusterDbRevision[];
}

// refs: 1 - tags: named, output
export interface ClusterParameterGroupsMessage {
  Marker?: string | null;
  ParameterGroups: ClusterParameterGroup[];
}

// refs: 1 - tags: named, output
export interface ClusterParameterGroupDetails {
  Parameters: Parameter[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ClusterSecurityGroupMessage {
  Marker?: string | null;
  ClusterSecurityGroups: ClusterSecurityGroup[];
}

// refs: 1 - tags: named, output
export interface SnapshotMessage {
  Marker?: string | null;
  Snapshots: Snapshot[];
}

// refs: 1 - tags: named, output
export interface ClusterSubnetGroupMessage {
  Marker?: string | null;
  ClusterSubnetGroups: ClusterSubnetGroup[];
}

// refs: 1 - tags: named, output
export interface TrackListMessage {
  MaintenanceTracks: MaintenanceTrack[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ClusterVersionsMessage {
  Marker?: string | null;
  ClusterVersions: ClusterVersion[];
}

// refs: 1 - tags: named, output
export interface ClustersMessage {
  Marker?: string | null;
  Clusters: Cluster[];
}

// refs: 1 - tags: named, output
export interface DescribeDefaultClusterParametersResult {
  DefaultClusterParameters?: DefaultClusterParameters | null;
}

// refs: 1 - tags: named, output
export interface EventCategoriesMessage {
  EventCategoriesMapList: EventCategoriesMap[];
}

// refs: 1 - tags: named, output
export interface EventSubscriptionsMessage {
  Marker?: string | null;
  EventSubscriptionsList: EventSubscription[];
}

// refs: 1 - tags: named, output
export interface EventsMessage {
  Marker?: string | null;
  Events: Event[];
}

// refs: 1 - tags: named, output
export interface HsmClientCertificateMessage {
  Marker?: string | null;
  HsmClientCertificates: HsmClientCertificate[];
}

// refs: 1 - tags: named, output
export interface HsmConfigurationMessage {
  Marker?: string | null;
  HsmConfigurations: HsmConfiguration[];
}

// refs: 1 - tags: named, output
export interface LoggingStatus {
  LoggingEnabled?: boolean | null;
  BucketName?: string | null;
  S3KeyPrefix?: string | null;
  LastSuccessfulDeliveryTime?: Date | number | null;
  LastFailureTime?: Date | number | null;
  LastFailureMessage?: string | null;
}

// refs: 1 - tags: named, output
export interface NodeConfigurationOptionsMessage {
  NodeConfigurationOptionList: NodeConfigurationOption[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface OrderableClusterOptionsMessage {
  OrderableClusterOptions: OrderableClusterOption[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ReservedNodeOfferingsMessage {
  Marker?: string | null;
  ReservedNodeOfferings: ReservedNodeOffering[];
}

// refs: 1 - tags: named, output
export interface ReservedNodesMessage {
  Marker?: string | null;
  ReservedNodes: ReservedNode[];
}

// refs: 1 - tags: named, output
export interface ScheduledActionsMessage {
  Marker?: string | null;
  ScheduledActions: ScheduledAction[];
}

// refs: 1 - tags: named, output
export interface SnapshotCopyGrantMessage {
  Marker?: string | null;
  SnapshotCopyGrants: SnapshotCopyGrant[];
}

// refs: 1 - tags: named, output
export interface DescribeSnapshotSchedulesOutputMessage {
  SnapshotSchedules: SnapshotSchedule[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface CustomerStorageMessage {
  TotalBackupSizeInMegaBytes?: number | null;
  TotalProvisionedStorageInMegaBytes?: number | null;
}

// refs: 1 - tags: named, output
export interface TableRestoreStatusMessage {
  TableRestoreStatusDetails: TableRestoreStatus[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface TaggedResourceListMessage {
  TaggedResources: TaggedResource[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface UsageLimitList {
  UsageLimits: UsageLimit[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DisableSnapshotCopyResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface EnableSnapshotCopyResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface ClusterCredentials {
  DbUser?: string | null;
  DbPassword?: string | null;
  Expiration?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetReservedNodeExchangeOfferingsOutputMessage {
  Marker?: string | null;
  ReservedNodeOfferings: ReservedNodeOffering[];
}

// refs: 1 - tags: named, output
export interface ModifyClusterResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface ModifyClusterDbRevisionResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface ModifyClusterIamRolesResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface ModifyClusterMaintenanceResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface ClusterParameterGroupNameMessage {
  ParameterGroupName?: string | null;
  ParameterGroupStatus?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyClusterSnapshotResult {
  Snapshot?: Snapshot | null;
}

// refs: 1 - tags: named, output
export interface ModifyClusterSubnetGroupResult {
  ClusterSubnetGroup?: ClusterSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface ModifyEventSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface ModifySnapshotCopyRetentionPeriodResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface PauseClusterResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface PurchaseReservedNodeOfferingResult {
  ReservedNode?: ReservedNode | null;
}

// refs: 1 - tags: named, output
export interface RebootClusterResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface ResizeClusterResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface RestoreFromClusterSnapshotResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface RestoreTableFromClusterSnapshotResult {
  TableRestoreStatus?: TableRestoreStatus | null;
}

// refs: 1 - tags: named, output
export interface ResumeClusterResult {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface RevokeClusterSecurityGroupIngressResult {
  ClusterSecurityGroup?: ClusterSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface RevokeSnapshotAccessResult {
  Snapshot?: Snapshot | null;
}

// refs: 1 - tags: named, output
export interface RotateEncryptionKeyResult {
  Cluster?: Cluster | null;
}

// refs: 66 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 4 - tags: input, named, interface, output
export interface ScheduledActionType {
  ResizeCluster?: ResizeClusterMessage | null;
  PauseCluster?: PauseClusterMessage | null;
  ResumeCluster?: ResumeClusterMessage | null;
}
function ScheduledActionType_Serialize(body: URLSearchParams, prefix: string, params: ScheduledActionType) {
    if (params["ResizeCluster"] != null) ResizeClusterMessage_Serialize(body, prefix+".ResizeCluster", params["ResizeCluster"]);
    if (params["PauseCluster"] != null) PauseClusterMessage_Serialize(body, prefix+".PauseCluster", params["PauseCluster"]);
    if (params["ResumeCluster"] != null) ResumeClusterMessage_Serialize(body, prefix+".ResumeCluster", params["ResumeCluster"]);
}
function ScheduledActionType_Parse(node: xmlP.XmlNode): ScheduledActionType {
  return {
    ResizeCluster: node.first("ResizeCluster", false, ResizeClusterMessage_Parse),
    PauseCluster: node.first("PauseCluster", false, PauseClusterMessage_Parse),
    ResumeCluster: node.first("ResumeCluster", false, ResumeClusterMessage_Parse),
  };
}

// refs: 4 - tags: input, named, enum, output
export type UsageLimitFeatureType =
| "spectrum"
| "concurrency-scaling"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type UsageLimitLimitType =
| "time"
| "data-scanned"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type UsageLimitPeriod =
| "daily"
| "weekly"
| "monthly"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type UsageLimitBreachAction =
| "log"
| "emit-metric"
| "disable"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SnapshotSortingEntity {
  Attribute: SnapshotAttributeToSortBy;
  SortOrder?: SortByOrder | null;
}
function SnapshotSortingEntity_Serialize(body: URLSearchParams, prefix: string, params: SnapshotSortingEntity) {
    body.append(prefix+".Attribute", (params["Attribute"] ?? '').toString());
    if ("SortOrder" in params) body.append(prefix+".SortOrder", (params["SortOrder"] ?? '').toString());
}

// refs: 1 - tags: input, named, enum
export type SnapshotAttributeToSortBy =
| "SOURCE_TYPE"
| "TOTAL_SIZE"
| "CREATE_TIME"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SortByOrder =
| "ASC"
| "DESC"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type SourceType =
| "cluster"
| "cluster-parameter-group"
| "cluster-security-group"
| "cluster-snapshot"
| "scheduled-action"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ActionType =
| "restore-cluster"
| "recommend-node-config"
| "resize-cluster"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface NodeConfigurationOptionsFilter {
  Name?: NodeConfigurationOptionsFilterName | null;
  Operator?: OperatorType | null;
  Values?: string[] | null;
}
function NodeConfigurationOptionsFilter_Serialize(body: URLSearchParams, prefix: string, params: NodeConfigurationOptionsFilter) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Operator" in params) body.append(prefix+".Operator", (params["Operator"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Value", params["Values"], {"entryPrefix":".item."})
}

// refs: 1 - tags: input, named, enum
export type NodeConfigurationOptionsFilterName =
| "NodeType"
| "NumberOfNodes"
| "EstimatedDiskUtilizationPercent"
| "Mode"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type OperatorType =
| "eq"
| "lt"
| "gt"
| "le"
| "ge"
| "in"
| "between"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ScheduledActionTypeValues =
| "ResizeCluster"
| "PauseCluster"
| "ResumeCluster"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ScheduledActionFilter {
  Name: ScheduledActionFilterName;
  Values: string[];
}
function ScheduledActionFilter_Serialize(body: URLSearchParams, prefix: string, params: ScheduledActionFilter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".item."})
}

// refs: 1 - tags: input, named, enum
export type ScheduledActionFilterName =
| "cluster-identifier"
| "iam-role"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Parameter {
  ParameterName?: string | null;
  ParameterValue?: string | null;
  Description?: string | null;
  Source?: string | null;
  DataType?: string | null;
  AllowedValues?: string | null;
  ApplyType?: ParameterApplyType | null;
  IsModifiable?: boolean | null;
  MinimumEngineVersion?: string | null;
}
function Parameter_Serialize(body: URLSearchParams, prefix: string, params: Parameter) {
    if ("ParameterName" in params) body.append(prefix+".ParameterName", (params["ParameterName"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("Source" in params) body.append(prefix+".Source", (params["Source"] ?? '').toString());
    if ("DataType" in params) body.append(prefix+".DataType", (params["DataType"] ?? '').toString());
    if ("AllowedValues" in params) body.append(prefix+".AllowedValues", (params["AllowedValues"] ?? '').toString());
    if ("ApplyType" in params) body.append(prefix+".ApplyType", (params["ApplyType"] ?? '').toString());
    if ("IsModifiable" in params) body.append(prefix+".IsModifiable", (params["IsModifiable"] ?? '').toString());
    if ("MinimumEngineVersion" in params) body.append(prefix+".MinimumEngineVersion", (params["MinimumEngineVersion"] ?? '').toString());
}
function Parameter_Parse(node: xmlP.XmlNode): Parameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"ParameterValue":true,"Description":true,"Source":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    ApplyType: node.first("ApplyType", false, x => (x.content ?? '') as ParameterApplyType),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, enum, output
export type ParameterApplyType =
| "static"
| "dynamic"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface ReservedNode {
  ReservedNodeId?: string | null;
  ReservedNodeOfferingId?: string | null;
  NodeType?: string | null;
  StartTime?: Date | number | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  CurrencyCode?: string | null;
  NodeCount?: number | null;
  State?: string | null;
  OfferingType?: string | null;
  RecurringCharges: RecurringCharge[];
  ReservedNodeOfferingType?: ReservedNodeOfferingType | null;
}
function ReservedNode_Parse(node: xmlP.XmlNode): ReservedNode {
  return {
    ...node.strings({
      optional: {"ReservedNodeId":true,"ReservedNodeOfferingId":true,"NodeType":true,"CurrencyCode":true,"State":true,"OfferingType":true},
    }),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    NodeCount: node.first("NodeCount", false, x => parseInt(x.content ?? '0')),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
    ReservedNodeOfferingType: node.first("ReservedNodeOfferingType", false, x => (x.content ?? '') as ReservedNodeOfferingType),
  };
}

// refs: 5 - tags: output, named, interface
export interface RecurringCharge {
  RecurringChargeAmount?: number | null;
  RecurringChargeFrequency?: string | null;
}
function RecurringCharge_Parse(node: xmlP.XmlNode): RecurringCharge {
  return {
    ...node.strings({
      optional: {"RecurringChargeFrequency":true},
    }),
    RecurringChargeAmount: node.first("RecurringChargeAmount", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 5 - tags: output, named, enum
export type ReservedNodeOfferingType =
| "Regular"
| "Upgradable"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface ClusterSecurityGroup {
  ClusterSecurityGroupName?: string | null;
  Description?: string | null;
  EC2SecurityGroups: EC2SecurityGroup[];
  IPRanges: IPRange[];
  Tags: Tag[];
}
function ClusterSecurityGroup_Parse(node: xmlP.XmlNode): ClusterSecurityGroup {
  return {
    ...node.strings({
      optional: {"ClusterSecurityGroupName":true,"Description":true},
    }),
    EC2SecurityGroups: node.getList("EC2SecurityGroups", "EC2SecurityGroup").map(EC2SecurityGroup_Parse),
    IPRanges: node.getList("IPRanges", "IPRange").map(IPRange_Parse),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface EC2SecurityGroup {
  Status?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
  Tags: Tag[];
}
function EC2SecurityGroup_Parse(node: xmlP.XmlNode): EC2SecurityGroup {
  return {
    ...node.strings({
      optional: {"Status":true,"EC2SecurityGroupName":true,"EC2SecurityGroupOwnerId":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface IPRange {
  Status?: string | null;
  CIDRIP?: string | null;
  Tags: Tag[];
}
function IPRange_Parse(node: xmlP.XmlNode): IPRange {
  return {
    ...node.strings({
      optional: {"Status":true,"CIDRIP":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 7 - tags: output, named, interface
export interface Snapshot {
  SnapshotIdentifier?: string | null;
  ClusterIdentifier?: string | null;
  SnapshotCreateTime?: Date | number | null;
  Status?: string | null;
  Port?: number | null;
  AvailabilityZone?: string | null;
  ClusterCreateTime?: Date | number | null;
  MasterUsername?: string | null;
  ClusterVersion?: string | null;
  EngineFullVersion?: string | null;
  SnapshotType?: string | null;
  NodeType?: string | null;
  NumberOfNodes?: number | null;
  DBName?: string | null;
  VpcId?: string | null;
  Encrypted?: boolean | null;
  KmsKeyId?: string | null;
  EncryptedWithHSM?: boolean | null;
  AccountsWithRestoreAccess: AccountWithRestoreAccess[];
  OwnerAccount?: string | null;
  TotalBackupSizeInMegaBytes?: number | null;
  ActualIncrementalBackupSizeInMegaBytes?: number | null;
  BackupProgressInMegaBytes?: number | null;
  CurrentBackupRateInMegaBytesPerSecond?: number | null;
  EstimatedSecondsToCompletion?: number | null;
  ElapsedTimeInSeconds?: number | null;
  SourceRegion?: string | null;
  Tags: Tag[];
  RestorableNodeTypes: string[];
  EnhancedVpcRouting?: boolean | null;
  MaintenanceTrackName?: string | null;
  ManualSnapshotRetentionPeriod?: number | null;
  ManualSnapshotRemainingDays?: number | null;
  SnapshotRetentionStartTime?: Date | number | null;
}
function Snapshot_Parse(node: xmlP.XmlNode): Snapshot {
  return {
    ...node.strings({
      optional: {"SnapshotIdentifier":true,"ClusterIdentifier":true,"Status":true,"AvailabilityZone":true,"MasterUsername":true,"ClusterVersion":true,"EngineFullVersion":true,"SnapshotType":true,"NodeType":true,"DBName":true,"VpcId":true,"KmsKeyId":true,"OwnerAccount":true,"SourceRegion":true,"MaintenanceTrackName":true},
    }),
    SnapshotCreateTime: node.first("SnapshotCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    ClusterCreateTime: node.first("ClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    Encrypted: node.first("Encrypted", false, x => x.content === 'true'),
    EncryptedWithHSM: node.first("EncryptedWithHSM", false, x => x.content === 'true'),
    AccountsWithRestoreAccess: node.getList("AccountsWithRestoreAccess", "AccountWithRestoreAccess").map(AccountWithRestoreAccess_Parse),
    TotalBackupSizeInMegaBytes: node.first("TotalBackupSizeInMegaBytes", false, x => parseFloat(x.content ?? '0')),
    ActualIncrementalBackupSizeInMegaBytes: node.first("ActualIncrementalBackupSizeInMegaBytes", false, x => parseFloat(x.content ?? '0')),
    BackupProgressInMegaBytes: node.first("BackupProgressInMegaBytes", false, x => parseFloat(x.content ?? '0')),
    CurrentBackupRateInMegaBytesPerSecond: node.first("CurrentBackupRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
    EstimatedSecondsToCompletion: node.first("EstimatedSecondsToCompletion", false, x => parseInt(x.content ?? '0')),
    ElapsedTimeInSeconds: node.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
    RestorableNodeTypes: node.getList("RestorableNodeTypes", "NodeType").map(x => x.content ?? ''),
    EnhancedVpcRouting: node.first("EnhancedVpcRouting", false, x => x.content === 'true'),
    ManualSnapshotRetentionPeriod: node.first("ManualSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    ManualSnapshotRemainingDays: node.first("ManualSnapshotRemainingDays", false, x => parseInt(x.content ?? '0')),
    SnapshotRetentionStartTime: node.first("SnapshotRetentionStartTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 7 - tags: output, named, interface
export interface AccountWithRestoreAccess {
  AccountId?: string | null;
  AccountAlias?: string | null;
}
function AccountWithRestoreAccess_Parse(node: xmlP.XmlNode): AccountWithRestoreAccess {
  return node.strings({
    optional: {"AccountId":true,"AccountAlias":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface SnapshotErrorMessage {
  SnapshotIdentifier?: string | null;
  SnapshotClusterIdentifier?: string | null;
  FailureCode?: string | null;
  FailureReason?: string | null;
}
function SnapshotErrorMessage_Parse(node: xmlP.XmlNode): SnapshotErrorMessage {
  return node.strings({
    optional: {"SnapshotIdentifier":true,"SnapshotClusterIdentifier":true,"FailureCode":true,"FailureReason":true},
  });
}

// refs: 16 - tags: output, named, interface
export interface Cluster {
  ClusterIdentifier?: string | null;
  NodeType?: string | null;
  ClusterStatus?: string | null;
  ClusterAvailabilityStatus?: string | null;
  ModifyStatus?: string | null;
  MasterUsername?: string | null;
  DBName?: string | null;
  Endpoint?: Endpoint | null;
  ClusterCreateTime?: Date | number | null;
  AutomatedSnapshotRetentionPeriod?: number | null;
  ManualSnapshotRetentionPeriod?: number | null;
  ClusterSecurityGroups: ClusterSecurityGroupMembership[];
  VpcSecurityGroups: VpcSecurityGroupMembership[];
  ClusterParameterGroups: ClusterParameterGroupStatus[];
  ClusterSubnetGroupName?: string | null;
  VpcId?: string | null;
  AvailabilityZone?: string | null;
  PreferredMaintenanceWindow?: string | null;
  PendingModifiedValues?: PendingModifiedValues | null;
  ClusterVersion?: string | null;
  AllowVersionUpgrade?: boolean | null;
  NumberOfNodes?: number | null;
  PubliclyAccessible?: boolean | null;
  Encrypted?: boolean | null;
  RestoreStatus?: RestoreStatus | null;
  DataTransferProgress?: DataTransferProgress | null;
  HsmStatus?: HsmStatus | null;
  ClusterSnapshotCopyStatus?: ClusterSnapshotCopyStatus | null;
  ClusterPublicKey?: string | null;
  ClusterNodes: ClusterNode[];
  ElasticIpStatus?: ElasticIpStatus | null;
  ClusterRevisionNumber?: string | null;
  Tags: Tag[];
  KmsKeyId?: string | null;
  EnhancedVpcRouting?: boolean | null;
  IamRoles: ClusterIamRole[];
  PendingActions: string[];
  MaintenanceTrackName?: string | null;
  ElasticResizeNumberOfNodeOptions?: string | null;
  DeferredMaintenanceWindows: DeferredMaintenanceWindow[];
  SnapshotScheduleIdentifier?: string | null;
  SnapshotScheduleState?: ScheduleState | null;
  ExpectedNextSnapshotScheduleTime?: Date | number | null;
  ExpectedNextSnapshotScheduleTimeStatus?: string | null;
  NextMaintenanceWindowStartTime?: Date | number | null;
  ResizeInfo?: ResizeInfo | null;
  AvailabilityZoneRelocationStatus?: string | null;
  ClusterNamespaceArn?: string | null;
}
function Cluster_Parse(node: xmlP.XmlNode): Cluster {
  return {
    ...node.strings({
      optional: {"ClusterIdentifier":true,"NodeType":true,"ClusterStatus":true,"ClusterAvailabilityStatus":true,"ModifyStatus":true,"MasterUsername":true,"DBName":true,"ClusterSubnetGroupName":true,"VpcId":true,"AvailabilityZone":true,"PreferredMaintenanceWindow":true,"ClusterVersion":true,"ClusterPublicKey":true,"ClusterRevisionNumber":true,"KmsKeyId":true,"MaintenanceTrackName":true,"ElasticResizeNumberOfNodeOptions":true,"SnapshotScheduleIdentifier":true,"ExpectedNextSnapshotScheduleTimeStatus":true,"AvailabilityZoneRelocationStatus":true,"ClusterNamespaceArn":true},
    }),
    Endpoint: node.first("Endpoint", false, Endpoint_Parse),
    ClusterCreateTime: node.first("ClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    AutomatedSnapshotRetentionPeriod: node.first("AutomatedSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    ManualSnapshotRetentionPeriod: node.first("ManualSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    ClusterSecurityGroups: node.getList("ClusterSecurityGroups", "ClusterSecurityGroup").map(ClusterSecurityGroupMembership_Parse),
    VpcSecurityGroups: node.getList("VpcSecurityGroups", "VpcSecurityGroup").map(VpcSecurityGroupMembership_Parse),
    ClusterParameterGroups: node.getList("ClusterParameterGroups", "ClusterParameterGroup").map(ClusterParameterGroupStatus_Parse),
    PendingModifiedValues: node.first("PendingModifiedValues", false, PendingModifiedValues_Parse),
    AllowVersionUpgrade: node.first("AllowVersionUpgrade", false, x => x.content === 'true'),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    PubliclyAccessible: node.first("PubliclyAccessible", false, x => x.content === 'true'),
    Encrypted: node.first("Encrypted", false, x => x.content === 'true'),
    RestoreStatus: node.first("RestoreStatus", false, RestoreStatus_Parse),
    DataTransferProgress: node.first("DataTransferProgress", false, DataTransferProgress_Parse),
    HsmStatus: node.first("HsmStatus", false, HsmStatus_Parse),
    ClusterSnapshotCopyStatus: node.first("ClusterSnapshotCopyStatus", false, ClusterSnapshotCopyStatus_Parse),
    ClusterNodes: node.getList("ClusterNodes", "member").map(ClusterNode_Parse),
    ElasticIpStatus: node.first("ElasticIpStatus", false, ElasticIpStatus_Parse),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
    EnhancedVpcRouting: node.first("EnhancedVpcRouting", false, x => x.content === 'true'),
    IamRoles: node.getList("IamRoles", "ClusterIamRole").map(ClusterIamRole_Parse),
    PendingActions: node.getList("PendingActions", "member").map(x => x.content ?? ''),
    DeferredMaintenanceWindows: node.getList("DeferredMaintenanceWindows", "DeferredMaintenanceWindow").map(DeferredMaintenanceWindow_Parse),
    SnapshotScheduleState: node.first("SnapshotScheduleState", false, x => (x.content ?? '') as ScheduleState),
    ExpectedNextSnapshotScheduleTime: node.first("ExpectedNextSnapshotScheduleTime", false, x => xmlP.parseTimestamp(x.content)),
    NextMaintenanceWindowStartTime: node.first("NextMaintenanceWindowStartTime", false, x => xmlP.parseTimestamp(x.content)),
    ResizeInfo: node.first("ResizeInfo", false, ResizeInfo_Parse),
  };
}

// refs: 16 - tags: output, named, interface
export interface Endpoint {
  Address?: string | null;
  Port?: number | null;
  VpcEndpoints: VpcEndpoint[];
}
function Endpoint_Parse(node: xmlP.XmlNode): Endpoint {
  return {
    ...node.strings({
      optional: {"Address":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    VpcEndpoints: node.getList("VpcEndpoints", "VpcEndpoint").map(VpcEndpoint_Parse),
  };
}

// refs: 16 - tags: output, named, interface
export interface VpcEndpoint {
  VpcEndpointId?: string | null;
}
function VpcEndpoint_Parse(node: xmlP.XmlNode): VpcEndpoint {
  return node.strings({
    optional: {"VpcEndpointId":true},
  });
}

// refs: 16 - tags: output, named, interface
export interface ClusterSecurityGroupMembership {
  ClusterSecurityGroupName?: string | null;
  Status?: string | null;
}
function ClusterSecurityGroupMembership_Parse(node: xmlP.XmlNode): ClusterSecurityGroupMembership {
  return node.strings({
    optional: {"ClusterSecurityGroupName":true,"Status":true},
  });
}

// refs: 16 - tags: output, named, interface
export interface VpcSecurityGroupMembership {
  VpcSecurityGroupId?: string | null;
  Status?: string | null;
}
function VpcSecurityGroupMembership_Parse(node: xmlP.XmlNode): VpcSecurityGroupMembership {
  return node.strings({
    optional: {"VpcSecurityGroupId":true,"Status":true},
  });
}

// refs: 16 - tags: output, named, interface
export interface ClusterParameterGroupStatus {
  ParameterGroupName?: string | null;
  ParameterApplyStatus?: string | null;
  ClusterParameterStatusList: ClusterParameterStatus[];
}
function ClusterParameterGroupStatus_Parse(node: xmlP.XmlNode): ClusterParameterGroupStatus {
  return {
    ...node.strings({
      optional: {"ParameterGroupName":true,"ParameterApplyStatus":true},
    }),
    ClusterParameterStatusList: node.getList("ClusterParameterStatusList", "member").map(ClusterParameterStatus_Parse),
  };
}

// refs: 16 - tags: output, named, interface
export interface ClusterParameterStatus {
  ParameterName?: string | null;
  ParameterApplyStatus?: string | null;
  ParameterApplyErrorDescription?: string | null;
}
function ClusterParameterStatus_Parse(node: xmlP.XmlNode): ClusterParameterStatus {
  return node.strings({
    optional: {"ParameterName":true,"ParameterApplyStatus":true,"ParameterApplyErrorDescription":true},
  });
}

// refs: 16 - tags: output, named, interface
export interface PendingModifiedValues {
  MasterUserPassword?: string | null;
  NodeType?: string | null;
  NumberOfNodes?: number | null;
  ClusterType?: string | null;
  ClusterVersion?: string | null;
  AutomatedSnapshotRetentionPeriod?: number | null;
  ClusterIdentifier?: string | null;
  PubliclyAccessible?: boolean | null;
  EnhancedVpcRouting?: boolean | null;
  MaintenanceTrackName?: string | null;
  EncryptionType?: string | null;
}
function PendingModifiedValues_Parse(node: xmlP.XmlNode): PendingModifiedValues {
  return {
    ...node.strings({
      optional: {"MasterUserPassword":true,"NodeType":true,"ClusterType":true,"ClusterVersion":true,"ClusterIdentifier":true,"MaintenanceTrackName":true,"EncryptionType":true},
    }),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    AutomatedSnapshotRetentionPeriod: node.first("AutomatedSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    PubliclyAccessible: node.first("PubliclyAccessible", false, x => x.content === 'true'),
    EnhancedVpcRouting: node.first("EnhancedVpcRouting", false, x => x.content === 'true'),
  };
}

// refs: 16 - tags: output, named, interface
export interface RestoreStatus {
  Status?: string | null;
  CurrentRestoreRateInMegaBytesPerSecond?: number | null;
  SnapshotSizeInMegaBytes?: number | null;
  ProgressInMegaBytes?: number | null;
  ElapsedTimeInSeconds?: number | null;
  EstimatedTimeToCompletionInSeconds?: number | null;
}
function RestoreStatus_Parse(node: xmlP.XmlNode): RestoreStatus {
  return {
    ...node.strings({
      optional: {"Status":true},
    }),
    CurrentRestoreRateInMegaBytesPerSecond: node.first("CurrentRestoreRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
    SnapshotSizeInMegaBytes: node.first("SnapshotSizeInMegaBytes", false, x => parseInt(x.content ?? '0')),
    ProgressInMegaBytes: node.first("ProgressInMegaBytes", false, x => parseInt(x.content ?? '0')),
    ElapsedTimeInSeconds: node.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
    EstimatedTimeToCompletionInSeconds: node.first("EstimatedTimeToCompletionInSeconds", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 16 - tags: output, named, interface
export interface DataTransferProgress {
  Status?: string | null;
  CurrentRateInMegaBytesPerSecond?: number | null;
  TotalDataInMegaBytes?: number | null;
  DataTransferredInMegaBytes?: number | null;
  EstimatedTimeToCompletionInSeconds?: number | null;
  ElapsedTimeInSeconds?: number | null;
}
function DataTransferProgress_Parse(node: xmlP.XmlNode): DataTransferProgress {
  return {
    ...node.strings({
      optional: {"Status":true},
    }),
    CurrentRateInMegaBytesPerSecond: node.first("CurrentRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
    TotalDataInMegaBytes: node.first("TotalDataInMegaBytes", false, x => parseInt(x.content ?? '0')),
    DataTransferredInMegaBytes: node.first("DataTransferredInMegaBytes", false, x => parseInt(x.content ?? '0')),
    EstimatedTimeToCompletionInSeconds: node.first("EstimatedTimeToCompletionInSeconds", false, x => parseInt(x.content ?? '0')),
    ElapsedTimeInSeconds: node.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 16 - tags: output, named, interface
export interface HsmStatus {
  HsmClientCertificateIdentifier?: string | null;
  HsmConfigurationIdentifier?: string | null;
  Status?: string | null;
}
function HsmStatus_Parse(node: xmlP.XmlNode): HsmStatus {
  return node.strings({
    optional: {"HsmClientCertificateIdentifier":true,"HsmConfigurationIdentifier":true,"Status":true},
  });
}

// refs: 16 - tags: output, named, interface
export interface ClusterSnapshotCopyStatus {
  DestinationRegion?: string | null;
  RetentionPeriod?: number | null;
  ManualSnapshotRetentionPeriod?: number | null;
  SnapshotCopyGrantName?: string | null;
}
function ClusterSnapshotCopyStatus_Parse(node: xmlP.XmlNode): ClusterSnapshotCopyStatus {
  return {
    ...node.strings({
      optional: {"DestinationRegion":true,"SnapshotCopyGrantName":true},
    }),
    RetentionPeriod: node.first("RetentionPeriod", false, x => parseInt(x.content ?? '0')),
    ManualSnapshotRetentionPeriod: node.first("ManualSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 16 - tags: output, named, interface
export interface ClusterNode {
  NodeRole?: string | null;
  PrivateIPAddress?: string | null;
  PublicIPAddress?: string | null;
}
function ClusterNode_Parse(node: xmlP.XmlNode): ClusterNode {
  return node.strings({
    optional: {"NodeRole":true,"PrivateIPAddress":true,"PublicIPAddress":true},
  });
}

// refs: 16 - tags: output, named, interface
export interface ElasticIpStatus {
  ElasticIp?: string | null;
  Status?: string | null;
}
function ElasticIpStatus_Parse(node: xmlP.XmlNode): ElasticIpStatus {
  return node.strings({
    optional: {"ElasticIp":true,"Status":true},
  });
}

// refs: 16 - tags: output, named, interface
export interface ClusterIamRole {
  IamRoleArn?: string | null;
  ApplyStatus?: string | null;
}
function ClusterIamRole_Parse(node: xmlP.XmlNode): ClusterIamRole {
  return node.strings({
    optional: {"IamRoleArn":true,"ApplyStatus":true},
  });
}

// refs: 16 - tags: output, named, interface
export interface DeferredMaintenanceWindow {
  DeferMaintenanceIdentifier?: string | null;
  DeferMaintenanceStartTime?: Date | number | null;
  DeferMaintenanceEndTime?: Date | number | null;
}
function DeferredMaintenanceWindow_Parse(node: xmlP.XmlNode): DeferredMaintenanceWindow {
  return {
    ...node.strings({
      optional: {"DeferMaintenanceIdentifier":true},
    }),
    DeferMaintenanceStartTime: node.first("DeferMaintenanceStartTime", false, x => xmlP.parseTimestamp(x.content)),
    DeferMaintenanceEndTime: node.first("DeferMaintenanceEndTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 18 - tags: output, named, enum
export type ScheduleState =
| "MODIFYING"
| "ACTIVE"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: output, named, interface
export interface ResizeInfo {
  ResizeType?: string | null;
  AllowCancelResize?: boolean | null;
}
function ResizeInfo_Parse(node: xmlP.XmlNode): ResizeInfo {
  return {
    ...node.strings({
      optional: {"ResizeType":true},
    }),
    AllowCancelResize: node.first("AllowCancelResize", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface ClusterParameterGroup {
  ParameterGroupName?: string | null;
  ParameterGroupFamily?: string | null;
  Description?: string | null;
  Tags: Tag[];
}
function ClusterParameterGroup_Parse(node: xmlP.XmlNode): ClusterParameterGroup {
  return {
    ...node.strings({
      optional: {"ParameterGroupName":true,"ParameterGroupFamily":true,"Description":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface ClusterSubnetGroup {
  ClusterSubnetGroupName?: string | null;
  Description?: string | null;
  VpcId?: string | null;
  SubnetGroupStatus?: string | null;
  Subnets: Subnet[];
  Tags: Tag[];
}
function ClusterSubnetGroup_Parse(node: xmlP.XmlNode): ClusterSubnetGroup {
  return {
    ...node.strings({
      optional: {"ClusterSubnetGroupName":true,"Description":true,"VpcId":true,"SubnetGroupStatus":true},
    }),
    Subnets: node.getList("Subnets", "Subnet").map(Subnet_Parse),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface Subnet {
  SubnetIdentifier?: string | null;
  SubnetAvailabilityZone?: AvailabilityZone | null;
  SubnetStatus?: string | null;
}
function Subnet_Parse(node: xmlP.XmlNode): Subnet {
  return {
    ...node.strings({
      optional: {"SubnetIdentifier":true,"SubnetStatus":true},
    }),
    SubnetAvailabilityZone: node.first("SubnetAvailabilityZone", false, AvailabilityZone_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface AvailabilityZone {
  Name?: string | null;
  SupportedPlatforms: SupportedPlatform[];
}
function AvailabilityZone_Parse(node: xmlP.XmlNode): AvailabilityZone {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    SupportedPlatforms: node.getList("SupportedPlatforms", "SupportedPlatform").map(SupportedPlatform_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface SupportedPlatform {
  Name?: string | null;
}
function SupportedPlatform_Parse(node: xmlP.XmlNode): SupportedPlatform {
  return node.strings({
    optional: {"Name":true},
  });
}

// refs: 3 - tags: output, named, interface
export interface EventSubscription {
  CustomerAwsId?: string | null;
  CustSubscriptionId?: string | null;
  SnsTopicArn?: string | null;
  Status?: string | null;
  SubscriptionCreationTime?: Date | number | null;
  SourceType?: string | null;
  SourceIdsList: string[];
  EventCategoriesList: string[];
  Severity?: string | null;
  Enabled?: boolean | null;
  Tags: Tag[];
}
function EventSubscription_Parse(node: xmlP.XmlNode): EventSubscription {
  return {
    ...node.strings({
      optional: {"CustomerAwsId":true,"CustSubscriptionId":true,"SnsTopicArn":true,"Status":true,"SourceType":true,"Severity":true},
    }),
    SubscriptionCreationTime: node.first("SubscriptionCreationTime", false, x => xmlP.parseTimestamp(x.content)),
    SourceIdsList: node.getList("SourceIdsList", "SourceId").map(x => x.content ?? ''),
    EventCategoriesList: node.getList("EventCategoriesList", "EventCategory").map(x => x.content ?? ''),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface HsmClientCertificate {
  HsmClientCertificateIdentifier?: string | null;
  HsmClientCertificatePublicKey?: string | null;
  Tags: Tag[];
}
function HsmClientCertificate_Parse(node: xmlP.XmlNode): HsmClientCertificate {
  return {
    ...node.strings({
      optional: {"HsmClientCertificateIdentifier":true,"HsmClientCertificatePublicKey":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface HsmConfiguration {
  HsmConfigurationIdentifier?: string | null;
  Description?: string | null;
  HsmIpAddress?: string | null;
  HsmPartitionName?: string | null;
  Tags: Tag[];
}
function HsmConfiguration_Parse(node: xmlP.XmlNode): HsmConfiguration {
  return {
    ...node.strings({
      optional: {"HsmConfigurationIdentifier":true,"Description":true,"HsmIpAddress":true,"HsmPartitionName":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, enum
export type ScheduledActionState =
| "ACTIVE"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface SnapshotCopyGrant {
  SnapshotCopyGrantName?: string | null;
  KmsKeyId?: string | null;
  Tags: Tag[];
}
function SnapshotCopyGrant_Parse(node: xmlP.XmlNode): SnapshotCopyGrant {
  return {
    ...node.strings({
      optional: {"SnapshotCopyGrantName":true,"KmsKeyId":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface ClusterAssociatedToSchedule {
  ClusterIdentifier?: string | null;
  ScheduleAssociationState?: ScheduleState | null;
}
function ClusterAssociatedToSchedule_Parse(node: xmlP.XmlNode): ClusterAssociatedToSchedule {
  return {
    ...node.strings({
      optional: {"ClusterIdentifier":true},
    }),
    ScheduleAssociationState: node.first("ScheduleAssociationState", false, x => (x.content ?? '') as ScheduleState),
  };
}

// refs: 1 - tags: output, named, interface
export interface AccountAttribute {
  AttributeName?: string | null;
  AttributeValues: AttributeValueTarget[];
}
function AccountAttribute_Parse(node: xmlP.XmlNode): AccountAttribute {
  return {
    ...node.strings({
      optional: {"AttributeName":true},
    }),
    AttributeValues: node.getList("AttributeValues", "AttributeValueTarget").map(AttributeValueTarget_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface AttributeValueTarget {
  AttributeValue?: string | null;
}
function AttributeValueTarget_Parse(node: xmlP.XmlNode): AttributeValueTarget {
  return node.strings({
    optional: {"AttributeValue":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface ClusterDbRevision {
  ClusterIdentifier?: string | null;
  CurrentDatabaseRevision?: string | null;
  DatabaseRevisionReleaseDate?: Date | number | null;
  RevisionTargets: RevisionTarget[];
}
function ClusterDbRevision_Parse(node: xmlP.XmlNode): ClusterDbRevision {
  return {
    ...node.strings({
      optional: {"ClusterIdentifier":true,"CurrentDatabaseRevision":true},
    }),
    DatabaseRevisionReleaseDate: node.first("DatabaseRevisionReleaseDate", false, x => xmlP.parseTimestamp(x.content)),
    RevisionTargets: node.getList("RevisionTargets", "RevisionTarget").map(RevisionTarget_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface RevisionTarget {
  DatabaseRevision?: string | null;
  Description?: string | null;
  DatabaseRevisionReleaseDate?: Date | number | null;
}
function RevisionTarget_Parse(node: xmlP.XmlNode): RevisionTarget {
  return {
    ...node.strings({
      optional: {"DatabaseRevision":true,"Description":true},
    }),
    DatabaseRevisionReleaseDate: node.first("DatabaseRevisionReleaseDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface MaintenanceTrack {
  MaintenanceTrackName?: string | null;
  DatabaseVersion?: string | null;
  UpdateTargets: UpdateTarget[];
}
function MaintenanceTrack_Parse(node: xmlP.XmlNode): MaintenanceTrack {
  return {
    ...node.strings({
      optional: {"MaintenanceTrackName":true,"DatabaseVersion":true},
    }),
    UpdateTargets: node.getList("UpdateTargets", "UpdateTarget").map(UpdateTarget_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface UpdateTarget {
  MaintenanceTrackName?: string | null;
  DatabaseVersion?: string | null;
  SupportedOperations: SupportedOperation[];
}
function UpdateTarget_Parse(node: xmlP.XmlNode): UpdateTarget {
  return {
    ...node.strings({
      optional: {"MaintenanceTrackName":true,"DatabaseVersion":true},
    }),
    SupportedOperations: node.getList("SupportedOperations", "SupportedOperation").map(SupportedOperation_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface SupportedOperation {
  OperationName?: string | null;
}
function SupportedOperation_Parse(node: xmlP.XmlNode): SupportedOperation {
  return node.strings({
    optional: {"OperationName":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface ClusterVersion {
  ClusterVersion?: string | null;
  ClusterParameterGroupFamily?: string | null;
  Description?: string | null;
}
function ClusterVersion_Parse(node: xmlP.XmlNode): ClusterVersion {
  return node.strings({
    optional: {"ClusterVersion":true,"ClusterParameterGroupFamily":true,"Description":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface DefaultClusterParameters {
  ParameterGroupFamily?: string | null;
  Marker?: string | null;
  Parameters: Parameter[];
}
function DefaultClusterParameters_Parse(node: xmlP.XmlNode): DefaultClusterParameters {
  return {
    ...node.strings({
      optional: {"ParameterGroupFamily":true,"Marker":true},
    }),
    Parameters: node.getList("Parameters", "Parameter").map(Parameter_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface EventCategoriesMap {
  SourceType?: string | null;
  Events: EventInfoMap[];
}
function EventCategoriesMap_Parse(node: xmlP.XmlNode): EventCategoriesMap {
  return {
    ...node.strings({
      optional: {"SourceType":true},
    }),
    Events: node.getList("Events", "EventInfoMap").map(EventInfoMap_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface EventInfoMap {
  EventId?: string | null;
  EventCategories: string[];
  EventDescription?: string | null;
  Severity?: string | null;
}
function EventInfoMap_Parse(node: xmlP.XmlNode): EventInfoMap {
  return {
    ...node.strings({
      optional: {"EventId":true,"EventDescription":true,"Severity":true},
    }),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface Event {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  Message?: string | null;
  EventCategories: string[];
  Severity?: string | null;
  Date?: Date | number | null;
  EventId?: string | null;
}
function Event_Parse(node: xmlP.XmlNode): Event {
  return {
    ...node.strings({
      optional: {"SourceIdentifier":true,"Message":true,"Severity":true,"EventId":true},
    }),
    SourceType: node.first("SourceType", false, x => (x.content ?? '') as SourceType),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface NodeConfigurationOption {
  NodeType?: string | null;
  NumberOfNodes?: number | null;
  EstimatedDiskUtilizationPercent?: number | null;
  Mode?: Mode | null;
}
function NodeConfigurationOption_Parse(node: xmlP.XmlNode): NodeConfigurationOption {
  return {
    ...node.strings({
      optional: {"NodeType":true},
    }),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    EstimatedDiskUtilizationPercent: node.first("EstimatedDiskUtilizationPercent", false, x => parseFloat(x.content ?? '0')),
    Mode: node.first("Mode", false, x => (x.content ?? '') as Mode),
  };
}

// refs: 1 - tags: output, named, enum
export type Mode =
| "standard"
| "high-performance"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface OrderableClusterOption {
  ClusterVersion?: string | null;
  ClusterType?: string | null;
  NodeType?: string | null;
  AvailabilityZones: AvailabilityZone[];
}
function OrderableClusterOption_Parse(node: xmlP.XmlNode): OrderableClusterOption {
  return {
    ...node.strings({
      optional: {"ClusterVersion":true,"ClusterType":true,"NodeType":true},
    }),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(AvailabilityZone_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface ReservedNodeOffering {
  ReservedNodeOfferingId?: string | null;
  NodeType?: string | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  CurrencyCode?: string | null;
  OfferingType?: string | null;
  RecurringCharges: RecurringCharge[];
  ReservedNodeOfferingType?: ReservedNodeOfferingType | null;
}
function ReservedNodeOffering_Parse(node: xmlP.XmlNode): ReservedNodeOffering {
  return {
    ...node.strings({
      optional: {"ReservedNodeOfferingId":true,"NodeType":true,"CurrencyCode":true,"OfferingType":true},
    }),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
    ReservedNodeOfferingType: node.first("ReservedNodeOfferingType", false, x => (x.content ?? '') as ReservedNodeOfferingType),
  };
}

// refs: 2 - tags: output, named, interface
export interface TableRestoreStatus {
  TableRestoreRequestId?: string | null;
  Status?: TableRestoreStatusType | null;
  Message?: string | null;
  RequestTime?: Date | number | null;
  ProgressInMegaBytes?: number | null;
  TotalDataInMegaBytes?: number | null;
  ClusterIdentifier?: string | null;
  SnapshotIdentifier?: string | null;
  SourceDatabaseName?: string | null;
  SourceSchemaName?: string | null;
  SourceTableName?: string | null;
  TargetDatabaseName?: string | null;
  TargetSchemaName?: string | null;
  NewTableName?: string | null;
}
function TableRestoreStatus_Parse(node: xmlP.XmlNode): TableRestoreStatus {
  return {
    ...node.strings({
      optional: {"TableRestoreRequestId":true,"Message":true,"ClusterIdentifier":true,"SnapshotIdentifier":true,"SourceDatabaseName":true,"SourceSchemaName":true,"SourceTableName":true,"TargetDatabaseName":true,"TargetSchemaName":true,"NewTableName":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as TableRestoreStatusType),
    RequestTime: node.first("RequestTime", false, x => xmlP.parseTimestamp(x.content)),
    ProgressInMegaBytes: node.first("ProgressInMegaBytes", false, x => parseInt(x.content ?? '0')),
    TotalDataInMegaBytes: node.first("TotalDataInMegaBytes", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: output, named, enum
export type TableRestoreStatusType =
| "PENDING"
| "IN_PROGRESS"
| "SUCCEEDED"
| "FAILED"
| "CANCELED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface TaggedResource {
  Tag?: Tag | null;
  ResourceName?: string | null;
  ResourceType?: string | null;
}
function TaggedResource_Parse(node: xmlP.XmlNode): TaggedResource {
  return {
    ...node.strings({
      optional: {"ResourceName":true,"ResourceType":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
  };
}
