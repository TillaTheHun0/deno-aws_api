// Autogenerated API client for: Amazon Redshift

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export default class Redshift {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Redshift.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2012-12-01",
    "endpointPrefix": "redshift",
    "protocol": "query",
    "serviceFullName": "Amazon Redshift",
    "serviceId": "Redshift",
    "signatureVersion": "v4",
    "uid": "redshift-2012-12-01",
    "xmlNamespace": "http://redshift.amazonaws.com/doc/2012-12-01/"
  };

  async acceptReservedNodeExchange(
    {abortSignal, ...params}: RequestConfig & s.AcceptReservedNodeExchangeInputMessage,
  ): Promise<s.AcceptReservedNodeExchangeOutputMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedNodeId", (params["ReservedNodeId"] ?? '').toString());
    body.append(prefix+"TargetReservedNodeOfferingId", (params["TargetReservedNodeOfferingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptReservedNodeExchange",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AcceptReservedNodeExchangeResult");
    return {
      ExchangedReservedNode: xml.first("ExchangedReservedNode", false, ReservedNode_Parse),
    };
  }

  async authorizeClusterSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & s.AuthorizeClusterSecurityGroupIngressMessage,
  ): Promise<s.AuthorizeClusterSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeClusterSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AuthorizeClusterSecurityGroupIngressResult");
    return {
      ClusterSecurityGroup: xml.first("ClusterSecurityGroup", false, ClusterSecurityGroup_Parse),
    };
  }

  async authorizeSnapshotAccess(
    {abortSignal, ...params}: RequestConfig & s.AuthorizeSnapshotAccessMessage,
  ): Promise<s.AuthorizeSnapshotAccessResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+"SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
    body.append(prefix+"AccountWithRestoreAccess", (params["AccountWithRestoreAccess"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeSnapshotAccess",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AuthorizeSnapshotAccessResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async batchDeleteClusterSnapshots(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteClusterSnapshotsRequest,
  ): Promise<s.BatchDeleteClusterSnapshotsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identifiers"]) qsP.appendList(body, prefix+"Identifiers", params["Identifiers"], {"appender":DeleteClusterSnapshotMessage_Serialize,"entryPrefix":".DeleteClusterSnapshotMessage."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteClusterSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchDeleteClusterSnapshotsResult");
    return {
      Resources: xml.getList("Resources", "String").map(x => x.content ?? ''),
      Errors: xml.getList("Errors", "SnapshotErrorMessage").map(SnapshotErrorMessage_Parse),
    };
  }

  async batchModifyClusterSnapshots(
    {abortSignal, ...params}: RequestConfig & s.BatchModifyClusterSnapshotsMessage,
  ): Promise<s.BatchModifyClusterSnapshotsOutputMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["SnapshotIdentifierList"]) qsP.appendList(body, prefix+"SnapshotIdentifierList", params["SnapshotIdentifierList"], {"entryPrefix":".String."})
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchModifyClusterSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchModifyClusterSnapshotsResult");
    return {
      Resources: xml.getList("Resources", "String").map(x => x.content ?? ''),
      Errors: xml.getList("Errors", "SnapshotErrorMessage").map(SnapshotErrorMessage_Parse),
    };
  }

  async cancelResize(
    {abortSignal, ...params}: RequestConfig & s.CancelResizeMessage,
  ): Promise<s.ResizeProgressMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelResize",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CancelResizeResult");
    return {
      ...xml.strings({
        optional: {"TargetNodeType":true,"TargetClusterType":true,"Status":true,"ResizeType":true,"Message":true,"TargetEncryptionType":true},
      }),
      TargetNumberOfNodes: xml.first("TargetNumberOfNodes", false, x => parseInt(x.content ?? '0')),
      ImportTablesCompleted: xml.getList("ImportTablesCompleted", "member").map(x => x.content ?? ''),
      ImportTablesInProgress: xml.getList("ImportTablesInProgress", "member").map(x => x.content ?? ''),
      ImportTablesNotStarted: xml.getList("ImportTablesNotStarted", "member").map(x => x.content ?? ''),
      AvgResizeRateInMegaBytesPerSecond: xml.first("AvgResizeRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
      TotalResizeDataInMegaBytes: xml.first("TotalResizeDataInMegaBytes", false, x => parseInt(x.content ?? '0')),
      ProgressInMegaBytes: xml.first("ProgressInMegaBytes", false, x => parseInt(x.content ?? '0')),
      ElapsedTimeInSeconds: xml.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
      EstimatedTimeToCompletionInSeconds: xml.first("EstimatedTimeToCompletionInSeconds", false, x => parseInt(x.content ?? '0')),
      DataTransferProgressPercent: xml.first("DataTransferProgressPercent", false, x => parseFloat(x.content ?? '0')),
    };
  }

  async copyClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CopyClusterSnapshotMessage,
  ): Promise<s.CopyClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceSnapshotIdentifier", (params["SourceSnapshotIdentifier"] ?? '').toString());
    if ("SourceSnapshotClusterIdentifier" in params) body.append(prefix+"SourceSnapshotClusterIdentifier", (params["SourceSnapshotClusterIdentifier"] ?? '').toString());
    body.append(prefix+"TargetSnapshotIdentifier", (params["TargetSnapshotIdentifier"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CopyClusterSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async createCluster(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterMessage,
  ): Promise<s.CreateClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ClusterType" in params) body.append(prefix+"ClusterType", (params["ClusterType"] ?? '').toString());
    body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    body.append(prefix+"MasterUsername", (params["MasterUsername"] ?? '').toString());
    body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if (params["ClusterSecurityGroups"]) qsP.appendList(body, prefix+"ClusterSecurityGroups", params["ClusterSecurityGroups"], {"entryPrefix":".ClusterSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("ClusterSubnetGroupName" in params) body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("ClusterParameterGroupName" in params) body.append(prefix+"ClusterParameterGroupName", (params["ClusterParameterGroupName"] ?? '').toString());
    if ("AutomatedSnapshotRetentionPeriod" in params) body.append(prefix+"AutomatedSnapshotRetentionPeriod", (params["AutomatedSnapshotRetentionPeriod"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("ClusterVersion" in params) body.append(prefix+"ClusterVersion", (params["ClusterVersion"] ?? '').toString());
    if ("AllowVersionUpgrade" in params) body.append(prefix+"AllowVersionUpgrade", (params["AllowVersionUpgrade"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+"NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("HsmClientCertificateIdentifier" in params) body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if ("HsmConfigurationIdentifier" in params) body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    if ("ElasticIp" in params) body.append(prefix+"ElasticIp", (params["ElasticIp"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("EnhancedVpcRouting" in params) body.append(prefix+"EnhancedVpcRouting", (params["EnhancedVpcRouting"] ?? '').toString());
    if ("AdditionalInfo" in params) body.append(prefix+"AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    if (params["IamRoles"]) qsP.appendList(body, prefix+"IamRoles", params["IamRoles"], {"entryPrefix":".IamRoleArn."})
    if ("MaintenanceTrackName" in params) body.append(prefix+"MaintenanceTrackName", (params["MaintenanceTrackName"] ?? '').toString());
    if ("SnapshotScheduleIdentifier" in params) body.append(prefix+"SnapshotScheduleIdentifier", (params["SnapshotScheduleIdentifier"] ?? '').toString());
    if ("AvailabilityZoneRelocation" in params) body.append(prefix+"AvailabilityZoneRelocation", (params["AvailabilityZoneRelocation"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async createClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterParameterGroupMessage,
  ): Promise<s.CreateClusterParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    body.append(prefix+"ParameterGroupFamily", (params["ParameterGroupFamily"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterParameterGroupResult");
    return {
      ClusterParameterGroup: xml.first("ClusterParameterGroup", false, ClusterParameterGroup_Parse),
    };
  }

  async createClusterSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterSecurityGroupMessage,
  ): Promise<s.CreateClusterSecurityGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClusterSecurityGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterSecurityGroupResult");
    return {
      ClusterSecurityGroup: xml.first("ClusterSecurityGroup", false, ClusterSecurityGroup_Parse),
    };
  }

  async createClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterSnapshotMessage,
  ): Promise<s.CreateClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async createClusterSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterSubnetGroupMessage,
  ): Promise<s.CreateClusterSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClusterSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateClusterSubnetGroupResult");
    return {
      ClusterSubnetGroup: xml.first("ClusterSubnetGroup", false, ClusterSubnetGroup_Parse),
    };
  }

  async createEventSubscription(
    {abortSignal, ...params}: RequestConfig & s.CreateEventSubscriptionMessage,
  ): Promise<s.CreateEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["SourceIds"]) qsP.appendList(body, prefix+"SourceIds", params["SourceIds"], {"entryPrefix":".SourceId."})
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if ("Severity" in params) body.append(prefix+"Severity", (params["Severity"] ?? '').toString());
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async createHsmClientCertificate(
    {abortSignal, ...params}: RequestConfig & s.CreateHsmClientCertificateMessage,
  ): Promise<s.CreateHsmClientCertificateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHsmClientCertificate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateHsmClientCertificateResult");
    return {
      HsmClientCertificate: xml.first("HsmClientCertificate", false, HsmClientCertificate_Parse),
    };
  }

  async createHsmConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateHsmConfigurationMessage,
  ): Promise<s.CreateHsmConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    body.append(prefix+"HsmIpAddress", (params["HsmIpAddress"] ?? '').toString());
    body.append(prefix+"HsmPartitionName", (params["HsmPartitionName"] ?? '').toString());
    body.append(prefix+"HsmPartitionPassword", (params["HsmPartitionPassword"] ?? '').toString());
    body.append(prefix+"HsmServerPublicCertificate", (params["HsmServerPublicCertificate"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHsmConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateHsmConfigurationResult");
    return {
      HsmConfiguration: xml.first("HsmConfiguration", false, HsmConfiguration_Parse),
    };
  }

  async createScheduledAction(
    {abortSignal, ...params}: RequestConfig & s.CreateScheduledActionMessage,
  ): Promise<s.ScheduledAction> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    ScheduledActionType_Serialize(body, prefix+"TargetAction", params["TargetAction"]);
    body.append(prefix+"Schedule", (params["Schedule"] ?? '').toString());
    body.append(prefix+"IamRole", (params["IamRole"] ?? '').toString());
    if ("ScheduledActionDescription" in params) body.append(prefix+"ScheduledActionDescription", (params["ScheduledActionDescription"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Enable" in params) body.append(prefix+"Enable", (params["Enable"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateScheduledAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateScheduledActionResult");
    return ScheduledAction_Parse(xml);
  }

  async createSnapshotCopyGrant(
    {abortSignal, ...params}: RequestConfig & s.CreateSnapshotCopyGrantMessage,
  ): Promise<s.CreateSnapshotCopyGrantResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotCopyGrantName", (params["SnapshotCopyGrantName"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshotCopyGrant",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateSnapshotCopyGrantResult");
    return {
      SnapshotCopyGrant: xml.first("SnapshotCopyGrant", false, SnapshotCopyGrant_Parse),
    };
  }

  async createSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & s.CreateSnapshotScheduleMessage = {},
  ): Promise<s.SnapshotSchedule> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ScheduleDefinitions"]) qsP.appendList(body, prefix+"ScheduleDefinitions", params["ScheduleDefinitions"], {"entryPrefix":".ScheduleDefinition."})
    if ("ScheduleIdentifier" in params) body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    if ("ScheduleDescription" in params) body.append(prefix+"ScheduleDescription", (params["ScheduleDescription"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextInvocations" in params) body.append(prefix+"NextInvocations", (params["NextInvocations"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshotSchedule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateSnapshotScheduleResult");
    return SnapshotSchedule_Parse(xml);
  }

  async createTags(
    {abortSignal, ...params}: RequestConfig & s.CreateTagsMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTags",
    });
  }

  async createUsageLimit(
    {abortSignal, ...params}: RequestConfig & s.CreateUsageLimitMessage,
  ): Promise<s.UsageLimit> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"FeatureType", (params["FeatureType"] ?? '').toString());
    body.append(prefix+"LimitType", (params["LimitType"] ?? '').toString());
    body.append(prefix+"Amount", (params["Amount"] ?? '').toString());
    if ("Period" in params) body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if ("BreachAction" in params) body.append(prefix+"BreachAction", (params["BreachAction"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUsageLimit",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateUsageLimitResult");
    return UsageLimit_Parse(xml);
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterMessage,
  ): Promise<s.DeleteClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("SkipFinalClusterSnapshot" in params) body.append(prefix+"SkipFinalClusterSnapshot", (params["SkipFinalClusterSnapshot"] ?? '').toString());
    if ("FinalClusterSnapshotIdentifier" in params) body.append(prefix+"FinalClusterSnapshotIdentifier", (params["FinalClusterSnapshotIdentifier"] ?? '').toString());
    if ("FinalClusterSnapshotRetentionPeriod" in params) body.append(prefix+"FinalClusterSnapshotRetentionPeriod", (params["FinalClusterSnapshotRetentionPeriod"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async deleteClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterParameterGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClusterParameterGroup",
    });
  }

  async deleteClusterSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterSecurityGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClusterSecurityGroup",
    });
  }

  async deleteClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterSnapshotMessage,
  ): Promise<s.DeleteClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+"SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteClusterSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async deleteClusterSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterSubnetGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClusterSubnetGroup",
    });
  }

  async deleteEventSubscription(
    {abortSignal, ...params}: RequestConfig & s.DeleteEventSubscriptionMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventSubscription",
    });
  }

  async deleteHsmClientCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteHsmClientCertificateMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteHsmClientCertificate",
    });
  }

  async deleteHsmConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteHsmConfigurationMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteHsmConfiguration",
    });
  }

  async deleteScheduledAction(
    {abortSignal, ...params}: RequestConfig & s.DeleteScheduledActionMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteScheduledAction",
    });
  }

  async deleteSnapshotCopyGrant(
    {abortSignal, ...params}: RequestConfig & s.DeleteSnapshotCopyGrantMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotCopyGrantName", (params["SnapshotCopyGrantName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshotCopyGrant",
    });
  }

  async deleteSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & s.DeleteSnapshotScheduleMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshotSchedule",
    });
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & s.DeleteTagsMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
  }

  async deleteUsageLimit(
    {abortSignal, ...params}: RequestConfig & s.DeleteUsageLimitMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UsageLimitId", (params["UsageLimitId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUsageLimit",
    });
  }

  async describeAccountAttributes(
    {abortSignal, ...params}: RequestConfig & s.DescribeAccountAttributesMessage = {},
  ): Promise<s.AccountAttributeList> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AttributeNames"]) qsP.appendList(body, prefix+"AttributeNames", params["AttributeNames"], {"entryPrefix":".AttributeName."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAccountAttributesResult");
    return {
      AccountAttributes: xml.getList("AccountAttributes", "AccountAttribute").map(AccountAttribute_Parse),
    };
  }

  async describeClusterDbRevisions(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterDbRevisionsMessage = {},
  ): Promise<s.ClusterDbRevisionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterDbRevisions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterDbRevisionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ClusterDbRevisions: xml.getList("ClusterDbRevisions", "ClusterDbRevision").map(ClusterDbRevision_Parse),
    };
  }

  async describeClusterParameterGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterParameterGroupsMessage = {},
  ): Promise<s.ClusterParameterGroupsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ParameterGroupName" in params) body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterParameterGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterParameterGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ParameterGroups: xml.getList("ParameterGroups", "ClusterParameterGroup").map(ClusterParameterGroup_Parse),
    };
  }

  async describeClusterParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterParametersMessage,
  ): Promise<s.ClusterParameterGroupDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterParametersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Parameters: xml.getList("Parameters", "Parameter").map(Parameter_Parse),
    };
  }

  async describeClusterSecurityGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterSecurityGroupsMessage = {},
  ): Promise<s.ClusterSecurityGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterSecurityGroupName" in params) body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterSecurityGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ClusterSecurityGroups: xml.getList("ClusterSecurityGroups", "ClusterSecurityGroup").map(ClusterSecurityGroup_Parse),
    };
  }

  async describeClusterSnapshots(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterSnapshotsMessage = {},
  ): Promise<s.SnapshotMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("SnapshotIdentifier" in params) body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotType" in params) body.append(prefix+"SnapshotType", (params["SnapshotType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("OwnerAccount" in params) body.append(prefix+"OwnerAccount", (params["OwnerAccount"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    if ("ClusterExists" in params) body.append(prefix+"ClusterExists", (params["ClusterExists"] ?? '').toString());
    if (params["SortingEntities"]) qsP.appendList(body, prefix+"SortingEntities", params["SortingEntities"], {"appender":SnapshotSortingEntity_Serialize,"entryPrefix":".SnapshotSortingEntity."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterSnapshotsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Snapshots: xml.getList("Snapshots", "Snapshot").map(Snapshot_Parse),
    };
  }

  async describeClusterSubnetGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterSubnetGroupsMessage = {},
  ): Promise<s.ClusterSubnetGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterSubnetGroupName" in params) body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterSubnetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterSubnetGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ClusterSubnetGroups: xml.getList("ClusterSubnetGroups", "ClusterSubnetGroup").map(ClusterSubnetGroup_Parse),
    };
  }

  async describeClusterTracks(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterTracksMessage = {},
  ): Promise<s.TrackListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("MaintenanceTrackName" in params) body.append(prefix+"MaintenanceTrackName", (params["MaintenanceTrackName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterTracks",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterTracksResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      MaintenanceTracks: xml.getList("MaintenanceTracks", "MaintenanceTrack").map(MaintenanceTrack_Parse),
    };
  }

  async describeClusterVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterVersionsMessage = {},
  ): Promise<s.ClusterVersionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterVersion" in params) body.append(prefix+"ClusterVersion", (params["ClusterVersion"] ?? '').toString());
    if ("ClusterParameterGroupFamily" in params) body.append(prefix+"ClusterParameterGroupFamily", (params["ClusterParameterGroupFamily"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusterVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClusterVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ClusterVersions: xml.getList("ClusterVersions", "ClusterVersion").map(ClusterVersion_Parse),
    };
  }

  async describeClusters(
    {abortSignal, ...params}: RequestConfig & s.DescribeClustersMessage = {},
  ): Promise<s.ClustersMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeClustersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Clusters: xml.getList("Clusters", "Cluster").map(Cluster_Parse),
    };
  }

  async describeDefaultClusterParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeDefaultClusterParametersMessage,
  ): Promise<s.DescribeDefaultClusterParametersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupFamily", (params["ParameterGroupFamily"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDefaultClusterParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDefaultClusterParametersResult");
    return {
      DefaultClusterParameters: xml.first("DefaultClusterParameters", false, DefaultClusterParameters_Parse),
    };
  }

  async describeEventCategories(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventCategoriesMessage = {},
  ): Promise<s.EventCategoriesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventCategories",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventCategoriesResult");
    return {
      EventCategoriesMapList: xml.getList("EventCategoriesMapList", "EventCategoriesMap").map(EventCategoriesMap_Parse),
    };
  }

  async describeEventSubscriptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventSubscriptionsMessage = {},
  ): Promise<s.EventSubscriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SubscriptionName" in params) body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventSubscriptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventSubscriptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      EventSubscriptionsList: xml.getList("EventSubscriptionsList", "EventSubscription").map(EventSubscription_Parse),
    };
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsMessage = {},
  ): Promise<s.EventsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceIdentifier" in params) body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Events: xml.getList("Events", "Event").map(Event_Parse),
    };
  }

  async describeHsmClientCertificates(
    {abortSignal, ...params}: RequestConfig & s.DescribeHsmClientCertificatesMessage = {},
  ): Promise<s.HsmClientCertificateMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("HsmClientCertificateIdentifier" in params) body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHsmClientCertificates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeHsmClientCertificatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      HsmClientCertificates: xml.getList("HsmClientCertificates", "HsmClientCertificate").map(HsmClientCertificate_Parse),
    };
  }

  async describeHsmConfigurations(
    {abortSignal, ...params}: RequestConfig & s.DescribeHsmConfigurationsMessage = {},
  ): Promise<s.HsmConfigurationMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("HsmConfigurationIdentifier" in params) body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHsmConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeHsmConfigurationsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      HsmConfigurations: xml.getList("HsmConfigurations", "HsmConfiguration").map(HsmConfiguration_Parse),
    };
  }

  async describeLoggingStatus(
    {abortSignal, ...params}: RequestConfig & s.DescribeLoggingStatusMessage,
  ): Promise<s.LoggingStatus> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoggingStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLoggingStatusResult");
    return {
      ...xml.strings({
        optional: {"BucketName":true,"S3KeyPrefix":true,"LastFailureMessage":true},
      }),
      LoggingEnabled: xml.first("LoggingEnabled", false, x => x.content === 'true'),
      LastSuccessfulDeliveryTime: xml.first("LastSuccessfulDeliveryTime", false, x => xmlP.parseTimestamp(x.content)),
      LastFailureTime: xml.first("LastFailureTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeNodeConfigurationOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeNodeConfigurationOptionsMessage,
  ): Promise<s.NodeConfigurationOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ActionType", (params["ActionType"] ?? '').toString());
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("SnapshotIdentifier" in params) body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("OwnerAccount" in params) body.append(prefix+"OwnerAccount", (params["OwnerAccount"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":NodeConfigurationOptionsFilter_Serialize,"entryPrefix":".NodeConfigurationOptionsFilter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNodeConfigurationOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeNodeConfigurationOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      NodeConfigurationOptionList: xml.getList("NodeConfigurationOptionList", "NodeConfigurationOption").map(NodeConfigurationOption_Parse),
    };
  }

  async describeOrderableClusterOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeOrderableClusterOptionsMessage = {},
  ): Promise<s.OrderableClusterOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterVersion" in params) body.append(prefix+"ClusterVersion", (params["ClusterVersion"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOrderableClusterOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeOrderableClusterOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OrderableClusterOptions: xml.getList("OrderableClusterOptions", "OrderableClusterOption").map(OrderableClusterOption_Parse),
    };
  }

  async describeReservedNodeOfferings(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedNodeOfferingsMessage = {},
  ): Promise<s.ReservedNodeOfferingsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedNodeOfferingId" in params) body.append(prefix+"ReservedNodeOfferingId", (params["ReservedNodeOfferingId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedNodeOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedNodeOfferingsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedNodeOfferings: xml.getList("ReservedNodeOfferings", "ReservedNodeOffering").map(ReservedNodeOffering_Parse),
    };
  }

  async describeReservedNodes(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedNodesMessage = {},
  ): Promise<s.ReservedNodesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedNodeId" in params) body.append(prefix+"ReservedNodeId", (params["ReservedNodeId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedNodes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedNodesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedNodes: xml.getList("ReservedNodes", "ReservedNode").map(ReservedNode_Parse),
    };
  }

  async describeResize(
    {abortSignal, ...params}: RequestConfig & s.DescribeResizeMessage,
  ): Promise<s.ResizeProgressMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeResize",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeResizeResult");
    return {
      ...xml.strings({
        optional: {"TargetNodeType":true,"TargetClusterType":true,"Status":true,"ResizeType":true,"Message":true,"TargetEncryptionType":true},
      }),
      TargetNumberOfNodes: xml.first("TargetNumberOfNodes", false, x => parseInt(x.content ?? '0')),
      ImportTablesCompleted: xml.getList("ImportTablesCompleted", "member").map(x => x.content ?? ''),
      ImportTablesInProgress: xml.getList("ImportTablesInProgress", "member").map(x => x.content ?? ''),
      ImportTablesNotStarted: xml.getList("ImportTablesNotStarted", "member").map(x => x.content ?? ''),
      AvgResizeRateInMegaBytesPerSecond: xml.first("AvgResizeRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
      TotalResizeDataInMegaBytes: xml.first("TotalResizeDataInMegaBytes", false, x => parseInt(x.content ?? '0')),
      ProgressInMegaBytes: xml.first("ProgressInMegaBytes", false, x => parseInt(x.content ?? '0')),
      ElapsedTimeInSeconds: xml.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
      EstimatedTimeToCompletionInSeconds: xml.first("EstimatedTimeToCompletionInSeconds", false, x => parseInt(x.content ?? '0')),
      DataTransferProgressPercent: xml.first("DataTransferProgressPercent", false, x => parseFloat(x.content ?? '0')),
    };
  }

  async describeScheduledActions(
    {abortSignal, ...params}: RequestConfig & s.DescribeScheduledActionsMessage = {},
  ): Promise<s.ScheduledActionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ScheduledActionName" in params) body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    if ("TargetActionType" in params) body.append(prefix+"TargetActionType", (params["TargetActionType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Active" in params) body.append(prefix+"Active", (params["Active"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":ScheduledActionFilter_Serialize,"entryPrefix":".ScheduledActionFilter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScheduledActions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeScheduledActionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ScheduledActions: xml.getList("ScheduledActions", "ScheduledAction").map(ScheduledAction_Parse),
    };
  }

  async describeSnapshotCopyGrants(
    {abortSignal, ...params}: RequestConfig & s.DescribeSnapshotCopyGrantsMessage = {},
  ): Promise<s.SnapshotCopyGrantMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SnapshotCopyGrantName" in params) body.append(prefix+"SnapshotCopyGrantName", (params["SnapshotCopyGrantName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshotCopyGrants",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeSnapshotCopyGrantsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      SnapshotCopyGrants: xml.getList("SnapshotCopyGrants", "SnapshotCopyGrant").map(SnapshotCopyGrant_Parse),
    };
  }

  async describeSnapshotSchedules(
    {abortSignal, ...params}: RequestConfig & s.DescribeSnapshotSchedulesMessage = {},
  ): Promise<s.DescribeSnapshotSchedulesOutputMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ScheduleIdentifier" in params) body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshotSchedules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeSnapshotSchedulesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      SnapshotSchedules: xml.getList("SnapshotSchedules", "SnapshotSchedule").map(SnapshotSchedule_Parse),
    };
  }

  async describeStorage(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.CustomerStorageMessage> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeStorage",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStorageResult");
    return {
      TotalBackupSizeInMegaBytes: xml.first("TotalBackupSizeInMegaBytes", false, x => parseFloat(x.content ?? '0')),
      TotalProvisionedStorageInMegaBytes: xml.first("TotalProvisionedStorageInMegaBytes", false, x => parseFloat(x.content ?? '0')),
    };
  }

  async describeTableRestoreStatus(
    {abortSignal, ...params}: RequestConfig & s.DescribeTableRestoreStatusMessage = {},
  ): Promise<s.TableRestoreStatusMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("TableRestoreRequestId" in params) body.append(prefix+"TableRestoreRequestId", (params["TableRestoreRequestId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTableRestoreStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTableRestoreStatusResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      TableRestoreStatusDetails: xml.getList("TableRestoreStatusDetails", "TableRestoreStatus").map(TableRestoreStatus_Parse),
    };
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & s.DescribeTagsMessage = {},
  ): Promise<s.TaggedResourceListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ResourceName" in params) body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if ("ResourceType" in params) body.append(prefix+"ResourceType", (params["ResourceType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTagsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      TaggedResources: xml.getList("TaggedResources", "TaggedResource").map(TaggedResource_Parse),
    };
  }

  async describeUsageLimits(
    {abortSignal, ...params}: RequestConfig & s.DescribeUsageLimitsMessage = {},
  ): Promise<s.UsageLimitList> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UsageLimitId" in params) body.append(prefix+"UsageLimitId", (params["UsageLimitId"] ?? '').toString());
    if ("ClusterIdentifier" in params) body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("FeatureType" in params) body.append(prefix+"FeatureType", (params["FeatureType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".TagKey."})
    if (params["TagValues"]) qsP.appendList(body, prefix+"TagValues", params["TagValues"], {"entryPrefix":".TagValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUsageLimits",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeUsageLimitsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      UsageLimits: xml.getList("UsageLimits", "member").map(UsageLimit_Parse),
    };
  }

  async disableLogging(
    {abortSignal, ...params}: RequestConfig & s.DisableLoggingMessage,
  ): Promise<s.LoggingStatus> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableLogging",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DisableLoggingResult");
    return {
      ...xml.strings({
        optional: {"BucketName":true,"S3KeyPrefix":true,"LastFailureMessage":true},
      }),
      LoggingEnabled: xml.first("LoggingEnabled", false, x => x.content === 'true'),
      LastSuccessfulDeliveryTime: xml.first("LastSuccessfulDeliveryTime", false, x => xmlP.parseTimestamp(x.content)),
      LastFailureTime: xml.first("LastFailureTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async disableSnapshotCopy(
    {abortSignal, ...params}: RequestConfig & s.DisableSnapshotCopyMessage,
  ): Promise<s.DisableSnapshotCopyResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableSnapshotCopy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DisableSnapshotCopyResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async enableLogging(
    {abortSignal, ...params}: RequestConfig & s.EnableLoggingMessage,
  ): Promise<s.LoggingStatus> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"BucketName", (params["BucketName"] ?? '').toString());
    if ("S3KeyPrefix" in params) body.append(prefix+"S3KeyPrefix", (params["S3KeyPrefix"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableLogging",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EnableLoggingResult");
    return {
      ...xml.strings({
        optional: {"BucketName":true,"S3KeyPrefix":true,"LastFailureMessage":true},
      }),
      LoggingEnabled: xml.first("LoggingEnabled", false, x => x.content === 'true'),
      LastSuccessfulDeliveryTime: xml.first("LastSuccessfulDeliveryTime", false, x => xmlP.parseTimestamp(x.content)),
      LastFailureTime: xml.first("LastFailureTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async enableSnapshotCopy(
    {abortSignal, ...params}: RequestConfig & s.EnableSnapshotCopyMessage,
  ): Promise<s.EnableSnapshotCopyResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"DestinationRegion", (params["DestinationRegion"] ?? '').toString());
    if ("RetentionPeriod" in params) body.append(prefix+"RetentionPeriod", (params["RetentionPeriod"] ?? '').toString());
    if ("SnapshotCopyGrantName" in params) body.append(prefix+"SnapshotCopyGrantName", (params["SnapshotCopyGrantName"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableSnapshotCopy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EnableSnapshotCopyResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async getClusterCredentials(
    {abortSignal, ...params}: RequestConfig & s.GetClusterCredentialsMessage,
  ): Promise<s.ClusterCredentials> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DbUser", (params["DbUser"] ?? '').toString());
    if ("DbName" in params) body.append(prefix+"DbName", (params["DbName"] ?? '').toString());
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("DurationSeconds" in params) body.append(prefix+"DurationSeconds", (params["DurationSeconds"] ?? '').toString());
    if ("AutoCreate" in params) body.append(prefix+"AutoCreate", (params["AutoCreate"] ?? '').toString());
    if (params["DbGroups"]) qsP.appendList(body, prefix+"DbGroups", params["DbGroups"], {"entryPrefix":".DbGroup."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetClusterCredentials",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetClusterCredentialsResult");
    return {
      ...xml.strings({
        optional: {"DbUser":true,"DbPassword":true},
      }),
      Expiration: xml.first("Expiration", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getReservedNodeExchangeOfferings(
    {abortSignal, ...params}: RequestConfig & s.GetReservedNodeExchangeOfferingsInputMessage,
  ): Promise<s.GetReservedNodeExchangeOfferingsOutputMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedNodeId", (params["ReservedNodeId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservedNodeExchangeOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetReservedNodeExchangeOfferingsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedNodeOfferings: xml.getList("ReservedNodeOfferings", "ReservedNodeOffering").map(ReservedNodeOffering_Parse),
    };
  }

  async modifyCluster(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterMessage,
  ): Promise<s.ModifyClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ClusterType" in params) body.append(prefix+"ClusterType", (params["ClusterType"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+"NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if (params["ClusterSecurityGroups"]) qsP.appendList(body, prefix+"ClusterSecurityGroups", params["ClusterSecurityGroups"], {"entryPrefix":".ClusterSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("ClusterParameterGroupName" in params) body.append(prefix+"ClusterParameterGroupName", (params["ClusterParameterGroupName"] ?? '').toString());
    if ("AutomatedSnapshotRetentionPeriod" in params) body.append(prefix+"AutomatedSnapshotRetentionPeriod", (params["AutomatedSnapshotRetentionPeriod"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("ClusterVersion" in params) body.append(prefix+"ClusterVersion", (params["ClusterVersion"] ?? '').toString());
    if ("AllowVersionUpgrade" in params) body.append(prefix+"AllowVersionUpgrade", (params["AllowVersionUpgrade"] ?? '').toString());
    if ("HsmClientCertificateIdentifier" in params) body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if ("HsmConfigurationIdentifier" in params) body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    if ("NewClusterIdentifier" in params) body.append(prefix+"NewClusterIdentifier", (params["NewClusterIdentifier"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("ElasticIp" in params) body.append(prefix+"ElasticIp", (params["ElasticIp"] ?? '').toString());
    if ("EnhancedVpcRouting" in params) body.append(prefix+"EnhancedVpcRouting", (params["EnhancedVpcRouting"] ?? '').toString());
    if ("MaintenanceTrackName" in params) body.append(prefix+"MaintenanceTrackName", (params["MaintenanceTrackName"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("AvailabilityZoneRelocation" in params) body.append(prefix+"AvailabilityZoneRelocation", (params["AvailabilityZoneRelocation"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifyClusterDbRevision(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterDbRevisionMessage,
  ): Promise<s.ModifyClusterDbRevisionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"RevisionTarget", (params["RevisionTarget"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterDbRevision",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterDbRevisionResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifyClusterIamRoles(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterIamRolesMessage,
  ): Promise<s.ModifyClusterIamRolesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if (params["AddIamRoles"]) qsP.appendList(body, prefix+"AddIamRoles", params["AddIamRoles"], {"entryPrefix":".IamRoleArn."})
    if (params["RemoveIamRoles"]) qsP.appendList(body, prefix+"RemoveIamRoles", params["RemoveIamRoles"], {"entryPrefix":".IamRoleArn."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterIamRoles",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterIamRolesResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifyClusterMaintenance(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterMaintenanceMessage,
  ): Promise<s.ModifyClusterMaintenanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("DeferMaintenance" in params) body.append(prefix+"DeferMaintenance", (params["DeferMaintenance"] ?? '').toString());
    if ("DeferMaintenanceIdentifier" in params) body.append(prefix+"DeferMaintenanceIdentifier", (params["DeferMaintenanceIdentifier"] ?? '').toString());
    if ("DeferMaintenanceStartTime" in params) body.append(prefix+"DeferMaintenanceStartTime", qsP.encodeDate_iso8601(params["DeferMaintenanceStartTime"]));
    if ("DeferMaintenanceEndTime" in params) body.append(prefix+"DeferMaintenanceEndTime", qsP.encodeDate_iso8601(params["DeferMaintenanceEndTime"]));
    if ("DeferMaintenanceDuration" in params) body.append(prefix+"DeferMaintenanceDuration", (params["DeferMaintenanceDuration"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterMaintenance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterMaintenanceResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifyClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterParameterGroupMessage,
  ): Promise<s.ClusterParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterParameterGroupResult");
    return xml.strings({
      optional: {"ParameterGroupName":true,"ParameterGroupStatus":true},
    });
  }

  async modifyClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterSnapshotMessage,
  ): Promise<s.ModifyClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async modifyClusterSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterSnapshotScheduleMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ScheduleIdentifier" in params) body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    if ("DisassociateSchedule" in params) body.append(prefix+"DisassociateSchedule", (params["DisassociateSchedule"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterSnapshotSchedule",
    });
  }

  async modifyClusterSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterSubnetGroupMessage,
  ): Promise<s.ModifyClusterSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClusterSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyClusterSubnetGroupResult");
    return {
      ClusterSubnetGroup: xml.first("ClusterSubnetGroup", false, ClusterSubnetGroup_Parse),
    };
  }

  async modifyEventSubscription(
    {abortSignal, ...params}: RequestConfig & s.ModifyEventSubscriptionMessage,
  ): Promise<s.ModifyEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if ("SnsTopicArn" in params) body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["SourceIds"]) qsP.appendList(body, prefix+"SourceIds", params["SourceIds"], {"entryPrefix":".SourceId."})
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if ("Severity" in params) body.append(prefix+"Severity", (params["Severity"] ?? '').toString());
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async modifyScheduledAction(
    {abortSignal, ...params}: RequestConfig & s.ModifyScheduledActionMessage,
  ): Promise<s.ScheduledAction> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    if (params["TargetAction"] != null) ScheduledActionType_Serialize(body, prefix+"TargetAction", params["TargetAction"]);
    if ("Schedule" in params) body.append(prefix+"Schedule", (params["Schedule"] ?? '').toString());
    if ("IamRole" in params) body.append(prefix+"IamRole", (params["IamRole"] ?? '').toString());
    if ("ScheduledActionDescription" in params) body.append(prefix+"ScheduledActionDescription", (params["ScheduledActionDescription"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Enable" in params) body.append(prefix+"Enable", (params["Enable"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyScheduledAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyScheduledActionResult");
    return ScheduledAction_Parse(xml);
  }

  async modifySnapshotCopyRetentionPeriod(
    {abortSignal, ...params}: RequestConfig & s.ModifySnapshotCopyRetentionPeriodMessage,
  ): Promise<s.ModifySnapshotCopyRetentionPeriodResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"RetentionPeriod", (params["RetentionPeriod"] ?? '').toString());
    if ("Manual" in params) body.append(prefix+"Manual", (params["Manual"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySnapshotCopyRetentionPeriod",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifySnapshotCopyRetentionPeriodResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async modifySnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & s.ModifySnapshotScheduleMessage,
  ): Promise<s.SnapshotSchedule> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ScheduleIdentifier", (params["ScheduleIdentifier"] ?? '').toString());
    if (params["ScheduleDefinitions"]) qsP.appendList(body, prefix+"ScheduleDefinitions", params["ScheduleDefinitions"], {"entryPrefix":".ScheduleDefinition."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySnapshotSchedule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifySnapshotScheduleResult");
    return SnapshotSchedule_Parse(xml);
  }

  async modifyUsageLimit(
    {abortSignal, ...params}: RequestConfig & s.ModifyUsageLimitMessage,
  ): Promise<s.UsageLimit> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UsageLimitId", (params["UsageLimitId"] ?? '').toString());
    if ("Amount" in params) body.append(prefix+"Amount", (params["Amount"] ?? '').toString());
    if ("BreachAction" in params) body.append(prefix+"BreachAction", (params["BreachAction"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyUsageLimit",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyUsageLimitResult");
    return UsageLimit_Parse(xml);
  }

  async pauseCluster(
    {abortSignal, ...params}: RequestConfig & s.PauseClusterMessage,
  ): Promise<s.PauseClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PauseCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PauseClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async purchaseReservedNodeOffering(
    {abortSignal, ...params}: RequestConfig & s.PurchaseReservedNodeOfferingMessage,
  ): Promise<s.PurchaseReservedNodeOfferingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedNodeOfferingId", (params["ReservedNodeOfferingId"] ?? '').toString());
    if ("NodeCount" in params) body.append(prefix+"NodeCount", (params["NodeCount"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedNodeOffering",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PurchaseReservedNodeOfferingResult");
    return {
      ReservedNode: xml.first("ReservedNode", false, ReservedNode_Parse),
    };
  }

  async rebootCluster(
    {abortSignal, ...params}: RequestConfig & s.RebootClusterMessage,
  ): Promise<s.RebootClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RebootClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async resetClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.ResetClusterParameterGroupMessage,
  ): Promise<s.ClusterParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ParameterGroupName", (params["ParameterGroupName"] ?? '').toString());
    if ("ResetAllParameters" in params) body.append(prefix+"ResetAllParameters", (params["ResetAllParameters"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResetClusterParameterGroupResult");
    return xml.strings({
      optional: {"ParameterGroupName":true,"ParameterGroupStatus":true},
    });
  }

  async resizeCluster(
    {abortSignal, ...params}: RequestConfig & s.ResizeClusterMessage,
  ): Promise<s.ResizeClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ClusterType" in params) body.append(prefix+"ClusterType", (params["ClusterType"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+"NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if ("Classic" in params) body.append(prefix+"Classic", (params["Classic"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResizeCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResizeClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async restoreFromClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & s.RestoreFromClusterSnapshotMessage,
  ): Promise<s.RestoreFromClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+"SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("AllowVersionUpgrade" in params) body.append(prefix+"AllowVersionUpgrade", (params["AllowVersionUpgrade"] ?? '').toString());
    if ("ClusterSubnetGroupName" in params) body.append(prefix+"ClusterSubnetGroupName", (params["ClusterSubnetGroupName"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("OwnerAccount" in params) body.append(prefix+"OwnerAccount", (params["OwnerAccount"] ?? '').toString());
    if ("HsmClientCertificateIdentifier" in params) body.append(prefix+"HsmClientCertificateIdentifier", (params["HsmClientCertificateIdentifier"] ?? '').toString());
    if ("HsmConfigurationIdentifier" in params) body.append(prefix+"HsmConfigurationIdentifier", (params["HsmConfigurationIdentifier"] ?? '').toString());
    if ("ElasticIp" in params) body.append(prefix+"ElasticIp", (params["ElasticIp"] ?? '').toString());
    if ("ClusterParameterGroupName" in params) body.append(prefix+"ClusterParameterGroupName", (params["ClusterParameterGroupName"] ?? '').toString());
    if (params["ClusterSecurityGroups"]) qsP.appendList(body, prefix+"ClusterSecurityGroups", params["ClusterSecurityGroups"], {"entryPrefix":".ClusterSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("AutomatedSnapshotRetentionPeriod" in params) body.append(prefix+"AutomatedSnapshotRetentionPeriod", (params["AutomatedSnapshotRetentionPeriod"] ?? '').toString());
    if ("ManualSnapshotRetentionPeriod" in params) body.append(prefix+"ManualSnapshotRetentionPeriod", (params["ManualSnapshotRetentionPeriod"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+"NodeType", (params["NodeType"] ?? '').toString());
    if ("EnhancedVpcRouting" in params) body.append(prefix+"EnhancedVpcRouting", (params["EnhancedVpcRouting"] ?? '').toString());
    if ("AdditionalInfo" in params) body.append(prefix+"AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    if (params["IamRoles"]) qsP.appendList(body, prefix+"IamRoles", params["IamRoles"], {"entryPrefix":".IamRoleArn."})
    if ("MaintenanceTrackName" in params) body.append(prefix+"MaintenanceTrackName", (params["MaintenanceTrackName"] ?? '').toString());
    if ("SnapshotScheduleIdentifier" in params) body.append(prefix+"SnapshotScheduleIdentifier", (params["SnapshotScheduleIdentifier"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+"NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if ("AvailabilityZoneRelocation" in params) body.append(prefix+"AvailabilityZoneRelocation", (params["AvailabilityZoneRelocation"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreFromClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreFromClusterSnapshotResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async restoreTableFromClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & s.RestoreTableFromClusterSnapshotMessage,
  ): Promise<s.RestoreTableFromClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"SourceDatabaseName", (params["SourceDatabaseName"] ?? '').toString());
    if ("SourceSchemaName" in params) body.append(prefix+"SourceSchemaName", (params["SourceSchemaName"] ?? '').toString());
    body.append(prefix+"SourceTableName", (params["SourceTableName"] ?? '').toString());
    if ("TargetDatabaseName" in params) body.append(prefix+"TargetDatabaseName", (params["TargetDatabaseName"] ?? '').toString());
    if ("TargetSchemaName" in params) body.append(prefix+"TargetSchemaName", (params["TargetSchemaName"] ?? '').toString());
    body.append(prefix+"NewTableName", (params["NewTableName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreTableFromClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreTableFromClusterSnapshotResult");
    return {
      TableRestoreStatus: xml.first("TableRestoreStatus", false, TableRestoreStatus_Parse),
    };
  }

  async resumeCluster(
    {abortSignal, ...params}: RequestConfig & s.ResumeClusterMessage,
  ): Promise<s.ResumeClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResumeCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResumeClusterResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  async revokeClusterSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & s.RevokeClusterSecurityGroupIngressMessage,
  ): Promise<s.RevokeClusterSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterSecurityGroupName", (params["ClusterSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeClusterSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RevokeClusterSecurityGroupIngressResult");
    return {
      ClusterSecurityGroup: xml.first("ClusterSecurityGroup", false, ClusterSecurityGroup_Parse),
    };
  }

  async revokeSnapshotAccess(
    {abortSignal, ...params}: RequestConfig & s.RevokeSnapshotAccessMessage,
  ): Promise<s.RevokeSnapshotAccessResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+"SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
    body.append(prefix+"AccountWithRestoreAccess", (params["AccountWithRestoreAccess"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeSnapshotAccess",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RevokeSnapshotAccessResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async rotateEncryptionKey(
    {abortSignal, ...params}: RequestConfig & s.RotateEncryptionKeyMessage,
  ): Promise<s.RotateEncryptionKeyResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RotateEncryptionKey",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RotateEncryptionKeyResult");
    return {
      Cluster: xml.first("Cluster", false, Cluster_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 30 times, 60 seconds apart (about 30 minutes max wait time). */
  async waitForClusterAvailable(
    params: RequestConfig & s.DescribeClustersMessage,
  ): Promise<s.ClustersMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterAvailable';
    for (let i = 0; i < 30; i++) {
      try {
        const resp = await this.describeClusters(params);
        const field = resp?.Clusters?.flatMap(x => x?.ClusterStatus);
        if (field?.every(x => x === "available")) return resp;
        if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      } catch (err) {
        if (!["ClusterNotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 30 times, 60 seconds apart (about 30 minutes max wait time). */
  async waitForClusterDeleted(
    params: RequestConfig & s.DescribeClustersMessage,
  ): Promise<Error | s.ClustersMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterDeleted';
    for (let i = 0; i < 30; i++) {
      try {
        const resp = await this.describeClusters(params);
        const field = resp?.Clusters?.flatMap(x => x?.ClusterStatus);
        if (field?.some(x => x === "creating")) throw new Error(errMessage);
        if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      } catch (err) {
        if (["ClusterNotFound"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 30 times, 60 seconds apart (about 30 minutes max wait time). */
  async waitForClusterRestored(
    params: RequestConfig & s.DescribeClustersMessage,
  ): Promise<s.ClustersMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterRestored';
    for (let i = 0; i < 30; i++) {
      const resp = await this.describeClusters(params);
      if (resp?.Clusters?.flatMap(x => x?.RestoreStatus?.Status)?.every(x => x === "completed")) return resp;
      if (resp?.Clusters?.flatMap(x => x?.ClusterStatus)?.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 15 seconds apart (about 5 minutes max wait time). */
  async waitForSnapshotAvailable(
    params: RequestConfig & s.DescribeClusterSnapshotsMessage,
  ): Promise<s.SnapshotMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SnapshotAvailable';
    for (let i = 0; i < 20; i++) {
      const resp = await this.describeClusterSnapshots(params);
      const field = resp?.Snapshots?.flatMap(x => x?.Status);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

function DeleteClusterSnapshotMessage_Serialize(body: URLSearchParams, prefix: string, params: s.DeleteClusterSnapshotMessage) {
    body.append(prefix+".SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    if ("SnapshotClusterIdentifier" in params) body.append(prefix+".SnapshotClusterIdentifier", (params["SnapshotClusterIdentifier"] ?? '').toString());
}

function PauseClusterMessage_Serialize(body: URLSearchParams, prefix: string, params: s.PauseClusterMessage) {
    body.append(prefix+".ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
}
function PauseClusterMessage_Parse(node: xmlP.XmlNode): s.PauseClusterMessage {
  return node.strings({
    required: {"ClusterIdentifier":true},
  });
}

function ResizeClusterMessage_Serialize(body: URLSearchParams, prefix: string, params: s.ResizeClusterMessage) {
    body.append(prefix+".ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
    if ("ClusterType" in params) body.append(prefix+".ClusterType", (params["ClusterType"] ?? '').toString());
    if ("NodeType" in params) body.append(prefix+".NodeType", (params["NodeType"] ?? '').toString());
    if ("NumberOfNodes" in params) body.append(prefix+".NumberOfNodes", (params["NumberOfNodes"] ?? '').toString());
    if ("Classic" in params) body.append(prefix+".Classic", (params["Classic"] ?? '').toString());
}
function ResizeClusterMessage_Parse(node: xmlP.XmlNode): s.ResizeClusterMessage {
  return {
    ...node.strings({
      required: {"ClusterIdentifier":true},
      optional: {"ClusterType":true,"NodeType":true},
    }),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    Classic: node.first("Classic", false, x => x.content === 'true'),
  };
}

function ResumeClusterMessage_Serialize(body: URLSearchParams, prefix: string, params: s.ResumeClusterMessage) {
    body.append(prefix+".ClusterIdentifier", (params["ClusterIdentifier"] ?? '').toString());
}
function ResumeClusterMessage_Parse(node: xmlP.XmlNode): s.ResumeClusterMessage {
  return node.strings({
    required: {"ClusterIdentifier":true},
  });
}

function ScheduledAction_Parse(node: xmlP.XmlNode): s.ScheduledAction {
  return {
    ...node.strings({
      optional: {"ScheduledActionName":true,"Schedule":true,"IamRole":true,"ScheduledActionDescription":true},
    }),
    TargetAction: node.first("TargetAction", false, ScheduledActionType_Parse),
    State: node.first("State", false, x => (x.content ?? '') as s.ScheduledActionState),
    NextInvocations: node.getList("NextInvocations", "ScheduledActionTime").map(x => xmlP.parseTimestamp(x.content)),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function SnapshotSchedule_Parse(node: xmlP.XmlNode): s.SnapshotSchedule {
  return {
    ...node.strings({
      optional: {"ScheduleIdentifier":true,"ScheduleDescription":true},
    }),
    ScheduleDefinitions: node.getList("ScheduleDefinitions", "ScheduleDefinition").map(x => x.content ?? ''),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
    NextInvocations: node.getList("NextInvocations", "SnapshotTime").map(x => xmlP.parseTimestamp(x.content)),
    AssociatedClusterCount: node.first("AssociatedClusterCount", false, x => parseInt(x.content ?? '0')),
    AssociatedClusters: node.getList("AssociatedClusters", "ClusterAssociatedToSchedule").map(ClusterAssociatedToSchedule_Parse),
  };
}

function UsageLimit_Parse(node: xmlP.XmlNode): s.UsageLimit {
  return {
    ...node.strings({
      optional: {"UsageLimitId":true,"ClusterIdentifier":true},
    }),
    FeatureType: node.first("FeatureType", false, x => (x.content ?? '') as s.UsageLimitFeatureType),
    LimitType: node.first("LimitType", false, x => (x.content ?? '') as s.UsageLimitLimitType),
    Amount: node.first("Amount", false, x => parseInt(x.content ?? '0')),
    Period: node.first("Period", false, x => (x.content ?? '') as s.UsageLimitPeriod),
    BreachAction: node.first("BreachAction", false, x => (x.content ?? '') as s.UsageLimitBreachAction),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

function ScheduledActionType_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledActionType) {
    if (params["ResizeCluster"] != null) ResizeClusterMessage_Serialize(body, prefix+".ResizeCluster", params["ResizeCluster"]);
    if (params["PauseCluster"] != null) PauseClusterMessage_Serialize(body, prefix+".PauseCluster", params["PauseCluster"]);
    if (params["ResumeCluster"] != null) ResumeClusterMessage_Serialize(body, prefix+".ResumeCluster", params["ResumeCluster"]);
}
function ScheduledActionType_Parse(node: xmlP.XmlNode): s.ScheduledActionType {
  return {
    ResizeCluster: node.first("ResizeCluster", false, ResizeClusterMessage_Parse),
    PauseCluster: node.first("PauseCluster", false, PauseClusterMessage_Parse),
    ResumeCluster: node.first("ResumeCluster", false, ResumeClusterMessage_Parse),
  };
}

function SnapshotSortingEntity_Serialize(body: URLSearchParams, prefix: string, params: s.SnapshotSortingEntity) {
    body.append(prefix+".Attribute", (params["Attribute"] ?? '').toString());
    if ("SortOrder" in params) body.append(prefix+".SortOrder", (params["SortOrder"] ?? '').toString());
}

function NodeConfigurationOptionsFilter_Serialize(body: URLSearchParams, prefix: string, params: s.NodeConfigurationOptionsFilter) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Operator" in params) body.append(prefix+".Operator", (params["Operator"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Value", params["Values"], {"entryPrefix":".item."})
}

function ScheduledActionFilter_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledActionFilter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".item."})
}

function Parameter_Serialize(body: URLSearchParams, prefix: string, params: s.Parameter) {
    if ("ParameterName" in params) body.append(prefix+".ParameterName", (params["ParameterName"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("Source" in params) body.append(prefix+".Source", (params["Source"] ?? '').toString());
    if ("DataType" in params) body.append(prefix+".DataType", (params["DataType"] ?? '').toString());
    if ("AllowedValues" in params) body.append(prefix+".AllowedValues", (params["AllowedValues"] ?? '').toString());
    if ("ApplyType" in params) body.append(prefix+".ApplyType", (params["ApplyType"] ?? '').toString());
    if ("IsModifiable" in params) body.append(prefix+".IsModifiable", (params["IsModifiable"] ?? '').toString());
    if ("MinimumEngineVersion" in params) body.append(prefix+".MinimumEngineVersion", (params["MinimumEngineVersion"] ?? '').toString());
}
function Parameter_Parse(node: xmlP.XmlNode): s.Parameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"ParameterValue":true,"Description":true,"Source":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    ApplyType: node.first("ApplyType", false, x => (x.content ?? '') as s.ParameterApplyType),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
  };
}

function ReservedNode_Parse(node: xmlP.XmlNode): s.ReservedNode {
  return {
    ...node.strings({
      optional: {"ReservedNodeId":true,"ReservedNodeOfferingId":true,"NodeType":true,"CurrencyCode":true,"State":true,"OfferingType":true},
    }),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    NodeCount: node.first("NodeCount", false, x => parseInt(x.content ?? '0')),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
    ReservedNodeOfferingType: node.first("ReservedNodeOfferingType", false, x => (x.content ?? '') as s.ReservedNodeOfferingType),
  };
}

function RecurringCharge_Parse(node: xmlP.XmlNode): s.RecurringCharge {
  return {
    ...node.strings({
      optional: {"RecurringChargeFrequency":true},
    }),
    RecurringChargeAmount: node.first("RecurringChargeAmount", false, x => parseFloat(x.content ?? '0')),
  };
}

function ClusterSecurityGroup_Parse(node: xmlP.XmlNode): s.ClusterSecurityGroup {
  return {
    ...node.strings({
      optional: {"ClusterSecurityGroupName":true,"Description":true},
    }),
    EC2SecurityGroups: node.getList("EC2SecurityGroups", "EC2SecurityGroup").map(EC2SecurityGroup_Parse),
    IPRanges: node.getList("IPRanges", "IPRange").map(IPRange_Parse),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function EC2SecurityGroup_Parse(node: xmlP.XmlNode): s.EC2SecurityGroup {
  return {
    ...node.strings({
      optional: {"Status":true,"EC2SecurityGroupName":true,"EC2SecurityGroupOwnerId":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function IPRange_Parse(node: xmlP.XmlNode): s.IPRange {
  return {
    ...node.strings({
      optional: {"Status":true,"CIDRIP":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function Snapshot_Parse(node: xmlP.XmlNode): s.Snapshot {
  return {
    ...node.strings({
      optional: {"SnapshotIdentifier":true,"ClusterIdentifier":true,"Status":true,"AvailabilityZone":true,"MasterUsername":true,"ClusterVersion":true,"EngineFullVersion":true,"SnapshotType":true,"NodeType":true,"DBName":true,"VpcId":true,"KmsKeyId":true,"OwnerAccount":true,"SourceRegion":true,"MaintenanceTrackName":true},
    }),
    SnapshotCreateTime: node.first("SnapshotCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    ClusterCreateTime: node.first("ClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    Encrypted: node.first("Encrypted", false, x => x.content === 'true'),
    EncryptedWithHSM: node.first("EncryptedWithHSM", false, x => x.content === 'true'),
    AccountsWithRestoreAccess: node.getList("AccountsWithRestoreAccess", "AccountWithRestoreAccess").map(AccountWithRestoreAccess_Parse),
    TotalBackupSizeInMegaBytes: node.first("TotalBackupSizeInMegaBytes", false, x => parseFloat(x.content ?? '0')),
    ActualIncrementalBackupSizeInMegaBytes: node.first("ActualIncrementalBackupSizeInMegaBytes", false, x => parseFloat(x.content ?? '0')),
    BackupProgressInMegaBytes: node.first("BackupProgressInMegaBytes", false, x => parseFloat(x.content ?? '0')),
    CurrentBackupRateInMegaBytesPerSecond: node.first("CurrentBackupRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
    EstimatedSecondsToCompletion: node.first("EstimatedSecondsToCompletion", false, x => parseInt(x.content ?? '0')),
    ElapsedTimeInSeconds: node.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
    RestorableNodeTypes: node.getList("RestorableNodeTypes", "NodeType").map(x => x.content ?? ''),
    EnhancedVpcRouting: node.first("EnhancedVpcRouting", false, x => x.content === 'true'),
    ManualSnapshotRetentionPeriod: node.first("ManualSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    ManualSnapshotRemainingDays: node.first("ManualSnapshotRemainingDays", false, x => parseInt(x.content ?? '0')),
    SnapshotRetentionStartTime: node.first("SnapshotRetentionStartTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function AccountWithRestoreAccess_Parse(node: xmlP.XmlNode): s.AccountWithRestoreAccess {
  return node.strings({
    optional: {"AccountId":true,"AccountAlias":true},
  });
}

function SnapshotErrorMessage_Parse(node: xmlP.XmlNode): s.SnapshotErrorMessage {
  return node.strings({
    optional: {"SnapshotIdentifier":true,"SnapshotClusterIdentifier":true,"FailureCode":true,"FailureReason":true},
  });
}

function Cluster_Parse(node: xmlP.XmlNode): s.Cluster {
  return {
    ...node.strings({
      optional: {"ClusterIdentifier":true,"NodeType":true,"ClusterStatus":true,"ClusterAvailabilityStatus":true,"ModifyStatus":true,"MasterUsername":true,"DBName":true,"ClusterSubnetGroupName":true,"VpcId":true,"AvailabilityZone":true,"PreferredMaintenanceWindow":true,"ClusterVersion":true,"ClusterPublicKey":true,"ClusterRevisionNumber":true,"KmsKeyId":true,"MaintenanceTrackName":true,"ElasticResizeNumberOfNodeOptions":true,"SnapshotScheduleIdentifier":true,"ExpectedNextSnapshotScheduleTimeStatus":true,"AvailabilityZoneRelocationStatus":true,"ClusterNamespaceArn":true},
    }),
    Endpoint: node.first("Endpoint", false, Endpoint_Parse),
    ClusterCreateTime: node.first("ClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    AutomatedSnapshotRetentionPeriod: node.first("AutomatedSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    ManualSnapshotRetentionPeriod: node.first("ManualSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    ClusterSecurityGroups: node.getList("ClusterSecurityGroups", "ClusterSecurityGroup").map(ClusterSecurityGroupMembership_Parse),
    VpcSecurityGroups: node.getList("VpcSecurityGroups", "VpcSecurityGroup").map(VpcSecurityGroupMembership_Parse),
    ClusterParameterGroups: node.getList("ClusterParameterGroups", "ClusterParameterGroup").map(ClusterParameterGroupStatus_Parse),
    PendingModifiedValues: node.first("PendingModifiedValues", false, PendingModifiedValues_Parse),
    AllowVersionUpgrade: node.first("AllowVersionUpgrade", false, x => x.content === 'true'),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    PubliclyAccessible: node.first("PubliclyAccessible", false, x => x.content === 'true'),
    Encrypted: node.first("Encrypted", false, x => x.content === 'true'),
    RestoreStatus: node.first("RestoreStatus", false, RestoreStatus_Parse),
    DataTransferProgress: node.first("DataTransferProgress", false, DataTransferProgress_Parse),
    HsmStatus: node.first("HsmStatus", false, HsmStatus_Parse),
    ClusterSnapshotCopyStatus: node.first("ClusterSnapshotCopyStatus", false, ClusterSnapshotCopyStatus_Parse),
    ClusterNodes: node.getList("ClusterNodes", "member").map(ClusterNode_Parse),
    ElasticIpStatus: node.first("ElasticIpStatus", false, ElasticIpStatus_Parse),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
    EnhancedVpcRouting: node.first("EnhancedVpcRouting", false, x => x.content === 'true'),
    IamRoles: node.getList("IamRoles", "ClusterIamRole").map(ClusterIamRole_Parse),
    PendingActions: node.getList("PendingActions", "member").map(x => x.content ?? ''),
    DeferredMaintenanceWindows: node.getList("DeferredMaintenanceWindows", "DeferredMaintenanceWindow").map(DeferredMaintenanceWindow_Parse),
    SnapshotScheduleState: node.first("SnapshotScheduleState", false, x => (x.content ?? '') as s.ScheduleState),
    ExpectedNextSnapshotScheduleTime: node.first("ExpectedNextSnapshotScheduleTime", false, x => xmlP.parseTimestamp(x.content)),
    NextMaintenanceWindowStartTime: node.first("NextMaintenanceWindowStartTime", false, x => xmlP.parseTimestamp(x.content)),
    ResizeInfo: node.first("ResizeInfo", false, ResizeInfo_Parse),
  };
}

function Endpoint_Parse(node: xmlP.XmlNode): s.Endpoint {
  return {
    ...node.strings({
      optional: {"Address":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    VpcEndpoints: node.getList("VpcEndpoints", "VpcEndpoint").map(VpcEndpoint_Parse),
  };
}

function VpcEndpoint_Parse(node: xmlP.XmlNode): s.VpcEndpoint {
  return node.strings({
    optional: {"VpcEndpointId":true},
  });
}

function ClusterSecurityGroupMembership_Parse(node: xmlP.XmlNode): s.ClusterSecurityGroupMembership {
  return node.strings({
    optional: {"ClusterSecurityGroupName":true,"Status":true},
  });
}

function VpcSecurityGroupMembership_Parse(node: xmlP.XmlNode): s.VpcSecurityGroupMembership {
  return node.strings({
    optional: {"VpcSecurityGroupId":true,"Status":true},
  });
}

function ClusterParameterGroupStatus_Parse(node: xmlP.XmlNode): s.ClusterParameterGroupStatus {
  return {
    ...node.strings({
      optional: {"ParameterGroupName":true,"ParameterApplyStatus":true},
    }),
    ClusterParameterStatusList: node.getList("ClusterParameterStatusList", "member").map(ClusterParameterStatus_Parse),
  };
}

function ClusterParameterStatus_Parse(node: xmlP.XmlNode): s.ClusterParameterStatus {
  return node.strings({
    optional: {"ParameterName":true,"ParameterApplyStatus":true,"ParameterApplyErrorDescription":true},
  });
}

function PendingModifiedValues_Parse(node: xmlP.XmlNode): s.PendingModifiedValues {
  return {
    ...node.strings({
      optional: {"MasterUserPassword":true,"NodeType":true,"ClusterType":true,"ClusterVersion":true,"ClusterIdentifier":true,"MaintenanceTrackName":true,"EncryptionType":true},
    }),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    AutomatedSnapshotRetentionPeriod: node.first("AutomatedSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    PubliclyAccessible: node.first("PubliclyAccessible", false, x => x.content === 'true'),
    EnhancedVpcRouting: node.first("EnhancedVpcRouting", false, x => x.content === 'true'),
  };
}

function RestoreStatus_Parse(node: xmlP.XmlNode): s.RestoreStatus {
  return {
    ...node.strings({
      optional: {"Status":true},
    }),
    CurrentRestoreRateInMegaBytesPerSecond: node.first("CurrentRestoreRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
    SnapshotSizeInMegaBytes: node.first("SnapshotSizeInMegaBytes", false, x => parseInt(x.content ?? '0')),
    ProgressInMegaBytes: node.first("ProgressInMegaBytes", false, x => parseInt(x.content ?? '0')),
    ElapsedTimeInSeconds: node.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
    EstimatedTimeToCompletionInSeconds: node.first("EstimatedTimeToCompletionInSeconds", false, x => parseInt(x.content ?? '0')),
  };
}

function DataTransferProgress_Parse(node: xmlP.XmlNode): s.DataTransferProgress {
  return {
    ...node.strings({
      optional: {"Status":true},
    }),
    CurrentRateInMegaBytesPerSecond: node.first("CurrentRateInMegaBytesPerSecond", false, x => parseFloat(x.content ?? '0')),
    TotalDataInMegaBytes: node.first("TotalDataInMegaBytes", false, x => parseInt(x.content ?? '0')),
    DataTransferredInMegaBytes: node.first("DataTransferredInMegaBytes", false, x => parseInt(x.content ?? '0')),
    EstimatedTimeToCompletionInSeconds: node.first("EstimatedTimeToCompletionInSeconds", false, x => parseInt(x.content ?? '0')),
    ElapsedTimeInSeconds: node.first("ElapsedTimeInSeconds", false, x => parseInt(x.content ?? '0')),
  };
}

function HsmStatus_Parse(node: xmlP.XmlNode): s.HsmStatus {
  return node.strings({
    optional: {"HsmClientCertificateIdentifier":true,"HsmConfigurationIdentifier":true,"Status":true},
  });
}

function ClusterSnapshotCopyStatus_Parse(node: xmlP.XmlNode): s.ClusterSnapshotCopyStatus {
  return {
    ...node.strings({
      optional: {"DestinationRegion":true,"SnapshotCopyGrantName":true},
    }),
    RetentionPeriod: node.first("RetentionPeriod", false, x => parseInt(x.content ?? '0')),
    ManualSnapshotRetentionPeriod: node.first("ManualSnapshotRetentionPeriod", false, x => parseInt(x.content ?? '0')),
  };
}

function ClusterNode_Parse(node: xmlP.XmlNode): s.ClusterNode {
  return node.strings({
    optional: {"NodeRole":true,"PrivateIPAddress":true,"PublicIPAddress":true},
  });
}

function ElasticIpStatus_Parse(node: xmlP.XmlNode): s.ElasticIpStatus {
  return node.strings({
    optional: {"ElasticIp":true,"Status":true},
  });
}

function ClusterIamRole_Parse(node: xmlP.XmlNode): s.ClusterIamRole {
  return node.strings({
    optional: {"IamRoleArn":true,"ApplyStatus":true},
  });
}

function DeferredMaintenanceWindow_Parse(node: xmlP.XmlNode): s.DeferredMaintenanceWindow {
  return {
    ...node.strings({
      optional: {"DeferMaintenanceIdentifier":true},
    }),
    DeferMaintenanceStartTime: node.first("DeferMaintenanceStartTime", false, x => xmlP.parseTimestamp(x.content)),
    DeferMaintenanceEndTime: node.first("DeferMaintenanceEndTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ResizeInfo_Parse(node: xmlP.XmlNode): s.ResizeInfo {
  return {
    ...node.strings({
      optional: {"ResizeType":true},
    }),
    AllowCancelResize: node.first("AllowCancelResize", false, x => x.content === 'true'),
  };
}

function ClusterParameterGroup_Parse(node: xmlP.XmlNode): s.ClusterParameterGroup {
  return {
    ...node.strings({
      optional: {"ParameterGroupName":true,"ParameterGroupFamily":true,"Description":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function ClusterSubnetGroup_Parse(node: xmlP.XmlNode): s.ClusterSubnetGroup {
  return {
    ...node.strings({
      optional: {"ClusterSubnetGroupName":true,"Description":true,"VpcId":true,"SubnetGroupStatus":true},
    }),
    Subnets: node.getList("Subnets", "Subnet").map(Subnet_Parse),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function Subnet_Parse(node: xmlP.XmlNode): s.Subnet {
  return {
    ...node.strings({
      optional: {"SubnetIdentifier":true,"SubnetStatus":true},
    }),
    SubnetAvailabilityZone: node.first("SubnetAvailabilityZone", false, AvailabilityZone_Parse),
  };
}

function AvailabilityZone_Parse(node: xmlP.XmlNode): s.AvailabilityZone {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    SupportedPlatforms: node.getList("SupportedPlatforms", "SupportedPlatform").map(SupportedPlatform_Parse),
  };
}

function SupportedPlatform_Parse(node: xmlP.XmlNode): s.SupportedPlatform {
  return node.strings({
    optional: {"Name":true},
  });
}

function EventSubscription_Parse(node: xmlP.XmlNode): s.EventSubscription {
  return {
    ...node.strings({
      optional: {"CustomerAwsId":true,"CustSubscriptionId":true,"SnsTopicArn":true,"Status":true,"SourceType":true,"Severity":true},
    }),
    SubscriptionCreationTime: node.first("SubscriptionCreationTime", false, x => xmlP.parseTimestamp(x.content)),
    SourceIdsList: node.getList("SourceIdsList", "SourceId").map(x => x.content ?? ''),
    EventCategoriesList: node.getList("EventCategoriesList", "EventCategory").map(x => x.content ?? ''),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function HsmClientCertificate_Parse(node: xmlP.XmlNode): s.HsmClientCertificate {
  return {
    ...node.strings({
      optional: {"HsmClientCertificateIdentifier":true,"HsmClientCertificatePublicKey":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function HsmConfiguration_Parse(node: xmlP.XmlNode): s.HsmConfiguration {
  return {
    ...node.strings({
      optional: {"HsmConfigurationIdentifier":true,"Description":true,"HsmIpAddress":true,"HsmPartitionName":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function SnapshotCopyGrant_Parse(node: xmlP.XmlNode): s.SnapshotCopyGrant {
  return {
    ...node.strings({
      optional: {"SnapshotCopyGrantName":true,"KmsKeyId":true},
    }),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function ClusterAssociatedToSchedule_Parse(node: xmlP.XmlNode): s.ClusterAssociatedToSchedule {
  return {
    ...node.strings({
      optional: {"ClusterIdentifier":true},
    }),
    ScheduleAssociationState: node.first("ScheduleAssociationState", false, x => (x.content ?? '') as s.ScheduleState),
  };
}

function AccountAttribute_Parse(node: xmlP.XmlNode): s.AccountAttribute {
  return {
    ...node.strings({
      optional: {"AttributeName":true},
    }),
    AttributeValues: node.getList("AttributeValues", "AttributeValueTarget").map(AttributeValueTarget_Parse),
  };
}

function AttributeValueTarget_Parse(node: xmlP.XmlNode): s.AttributeValueTarget {
  return node.strings({
    optional: {"AttributeValue":true},
  });
}

function ClusterDbRevision_Parse(node: xmlP.XmlNode): s.ClusterDbRevision {
  return {
    ...node.strings({
      optional: {"ClusterIdentifier":true,"CurrentDatabaseRevision":true},
    }),
    DatabaseRevisionReleaseDate: node.first("DatabaseRevisionReleaseDate", false, x => xmlP.parseTimestamp(x.content)),
    RevisionTargets: node.getList("RevisionTargets", "RevisionTarget").map(RevisionTarget_Parse),
  };
}

function RevisionTarget_Parse(node: xmlP.XmlNode): s.RevisionTarget {
  return {
    ...node.strings({
      optional: {"DatabaseRevision":true,"Description":true},
    }),
    DatabaseRevisionReleaseDate: node.first("DatabaseRevisionReleaseDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function MaintenanceTrack_Parse(node: xmlP.XmlNode): s.MaintenanceTrack {
  return {
    ...node.strings({
      optional: {"MaintenanceTrackName":true,"DatabaseVersion":true},
    }),
    UpdateTargets: node.getList("UpdateTargets", "UpdateTarget").map(UpdateTarget_Parse),
  };
}

function UpdateTarget_Parse(node: xmlP.XmlNode): s.UpdateTarget {
  return {
    ...node.strings({
      optional: {"MaintenanceTrackName":true,"DatabaseVersion":true},
    }),
    SupportedOperations: node.getList("SupportedOperations", "SupportedOperation").map(SupportedOperation_Parse),
  };
}

function SupportedOperation_Parse(node: xmlP.XmlNode): s.SupportedOperation {
  return node.strings({
    optional: {"OperationName":true},
  });
}

function ClusterVersion_Parse(node: xmlP.XmlNode): s.ClusterVersion {
  return node.strings({
    optional: {"ClusterVersion":true,"ClusterParameterGroupFamily":true,"Description":true},
  });
}

function DefaultClusterParameters_Parse(node: xmlP.XmlNode): s.DefaultClusterParameters {
  return {
    ...node.strings({
      optional: {"ParameterGroupFamily":true,"Marker":true},
    }),
    Parameters: node.getList("Parameters", "Parameter").map(Parameter_Parse),
  };
}

function EventCategoriesMap_Parse(node: xmlP.XmlNode): s.EventCategoriesMap {
  return {
    ...node.strings({
      optional: {"SourceType":true},
    }),
    Events: node.getList("Events", "EventInfoMap").map(EventInfoMap_Parse),
  };
}

function EventInfoMap_Parse(node: xmlP.XmlNode): s.EventInfoMap {
  return {
    ...node.strings({
      optional: {"EventId":true,"EventDescription":true,"Severity":true},
    }),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
  };
}

function Event_Parse(node: xmlP.XmlNode): s.Event {
  return {
    ...node.strings({
      optional: {"SourceIdentifier":true,"Message":true,"Severity":true,"EventId":true},
    }),
    SourceType: node.first("SourceType", false, x => (x.content ?? '') as s.SourceType),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function NodeConfigurationOption_Parse(node: xmlP.XmlNode): s.NodeConfigurationOption {
  return {
    ...node.strings({
      optional: {"NodeType":true},
    }),
    NumberOfNodes: node.first("NumberOfNodes", false, x => parseInt(x.content ?? '0')),
    EstimatedDiskUtilizationPercent: node.first("EstimatedDiskUtilizationPercent", false, x => parseFloat(x.content ?? '0')),
    Mode: node.first("Mode", false, x => (x.content ?? '') as s.Mode),
  };
}

function OrderableClusterOption_Parse(node: xmlP.XmlNode): s.OrderableClusterOption {
  return {
    ...node.strings({
      optional: {"ClusterVersion":true,"ClusterType":true,"NodeType":true},
    }),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(AvailabilityZone_Parse),
  };
}

function ReservedNodeOffering_Parse(node: xmlP.XmlNode): s.ReservedNodeOffering {
  return {
    ...node.strings({
      optional: {"ReservedNodeOfferingId":true,"NodeType":true,"CurrencyCode":true,"OfferingType":true},
    }),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
    ReservedNodeOfferingType: node.first("ReservedNodeOfferingType", false, x => (x.content ?? '') as s.ReservedNodeOfferingType),
  };
}

function TableRestoreStatus_Parse(node: xmlP.XmlNode): s.TableRestoreStatus {
  return {
    ...node.strings({
      optional: {"TableRestoreRequestId":true,"Message":true,"ClusterIdentifier":true,"SnapshotIdentifier":true,"SourceDatabaseName":true,"SourceSchemaName":true,"SourceTableName":true,"TargetDatabaseName":true,"TargetSchemaName":true,"NewTableName":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as s.TableRestoreStatusType),
    RequestTime: node.first("RequestTime", false, x => xmlP.parseTimestamp(x.content)),
    ProgressInMegaBytes: node.first("ProgressInMegaBytes", false, x => parseInt(x.content ?? '0')),
    TotalDataInMegaBytes: node.first("TotalDataInMegaBytes", false, x => parseInt(x.content ?? '0')),
  };
}

function TaggedResource_Parse(node: xmlP.XmlNode): s.TaggedResource {
  return {
    ...node.strings({
      optional: {"ResourceName":true,"ResourceType":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
  };
}
