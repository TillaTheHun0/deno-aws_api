// Autogenerated API client for: AWS IoT Secure Tunneling

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class IoTSecureTunneling {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(IoTSecureTunneling.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-10-05",
    "endpointPrefix": "api.tunneling.iot",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS IoT Secure Tunneling",
    "serviceId": "IoTSecureTunneling",
    "signatureVersion": "v4",
    "signingName": "IoTSecuredTunneling",
    "targetPrefix": "IoTSecuredTunneling",
    "uid": "iotsecuretunneling-2018-10-05"
  };

  async closeTunnel(
    {abortSignal, ...params}: RequestConfig & CloseTunnelRequest,
  ): Promise<CloseTunnelResponse> {
    const body: jsonP.JSONObject = {
      tunnelId: params["tunnelId"],
      delete: params["delete"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CloseTunnel",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeTunnel(
    {abortSignal, ...params}: RequestConfig & DescribeTunnelRequest,
  ): Promise<DescribeTunnelResponse> {
    const body: jsonP.JSONObject = {
      tunnelId: params["tunnelId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTunnel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tunnel": toTunnel,
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async listTunnels(
    {abortSignal, ...params}: RequestConfig & ListTunnelsRequest = {},
  ): Promise<ListTunnelsResponse> {
    const body: jsonP.JSONObject = {
      thingName: params["thingName"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTunnels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tunnelSummaries": [toTunnelSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async openTunnel(
    {abortSignal, ...params}: RequestConfig & OpenTunnelRequest = {},
  ): Promise<OpenTunnelResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      tags: params["tags"]?.map(x => fromTag(x)),
      destinationConfig: fromDestinationConfig(params["destinationConfig"]),
      timeoutConfig: fromTimeoutConfig(params["timeoutConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "OpenTunnel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tunnelId": "s",
        "tunnelArn": "s",
        "sourceAccessToken": "s",
        "destinationAccessToken": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CloseTunnelRequest {
  tunnelId: string;
  delete?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeTunnelRequest {
  tunnelId: string;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface ListTunnelsRequest {
  thingName?: string | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface OpenTunnelRequest {
  description?: string | null;
  tags?: Tag[] | null;
  destinationConfig?: DestinationConfig | null;
  timeoutConfig?: TimeoutConfig | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, output
export interface CloseTunnelResponse {
}

// refs: 1 - tags: named, output
export interface DescribeTunnelResponse {
  tunnel?: Tunnel | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface ListTunnelsResponse {
  tunnelSummaries?: TunnelSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface OpenTunnelResponse {
  tunnelId?: string | null;
  tunnelArn?: string | null;
  sourceAccessToken?: string | null;
  destinationAccessToken?: string | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 4 - tags: input, named, interface, output
export interface Tag {
  key: string;
  value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface DestinationConfig {
  thingName: string;
  services: string[];
}
function fromDestinationConfig(input?: DestinationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    thingName: input["thingName"],
    services: input["services"],
  }
}
function toDestinationConfig(root: jsonP.JSONValue): DestinationConfig {
  return jsonP.readObj({
    required: {
      "thingName": "s",
      "services": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface TimeoutConfig {
  maxLifetimeTimeoutMinutes?: number | null;
}
function fromTimeoutConfig(input?: TimeoutConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxLifetimeTimeoutMinutes: input["maxLifetimeTimeoutMinutes"],
  }
}
function toTimeoutConfig(root: jsonP.JSONValue): TimeoutConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "maxLifetimeTimeoutMinutes": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Tunnel {
  tunnelId?: string | null;
  tunnelArn?: string | null;
  status?: TunnelStatus | null;
  sourceConnectionState?: ConnectionState | null;
  destinationConnectionState?: ConnectionState | null;
  description?: string | null;
  destinationConfig?: DestinationConfig | null;
  timeoutConfig?: TimeoutConfig | null;
  tags?: Tag[] | null;
  createdAt?: Date | number | null;
  lastUpdatedAt?: Date | number | null;
}
function toTunnel(root: jsonP.JSONValue): Tunnel {
  return jsonP.readObj({
    required: {},
    optional: {
      "tunnelId": "s",
      "tunnelArn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<TunnelStatus>(x),
      "sourceConnectionState": toConnectionState,
      "destinationConnectionState": toConnectionState,
      "description": "s",
      "destinationConfig": toDestinationConfig,
      "timeoutConfig": toTimeoutConfig,
      "tags": [toTag],
      "createdAt": "d",
      "lastUpdatedAt": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type TunnelStatus =
| "OPEN"
| "CLOSED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ConnectionState {
  status?: ConnectionStatus | null;
  lastUpdatedAt?: Date | number | null;
}
function toConnectionState(root: jsonP.JSONValue): ConnectionState {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ConnectionStatus>(x),
      "lastUpdatedAt": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ConnectionStatus =
| "CONNECTED"
| "DISCONNECTED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface TunnelSummary {
  tunnelId?: string | null;
  tunnelArn?: string | null;
  status?: TunnelStatus | null;
  description?: string | null;
  createdAt?: Date | number | null;
  lastUpdatedAt?: Date | number | null;
}
function toTunnelSummary(root: jsonP.JSONValue): TunnelSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "tunnelId": "s",
      "tunnelArn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<TunnelStatus>(x),
      "description": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
    },
  }, root);
}
