// Autogenerated API client for: AWS IoT Secure Tunneling

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { JSONObject, JSONValue } from '../../encoding/json.ts';
import * as prt from "../../encoding/json.ts";

export default class IoTSecureTunneling {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(IoTSecureTunneling.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-10-05",
    "endpointPrefix": "api.tunneling.iot",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS IoT Secure Tunneling",
    "serviceId": "IoTSecureTunneling",
    "signatureVersion": "v4",
    "signingName": "IoTSecuredTunneling",
    "targetPrefix": "IoTSecuredTunneling",
    "uid": "iotsecuretunneling-2018-10-05"
  };

  async closeTunnel(
    {abortSignal, ...params}: RequestConfig & CloseTunnelRequest,
  ): Promise<CloseTunnelResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CloseTunnel",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeTunnel(
    {abortSignal, ...params}: RequestConfig & DescribeTunnelRequest,
  ): Promise<DescribeTunnelResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTunnel",
    });
    return prt.readObj({
      required: {},
      optional: {
        "tunnel": toTunnel,
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return prt.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async listTunnels(
    {abortSignal, ...params}: RequestConfig & ListTunnelsRequest = {},
  ): Promise<ListTunnelsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTunnels",
    });
    return prt.readObj({
      required: {},
      optional: {
        "tunnelSummaries": [toTunnelSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async openTunnel(
    {abortSignal, ...params}: RequestConfig & OpenTunnelRequest = {},
  ): Promise<OpenTunnelResponse> {
    const body: JSONObject = {...params,
    tags: params["tags"]?.map(x => fromTag(x)),
    destinationConfig: fromDestinationConfig(params["destinationConfig"]),
    timeoutConfig: fromTimeoutConfig(params["timeoutConfig"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "OpenTunnel",
    });
    return prt.readObj({
      required: {},
      optional: {
        "tunnelId": "s",
        "tunnelArn": "s",
        "sourceAccessToken": "s",
        "destinationAccessToken": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: JSONObject = {...params,
    tags: params["tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CloseTunnelRequest {
  tunnelId: string;
  delete?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeTunnelRequest {
  tunnelId: string;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface ListTunnelsRequest {
  thingName?: string | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface OpenTunnelRequest {
  description?: string | null;
  tags?: Tag[] | null;
  destinationConfig?: DestinationConfig | null;
  timeoutConfig?: TimeoutConfig | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, output
export interface CloseTunnelResponse {
}

// refs: 1 - tags: named, output
export interface DescribeTunnelResponse {
  tunnel?: Tunnel | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface ListTunnelsResponse {
  tunnelSummaries?: TunnelSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface OpenTunnelResponse {
  tunnelId?: string | null;
  tunnelArn?: string | null;
  sourceAccessToken?: string | null;
  destinationAccessToken?: string | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 4 - tags: input, named, interface, output
export interface Tag {
  key: string;
  value: string;
}
function fromTag(input?: Tag | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toTag(root: JSONValue): Tag {
  return prt.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface DestinationConfig {
  thingName: string;
  services: string[];
}
function fromDestinationConfig(input?: DestinationConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toDestinationConfig(root: JSONValue): DestinationConfig {
  return prt.readObj({
    required: {
      "thingName": "s",
      "services": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface TimeoutConfig {
  maxLifetimeTimeoutMinutes?: number | null;
}
function fromTimeoutConfig(input?: TimeoutConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toTimeoutConfig(root: JSONValue): TimeoutConfig {
  return prt.readObj({
    required: {},
    optional: {
      "maxLifetimeTimeoutMinutes": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Tunnel {
  tunnelId?: string | null;
  tunnelArn?: string | null;
  status?: TunnelStatus | null;
  sourceConnectionState?: ConnectionState | null;
  destinationConnectionState?: ConnectionState | null;
  description?: string | null;
  destinationConfig?: DestinationConfig | null;
  timeoutConfig?: TimeoutConfig | null;
  tags?: Tag[] | null;
  createdAt?: Date | number | null;
  lastUpdatedAt?: Date | number | null;
}
function toTunnel(root: JSONValue): Tunnel {
  return prt.readObj({
    required: {},
    optional: {
      "tunnelId": "s",
      "tunnelArn": "s",
      "status": toTunnelStatus,
      "sourceConnectionState": toConnectionState,
      "destinationConnectionState": toConnectionState,
      "description": "s",
      "destinationConfig": toDestinationConfig,
      "timeoutConfig": toTimeoutConfig,
      "tags": [toTag],
      "createdAt": "d",
      "lastUpdatedAt": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type TunnelStatus =
| "OPEN"
| "CLOSED"
;
function toTunnelStatus(root: JSONValue): TunnelStatus | null {
  return ( false
    || root == "OPEN"
    || root == "CLOSED"
  ) ? root : null;
}

// refs: 2 - tags: output, named, interface
export interface ConnectionState {
  status?: ConnectionStatus | null;
  lastUpdatedAt?: Date | number | null;
}
function toConnectionState(root: JSONValue): ConnectionState {
  return prt.readObj({
    required: {},
    optional: {
      "status": toConnectionStatus,
      "lastUpdatedAt": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ConnectionStatus =
| "CONNECTED"
| "DISCONNECTED"
;
function toConnectionStatus(root: JSONValue): ConnectionStatus | null {
  return ( false
    || root == "CONNECTED"
    || root == "DISCONNECTED"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface TunnelSummary {
  tunnelId?: string | null;
  tunnelArn?: string | null;
  status?: TunnelStatus | null;
  description?: string | null;
  createdAt?: Date | number | null;
  lastUpdatedAt?: Date | number | null;
}
function toTunnelSummary(root: JSONValue): TunnelSummary {
  return prt.readObj({
    required: {},
    optional: {
      "tunnelId": "s",
      "tunnelArn": "s",
      "status": toTunnelStatus,
      "description": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
    },
  }, root);
}
