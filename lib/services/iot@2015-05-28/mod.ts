// Autogenerated API client for: AWS IoT

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.91.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class Iot {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Iot.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-05-28",
    "endpointPrefix": "iot",
    "protocol": "rest-json",
    "serviceFullName": "AWS IoT",
    "serviceId": "IoT",
    "signatureVersion": "v4",
    "signingName": "execute-api",
    "uid": "iot-2015-05-28"
  };

  async acceptCertificateTransfer(
    {abortSignal, ...params}: RequestConfig & s.AcceptCertificateTransferRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["setAsActive"] != null) query.set("setAsActive", params["setAsActive"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "AcceptCertificateTransfer",
      method: "PATCH",
      requestUri: cmnP.encodePath`/accept-certificate-transfer/${params["certificateId"]}`,
    });
  }

  async addThingToBillingGroup(
    {abortSignal, ...params}: RequestConfig & s.AddThingToBillingGroupRequest = {},
  ): Promise<s.AddThingToBillingGroupResponse> {
    const body: jsonP.JSONObject = {
      billingGroupName: params["billingGroupName"],
      billingGroupArn: params["billingGroupArn"],
      thingName: params["thingName"],
      thingArn: params["thingArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddThingToBillingGroup",
      method: "PUT",
      requestUri: "/billing-groups/addThingToBillingGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async addThingToThingGroup(
    {abortSignal, ...params}: RequestConfig & s.AddThingToThingGroupRequest = {},
  ): Promise<s.AddThingToThingGroupResponse> {
    const body: jsonP.JSONObject = {
      thingGroupName: params["thingGroupName"],
      thingGroupArn: params["thingGroupArn"],
      thingName: params["thingName"],
      thingArn: params["thingArn"],
      overrideDynamicGroups: params["overrideDynamicGroups"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddThingToThingGroup",
      method: "PUT",
      requestUri: "/thing-groups/addThingToThingGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async associateTargetsWithJob(
    {abortSignal, ...params}: RequestConfig & s.AssociateTargetsWithJobRequest,
  ): Promise<s.AssociateTargetsWithJobResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      targets: params["targets"],
      comment: params["comment"],
    };
    if (params["namespaceId"] != null) query.set("namespaceId", params["namespaceId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "AssociateTargetsWithJob",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}/targets`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobArn": "s",
        "jobId": "s",
        "description": "s",
      },
    }, await resp.json());
  }

  async attachPolicy(
    {abortSignal, ...params}: RequestConfig & s.AttachPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      target: params["target"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/target-policies/${params["policyName"]}`,
    });
  }

  async attachPrincipalPolicy(
    {abortSignal, ...params}: RequestConfig & s.AttachPrincipalPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amzn-iot-principal", params["principal"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "AttachPrincipalPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/principal-policies/${params["policyName"]}`,
    });
  }

  async attachSecurityProfile(
    {abortSignal, ...params}: RequestConfig & s.AttachSecurityProfileRequest,
  ): Promise<s.AttachSecurityProfileResponse> {
    const query = new URLSearchParams;
    query.set("securityProfileTargetArn", params["securityProfileTargetArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "AttachSecurityProfile",
      method: "PUT",
      requestUri: cmnP.encodePath`/security-profiles/${params["securityProfileName"]}/targets`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async attachThingPrincipal(
    {abortSignal, ...params}: RequestConfig & s.AttachThingPrincipalRequest,
  ): Promise<s.AttachThingPrincipalResponse> {
    const headers = new Headers;
    headers.append("x-amzn-principal", params["principal"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "AttachThingPrincipal",
      method: "PUT",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}/principals`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelAuditMitigationActionsTask(
    {abortSignal, ...params}: RequestConfig & s.CancelAuditMitigationActionsTaskRequest,
  ): Promise<s.CancelAuditMitigationActionsTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelAuditMitigationActionsTask",
      method: "PUT",
      requestUri: cmnP.encodePath`/audit/mitigationactions/tasks/${params["taskId"]}/cancel`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelAuditTask(
    {abortSignal, ...params}: RequestConfig & s.CancelAuditTaskRequest,
  ): Promise<s.CancelAuditTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelAuditTask",
      method: "PUT",
      requestUri: cmnP.encodePath`/audit/tasks/${params["taskId"]}/cancel`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelCertificateTransfer(
    {abortSignal, ...params}: RequestConfig & s.CancelCertificateTransferRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelCertificateTransfer",
      method: "PATCH",
      requestUri: cmnP.encodePath`/cancel-certificate-transfer/${params["certificateId"]}`,
    });
  }

  async cancelDetectMitigationActionsTask(
    {abortSignal, ...params}: RequestConfig & s.CancelDetectMitigationActionsTaskRequest,
  ): Promise<s.CancelDetectMitigationActionsTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelDetectMitigationActionsTask",
      method: "PUT",
      requestUri: cmnP.encodePath`/detect/mitigationactions/tasks/${params["taskId"]}/cancel`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelJob(
    {abortSignal, ...params}: RequestConfig & s.CancelJobRequest,
  ): Promise<s.CancelJobResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      reasonCode: params["reasonCode"],
      comment: params["comment"],
    };
    if (params["force"] != null) query.set("force", params["force"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CancelJob",
      method: "PUT",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}/cancel`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobArn": "s",
        "jobId": "s",
        "description": "s",
      },
    }, await resp.json());
  }

  async cancelJobExecution(
    {abortSignal, ...params}: RequestConfig & s.CancelJobExecutionRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      expectedVersion: params["expectedVersion"],
      statusDetails: params["statusDetails"],
    };
    if (params["force"] != null) query.set("force", params["force"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CancelJobExecution",
      method: "PUT",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}/jobs/${params["jobId"]}/cancel`,
    });
  }

  async clearDefaultAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.ClearDefaultAuthorizerRequest = {},
  ): Promise<s.ClearDefaultAuthorizerResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ClearDefaultAuthorizer",
      method: "DELETE",
      requestUri: "/default-authorizer",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async confirmTopicRuleDestination(
    {abortSignal, ...params}: RequestConfig & s.ConfirmTopicRuleDestinationRequest,
  ): Promise<s.ConfirmTopicRuleDestinationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ConfirmTopicRuleDestination",
      method: "GET",
      requestUri: cmnP.encodePath`/confirmdestination/${params["confirmationToken"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createAuditSuppression(
    {abortSignal, ...params}: RequestConfig & s.CreateAuditSuppressionRequest,
  ): Promise<s.CreateAuditSuppressionResponse> {
    const body: jsonP.JSONObject = {
      checkName: params["checkName"],
      resourceIdentifier: fromResourceIdentifier(params["resourceIdentifier"]),
      expirationDate: jsonP.serializeDate_unixTimestamp(params["expirationDate"]),
      suppressIndefinitely: params["suppressIndefinitely"],
      description: params["description"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAuditSuppression",
      requestUri: "/audit/suppressions/create",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.CreateAuthorizerRequest,
  ): Promise<s.CreateAuthorizerResponse> {
    const body: jsonP.JSONObject = {
      authorizerFunctionArn: params["authorizerFunctionArn"],
      tokenKeyName: params["tokenKeyName"],
      tokenSigningPublicKeys: params["tokenSigningPublicKeys"],
      status: params["status"],
      tags: params["tags"]?.map(x => fromTag(x)),
      signingDisabled: params["signingDisabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAuthorizer",
      requestUri: cmnP.encodePath`/authorizer/${params["authorizerName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizerName": "s",
        "authorizerArn": "s",
      },
    }, await resp.json());
  }

  async createBillingGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateBillingGroupRequest,
  ): Promise<s.CreateBillingGroupResponse> {
    const body: jsonP.JSONObject = {
      billingGroupProperties: fromBillingGroupProperties(params["billingGroupProperties"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBillingGroup",
      requestUri: cmnP.encodePath`/billing-groups/${params["billingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "billingGroupName": "s",
        "billingGroupArn": "s",
        "billingGroupId": "s",
      },
    }, await resp.json());
  }

  async createCertificateFromCsr(
    {abortSignal, ...params}: RequestConfig & s.CreateCertificateFromCsrRequest,
  ): Promise<s.CreateCertificateFromCsrResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      certificateSigningRequest: params["certificateSigningRequest"],
    };
    if (params["setAsActive"] != null) query.set("setAsActive", params["setAsActive"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateCertificateFromCsr",
      requestUri: "/certificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificateArn": "s",
        "certificateId": "s",
        "certificatePem": "s",
      },
    }, await resp.json());
  }

  async createCustomMetric(
    {abortSignal, ...params}: RequestConfig & s.CreateCustomMetricRequest,
  ): Promise<s.CreateCustomMetricResponse> {
    const body: jsonP.JSONObject = {
      displayName: params["displayName"],
      metricType: params["metricType"],
      tags: params["tags"]?.map(x => fromTag(x)),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomMetric",
      requestUri: cmnP.encodePath`/custom-metric/${params["metricName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricName": "s",
        "metricArn": "s",
      },
    }, await resp.json());
  }

  async createDimension(
    {abortSignal, ...params}: RequestConfig & s.CreateDimensionRequest,
  ): Promise<s.CreateDimensionResponse> {
    const body: jsonP.JSONObject = {
      type: params["type"],
      stringValues: params["stringValues"],
      tags: params["tags"]?.map(x => fromTag(x)),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDimension",
      requestUri: cmnP.encodePath`/dimensions/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "arn": "s",
      },
    }, await resp.json());
  }

  async createDomainConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainConfigurationRequest,
  ): Promise<s.CreateDomainConfigurationResponse> {
    const body: jsonP.JSONObject = {
      domainName: params["domainName"],
      serverCertificateArns: params["serverCertificateArns"],
      validationCertificateArn: params["validationCertificateArn"],
      authorizerConfig: fromAuthorizerConfig(params["authorizerConfig"]),
      serviceType: params["serviceType"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomainConfiguration",
      requestUri: cmnP.encodePath`/domainConfigurations/${params["domainConfigurationName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainConfigurationName": "s",
        "domainConfigurationArn": "s",
      },
    }, await resp.json());
  }

  async createDynamicThingGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateDynamicThingGroupRequest,
  ): Promise<s.CreateDynamicThingGroupResponse> {
    const body: jsonP.JSONObject = {
      thingGroupProperties: fromThingGroupProperties(params["thingGroupProperties"]),
      indexName: params["indexName"],
      queryString: params["queryString"],
      queryVersion: params["queryVersion"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDynamicThingGroup",
      requestUri: cmnP.encodePath`/dynamic-thing-groups/${params["thingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingGroupName": "s",
        "thingGroupArn": "s",
        "thingGroupId": "s",
        "indexName": "s",
        "queryString": "s",
        "queryVersion": "s",
      },
    }, await resp.json());
  }

  async createJob(
    {abortSignal, ...params}: RequestConfig & s.CreateJobRequest,
  ): Promise<s.CreateJobResponse> {
    const body: jsonP.JSONObject = {
      targets: params["targets"],
      documentSource: params["documentSource"],
      document: params["document"],
      description: params["description"],
      presignedUrlConfig: fromPresignedUrlConfig(params["presignedUrlConfig"]),
      targetSelection: params["targetSelection"],
      jobExecutionsRolloutConfig: fromJobExecutionsRolloutConfig(params["jobExecutionsRolloutConfig"]),
      abortConfig: fromAbortConfig(params["abortConfig"]),
      timeoutConfig: fromTimeoutConfig(params["timeoutConfig"]),
      tags: params["tags"]?.map(x => fromTag(x)),
      namespaceId: params["namespaceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJob",
      method: "PUT",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobArn": "s",
        "jobId": "s",
        "description": "s",
      },
    }, await resp.json());
  }

  async createKeysAndCertificate(
    {abortSignal, ...params}: RequestConfig & s.CreateKeysAndCertificateRequest = {},
  ): Promise<s.CreateKeysAndCertificateResponse> {
    const query = new URLSearchParams;
    if (params["setAsActive"] != null) query.set("setAsActive", params["setAsActive"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "CreateKeysAndCertificate",
      requestUri: "/keys-and-certificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificateArn": "s",
        "certificateId": "s",
        "certificatePem": "s",
        "keyPair": toKeyPair,
      },
    }, await resp.json());
  }

  async createMitigationAction(
    {abortSignal, ...params}: RequestConfig & s.CreateMitigationActionRequest,
  ): Promise<s.CreateMitigationActionResponse> {
    const body: jsonP.JSONObject = {
      roleArn: params["roleArn"],
      actionParams: fromMitigationActionParams(params["actionParams"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMitigationAction",
      requestUri: cmnP.encodePath`/mitigationactions/actions/${params["actionName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "actionArn": "s",
        "actionId": "s",
      },
    }, await resp.json());
  }

  async createOTAUpdate(
    {abortSignal, ...params}: RequestConfig & s.CreateOTAUpdateRequest,
  ): Promise<s.CreateOTAUpdateResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      targets: params["targets"],
      protocols: params["protocols"],
      targetSelection: params["targetSelection"],
      awsJobExecutionsRolloutConfig: fromAwsJobExecutionsRolloutConfig(params["awsJobExecutionsRolloutConfig"]),
      awsJobPresignedUrlConfig: fromAwsJobPresignedUrlConfig(params["awsJobPresignedUrlConfig"]),
      awsJobAbortConfig: fromAwsJobAbortConfig(params["awsJobAbortConfig"]),
      awsJobTimeoutConfig: fromAwsJobTimeoutConfig(params["awsJobTimeoutConfig"]),
      files: params["files"]?.map(x => fromOTAUpdateFile(x)),
      roleArn: params["roleArn"],
      additionalParameters: params["additionalParameters"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOTAUpdate",
      requestUri: cmnP.encodePath`/otaUpdates/${params["otaUpdateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "otaUpdateId": "s",
        "awsIotJobId": "s",
        "otaUpdateArn": "s",
        "awsIotJobArn": "s",
        "otaUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.OTAUpdateStatus>(x),
      },
    }, await resp.json());
  }

  async createPolicy(
    {abortSignal, ...params}: RequestConfig & s.CreatePolicyRequest,
  ): Promise<s.CreatePolicyResponse> {
    const body: jsonP.JSONObject = {
      policyDocument: params["policyDocument"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePolicy",
      requestUri: cmnP.encodePath`/policies/${params["policyName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policyName": "s",
        "policyArn": "s",
        "policyDocument": "s",
        "policyVersionId": "s",
      },
    }, await resp.json());
  }

  async createPolicyVersion(
    {abortSignal, ...params}: RequestConfig & s.CreatePolicyVersionRequest,
  ): Promise<s.CreatePolicyVersionResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      policyDocument: params["policyDocument"],
    };
    if (params["setAsDefault"] != null) query.set("setAsDefault", params["setAsDefault"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreatePolicyVersion",
      requestUri: cmnP.encodePath`/policies/${params["policyName"]}/version`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policyArn": "s",
        "policyDocument": "s",
        "policyVersionId": "s",
        "isDefaultVersion": "b",
      },
    }, await resp.json());
  }

  async createProvisioningClaim(
    {abortSignal, ...params}: RequestConfig & s.CreateProvisioningClaimRequest,
  ): Promise<s.CreateProvisioningClaimResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CreateProvisioningClaim",
      requestUri: cmnP.encodePath`/provisioning-templates/${params["templateName"]}/provisioning-claim`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificateId": "s",
        "certificatePem": "s",
        "keyPair": toKeyPair,
        "expiration": "d",
      },
    }, await resp.json());
  }

  async createProvisioningTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateProvisioningTemplateRequest,
  ): Promise<s.CreateProvisioningTemplateResponse> {
    const body: jsonP.JSONObject = {
      templateName: params["templateName"],
      description: params["description"],
      templateBody: params["templateBody"],
      enabled: params["enabled"],
      provisioningRoleArn: params["provisioningRoleArn"],
      preProvisioningHook: fromProvisioningHook(params["preProvisioningHook"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProvisioningTemplate",
      requestUri: "/provisioning-templates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "templateArn": "s",
        "templateName": "s",
        "defaultVersionId": "n",
      },
    }, await resp.json());
  }

  async createProvisioningTemplateVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateProvisioningTemplateVersionRequest,
  ): Promise<s.CreateProvisioningTemplateVersionResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      templateBody: params["templateBody"],
    };
    if (params["setAsDefault"] != null) query.set("setAsDefault", params["setAsDefault"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateProvisioningTemplateVersion",
      requestUri: cmnP.encodePath`/provisioning-templates/${params["templateName"]}/versions`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "templateArn": "s",
        "templateName": "s",
        "versionId": "n",
        "isDefaultVersion": "b",
      },
    }, await resp.json());
  }

  async createRoleAlias(
    {abortSignal, ...params}: RequestConfig & s.CreateRoleAliasRequest,
  ): Promise<s.CreateRoleAliasResponse> {
    const body: jsonP.JSONObject = {
      roleArn: params["roleArn"],
      credentialDurationSeconds: params["credentialDurationSeconds"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRoleAlias",
      requestUri: cmnP.encodePath`/role-aliases/${params["roleAlias"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "roleAlias": "s",
        "roleAliasArn": "s",
      },
    }, await resp.json());
  }

  async createScheduledAudit(
    {abortSignal, ...params}: RequestConfig & s.CreateScheduledAuditRequest,
  ): Promise<s.CreateScheduledAuditResponse> {
    const body: jsonP.JSONObject = {
      frequency: params["frequency"],
      dayOfMonth: params["dayOfMonth"],
      dayOfWeek: params["dayOfWeek"],
      targetCheckNames: params["targetCheckNames"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateScheduledAudit",
      requestUri: cmnP.encodePath`/audit/scheduledaudits/${params["scheduledAuditName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "scheduledAuditArn": "s",
      },
    }, await resp.json());
  }

  async createSecurityProfile(
    {abortSignal, ...params}: RequestConfig & s.CreateSecurityProfileRequest,
  ): Promise<s.CreateSecurityProfileResponse> {
    const body: jsonP.JSONObject = {
      securityProfileDescription: params["securityProfileDescription"],
      behaviors: params["behaviors"]?.map(x => fromBehavior(x)),
      alertTargets: jsonP.serializeMap(params["alertTargets"], x => fromAlertTarget(x)),
      additionalMetricsToRetain: params["additionalMetricsToRetain"],
      additionalMetricsToRetainV2: params["additionalMetricsToRetainV2"]?.map(x => fromMetricToRetain(x)),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecurityProfile",
      requestUri: cmnP.encodePath`/security-profiles/${params["securityProfileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "securityProfileName": "s",
        "securityProfileArn": "s",
      },
    }, await resp.json());
  }

  async createStream(
    {abortSignal, ...params}: RequestConfig & s.CreateStreamRequest,
  ): Promise<s.CreateStreamResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      files: params["files"]?.map(x => fromStreamFile(x)),
      roleArn: params["roleArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStream",
      requestUri: cmnP.encodePath`/streams/${params["streamId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streamId": "s",
        "streamArn": "s",
        "description": "s",
        "streamVersion": "n",
      },
    }, await resp.json());
  }

  async createThing(
    {abortSignal, ...params}: RequestConfig & s.CreateThingRequest,
  ): Promise<s.CreateThingResponse> {
    const body: jsonP.JSONObject = {
      thingTypeName: params["thingTypeName"],
      attributePayload: fromAttributePayload(params["attributePayload"]),
      billingGroupName: params["billingGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateThing",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingName": "s",
        "thingArn": "s",
        "thingId": "s",
      },
    }, await resp.json());
  }

  async createThingGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateThingGroupRequest,
  ): Promise<s.CreateThingGroupResponse> {
    const body: jsonP.JSONObject = {
      parentGroupName: params["parentGroupName"],
      thingGroupProperties: fromThingGroupProperties(params["thingGroupProperties"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateThingGroup",
      requestUri: cmnP.encodePath`/thing-groups/${params["thingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingGroupName": "s",
        "thingGroupArn": "s",
        "thingGroupId": "s",
      },
    }, await resp.json());
  }

  async createThingType(
    {abortSignal, ...params}: RequestConfig & s.CreateThingTypeRequest,
  ): Promise<s.CreateThingTypeResponse> {
    const body: jsonP.JSONObject = {
      thingTypeProperties: fromThingTypeProperties(params["thingTypeProperties"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateThingType",
      requestUri: cmnP.encodePath`/thing-types/${params["thingTypeName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingTypeName": "s",
        "thingTypeArn": "s",
        "thingTypeId": "s",
      },
    }, await resp.json());
  }

  async createTopicRule(
    {abortSignal, ...params}: RequestConfig & s.CreateTopicRuleRequest,
  ): Promise<void> {
    const inner = params["topicRulePayload"];
    const body: jsonP.JSONObject = inner ? {
      sql: inner["sql"],
      description: inner["description"],
      actions: inner["actions"]?.map(x => fromAction(x)),
      ruleDisabled: inner["ruleDisabled"],
      awsIotSqlVersion: inner["awsIotSqlVersion"],
      errorAction: fromAction(inner["errorAction"]),
    } : {};
    const headers = new Headers;
    if (params["tags"] != null) headers.append("x-amz-tagging", params["tags"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateTopicRule",
      requestUri: cmnP.encodePath`/rules/${params["ruleName"]}`,
    });
  }

  async createTopicRuleDestination(
    {abortSignal, ...params}: RequestConfig & s.CreateTopicRuleDestinationRequest,
  ): Promise<s.CreateTopicRuleDestinationResponse> {
    const body: jsonP.JSONObject = {
      destinationConfiguration: fromTopicRuleDestinationConfiguration(params["destinationConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTopicRuleDestination",
      requestUri: "/destinations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "topicRuleDestination": toTopicRuleDestination,
      },
    }, await resp.json());
  }

  async deleteAccountAuditConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteAccountAuditConfigurationRequest = {},
  ): Promise<s.DeleteAccountAuditConfigurationResponse> {
    const query = new URLSearchParams;
    if (params["deleteScheduledAudits"] != null) query.set("deleteScheduledAudits", params["deleteScheduledAudits"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteAccountAuditConfiguration",
      method: "DELETE",
      requestUri: "/audit/configuration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteAuditSuppression(
    {abortSignal, ...params}: RequestConfig & s.DeleteAuditSuppressionRequest,
  ): Promise<s.DeleteAuditSuppressionResponse> {
    const body: jsonP.JSONObject = {
      checkName: params["checkName"],
      resourceIdentifier: fromResourceIdentifier(params["resourceIdentifier"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAuditSuppression",
      requestUri: "/audit/suppressions/delete",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.DeleteAuthorizerRequest,
  ): Promise<s.DeleteAuthorizerResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAuthorizer",
      method: "DELETE",
      requestUri: cmnP.encodePath`/authorizer/${params["authorizerName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteBillingGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteBillingGroupRequest,
  ): Promise<s.DeleteBillingGroupResponse> {
    const query = new URLSearchParams;
    if (params["expectedVersion"] != null) query.set("expectedVersion", params["expectedVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteBillingGroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/billing-groups/${params["billingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteCACertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteCACertificateRequest,
  ): Promise<s.DeleteCACertificateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteCACertificate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/cacertificate/${params["certificateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteCertificateRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["forceDelete"] != null) query.set("forceDelete", params["forceDelete"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteCertificate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/certificates/${params["certificateId"]}`,
    });
  }

  async deleteCustomMetric(
    {abortSignal, ...params}: RequestConfig & s.DeleteCustomMetricRequest,
  ): Promise<s.DeleteCustomMetricResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteCustomMetric",
      method: "DELETE",
      requestUri: cmnP.encodePath`/custom-metric/${params["metricName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDimension(
    {abortSignal, ...params}: RequestConfig & s.DeleteDimensionRequest,
  ): Promise<s.DeleteDimensionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDimension",
      method: "DELETE",
      requestUri: cmnP.encodePath`/dimensions/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDomainConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainConfigurationRequest,
  ): Promise<s.DeleteDomainConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDomainConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/domainConfigurations/${params["domainConfigurationName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDynamicThingGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteDynamicThingGroupRequest,
  ): Promise<s.DeleteDynamicThingGroupResponse> {
    const query = new URLSearchParams;
    if (params["expectedVersion"] != null) query.set("expectedVersion", params["expectedVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteDynamicThingGroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/dynamic-thing-groups/${params["thingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteJob(
    {abortSignal, ...params}: RequestConfig & s.DeleteJobRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["force"] != null) query.set("force", params["force"]?.toString() ?? "");
    if (params["namespaceId"] != null) query.set("namespaceId", params["namespaceId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteJob",
      method: "DELETE",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}`,
    });
  }

  async deleteJobExecution(
    {abortSignal, ...params}: RequestConfig & s.DeleteJobExecutionRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["force"] != null) query.set("force", params["force"]?.toString() ?? "");
    if (params["namespaceId"] != null) query.set("namespaceId", params["namespaceId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteJobExecution",
      method: "DELETE",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}/jobs/${params["jobId"]}/executionNumber/${params["executionNumber"].toString()}`,
    });
  }

  async deleteMitigationAction(
    {abortSignal, ...params}: RequestConfig & s.DeleteMitigationActionRequest,
  ): Promise<s.DeleteMitigationActionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMitigationAction",
      method: "DELETE",
      requestUri: cmnP.encodePath`/mitigationactions/actions/${params["actionName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteOTAUpdate(
    {abortSignal, ...params}: RequestConfig & s.DeleteOTAUpdateRequest,
  ): Promise<s.DeleteOTAUpdateResponse> {
    const query = new URLSearchParams;
    if (params["deleteStream"] != null) query.set("deleteStream", params["deleteStream"]?.toString() ?? "");
    if (params["forceDeleteAWSJob"] != null) query.set("forceDeleteAWSJob", params["forceDeleteAWSJob"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteOTAUpdate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/otaUpdates/${params["otaUpdateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deletePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeletePolicyRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/policies/${params["policyName"]}`,
    });
  }

  async deletePolicyVersion(
    {abortSignal, ...params}: RequestConfig & s.DeletePolicyVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePolicyVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/policies/${params["policyName"]}/version/${params["policyVersionId"]}`,
    });
  }

  async deleteProvisioningTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteProvisioningTemplateRequest,
  ): Promise<s.DeleteProvisioningTemplateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteProvisioningTemplate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/provisioning-templates/${params["templateName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteProvisioningTemplateVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteProvisioningTemplateVersionRequest,
  ): Promise<s.DeleteProvisioningTemplateVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteProvisioningTemplateVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/provisioning-templates/${params["templateName"]}/versions/${params["versionId"].toString()}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteRegistrationCode(
    {abortSignal, ...params}: RequestConfig & s.DeleteRegistrationCodeRequest = {},
  ): Promise<s.DeleteRegistrationCodeResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRegistrationCode",
      method: "DELETE",
      requestUri: "/registrationcode",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteRoleAlias(
    {abortSignal, ...params}: RequestConfig & s.DeleteRoleAliasRequest,
  ): Promise<s.DeleteRoleAliasResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRoleAlias",
      method: "DELETE",
      requestUri: cmnP.encodePath`/role-aliases/${params["roleAlias"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteScheduledAudit(
    {abortSignal, ...params}: RequestConfig & s.DeleteScheduledAuditRequest,
  ): Promise<s.DeleteScheduledAuditResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteScheduledAudit",
      method: "DELETE",
      requestUri: cmnP.encodePath`/audit/scheduledaudits/${params["scheduledAuditName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteSecurityProfile(
    {abortSignal, ...params}: RequestConfig & s.DeleteSecurityProfileRequest,
  ): Promise<s.DeleteSecurityProfileResponse> {
    const query = new URLSearchParams;
    if (params["expectedVersion"] != null) query.set("expectedVersion", params["expectedVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteSecurityProfile",
      method: "DELETE",
      requestUri: cmnP.encodePath`/security-profiles/${params["securityProfileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteStream(
    {abortSignal, ...params}: RequestConfig & s.DeleteStreamRequest,
  ): Promise<s.DeleteStreamResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteStream",
      method: "DELETE",
      requestUri: cmnP.encodePath`/streams/${params["streamId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteThing(
    {abortSignal, ...params}: RequestConfig & s.DeleteThingRequest,
  ): Promise<s.DeleteThingResponse> {
    const query = new URLSearchParams;
    if (params["expectedVersion"] != null) query.set("expectedVersion", params["expectedVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteThing",
      method: "DELETE",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteThingGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteThingGroupRequest,
  ): Promise<s.DeleteThingGroupResponse> {
    const query = new URLSearchParams;
    if (params["expectedVersion"] != null) query.set("expectedVersion", params["expectedVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteThingGroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/thing-groups/${params["thingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteThingType(
    {abortSignal, ...params}: RequestConfig & s.DeleteThingTypeRequest,
  ): Promise<s.DeleteThingTypeResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteThingType",
      method: "DELETE",
      requestUri: cmnP.encodePath`/thing-types/${params["thingTypeName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteTopicRule(
    {abortSignal, ...params}: RequestConfig & s.DeleteTopicRuleRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteTopicRule",
      method: "DELETE",
      requestUri: cmnP.encodePath`/rules/${params["ruleName"]}`,
    });
  }

  async deleteTopicRuleDestination(
    {abortSignal, ...params}: RequestConfig & s.DeleteTopicRuleDestinationRequest,
  ): Promise<s.DeleteTopicRuleDestinationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteTopicRuleDestination",
      method: "DELETE",
      requestUri: cmnP.encodePath`/destinations/${params["arn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteV2LoggingLevel(
    {abortSignal, ...params}: RequestConfig & s.DeleteV2LoggingLevelRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    query.set("targetType", params["targetType"]?.toString() ?? "");
    query.set("targetName", params["targetName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteV2LoggingLevel",
      method: "DELETE",
      requestUri: "/v2LoggingLevel",
    });
  }

  async deprecateThingType(
    {abortSignal, ...params}: RequestConfig & s.DeprecateThingTypeRequest,
  ): Promise<s.DeprecateThingTypeResponse> {
    const body: jsonP.JSONObject = {
      undoDeprecate: params["undoDeprecate"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeprecateThingType",
      requestUri: cmnP.encodePath`/thing-types/${params["thingTypeName"]}/deprecate`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeAccountAuditConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DescribeAccountAuditConfigurationRequest = {},
  ): Promise<s.DescribeAccountAuditConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAccountAuditConfiguration",
      method: "GET",
      requestUri: "/audit/configuration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "roleArn": "s",
        "auditNotificationTargetConfigurations": x => jsonP.readMap(x => cmnP.readEnumReq<s.AuditNotificationType>(x), toAuditNotificationTarget, x),
        "auditCheckConfigurations": x => jsonP.readMap(String, toAuditCheckConfiguration, x),
      },
    }, await resp.json());
  }

  async describeAuditFinding(
    {abortSignal, ...params}: RequestConfig & s.DescribeAuditFindingRequest,
  ): Promise<s.DescribeAuditFindingResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAuditFinding",
      method: "GET",
      requestUri: cmnP.encodePath`/audit/findings/${params["findingId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "finding": toAuditFinding,
      },
    }, await resp.json());
  }

  async describeAuditMitigationActionsTask(
    {abortSignal, ...params}: RequestConfig & s.DescribeAuditMitigationActionsTaskRequest,
  ): Promise<s.DescribeAuditMitigationActionsTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAuditMitigationActionsTask",
      method: "GET",
      requestUri: cmnP.encodePath`/audit/mitigationactions/tasks/${params["taskId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditMitigationActionsTaskStatus>(x),
        "startTime": "d",
        "endTime": "d",
        "taskStatistics": x => jsonP.readMap(String, toTaskStatisticsForAuditCheck, x),
        "target": toAuditMitigationActionsTaskTarget,
        "auditCheckToActionsMapping": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
        "actionsDefinition": [toMitigationAction],
      },
    }, await resp.json());
  }

  async describeAuditSuppression(
    {abortSignal, ...params}: RequestConfig & s.DescribeAuditSuppressionRequest,
  ): Promise<s.DescribeAuditSuppressionResponse> {
    const body: jsonP.JSONObject = {
      checkName: params["checkName"],
      resourceIdentifier: fromResourceIdentifier(params["resourceIdentifier"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAuditSuppression",
      requestUri: "/audit/suppressions/describe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "checkName": "s",
        "resourceIdentifier": toResourceIdentifier,
        "expirationDate": "d",
        "suppressIndefinitely": "b",
        "description": "s",
      },
    }, await resp.json());
  }

  async describeAuditTask(
    {abortSignal, ...params}: RequestConfig & s.DescribeAuditTaskRequest,
  ): Promise<s.DescribeAuditTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAuditTask",
      method: "GET",
      requestUri: cmnP.encodePath`/audit/tasks/${params["taskId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditTaskStatus>(x),
        "taskType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditTaskType>(x),
        "taskStartTime": "d",
        "taskStatistics": toTaskStatistics,
        "scheduledAuditName": "s",
        "auditDetails": x => jsonP.readMap(String, toAuditCheckDetails, x),
      },
    }, await resp.json());
  }

  async describeAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.DescribeAuthorizerRequest,
  ): Promise<s.DescribeAuthorizerResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAuthorizer",
      method: "GET",
      requestUri: cmnP.encodePath`/authorizer/${params["authorizerName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizerDescription": toAuthorizerDescription,
      },
    }, await resp.json());
  }

  async describeBillingGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeBillingGroupRequest,
  ): Promise<s.DescribeBillingGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeBillingGroup",
      method: "GET",
      requestUri: cmnP.encodePath`/billing-groups/${params["billingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "billingGroupName": "s",
        "billingGroupId": "s",
        "billingGroupArn": "s",
        "version": "n",
        "billingGroupProperties": toBillingGroupProperties,
        "billingGroupMetadata": toBillingGroupMetadata,
      },
    }, await resp.json());
  }

  async describeCACertificate(
    {abortSignal, ...params}: RequestConfig & s.DescribeCACertificateRequest,
  ): Promise<s.DescribeCACertificateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeCACertificate",
      method: "GET",
      requestUri: cmnP.encodePath`/cacertificate/${params["certificateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificateDescription": toCACertificateDescription,
        "registrationConfig": toRegistrationConfig,
      },
    }, await resp.json());
  }

  async describeCertificate(
    {abortSignal, ...params}: RequestConfig & s.DescribeCertificateRequest,
  ): Promise<s.DescribeCertificateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeCertificate",
      method: "GET",
      requestUri: cmnP.encodePath`/certificates/${params["certificateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificateDescription": toCertificateDescription,
      },
    }, await resp.json());
  }

  async describeCustomMetric(
    {abortSignal, ...params}: RequestConfig & s.DescribeCustomMetricRequest,
  ): Promise<s.DescribeCustomMetricResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeCustomMetric",
      method: "GET",
      requestUri: cmnP.encodePath`/custom-metric/${params["metricName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricName": "s",
        "metricArn": "s",
        "metricType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CustomMetricType>(x),
        "displayName": "s",
        "creationDate": "d",
        "lastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async describeDefaultAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.DescribeDefaultAuthorizerRequest = {},
  ): Promise<s.DescribeDefaultAuthorizerResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDefaultAuthorizer",
      method: "GET",
      requestUri: "/default-authorizer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizerDescription": toAuthorizerDescription,
      },
    }, await resp.json());
  }

  async describeDetectMitigationActionsTask(
    {abortSignal, ...params}: RequestConfig & s.DescribeDetectMitigationActionsTaskRequest,
  ): Promise<s.DescribeDetectMitigationActionsTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDetectMitigationActionsTask",
      method: "GET",
      requestUri: cmnP.encodePath`/detect/mitigationactions/tasks/${params["taskId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSummary": toDetectMitigationActionsTaskSummary,
      },
    }, await resp.json());
  }

  async describeDimension(
    {abortSignal, ...params}: RequestConfig & s.DescribeDimensionRequest,
  ): Promise<s.DescribeDimensionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDimension",
      method: "GET",
      requestUri: cmnP.encodePath`/dimensions/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "arn": "s",
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DimensionType>(x),
        "stringValues": ["s"],
        "creationDate": "d",
        "lastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async describeDomainConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DescribeDomainConfigurationRequest,
  ): Promise<s.DescribeDomainConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDomainConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/domainConfigurations/${params["domainConfigurationName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainConfigurationName": "s",
        "domainConfigurationArn": "s",
        "domainName": "s",
        "serverCertificates": [toServerCertificateSummary],
        "authorizerConfig": toAuthorizerConfig,
        "domainConfigurationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainConfigurationStatus>(x),
        "serviceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ServiceType>(x),
        "domainType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainType>(x),
        "lastStatusChangeDate": "d",
      },
    }, await resp.json());
  }

  async describeEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DescribeEndpointRequest = {},
  ): Promise<s.DescribeEndpointResponse> {
    const query = new URLSearchParams;
    if (params["endpointType"] != null) query.set("endpointType", params["endpointType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeEndpoint",
      method: "GET",
      requestUri: "/endpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "endpointAddress": "s",
      },
    }, await resp.json());
  }

  async describeEventConfigurations(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventConfigurationsRequest = {},
  ): Promise<s.DescribeEventConfigurationsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeEventConfigurations",
      method: "GET",
      requestUri: "/event-configurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventConfigurations": x => jsonP.readMap(x => cmnP.readEnumReq<s.EventType>(x), toConfiguration, x),
        "creationDate": "d",
        "lastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async describeIndex(
    {abortSignal, ...params}: RequestConfig & s.DescribeIndexRequest,
  ): Promise<s.DescribeIndexResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeIndex",
      method: "GET",
      requestUri: cmnP.encodePath`/indices/${params["indexName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "indexName": "s",
        "indexStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.IndexStatus>(x),
        "schema": "s",
      },
    }, await resp.json());
  }

  async describeJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeJobRequest,
  ): Promise<s.DescribeJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJob",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "documentSource": "s",
        "job": toJob,
      },
    }, await resp.json());
  }

  async describeJobExecution(
    {abortSignal, ...params}: RequestConfig & s.DescribeJobExecutionRequest,
  ): Promise<s.DescribeJobExecutionResponse> {
    const query = new URLSearchParams;
    if (params["executionNumber"] != null) query.set("executionNumber", params["executionNumber"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeJobExecution",
      method: "GET",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}/jobs/${params["jobId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "execution": toJobExecution,
      },
    }, await resp.json());
  }

  async describeMitigationAction(
    {abortSignal, ...params}: RequestConfig & s.DescribeMitigationActionRequest,
  ): Promise<s.DescribeMitigationActionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeMitigationAction",
      method: "GET",
      requestUri: cmnP.encodePath`/mitigationactions/actions/${params["actionName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "actionName": "s",
        "actionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MitigationActionType>(x),
        "actionArn": "s",
        "actionId": "s",
        "roleArn": "s",
        "actionParams": toMitigationActionParams,
        "creationDate": "d",
        "lastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async describeProvisioningTemplate(
    {abortSignal, ...params}: RequestConfig & s.DescribeProvisioningTemplateRequest,
  ): Promise<s.DescribeProvisioningTemplateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeProvisioningTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/provisioning-templates/${params["templateName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "templateArn": "s",
        "templateName": "s",
        "description": "s",
        "creationDate": "d",
        "lastModifiedDate": "d",
        "defaultVersionId": "n",
        "templateBody": "s",
        "enabled": "b",
        "provisioningRoleArn": "s",
        "preProvisioningHook": toProvisioningHook,
      },
    }, await resp.json());
  }

  async describeProvisioningTemplateVersion(
    {abortSignal, ...params}: RequestConfig & s.DescribeProvisioningTemplateVersionRequest,
  ): Promise<s.DescribeProvisioningTemplateVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeProvisioningTemplateVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/provisioning-templates/${params["templateName"]}/versions/${params["versionId"].toString()}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "versionId": "n",
        "creationDate": "d",
        "templateBody": "s",
        "isDefaultVersion": "b",
      },
    }, await resp.json());
  }

  async describeRoleAlias(
    {abortSignal, ...params}: RequestConfig & s.DescribeRoleAliasRequest,
  ): Promise<s.DescribeRoleAliasResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeRoleAlias",
      method: "GET",
      requestUri: cmnP.encodePath`/role-aliases/${params["roleAlias"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "roleAliasDescription": toRoleAliasDescription,
      },
    }, await resp.json());
  }

  async describeScheduledAudit(
    {abortSignal, ...params}: RequestConfig & s.DescribeScheduledAuditRequest,
  ): Promise<s.DescribeScheduledAuditResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeScheduledAudit",
      method: "GET",
      requestUri: cmnP.encodePath`/audit/scheduledaudits/${params["scheduledAuditName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "frequency": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditFrequency>(x),
        "dayOfMonth": "s",
        "dayOfWeek": (x: jsonP.JSONValue) => cmnP.readEnum<s.DayOfWeek>(x),
        "targetCheckNames": ["s"],
        "scheduledAuditName": "s",
        "scheduledAuditArn": "s",
      },
    }, await resp.json());
  }

  async describeSecurityProfile(
    {abortSignal, ...params}: RequestConfig & s.DescribeSecurityProfileRequest,
  ): Promise<s.DescribeSecurityProfileResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeSecurityProfile",
      method: "GET",
      requestUri: cmnP.encodePath`/security-profiles/${params["securityProfileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "securityProfileName": "s",
        "securityProfileArn": "s",
        "securityProfileDescription": "s",
        "behaviors": [toBehavior],
        "alertTargets": x => jsonP.readMap(x => cmnP.readEnumReq<s.AlertTargetType>(x), toAlertTarget, x),
        "additionalMetricsToRetain": ["s"],
        "additionalMetricsToRetainV2": [toMetricToRetain],
        "version": "n",
        "creationDate": "d",
        "lastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async describeStream(
    {abortSignal, ...params}: RequestConfig & s.DescribeStreamRequest,
  ): Promise<s.DescribeStreamResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeStream",
      method: "GET",
      requestUri: cmnP.encodePath`/streams/${params["streamId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streamInfo": toStreamInfo,
      },
    }, await resp.json());
  }

  async describeThing(
    {abortSignal, ...params}: RequestConfig & s.DescribeThingRequest,
  ): Promise<s.DescribeThingResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeThing",
      method: "GET",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "defaultClientId": "s",
        "thingName": "s",
        "thingId": "s",
        "thingArn": "s",
        "thingTypeName": "s",
        "attributes": x => jsonP.readMap(String, String, x),
        "version": "n",
        "billingGroupName": "s",
      },
    }, await resp.json());
  }

  async describeThingGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeThingGroupRequest,
  ): Promise<s.DescribeThingGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeThingGroup",
      method: "GET",
      requestUri: cmnP.encodePath`/thing-groups/${params["thingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingGroupName": "s",
        "thingGroupId": "s",
        "thingGroupArn": "s",
        "version": "n",
        "thingGroupProperties": toThingGroupProperties,
        "thingGroupMetadata": toThingGroupMetadata,
        "indexName": "s",
        "queryString": "s",
        "queryVersion": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DynamicGroupStatus>(x),
      },
    }, await resp.json());
  }

  async describeThingRegistrationTask(
    {abortSignal, ...params}: RequestConfig & s.DescribeThingRegistrationTaskRequest,
  ): Promise<s.DescribeThingRegistrationTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeThingRegistrationTask",
      method: "GET",
      requestUri: cmnP.encodePath`/thing-registration-tasks/${params["taskId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskId": "s",
        "creationDate": "d",
        "lastModifiedDate": "d",
        "templateBody": "s",
        "inputFileBucket": "s",
        "inputFileKey": "s",
        "roleArn": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
        "message": "s",
        "successCount": "n",
        "failureCount": "n",
        "percentageProgress": "n",
      },
    }, await resp.json());
  }

  async describeThingType(
    {abortSignal, ...params}: RequestConfig & s.DescribeThingTypeRequest,
  ): Promise<s.DescribeThingTypeResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeThingType",
      method: "GET",
      requestUri: cmnP.encodePath`/thing-types/${params["thingTypeName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingTypeName": "s",
        "thingTypeId": "s",
        "thingTypeArn": "s",
        "thingTypeProperties": toThingTypeProperties,
        "thingTypeMetadata": toThingTypeMetadata,
      },
    }, await resp.json());
  }

  async detachPolicy(
    {abortSignal, ...params}: RequestConfig & s.DetachPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      target: params["target"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachPolicy",
      requestUri: cmnP.encodePath`/target-policies/${params["policyName"]}`,
    });
  }

  async detachPrincipalPolicy(
    {abortSignal, ...params}: RequestConfig & s.DetachPrincipalPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amzn-iot-principal", params["principal"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DetachPrincipalPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/principal-policies/${params["policyName"]}`,
    });
  }

  async detachSecurityProfile(
    {abortSignal, ...params}: RequestConfig & s.DetachSecurityProfileRequest,
  ): Promise<s.DetachSecurityProfileResponse> {
    const query = new URLSearchParams;
    query.set("securityProfileTargetArn", params["securityProfileTargetArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DetachSecurityProfile",
      method: "DELETE",
      requestUri: cmnP.encodePath`/security-profiles/${params["securityProfileName"]}/targets`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async detachThingPrincipal(
    {abortSignal, ...params}: RequestConfig & s.DetachThingPrincipalRequest,
  ): Promise<s.DetachThingPrincipalResponse> {
    const headers = new Headers;
    headers.append("x-amzn-principal", params["principal"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DetachThingPrincipal",
      method: "DELETE",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}/principals`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async disableTopicRule(
    {abortSignal, ...params}: RequestConfig & s.DisableTopicRuleRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DisableTopicRule",
      requestUri: cmnP.encodePath`/rules/${params["ruleName"]}/disable`,
    });
  }

  async enableTopicRule(
    {abortSignal, ...params}: RequestConfig & s.EnableTopicRuleRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "EnableTopicRule",
      requestUri: cmnP.encodePath`/rules/${params["ruleName"]}/enable`,
    });
  }

  async getBehaviorModelTrainingSummaries(
    {abortSignal, ...params}: RequestConfig & s.GetBehaviorModelTrainingSummariesRequest = {},
  ): Promise<s.GetBehaviorModelTrainingSummariesResponse> {
    const query = new URLSearchParams;
    if (params["securityProfileName"] != null) query.set("securityProfileName", params["securityProfileName"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBehaviorModelTrainingSummaries",
      method: "GET",
      requestUri: "/behavior-model-training/summaries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "summaries": [toBehaviorModelTrainingSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getCardinality(
    {abortSignal, ...params}: RequestConfig & s.GetCardinalityRequest,
  ): Promise<s.GetCardinalityResponse> {
    const body: jsonP.JSONObject = {
      indexName: params["indexName"],
      queryString: params["queryString"],
      aggregationField: params["aggregationField"],
      queryVersion: params["queryVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCardinality",
      requestUri: "/indices/cardinality",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cardinality": "n",
      },
    }, await resp.json());
  }

  async getEffectivePolicies(
    {abortSignal, ...params}: RequestConfig & s.GetEffectivePoliciesRequest = {},
  ): Promise<s.GetEffectivePoliciesResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      principal: params["principal"],
      cognitoIdentityPoolId: params["cognitoIdentityPoolId"],
    };
    if (params["thingName"] != null) query.set("thingName", params["thingName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "GetEffectivePolicies",
      requestUri: "/effective-policies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "effectivePolicies": [toEffectivePolicy],
      },
    }, await resp.json());
  }

  async getIndexingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetIndexingConfigurationRequest = {},
  ): Promise<s.GetIndexingConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetIndexingConfiguration",
      method: "GET",
      requestUri: "/indexing/config",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingIndexingConfiguration": toThingIndexingConfiguration,
        "thingGroupIndexingConfiguration": toThingGroupIndexingConfiguration,
      },
    }, await resp.json());
  }

  async getJobDocument(
    {abortSignal, ...params}: RequestConfig & s.GetJobDocumentRequest,
  ): Promise<s.GetJobDocumentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetJobDocument",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}/job-document`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "document": "s",
      },
    }, await resp.json());
  }

  async getLoggingOptions(
    {abortSignal, ...params}: RequestConfig & s.GetLoggingOptionsRequest = {},
  ): Promise<s.GetLoggingOptionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetLoggingOptions",
      method: "GET",
      requestUri: "/loggingOptions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "roleArn": "s",
        "logLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
      },
    }, await resp.json());
  }

  async getOTAUpdate(
    {abortSignal, ...params}: RequestConfig & s.GetOTAUpdateRequest,
  ): Promise<s.GetOTAUpdateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetOTAUpdate",
      method: "GET",
      requestUri: cmnP.encodePath`/otaUpdates/${params["otaUpdateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "otaUpdateInfo": toOTAUpdateInfo,
      },
    }, await resp.json());
  }

  async getPercentiles(
    {abortSignal, ...params}: RequestConfig & s.GetPercentilesRequest,
  ): Promise<s.GetPercentilesResponse> {
    const body: jsonP.JSONObject = {
      indexName: params["indexName"],
      queryString: params["queryString"],
      aggregationField: params["aggregationField"],
      queryVersion: params["queryVersion"],
      percents: params["percents"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPercentiles",
      requestUri: "/indices/percentiles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "percentiles": [toPercentPair],
      },
    }, await resp.json());
  }

  async getPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetPolicyRequest,
  ): Promise<s.GetPolicyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/policies/${params["policyName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policyName": "s",
        "policyArn": "s",
        "policyDocument": "s",
        "defaultVersionId": "s",
        "creationDate": "d",
        "lastModifiedDate": "d",
        "generationId": "s",
      },
    }, await resp.json());
  }

  async getPolicyVersion(
    {abortSignal, ...params}: RequestConfig & s.GetPolicyVersionRequest,
  ): Promise<s.GetPolicyVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetPolicyVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/policies/${params["policyName"]}/version/${params["policyVersionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policyArn": "s",
        "policyName": "s",
        "policyDocument": "s",
        "policyVersionId": "s",
        "isDefaultVersion": "b",
        "creationDate": "d",
        "lastModifiedDate": "d",
        "generationId": "s",
      },
    }, await resp.json());
  }

  async getRegistrationCode(
    {abortSignal, ...params}: RequestConfig & s.GetRegistrationCodeRequest = {},
  ): Promise<s.GetRegistrationCodeResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetRegistrationCode",
      method: "GET",
      requestUri: "/registrationcode",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registrationCode": "s",
      },
    }, await resp.json());
  }

  async getStatistics(
    {abortSignal, ...params}: RequestConfig & s.GetStatisticsRequest,
  ): Promise<s.GetStatisticsResponse> {
    const body: jsonP.JSONObject = {
      indexName: params["indexName"],
      queryString: params["queryString"],
      aggregationField: params["aggregationField"],
      queryVersion: params["queryVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStatistics",
      requestUri: "/indices/statistics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statistics": toStatistics,
      },
    }, await resp.json());
  }

  async getTopicRule(
    {abortSignal, ...params}: RequestConfig & s.GetTopicRuleRequest,
  ): Promise<s.GetTopicRuleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetTopicRule",
      method: "GET",
      requestUri: cmnP.encodePath`/rules/${params["ruleName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ruleArn": "s",
        "rule": toTopicRule,
      },
    }, await resp.json());
  }

  async getTopicRuleDestination(
    {abortSignal, ...params}: RequestConfig & s.GetTopicRuleDestinationRequest,
  ): Promise<s.GetTopicRuleDestinationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetTopicRuleDestination",
      method: "GET",
      requestUri: cmnP.encodePath`/destinations/${params["arn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "topicRuleDestination": toTopicRuleDestination,
      },
    }, await resp.json());
  }

  async getV2LoggingOptions(
    {abortSignal, ...params}: RequestConfig & s.GetV2LoggingOptionsRequest = {},
  ): Promise<s.GetV2LoggingOptionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetV2LoggingOptions",
      method: "GET",
      requestUri: "/v2LoggingOptions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "roleArn": "s",
        "defaultLogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
        "disableAllLogs": "b",
      },
    }, await resp.json());
  }

  async listActiveViolations(
    {abortSignal, ...params}: RequestConfig & s.ListActiveViolationsRequest = {},
  ): Promise<s.ListActiveViolationsResponse> {
    const query = new URLSearchParams;
    if (params["thingName"] != null) query.set("thingName", params["thingName"]?.toString() ?? "");
    if (params["securityProfileName"] != null) query.set("securityProfileName", params["securityProfileName"]?.toString() ?? "");
    if (params["behaviorCriteriaType"] != null) query.set("behaviorCriteriaType", params["behaviorCriteriaType"]?.toString() ?? "");
    if (params["listSuppressedAlerts"] != null) query.set("listSuppressedAlerts", params["listSuppressedAlerts"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListActiveViolations",
      method: "GET",
      requestUri: "/active-violations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "activeViolations": [toActiveViolation],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAttachedPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListAttachedPoliciesRequest,
  ): Promise<s.ListAttachedPoliciesResponse> {
    const query = new URLSearchParams;
    if (params["recursive"] != null) query.set("recursive", params["recursive"]?.toString() ?? "");
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAttachedPolicies",
      requestUri: cmnP.encodePath`/attached-policies/${params["target"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policies": [toPolicy],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listAuditFindings(
    {abortSignal, ...params}: RequestConfig & s.ListAuditFindingsRequest = {},
  ): Promise<s.ListAuditFindingsResponse> {
    const body: jsonP.JSONObject = {
      taskId: params["taskId"],
      checkName: params["checkName"],
      resourceIdentifier: fromResourceIdentifier(params["resourceIdentifier"]),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      listSuppressedFindings: params["listSuppressedFindings"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAuditFindings",
      requestUri: "/audit/findings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "findings": [toAuditFinding],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAuditMitigationActionsExecutions(
    {abortSignal, ...params}: RequestConfig & s.ListAuditMitigationActionsExecutionsRequest,
  ): Promise<s.ListAuditMitigationActionsExecutionsResponse> {
    const query = new URLSearchParams;
    query.set("taskId", params["taskId"]?.toString() ?? "");
    if (params["actionStatus"] != null) query.set("actionStatus", params["actionStatus"]?.toString() ?? "");
    query.set("findingId", params["findingId"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAuditMitigationActionsExecutions",
      method: "GET",
      requestUri: "/audit/mitigationactions/executions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "actionsExecutions": [toAuditMitigationActionExecutionMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAuditMitigationActionsTasks(
    {abortSignal, ...params}: RequestConfig & s.ListAuditMitigationActionsTasksRequest,
  ): Promise<s.ListAuditMitigationActionsTasksResponse> {
    const query = new URLSearchParams;
    if (params["auditTaskId"] != null) query.set("auditTaskId", params["auditTaskId"]?.toString() ?? "");
    if (params["findingId"] != null) query.set("findingId", params["findingId"]?.toString() ?? "");
    if (params["taskStatus"] != null) query.set("taskStatus", params["taskStatus"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAuditMitigationActionsTasks",
      method: "GET",
      requestUri: "/audit/mitigationactions/tasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tasks": [toAuditMitigationActionsTaskMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAuditSuppressions(
    {abortSignal, ...params}: RequestConfig & s.ListAuditSuppressionsRequest = {},
  ): Promise<s.ListAuditSuppressionsResponse> {
    const body: jsonP.JSONObject = {
      checkName: params["checkName"],
      resourceIdentifier: fromResourceIdentifier(params["resourceIdentifier"]),
      ascendingOrder: params["ascendingOrder"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAuditSuppressions",
      requestUri: "/audit/suppressions/list",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "suppressions": [toAuditSuppression],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAuditTasks(
    {abortSignal, ...params}: RequestConfig & s.ListAuditTasksRequest,
  ): Promise<s.ListAuditTasksResponse> {
    const query = new URLSearchParams;
    query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    if (params["taskType"] != null) query.set("taskType", params["taskType"]?.toString() ?? "");
    if (params["taskStatus"] != null) query.set("taskStatus", params["taskStatus"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAuditTasks",
      method: "GET",
      requestUri: "/audit/tasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tasks": [toAuditTaskMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAuthorizers(
    {abortSignal, ...params}: RequestConfig & s.ListAuthorizersRequest = {},
  ): Promise<s.ListAuthorizersResponse> {
    const query = new URLSearchParams;
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    if (params["status"] != null) query.set("status", params["status"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAuthorizers",
      method: "GET",
      requestUri: "/authorizers/",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizers": [toAuthorizerSummary],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listBillingGroups(
    {abortSignal, ...params}: RequestConfig & s.ListBillingGroupsRequest = {},
  ): Promise<s.ListBillingGroupsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["namePrefixFilter"] != null) query.set("namePrefixFilter", params["namePrefixFilter"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListBillingGroups",
      method: "GET",
      requestUri: "/billing-groups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "billingGroups": [toGroupNameAndArn],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listCACertificates(
    {abortSignal, ...params}: RequestConfig & s.ListCACertificatesRequest = {},
  ): Promise<s.ListCACertificatesResponse> {
    const query = new URLSearchParams;
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCACertificates",
      method: "GET",
      requestUri: "/cacertificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificates": [toCACertificate],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listCertificates(
    {abortSignal, ...params}: RequestConfig & s.ListCertificatesRequest = {},
  ): Promise<s.ListCertificatesResponse> {
    const query = new URLSearchParams;
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCertificates",
      method: "GET",
      requestUri: "/certificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificates": [toCertificate],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listCertificatesByCA(
    {abortSignal, ...params}: RequestConfig & s.ListCertificatesByCARequest,
  ): Promise<s.ListCertificatesByCAResponse> {
    const query = new URLSearchParams;
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCertificatesByCA",
      method: "GET",
      requestUri: cmnP.encodePath`/certificates-by-ca/${params["caCertificateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificates": [toCertificate],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listCustomMetrics(
    {abortSignal, ...params}: RequestConfig & s.ListCustomMetricsRequest = {},
  ): Promise<s.ListCustomMetricsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCustomMetrics",
      method: "GET",
      requestUri: "/custom-metrics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDetectMitigationActionsExecutions(
    {abortSignal, ...params}: RequestConfig & s.ListDetectMitigationActionsExecutionsRequest = {},
  ): Promise<s.ListDetectMitigationActionsExecutionsResponse> {
    const query = new URLSearchParams;
    if (params["taskId"] != null) query.set("taskId", params["taskId"]?.toString() ?? "");
    if (params["violationId"] != null) query.set("violationId", params["violationId"]?.toString() ?? "");
    if (params["thingName"] != null) query.set("thingName", params["thingName"]?.toString() ?? "");
    if (params["startTime"] != null) query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    if (params["endTime"] != null) query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDetectMitigationActionsExecutions",
      method: "GET",
      requestUri: "/detect/mitigationactions/executions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "actionsExecutions": [toDetectMitigationActionExecution],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDetectMitigationActionsTasks(
    {abortSignal, ...params}: RequestConfig & s.ListDetectMitigationActionsTasksRequest,
  ): Promise<s.ListDetectMitigationActionsTasksResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDetectMitigationActionsTasks",
      method: "GET",
      requestUri: "/detect/mitigationactions/tasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tasks": [toDetectMitigationActionsTaskSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDimensions(
    {abortSignal, ...params}: RequestConfig & s.ListDimensionsRequest = {},
  ): Promise<s.ListDimensionsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDimensions",
      method: "GET",
      requestUri: "/dimensions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "dimensionNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDomainConfigurations(
    {abortSignal, ...params}: RequestConfig & s.ListDomainConfigurationsRequest = {},
  ): Promise<s.ListDomainConfigurationsResponse> {
    const query = new URLSearchParams;
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["serviceType"] != null) query.set("serviceType", params["serviceType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDomainConfigurations",
      method: "GET",
      requestUri: "/domainConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainConfigurations": [toDomainConfigurationSummary],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listIndices(
    {abortSignal, ...params}: RequestConfig & s.ListIndicesRequest = {},
  ): Promise<s.ListIndicesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListIndices",
      method: "GET",
      requestUri: "/indices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "indexNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listJobExecutionsForJob(
    {abortSignal, ...params}: RequestConfig & s.ListJobExecutionsForJobRequest,
  ): Promise<s.ListJobExecutionsForJobResponse> {
    const query = new URLSearchParams;
    if (params["status"] != null) query.set("status", params["status"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobExecutionsForJob",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}/things`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "executionSummaries": [toJobExecutionSummaryForJob],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listJobExecutionsForThing(
    {abortSignal, ...params}: RequestConfig & s.ListJobExecutionsForThingRequest,
  ): Promise<s.ListJobExecutionsForThingResponse> {
    const query = new URLSearchParams;
    if (params["status"] != null) query.set("status", params["status"]?.toString() ?? "");
    if (params["namespaceId"] != null) query.set("namespaceId", params["namespaceId"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobExecutionsForThing",
      method: "GET",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}/jobs`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "executionSummaries": [toJobExecutionSummaryForThing],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & s.ListJobsRequest = {},
  ): Promise<s.ListJobsResponse> {
    const query = new URLSearchParams;
    if (params["status"] != null) query.set("status", params["status"]?.toString() ?? "");
    if (params["targetSelection"] != null) query.set("targetSelection", params["targetSelection"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["thingGroupName"] != null) query.set("thingGroupName", params["thingGroupName"]?.toString() ?? "");
    if (params["thingGroupId"] != null) query.set("thingGroupId", params["thingGroupId"]?.toString() ?? "");
    if (params["namespaceId"] != null) query.set("namespaceId", params["namespaceId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobs",
      method: "GET",
      requestUri: "/jobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobs": [toJobSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listMitigationActions(
    {abortSignal, ...params}: RequestConfig & s.ListMitigationActionsRequest = {},
  ): Promise<s.ListMitigationActionsResponse> {
    const query = new URLSearchParams;
    if (params["actionType"] != null) query.set("actionType", params["actionType"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMitigationActions",
      method: "GET",
      requestUri: "/mitigationactions/actions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "actionIdentifiers": [toMitigationActionIdentifier],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listOTAUpdates(
    {abortSignal, ...params}: RequestConfig & s.ListOTAUpdatesRequest = {},
  ): Promise<s.ListOTAUpdatesResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["otaUpdateStatus"] != null) query.set("otaUpdateStatus", params["otaUpdateStatus"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOTAUpdates",
      method: "GET",
      requestUri: "/otaUpdates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "otaUpdates": [toOTAUpdateSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listOutgoingCertificates(
    {abortSignal, ...params}: RequestConfig & s.ListOutgoingCertificatesRequest = {},
  ): Promise<s.ListOutgoingCertificatesResponse> {
    const query = new URLSearchParams;
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOutgoingCertificates",
      method: "GET",
      requestUri: "/certificates-out-going",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "outgoingCertificates": [toOutgoingCertificate],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListPoliciesRequest = {},
  ): Promise<s.ListPoliciesResponse> {
    const query = new URLSearchParams;
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPolicies",
      method: "GET",
      requestUri: "/policies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policies": [toPolicy],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listPolicyPrincipals(
    {abortSignal, ...params}: RequestConfig & s.ListPolicyPrincipalsRequest,
  ): Promise<s.ListPolicyPrincipalsResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amzn-iot-policy", params["policyName"]);
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListPolicyPrincipals",
      method: "GET",
      requestUri: "/policy-principals",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "principals": ["s"],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listPolicyVersions(
    {abortSignal, ...params}: RequestConfig & s.ListPolicyVersionsRequest,
  ): Promise<s.ListPolicyVersionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListPolicyVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/policies/${params["policyName"]}/version`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policyVersions": [toPolicyVersion],
      },
    }, await resp.json());
  }

  async listPrincipalPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListPrincipalPoliciesRequest,
  ): Promise<s.ListPrincipalPoliciesResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amzn-iot-principal", params["principal"]);
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListPrincipalPolicies",
      method: "GET",
      requestUri: "/principal-policies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policies": [toPolicy],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listPrincipalThings(
    {abortSignal, ...params}: RequestConfig & s.ListPrincipalThingsRequest,
  ): Promise<s.ListPrincipalThingsResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    headers.append("x-amzn-principal", params["principal"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListPrincipalThings",
      method: "GET",
      requestUri: "/principals/things",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "things": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listProvisioningTemplateVersions(
    {abortSignal, ...params}: RequestConfig & s.ListProvisioningTemplateVersionsRequest,
  ): Promise<s.ListProvisioningTemplateVersionsResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProvisioningTemplateVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/provisioning-templates/${params["templateName"]}/versions`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "versions": [toProvisioningTemplateVersionSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listProvisioningTemplates(
    {abortSignal, ...params}: RequestConfig & s.ListProvisioningTemplatesRequest = {},
  ): Promise<s.ListProvisioningTemplatesResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProvisioningTemplates",
      method: "GET",
      requestUri: "/provisioning-templates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "templates": [toProvisioningTemplateSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRoleAliases(
    {abortSignal, ...params}: RequestConfig & s.ListRoleAliasesRequest = {},
  ): Promise<s.ListRoleAliasesResponse> {
    const query = new URLSearchParams;
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRoleAliases",
      method: "GET",
      requestUri: "/role-aliases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "roleAliases": ["s"],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listScheduledAudits(
    {abortSignal, ...params}: RequestConfig & s.ListScheduledAuditsRequest = {},
  ): Promise<s.ListScheduledAuditsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListScheduledAudits",
      method: "GET",
      requestUri: "/audit/scheduledaudits",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "scheduledAudits": [toScheduledAuditMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSecurityProfiles(
    {abortSignal, ...params}: RequestConfig & s.ListSecurityProfilesRequest = {},
  ): Promise<s.ListSecurityProfilesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["dimensionName"] != null) query.set("dimensionName", params["dimensionName"]?.toString() ?? "");
    if (params["metricName"] != null) query.set("metricName", params["metricName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListSecurityProfiles",
      method: "GET",
      requestUri: "/security-profiles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "securityProfileIdentifiers": [toSecurityProfileIdentifier],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSecurityProfilesForTarget(
    {abortSignal, ...params}: RequestConfig & s.ListSecurityProfilesForTargetRequest,
  ): Promise<s.ListSecurityProfilesForTargetResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["recursive"] != null) query.set("recursive", params["recursive"]?.toString() ?? "");
    query.set("securityProfileTargetArn", params["securityProfileTargetArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListSecurityProfilesForTarget",
      method: "GET",
      requestUri: "/security-profiles-for-target",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "securityProfileTargetMappings": [toSecurityProfileTargetMapping],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listStreams(
    {abortSignal, ...params}: RequestConfig & s.ListStreamsRequest = {},
  ): Promise<s.ListStreamsResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["ascendingOrder"] != null) query.set("isAscendingOrder", params["ascendingOrder"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListStreams",
      method: "GET",
      requestUri: "/streams",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streams": [toStreamSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const query = new URLSearchParams;
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: "/tags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTargetsForPolicy(
    {abortSignal, ...params}: RequestConfig & s.ListTargetsForPolicyRequest,
  ): Promise<s.ListTargetsForPolicyResponse> {
    const query = new URLSearchParams;
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["pageSize"] != null) query.set("pageSize", params["pageSize"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTargetsForPolicy",
      requestUri: cmnP.encodePath`/policy-targets/${params["policyName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "targets": ["s"],
        "nextMarker": "s",
      },
    }, await resp.json());
  }

  async listTargetsForSecurityProfile(
    {abortSignal, ...params}: RequestConfig & s.ListTargetsForSecurityProfileRequest,
  ): Promise<s.ListTargetsForSecurityProfileResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTargetsForSecurityProfile",
      method: "GET",
      requestUri: cmnP.encodePath`/security-profiles/${params["securityProfileName"]}/targets`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "securityProfileTargets": [toSecurityProfileTarget],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listThingGroups(
    {abortSignal, ...params}: RequestConfig & s.ListThingGroupsRequest = {},
  ): Promise<s.ListThingGroupsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["parentGroup"] != null) query.set("parentGroup", params["parentGroup"]?.toString() ?? "");
    if (params["namePrefixFilter"] != null) query.set("namePrefixFilter", params["namePrefixFilter"]?.toString() ?? "");
    if (params["recursive"] != null) query.set("recursive", params["recursive"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThingGroups",
      method: "GET",
      requestUri: "/thing-groups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingGroups": [toGroupNameAndArn],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listThingGroupsForThing(
    {abortSignal, ...params}: RequestConfig & s.ListThingGroupsForThingRequest,
  ): Promise<s.ListThingGroupsForThingResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThingGroupsForThing",
      method: "GET",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}/thing-groups`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingGroups": [toGroupNameAndArn],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listThingPrincipals(
    {abortSignal, ...params}: RequestConfig & s.ListThingPrincipalsRequest,
  ): Promise<s.ListThingPrincipalsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThingPrincipals",
      method: "GET",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}/principals`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "principals": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listThingRegistrationTaskReports(
    {abortSignal, ...params}: RequestConfig & s.ListThingRegistrationTaskReportsRequest,
  ): Promise<s.ListThingRegistrationTaskReportsResponse> {
    const query = new URLSearchParams;
    query.set("reportType", params["reportType"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThingRegistrationTaskReports",
      method: "GET",
      requestUri: cmnP.encodePath`/thing-registration-tasks/${params["taskId"]}/reports`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resourceLinks": ["s"],
        "reportType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReportType>(x),
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listThingRegistrationTasks(
    {abortSignal, ...params}: RequestConfig & s.ListThingRegistrationTasksRequest = {},
  ): Promise<s.ListThingRegistrationTasksResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["status"] != null) query.set("status", params["status"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThingRegistrationTasks",
      method: "GET",
      requestUri: "/thing-registration-tasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskIds": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listThingTypes(
    {abortSignal, ...params}: RequestConfig & s.ListThingTypesRequest = {},
  ): Promise<s.ListThingTypesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["thingTypeName"] != null) query.set("thingTypeName", params["thingTypeName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThingTypes",
      method: "GET",
      requestUri: "/thing-types",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "thingTypes": [toThingTypeDefinition],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listThings(
    {abortSignal, ...params}: RequestConfig & s.ListThingsRequest = {},
  ): Promise<s.ListThingsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["attributeName"] != null) query.set("attributeName", params["attributeName"]?.toString() ?? "");
    if (params["attributeValue"] != null) query.set("attributeValue", params["attributeValue"]?.toString() ?? "");
    if (params["thingTypeName"] != null) query.set("thingTypeName", params["thingTypeName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThings",
      method: "GET",
      requestUri: "/things",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "things": [toThingAttribute],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listThingsInBillingGroup(
    {abortSignal, ...params}: RequestConfig & s.ListThingsInBillingGroupRequest,
  ): Promise<s.ListThingsInBillingGroupResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThingsInBillingGroup",
      method: "GET",
      requestUri: cmnP.encodePath`/billing-groups/${params["billingGroupName"]}/things`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "things": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listThingsInThingGroup(
    {abortSignal, ...params}: RequestConfig & s.ListThingsInThingGroupRequest,
  ): Promise<s.ListThingsInThingGroupResponse> {
    const query = new URLSearchParams;
    if (params["recursive"] != null) query.set("recursive", params["recursive"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListThingsInThingGroup",
      method: "GET",
      requestUri: cmnP.encodePath`/thing-groups/${params["thingGroupName"]}/things`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "things": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTopicRuleDestinations(
    {abortSignal, ...params}: RequestConfig & s.ListTopicRuleDestinationsRequest = {},
  ): Promise<s.ListTopicRuleDestinationsResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTopicRuleDestinations",
      method: "GET",
      requestUri: "/destinations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "destinationSummaries": [toTopicRuleDestinationSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTopicRules(
    {abortSignal, ...params}: RequestConfig & s.ListTopicRulesRequest = {},
  ): Promise<s.ListTopicRulesResponse> {
    const query = new URLSearchParams;
    if (params["topic"] != null) query.set("topic", params["topic"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["ruleDisabled"] != null) query.set("ruleDisabled", params["ruleDisabled"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTopicRules",
      method: "GET",
      requestUri: "/rules",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "rules": [toTopicRuleListItem],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listV2LoggingLevels(
    {abortSignal, ...params}: RequestConfig & s.ListV2LoggingLevelsRequest = {},
  ): Promise<s.ListV2LoggingLevelsResponse> {
    const query = new URLSearchParams;
    if (params["targetType"] != null) query.set("targetType", params["targetType"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListV2LoggingLevels",
      method: "GET",
      requestUri: "/v2LoggingLevel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "logTargetConfigurations": [toLogTargetConfiguration],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listViolationEvents(
    {abortSignal, ...params}: RequestConfig & s.ListViolationEventsRequest,
  ): Promise<s.ListViolationEventsResponse> {
    const query = new URLSearchParams;
    query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    if (params["thingName"] != null) query.set("thingName", params["thingName"]?.toString() ?? "");
    if (params["securityProfileName"] != null) query.set("securityProfileName", params["securityProfileName"]?.toString() ?? "");
    if (params["behaviorCriteriaType"] != null) query.set("behaviorCriteriaType", params["behaviorCriteriaType"]?.toString() ?? "");
    if (params["listSuppressedAlerts"] != null) query.set("listSuppressedAlerts", params["listSuppressedAlerts"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListViolationEvents",
      method: "GET",
      requestUri: "/violation-events",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "violationEvents": [toViolationEvent],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async registerCACertificate(
    {abortSignal, ...params}: RequestConfig & s.RegisterCACertificateRequest,
  ): Promise<s.RegisterCACertificateResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      caCertificate: params["caCertificate"],
      verificationCertificate: params["verificationCertificate"],
      registrationConfig: fromRegistrationConfig(params["registrationConfig"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    if (params["setAsActive"] != null) query.set("setAsActive", params["setAsActive"]?.toString() ?? "");
    if (params["allowAutoRegistration"] != null) query.set("allowAutoRegistration", params["allowAutoRegistration"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "RegisterCACertificate",
      requestUri: "/cacertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificateArn": "s",
        "certificateId": "s",
      },
    }, await resp.json());
  }

  async registerCertificate(
    {abortSignal, ...params}: RequestConfig & s.RegisterCertificateRequest,
  ): Promise<s.RegisterCertificateResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      certificatePem: params["certificatePem"],
      caCertificatePem: params["caCertificatePem"],
      status: params["status"],
    };
    if (params["setAsActive"] != null) query.set("setAsActive", params["setAsActive"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "RegisterCertificate",
      requestUri: "/certificate/register",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificateArn": "s",
        "certificateId": "s",
      },
    }, await resp.json());
  }

  async registerCertificateWithoutCA(
    {abortSignal, ...params}: RequestConfig & s.RegisterCertificateWithoutCARequest,
  ): Promise<s.RegisterCertificateWithoutCAResponse> {
    const body: jsonP.JSONObject = {
      certificatePem: params["certificatePem"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterCertificateWithoutCA",
      requestUri: "/certificate/register-no-ca",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificateArn": "s",
        "certificateId": "s",
      },
    }, await resp.json());
  }

  async registerThing(
    {abortSignal, ...params}: RequestConfig & s.RegisterThingRequest,
  ): Promise<s.RegisterThingResponse> {
    const body: jsonP.JSONObject = {
      templateBody: params["templateBody"],
      parameters: params["parameters"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterThing",
      requestUri: "/things",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificatePem": "s",
        "resourceArns": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async rejectCertificateTransfer(
    {abortSignal, ...params}: RequestConfig & s.RejectCertificateTransferRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      rejectReason: params["rejectReason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectCertificateTransfer",
      method: "PATCH",
      requestUri: cmnP.encodePath`/reject-certificate-transfer/${params["certificateId"]}`,
    });
  }

  async removeThingFromBillingGroup(
    {abortSignal, ...params}: RequestConfig & s.RemoveThingFromBillingGroupRequest = {},
  ): Promise<s.RemoveThingFromBillingGroupResponse> {
    const body: jsonP.JSONObject = {
      billingGroupName: params["billingGroupName"],
      billingGroupArn: params["billingGroupArn"],
      thingName: params["thingName"],
      thingArn: params["thingArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveThingFromBillingGroup",
      method: "PUT",
      requestUri: "/billing-groups/removeThingFromBillingGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeThingFromThingGroup(
    {abortSignal, ...params}: RequestConfig & s.RemoveThingFromThingGroupRequest = {},
  ): Promise<s.RemoveThingFromThingGroupResponse> {
    const body: jsonP.JSONObject = {
      thingGroupName: params["thingGroupName"],
      thingGroupArn: params["thingGroupArn"],
      thingName: params["thingName"],
      thingArn: params["thingArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveThingFromThingGroup",
      method: "PUT",
      requestUri: "/thing-groups/removeThingFromThingGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async replaceTopicRule(
    {abortSignal, ...params}: RequestConfig & s.ReplaceTopicRuleRequest,
  ): Promise<void> {
    const inner = params["topicRulePayload"];
    const body: jsonP.JSONObject = inner ? {
      sql: inner["sql"],
      description: inner["description"],
      actions: inner["actions"]?.map(x => fromAction(x)),
      ruleDisabled: inner["ruleDisabled"],
      awsIotSqlVersion: inner["awsIotSqlVersion"],
      errorAction: fromAction(inner["errorAction"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceTopicRule",
      method: "PATCH",
      requestUri: cmnP.encodePath`/rules/${params["ruleName"]}`,
    });
  }

  async searchIndex(
    {abortSignal, ...params}: RequestConfig & s.SearchIndexRequest,
  ): Promise<s.SearchIndexResponse> {
    const body: jsonP.JSONObject = {
      indexName: params["indexName"],
      queryString: params["queryString"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      queryVersion: params["queryVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchIndex",
      requestUri: "/indices/search",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "things": [toThingDocument],
        "thingGroups": [toThingGroupDocument],
      },
    }, await resp.json());
  }

  async setDefaultAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.SetDefaultAuthorizerRequest,
  ): Promise<s.SetDefaultAuthorizerResponse> {
    const body: jsonP.JSONObject = {
      authorizerName: params["authorizerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetDefaultAuthorizer",
      requestUri: "/default-authorizer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizerName": "s",
        "authorizerArn": "s",
      },
    }, await resp.json());
  }

  async setDefaultPolicyVersion(
    {abortSignal, ...params}: RequestConfig & s.SetDefaultPolicyVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "SetDefaultPolicyVersion",
      method: "PATCH",
      requestUri: cmnP.encodePath`/policies/${params["policyName"]}/version/${params["policyVersionId"]}`,
    });
  }

  async setLoggingOptions(
    {abortSignal, ...params}: RequestConfig & s.SetLoggingOptionsRequest,
  ): Promise<void> {
    const inner = params["loggingOptionsPayload"];
    const body: jsonP.JSONObject = inner ? {
      roleArn: inner["roleArn"],
      logLevel: inner["logLevel"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetLoggingOptions",
      requestUri: "/loggingOptions",
    });
  }

  async setV2LoggingLevel(
    {abortSignal, ...params}: RequestConfig & s.SetV2LoggingLevelRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logTarget: fromLogTarget(params["logTarget"]),
      logLevel: params["logLevel"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetV2LoggingLevel",
      requestUri: "/v2LoggingLevel",
    });
  }

  async setV2LoggingOptions(
    {abortSignal, ...params}: RequestConfig & s.SetV2LoggingOptionsRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      roleArn: params["roleArn"],
      defaultLogLevel: params["defaultLogLevel"],
      disableAllLogs: params["disableAllLogs"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetV2LoggingOptions",
      requestUri: "/v2LoggingOptions",
    });
  }

  async startAuditMitigationActionsTask(
    {abortSignal, ...params}: RequestConfig & s.StartAuditMitigationActionsTaskRequest,
  ): Promise<s.StartAuditMitigationActionsTaskResponse> {
    const body: jsonP.JSONObject = {
      target: fromAuditMitigationActionsTaskTarget(params["target"]),
      auditCheckToActionsMapping: params["auditCheckToActionsMapping"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartAuditMitigationActionsTask",
      requestUri: cmnP.encodePath`/audit/mitigationactions/tasks/${params["taskId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskId": "s",
      },
    }, await resp.json());
  }

  async startDetectMitigationActionsTask(
    {abortSignal, ...params}: RequestConfig & s.StartDetectMitigationActionsTaskRequest,
  ): Promise<s.StartDetectMitigationActionsTaskResponse> {
    const body: jsonP.JSONObject = {
      target: fromDetectMitigationActionsTaskTarget(params["target"]),
      actions: params["actions"],
      violationEventOccurrenceRange: fromViolationEventOccurrenceRange(params["violationEventOccurrenceRange"]),
      includeOnlyActiveViolations: params["includeOnlyActiveViolations"],
      includeSuppressedAlerts: params["includeSuppressedAlerts"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDetectMitigationActionsTask",
      method: "PUT",
      requestUri: cmnP.encodePath`/detect/mitigationactions/tasks/${params["taskId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskId": "s",
      },
    }, await resp.json());
  }

  async startOnDemandAuditTask(
    {abortSignal, ...params}: RequestConfig & s.StartOnDemandAuditTaskRequest,
  ): Promise<s.StartOnDemandAuditTaskResponse> {
    const body: jsonP.JSONObject = {
      targetCheckNames: params["targetCheckNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartOnDemandAuditTask",
      requestUri: "/audit/tasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskId": "s",
      },
    }, await resp.json());
  }

  async startThingRegistrationTask(
    {abortSignal, ...params}: RequestConfig & s.StartThingRegistrationTaskRequest,
  ): Promise<s.StartThingRegistrationTaskResponse> {
    const body: jsonP.JSONObject = {
      templateBody: params["templateBody"],
      inputFileBucket: params["inputFileBucket"],
      inputFileKey: params["inputFileKey"],
      roleArn: params["roleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartThingRegistrationTask",
      requestUri: "/thing-registration-tasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskId": "s",
      },
    }, await resp.json());
  }

  async stopThingRegistrationTask(
    {abortSignal, ...params}: RequestConfig & s.StopThingRegistrationTaskRequest,
  ): Promise<s.StopThingRegistrationTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StopThingRegistrationTask",
      method: "PUT",
      requestUri: cmnP.encodePath`/thing-registration-tasks/${params["taskId"]}/cancel`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: "/tags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async testAuthorization(
    {abortSignal, ...params}: RequestConfig & s.TestAuthorizationRequest,
  ): Promise<s.TestAuthorizationResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      principal: params["principal"],
      cognitoIdentityPoolId: params["cognitoIdentityPoolId"],
      authInfos: params["authInfos"]?.map(x => fromAuthInfo(x)),
      policyNamesToAdd: params["policyNamesToAdd"],
      policyNamesToSkip: params["policyNamesToSkip"],
    };
    if (params["clientId"] != null) query.set("clientId", params["clientId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TestAuthorization",
      requestUri: "/test-authorization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authResults": [toAuthResult],
      },
    }, await resp.json());
  }

  async testInvokeAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.TestInvokeAuthorizerRequest,
  ): Promise<s.TestInvokeAuthorizerResponse> {
    const body: jsonP.JSONObject = {
      token: params["token"],
      tokenSignature: params["tokenSignature"],
      httpContext: fromHttpContext(params["httpContext"]),
      mqttContext: fromMqttContext(params["mqttContext"]),
      tlsContext: fromTlsContext(params["tlsContext"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestInvokeAuthorizer",
      requestUri: cmnP.encodePath`/authorizer/${params["authorizerName"]}/test`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "isAuthenticated": "b",
        "principalId": "s",
        "policyDocuments": ["s"],
        "refreshAfterInSeconds": "n",
        "disconnectAfterInSeconds": "n",
      },
    }, await resp.json());
  }

  async transferCertificate(
    {abortSignal, ...params}: RequestConfig & s.TransferCertificateRequest,
  ): Promise<s.TransferCertificateResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      transferMessage: params["transferMessage"],
    };
    query.set("targetAwsAccount", params["targetAwsAccount"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TransferCertificate",
      method: "PATCH",
      requestUri: cmnP.encodePath`/transfer-certificate/${params["certificateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "transferredCertificateArn": "s",
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
      requestUri: "/untag",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateAccountAuditConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateAccountAuditConfigurationRequest = {},
  ): Promise<s.UpdateAccountAuditConfigurationResponse> {
    const body: jsonP.JSONObject = {
      roleArn: params["roleArn"],
      auditNotificationTargetConfigurations: jsonP.serializeMap(params["auditNotificationTargetConfigurations"], x => fromAuditNotificationTarget(x)),
      auditCheckConfigurations: jsonP.serializeMap(params["auditCheckConfigurations"], x => fromAuditCheckConfiguration(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccountAuditConfiguration",
      method: "PATCH",
      requestUri: "/audit/configuration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateAuditSuppression(
    {abortSignal, ...params}: RequestConfig & s.UpdateAuditSuppressionRequest,
  ): Promise<s.UpdateAuditSuppressionResponse> {
    const body: jsonP.JSONObject = {
      checkName: params["checkName"],
      resourceIdentifier: fromResourceIdentifier(params["resourceIdentifier"]),
      expirationDate: jsonP.serializeDate_unixTimestamp(params["expirationDate"]),
      suppressIndefinitely: params["suppressIndefinitely"],
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAuditSuppression",
      method: "PATCH",
      requestUri: "/audit/suppressions/update",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.UpdateAuthorizerRequest,
  ): Promise<s.UpdateAuthorizerResponse> {
    const body: jsonP.JSONObject = {
      authorizerFunctionArn: params["authorizerFunctionArn"],
      tokenKeyName: params["tokenKeyName"],
      tokenSigningPublicKeys: params["tokenSigningPublicKeys"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAuthorizer",
      method: "PUT",
      requestUri: cmnP.encodePath`/authorizer/${params["authorizerName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizerName": "s",
        "authorizerArn": "s",
      },
    }, await resp.json());
  }

  async updateBillingGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateBillingGroupRequest,
  ): Promise<s.UpdateBillingGroupResponse> {
    const body: jsonP.JSONObject = {
      billingGroupProperties: fromBillingGroupProperties(params["billingGroupProperties"]),
      expectedVersion: params["expectedVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBillingGroup",
      method: "PATCH",
      requestUri: cmnP.encodePath`/billing-groups/${params["billingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "version": "n",
      },
    }, await resp.json());
  }

  async updateCACertificate(
    {abortSignal, ...params}: RequestConfig & s.UpdateCACertificateRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      registrationConfig: fromRegistrationConfig(params["registrationConfig"]),
      removeAutoRegistration: params["removeAutoRegistration"],
    };
    if (params["newStatus"] != null) query.set("newStatus", params["newStatus"]?.toString() ?? "");
    if (params["newAutoRegistrationStatus"] != null) query.set("newAutoRegistrationStatus", params["newAutoRegistrationStatus"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateCACertificate",
      method: "PUT",
      requestUri: cmnP.encodePath`/cacertificate/${params["certificateId"]}`,
    });
  }

  async updateCertificate(
    {abortSignal, ...params}: RequestConfig & s.UpdateCertificateRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    query.set("newStatus", params["newStatus"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UpdateCertificate",
      method: "PUT",
      requestUri: cmnP.encodePath`/certificates/${params["certificateId"]}`,
    });
  }

  async updateCustomMetric(
    {abortSignal, ...params}: RequestConfig & s.UpdateCustomMetricRequest,
  ): Promise<s.UpdateCustomMetricResponse> {
    const body: jsonP.JSONObject = {
      displayName: params["displayName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCustomMetric",
      method: "PATCH",
      requestUri: cmnP.encodePath`/custom-metric/${params["metricName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricName": "s",
        "metricArn": "s",
        "metricType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CustomMetricType>(x),
        "displayName": "s",
        "creationDate": "d",
        "lastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async updateDimension(
    {abortSignal, ...params}: RequestConfig & s.UpdateDimensionRequest,
  ): Promise<s.UpdateDimensionResponse> {
    const body: jsonP.JSONObject = {
      stringValues: params["stringValues"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDimension",
      method: "PATCH",
      requestUri: cmnP.encodePath`/dimensions/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "arn": "s",
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DimensionType>(x),
        "stringValues": ["s"],
        "creationDate": "d",
        "lastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async updateDomainConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateDomainConfigurationRequest,
  ): Promise<s.UpdateDomainConfigurationResponse> {
    const body: jsonP.JSONObject = {
      authorizerConfig: fromAuthorizerConfig(params["authorizerConfig"]),
      domainConfigurationStatus: params["domainConfigurationStatus"],
      removeAuthorizerConfig: params["removeAuthorizerConfig"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDomainConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/domainConfigurations/${params["domainConfigurationName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainConfigurationName": "s",
        "domainConfigurationArn": "s",
      },
    }, await resp.json());
  }

  async updateDynamicThingGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateDynamicThingGroupRequest,
  ): Promise<s.UpdateDynamicThingGroupResponse> {
    const body: jsonP.JSONObject = {
      thingGroupProperties: fromThingGroupProperties(params["thingGroupProperties"]),
      expectedVersion: params["expectedVersion"],
      indexName: params["indexName"],
      queryString: params["queryString"],
      queryVersion: params["queryVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDynamicThingGroup",
      method: "PATCH",
      requestUri: cmnP.encodePath`/dynamic-thing-groups/${params["thingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "version": "n",
      },
    }, await resp.json());
  }

  async updateEventConfigurations(
    {abortSignal, ...params}: RequestConfig & s.UpdateEventConfigurationsRequest = {},
  ): Promise<s.UpdateEventConfigurationsResponse> {
    const body: jsonP.JSONObject = {
      eventConfigurations: jsonP.serializeMap(params["eventConfigurations"], x => fromConfiguration(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEventConfigurations",
      method: "PATCH",
      requestUri: "/event-configurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateIndexingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateIndexingConfigurationRequest = {},
  ): Promise<s.UpdateIndexingConfigurationResponse> {
    const body: jsonP.JSONObject = {
      thingIndexingConfiguration: fromThingIndexingConfiguration(params["thingIndexingConfiguration"]),
      thingGroupIndexingConfiguration: fromThingGroupIndexingConfiguration(params["thingGroupIndexingConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIndexingConfiguration",
      requestUri: "/indexing/config",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateJob(
    {abortSignal, ...params}: RequestConfig & s.UpdateJobRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      description: params["description"],
      presignedUrlConfig: fromPresignedUrlConfig(params["presignedUrlConfig"]),
      jobExecutionsRolloutConfig: fromJobExecutionsRolloutConfig(params["jobExecutionsRolloutConfig"]),
      abortConfig: fromAbortConfig(params["abortConfig"]),
      timeoutConfig: fromTimeoutConfig(params["timeoutConfig"]),
    };
    if (params["namespaceId"] != null) query.set("namespaceId", params["namespaceId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateJob",
      method: "PATCH",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}`,
    });
  }

  async updateMitigationAction(
    {abortSignal, ...params}: RequestConfig & s.UpdateMitigationActionRequest,
  ): Promise<s.UpdateMitigationActionResponse> {
    const body: jsonP.JSONObject = {
      roleArn: params["roleArn"],
      actionParams: fromMitigationActionParams(params["actionParams"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMitigationAction",
      method: "PATCH",
      requestUri: cmnP.encodePath`/mitigationactions/actions/${params["actionName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "actionArn": "s",
        "actionId": "s",
      },
    }, await resp.json());
  }

  async updateProvisioningTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateProvisioningTemplateRequest,
  ): Promise<s.UpdateProvisioningTemplateResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      enabled: params["enabled"],
      defaultVersionId: params["defaultVersionId"],
      provisioningRoleArn: params["provisioningRoleArn"],
      preProvisioningHook: fromProvisioningHook(params["preProvisioningHook"]),
      removePreProvisioningHook: params["removePreProvisioningHook"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateProvisioningTemplate",
      method: "PATCH",
      requestUri: cmnP.encodePath`/provisioning-templates/${params["templateName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateRoleAlias(
    {abortSignal, ...params}: RequestConfig & s.UpdateRoleAliasRequest,
  ): Promise<s.UpdateRoleAliasResponse> {
    const body: jsonP.JSONObject = {
      roleArn: params["roleArn"],
      credentialDurationSeconds: params["credentialDurationSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRoleAlias",
      method: "PUT",
      requestUri: cmnP.encodePath`/role-aliases/${params["roleAlias"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "roleAlias": "s",
        "roleAliasArn": "s",
      },
    }, await resp.json());
  }

  async updateScheduledAudit(
    {abortSignal, ...params}: RequestConfig & s.UpdateScheduledAuditRequest,
  ): Promise<s.UpdateScheduledAuditResponse> {
    const body: jsonP.JSONObject = {
      frequency: params["frequency"],
      dayOfMonth: params["dayOfMonth"],
      dayOfWeek: params["dayOfWeek"],
      targetCheckNames: params["targetCheckNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateScheduledAudit",
      method: "PATCH",
      requestUri: cmnP.encodePath`/audit/scheduledaudits/${params["scheduledAuditName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "scheduledAuditArn": "s",
      },
    }, await resp.json());
  }

  async updateSecurityProfile(
    {abortSignal, ...params}: RequestConfig & s.UpdateSecurityProfileRequest,
  ): Promise<s.UpdateSecurityProfileResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      securityProfileDescription: params["securityProfileDescription"],
      behaviors: params["behaviors"]?.map(x => fromBehavior(x)),
      alertTargets: jsonP.serializeMap(params["alertTargets"], x => fromAlertTarget(x)),
      additionalMetricsToRetain: params["additionalMetricsToRetain"],
      additionalMetricsToRetainV2: params["additionalMetricsToRetainV2"]?.map(x => fromMetricToRetain(x)),
      deleteBehaviors: params["deleteBehaviors"],
      deleteAlertTargets: params["deleteAlertTargets"],
      deleteAdditionalMetricsToRetain: params["deleteAdditionalMetricsToRetain"],
    };
    if (params["expectedVersion"] != null) query.set("expectedVersion", params["expectedVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateSecurityProfile",
      method: "PATCH",
      requestUri: cmnP.encodePath`/security-profiles/${params["securityProfileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "securityProfileName": "s",
        "securityProfileArn": "s",
        "securityProfileDescription": "s",
        "behaviors": [toBehavior],
        "alertTargets": x => jsonP.readMap(x => cmnP.readEnumReq<s.AlertTargetType>(x), toAlertTarget, x),
        "additionalMetricsToRetain": ["s"],
        "additionalMetricsToRetainV2": [toMetricToRetain],
        "version": "n",
        "creationDate": "d",
        "lastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async updateStream(
    {abortSignal, ...params}: RequestConfig & s.UpdateStreamRequest,
  ): Promise<s.UpdateStreamResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      files: params["files"]?.map(x => fromStreamFile(x)),
      roleArn: params["roleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStream",
      method: "PUT",
      requestUri: cmnP.encodePath`/streams/${params["streamId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streamId": "s",
        "streamArn": "s",
        "description": "s",
        "streamVersion": "n",
      },
    }, await resp.json());
  }

  async updateThing(
    {abortSignal, ...params}: RequestConfig & s.UpdateThingRequest,
  ): Promise<s.UpdateThingResponse> {
    const body: jsonP.JSONObject = {
      thingTypeName: params["thingTypeName"],
      attributePayload: fromAttributePayload(params["attributePayload"]),
      expectedVersion: params["expectedVersion"],
      removeThingType: params["removeThingType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateThing",
      method: "PATCH",
      requestUri: cmnP.encodePath`/things/${params["thingName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateThingGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateThingGroupRequest,
  ): Promise<s.UpdateThingGroupResponse> {
    const body: jsonP.JSONObject = {
      thingGroupProperties: fromThingGroupProperties(params["thingGroupProperties"]),
      expectedVersion: params["expectedVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateThingGroup",
      method: "PATCH",
      requestUri: cmnP.encodePath`/thing-groups/${params["thingGroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "version": "n",
      },
    }, await resp.json());
  }

  async updateThingGroupsForThing(
    {abortSignal, ...params}: RequestConfig & s.UpdateThingGroupsForThingRequest = {},
  ): Promise<s.UpdateThingGroupsForThingResponse> {
    const body: jsonP.JSONObject = {
      thingName: params["thingName"],
      thingGroupsToAdd: params["thingGroupsToAdd"],
      thingGroupsToRemove: params["thingGroupsToRemove"],
      overrideDynamicGroups: params["overrideDynamicGroups"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateThingGroupsForThing",
      method: "PUT",
      requestUri: "/thing-groups/updateThingGroupsForThing",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateTopicRuleDestination(
    {abortSignal, ...params}: RequestConfig & s.UpdateTopicRuleDestinationRequest,
  ): Promise<s.UpdateTopicRuleDestinationResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTopicRuleDestination",
      method: "PATCH",
      requestUri: "/destinations",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async validateSecurityProfileBehaviors(
    {abortSignal, ...params}: RequestConfig & s.ValidateSecurityProfileBehaviorsRequest,
  ): Promise<s.ValidateSecurityProfileBehaviorsResponse> {
    const body: jsonP.JSONObject = {
      behaviors: params["behaviors"]?.map(x => fromBehavior(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ValidateSecurityProfileBehaviors",
      requestUri: "/security-profile-behaviors/validate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "valid": "b",
        "validationErrors": [toValidationError],
      },
    }, await resp.json());
  }

}

function fromResourceIdentifier(input?: s.ResourceIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deviceCertificateId: input["deviceCertificateId"],
    caCertificateId: input["caCertificateId"],
    cognitoIdentityPoolId: input["cognitoIdentityPoolId"],
    clientId: input["clientId"],
    policyVersionIdentifier: fromPolicyVersionIdentifier(input["policyVersionIdentifier"]),
    account: input["account"],
    iamRoleArn: input["iamRoleArn"],
    roleAliasArn: input["roleAliasArn"],
  }
}
function toResourceIdentifier(root: jsonP.JSONValue): s.ResourceIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "deviceCertificateId": "s",
      "caCertificateId": "s",
      "cognitoIdentityPoolId": "s",
      "clientId": "s",
      "policyVersionIdentifier": toPolicyVersionIdentifier,
      "account": "s",
      "iamRoleArn": "s",
      "roleAliasArn": "s",
    },
  }, root);
}

function fromPolicyVersionIdentifier(input?: s.PolicyVersionIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    policyName: input["policyName"],
    policyVersionId: input["policyVersionId"],
  }
}
function toPolicyVersionIdentifier(root: jsonP.JSONValue): s.PolicyVersionIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "policyName": "s",
      "policyVersionId": "s",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

function fromBillingGroupProperties(input?: s.BillingGroupProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    billingGroupDescription: input["billingGroupDescription"],
  }
}
function toBillingGroupProperties(root: jsonP.JSONValue): s.BillingGroupProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "billingGroupDescription": "s",
    },
  }, root);
}

function fromAuthorizerConfig(input?: s.AuthorizerConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    defaultAuthorizerName: input["defaultAuthorizerName"],
    allowAuthorizerOverride: input["allowAuthorizerOverride"],
  }
}
function toAuthorizerConfig(root: jsonP.JSONValue): s.AuthorizerConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "defaultAuthorizerName": "s",
      "allowAuthorizerOverride": "b",
    },
  }, root);
}

function fromThingGroupProperties(input?: s.ThingGroupProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    thingGroupDescription: input["thingGroupDescription"],
    attributePayload: fromAttributePayload(input["attributePayload"]),
  }
}
function toThingGroupProperties(root: jsonP.JSONValue): s.ThingGroupProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "thingGroupDescription": "s",
      "attributePayload": toAttributePayload,
    },
  }, root);
}

function fromAttributePayload(input?: s.AttributePayload | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attributes: input["attributes"],
    merge: input["merge"],
  }
}
function toAttributePayload(root: jsonP.JSONValue): s.AttributePayload {
  return jsonP.readObj({
    required: {},
    optional: {
      "attributes": x => jsonP.readMap(String, String, x),
      "merge": "b",
    },
  }, root);
}

function fromPresignedUrlConfig(input?: s.PresignedUrlConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    expiresInSec: input["expiresInSec"],
  }
}
function toPresignedUrlConfig(root: jsonP.JSONValue): s.PresignedUrlConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "roleArn": "s",
      "expiresInSec": "n",
    },
  }, root);
}

function fromJobExecutionsRolloutConfig(input?: s.JobExecutionsRolloutConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maximumPerMinute: input["maximumPerMinute"],
    exponentialRate: fromExponentialRolloutRate(input["exponentialRate"]),
  }
}
function toJobExecutionsRolloutConfig(root: jsonP.JSONValue): s.JobExecutionsRolloutConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "maximumPerMinute": "n",
      "exponentialRate": toExponentialRolloutRate,
    },
  }, root);
}

function fromExponentialRolloutRate(input?: s.ExponentialRolloutRate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    baseRatePerMinute: input["baseRatePerMinute"],
    incrementFactor: input["incrementFactor"],
    rateIncreaseCriteria: fromRateIncreaseCriteria(input["rateIncreaseCriteria"]),
  }
}
function toExponentialRolloutRate(root: jsonP.JSONValue): s.ExponentialRolloutRate {
  return jsonP.readObj({
    required: {
      "baseRatePerMinute": "n",
      "incrementFactor": "n",
      "rateIncreaseCriteria": toRateIncreaseCriteria,
    },
    optional: {},
  }, root);
}

function fromRateIncreaseCriteria(input?: s.RateIncreaseCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    numberOfNotifiedThings: input["numberOfNotifiedThings"],
    numberOfSucceededThings: input["numberOfSucceededThings"],
  }
}
function toRateIncreaseCriteria(root: jsonP.JSONValue): s.RateIncreaseCriteria {
  return jsonP.readObj({
    required: {},
    optional: {
      "numberOfNotifiedThings": "n",
      "numberOfSucceededThings": "n",
    },
  }, root);
}

function fromAbortConfig(input?: s.AbortConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    criteriaList: input["criteriaList"]?.map(x => fromAbortCriteria(x)),
  }
}
function toAbortConfig(root: jsonP.JSONValue): s.AbortConfig {
  return jsonP.readObj({
    required: {
      "criteriaList": [toAbortCriteria],
    },
    optional: {},
  }, root);
}

function fromAbortCriteria(input?: s.AbortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    failureType: input["failureType"],
    action: input["action"],
    thresholdPercentage: input["thresholdPercentage"],
    minNumberOfExecutedThings: input["minNumberOfExecutedThings"],
  }
}
function toAbortCriteria(root: jsonP.JSONValue): s.AbortCriteria {
  return jsonP.readObj({
    required: {
      "failureType": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobExecutionFailureType>(x),
      "action": (x: jsonP.JSONValue) => cmnP.readEnum<s.AbortAction>(x),
      "thresholdPercentage": "n",
      "minNumberOfExecutedThings": "n",
    },
    optional: {},
  }, root);
}

function fromTimeoutConfig(input?: s.TimeoutConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inProgressTimeoutInMinutes: input["inProgressTimeoutInMinutes"],
  }
}
function toTimeoutConfig(root: jsonP.JSONValue): s.TimeoutConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "inProgressTimeoutInMinutes": "n",
    },
  }, root);
}

function fromMitigationActionParams(input?: s.MitigationActionParams | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    updateDeviceCertificateParams: fromUpdateDeviceCertificateParams(input["updateDeviceCertificateParams"]),
    updateCACertificateParams: fromUpdateCACertificateParams(input["updateCACertificateParams"]),
    addThingsToThingGroupParams: fromAddThingsToThingGroupParams(input["addThingsToThingGroupParams"]),
    replaceDefaultPolicyVersionParams: fromReplaceDefaultPolicyVersionParams(input["replaceDefaultPolicyVersionParams"]),
    enableIoTLoggingParams: fromEnableIoTLoggingParams(input["enableIoTLoggingParams"]),
    publishFindingToSnsParams: fromPublishFindingToSnsParams(input["publishFindingToSnsParams"]),
  }
}
function toMitigationActionParams(root: jsonP.JSONValue): s.MitigationActionParams {
  return jsonP.readObj({
    required: {},
    optional: {
      "updateDeviceCertificateParams": toUpdateDeviceCertificateParams,
      "updateCACertificateParams": toUpdateCACertificateParams,
      "addThingsToThingGroupParams": toAddThingsToThingGroupParams,
      "replaceDefaultPolicyVersionParams": toReplaceDefaultPolicyVersionParams,
      "enableIoTLoggingParams": toEnableIoTLoggingParams,
      "publishFindingToSnsParams": toPublishFindingToSnsParams,
    },
  }, root);
}

function fromUpdateDeviceCertificateParams(input?: s.UpdateDeviceCertificateParams | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: input["action"],
  }
}
function toUpdateDeviceCertificateParams(root: jsonP.JSONValue): s.UpdateDeviceCertificateParams {
  return jsonP.readObj({
    required: {
      "action": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceCertificateUpdateAction>(x),
    },
    optional: {},
  }, root);
}

function fromUpdateCACertificateParams(input?: s.UpdateCACertificateParams | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: input["action"],
  }
}
function toUpdateCACertificateParams(root: jsonP.JSONValue): s.UpdateCACertificateParams {
  return jsonP.readObj({
    required: {
      "action": (x: jsonP.JSONValue) => cmnP.readEnum<s.CACertificateUpdateAction>(x),
    },
    optional: {},
  }, root);
}

function fromAddThingsToThingGroupParams(input?: s.AddThingsToThingGroupParams | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    thingGroupNames: input["thingGroupNames"],
    overrideDynamicGroups: input["overrideDynamicGroups"],
  }
}
function toAddThingsToThingGroupParams(root: jsonP.JSONValue): s.AddThingsToThingGroupParams {
  return jsonP.readObj({
    required: {
      "thingGroupNames": ["s"],
    },
    optional: {
      "overrideDynamicGroups": "b",
    },
  }, root);
}

function fromReplaceDefaultPolicyVersionParams(input?: s.ReplaceDefaultPolicyVersionParams | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    templateName: input["templateName"],
  }
}
function toReplaceDefaultPolicyVersionParams(root: jsonP.JSONValue): s.ReplaceDefaultPolicyVersionParams {
  return jsonP.readObj({
    required: {
      "templateName": (x: jsonP.JSONValue) => cmnP.readEnum<s.PolicyTemplateName>(x),
    },
    optional: {},
  }, root);
}

function fromEnableIoTLoggingParams(input?: s.EnableIoTLoggingParams | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArnForLogging: input["roleArnForLogging"],
    logLevel: input["logLevel"],
  }
}
function toEnableIoTLoggingParams(root: jsonP.JSONValue): s.EnableIoTLoggingParams {
  return jsonP.readObj({
    required: {
      "roleArnForLogging": "s",
      "logLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
    },
    optional: {},
  }, root);
}

function fromPublishFindingToSnsParams(input?: s.PublishFindingToSnsParams | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    topicArn: input["topicArn"],
  }
}
function toPublishFindingToSnsParams(root: jsonP.JSONValue): s.PublishFindingToSnsParams {
  return jsonP.readObj({
    required: {
      "topicArn": "s",
    },
    optional: {},
  }, root);
}

function fromAwsJobExecutionsRolloutConfig(input?: s.AwsJobExecutionsRolloutConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maximumPerMinute: input["maximumPerMinute"],
    exponentialRate: fromAwsJobExponentialRolloutRate(input["exponentialRate"]),
  }
}
function toAwsJobExecutionsRolloutConfig(root: jsonP.JSONValue): s.AwsJobExecutionsRolloutConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "maximumPerMinute": "n",
      "exponentialRate": toAwsJobExponentialRolloutRate,
    },
  }, root);
}

function fromAwsJobExponentialRolloutRate(input?: s.AwsJobExponentialRolloutRate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    baseRatePerMinute: input["baseRatePerMinute"],
    incrementFactor: input["incrementFactor"],
    rateIncreaseCriteria: fromAwsJobRateIncreaseCriteria(input["rateIncreaseCriteria"]),
  }
}
function toAwsJobExponentialRolloutRate(root: jsonP.JSONValue): s.AwsJobExponentialRolloutRate {
  return jsonP.readObj({
    required: {
      "baseRatePerMinute": "n",
      "incrementFactor": "n",
      "rateIncreaseCriteria": toAwsJobRateIncreaseCriteria,
    },
    optional: {},
  }, root);
}

function fromAwsJobRateIncreaseCriteria(input?: s.AwsJobRateIncreaseCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    numberOfNotifiedThings: input["numberOfNotifiedThings"],
    numberOfSucceededThings: input["numberOfSucceededThings"],
  }
}
function toAwsJobRateIncreaseCriteria(root: jsonP.JSONValue): s.AwsJobRateIncreaseCriteria {
  return jsonP.readObj({
    required: {},
    optional: {
      "numberOfNotifiedThings": "n",
      "numberOfSucceededThings": "n",
    },
  }, root);
}

function fromAwsJobPresignedUrlConfig(input?: s.AwsJobPresignedUrlConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    expiresInSec: input["expiresInSec"],
  }
}
function toAwsJobPresignedUrlConfig(root: jsonP.JSONValue): s.AwsJobPresignedUrlConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "expiresInSec": "n",
    },
  }, root);
}

function fromAwsJobAbortConfig(input?: s.AwsJobAbortConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    abortCriteriaList: input["abortCriteriaList"]?.map(x => fromAwsJobAbortCriteria(x)),
  }
}

function fromAwsJobAbortCriteria(input?: s.AwsJobAbortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    failureType: input["failureType"],
    action: input["action"],
    thresholdPercentage: input["thresholdPercentage"],
    minNumberOfExecutedThings: input["minNumberOfExecutedThings"],
  }
}

function fromAwsJobTimeoutConfig(input?: s.AwsJobTimeoutConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inProgressTimeoutInMinutes: input["inProgressTimeoutInMinutes"],
  }
}

function fromOTAUpdateFile(input?: s.OTAUpdateFile | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fileName: input["fileName"],
    fileType: input["fileType"],
    fileVersion: input["fileVersion"],
    fileLocation: fromFileLocation(input["fileLocation"]),
    codeSigning: fromCodeSigning(input["codeSigning"]),
    attributes: input["attributes"],
  }
}
function toOTAUpdateFile(root: jsonP.JSONValue): s.OTAUpdateFile {
  return jsonP.readObj({
    required: {},
    optional: {
      "fileName": "s",
      "fileType": "n",
      "fileVersion": "s",
      "fileLocation": toFileLocation,
      "codeSigning": toCodeSigning,
      "attributes": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromFileLocation(input?: s.FileLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    stream: fromStream(input["stream"]),
    s3Location: fromS3Location(input["s3Location"]),
  }
}
function toFileLocation(root: jsonP.JSONValue): s.FileLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "stream": toStream,
      "s3Location": toS3Location,
    },
  }, root);
}

function fromStream(input?: s.Stream | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    streamId: input["streamId"],
    fileId: input["fileId"],
  }
}
function toStream(root: jsonP.JSONValue): s.Stream {
  return jsonP.readObj({
    required: {},
    optional: {
      "streamId": "s",
      "fileId": "n",
    },
  }, root);
}

function fromS3Location(input?: s.S3Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    key: input["key"],
    version: input["version"],
  }
}
function toS3Location(root: jsonP.JSONValue): s.S3Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "key": "s",
      "version": "s",
    },
  }, root);
}

function fromCodeSigning(input?: s.CodeSigning | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    awsSignerJobId: input["awsSignerJobId"],
    startSigningJobParameter: fromStartSigningJobParameter(input["startSigningJobParameter"]),
    customCodeSigning: fromCustomCodeSigning(input["customCodeSigning"]),
  }
}
function toCodeSigning(root: jsonP.JSONValue): s.CodeSigning {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsSignerJobId": "s",
      "startSigningJobParameter": toStartSigningJobParameter,
      "customCodeSigning": toCustomCodeSigning,
    },
  }, root);
}

function fromStartSigningJobParameter(input?: s.StartSigningJobParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    signingProfileParameter: fromSigningProfileParameter(input["signingProfileParameter"]),
    signingProfileName: input["signingProfileName"],
    destination: fromDestination(input["destination"]),
  }
}
function toStartSigningJobParameter(root: jsonP.JSONValue): s.StartSigningJobParameter {
  return jsonP.readObj({
    required: {},
    optional: {
      "signingProfileParameter": toSigningProfileParameter,
      "signingProfileName": "s",
      "destination": toDestination,
    },
  }, root);
}

function fromSigningProfileParameter(input?: s.SigningProfileParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["certificateArn"],
    platform: input["platform"],
    certificatePathOnDevice: input["certificatePathOnDevice"],
  }
}
function toSigningProfileParameter(root: jsonP.JSONValue): s.SigningProfileParameter {
  return jsonP.readObj({
    required: {},
    optional: {
      "certificateArn": "s",
      "platform": "s",
      "certificatePathOnDevice": "s",
    },
  }, root);
}

function fromDestination(input?: s.Destination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Destination: fromS3Destination(input["s3Destination"]),
  }
}
function toDestination(root: jsonP.JSONValue): s.Destination {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3Destination": toS3Destination,
    },
  }, root);
}

function fromS3Destination(input?: s.S3Destination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    prefix: input["prefix"],
  }
}
function toS3Destination(root: jsonP.JSONValue): s.S3Destination {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "prefix": "s",
    },
  }, root);
}

function fromCustomCodeSigning(input?: s.CustomCodeSigning | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    signature: fromCodeSigningSignature(input["signature"]),
    certificateChain: fromCodeSigningCertificateChain(input["certificateChain"]),
    hashAlgorithm: input["hashAlgorithm"],
    signatureAlgorithm: input["signatureAlgorithm"],
  }
}
function toCustomCodeSigning(root: jsonP.JSONValue): s.CustomCodeSigning {
  return jsonP.readObj({
    required: {},
    optional: {
      "signature": toCodeSigningSignature,
      "certificateChain": toCodeSigningCertificateChain,
      "hashAlgorithm": "s",
      "signatureAlgorithm": "s",
    },
  }, root);
}

function fromCodeSigningSignature(input?: s.CodeSigningSignature | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inlineDocument: serializeBlob(input["inlineDocument"]),
  }
}
function toCodeSigningSignature(root: jsonP.JSONValue): s.CodeSigningSignature {
  return jsonP.readObj({
    required: {},
    optional: {
      "inlineDocument": "a",
    },
  }, root);
}

function fromCodeSigningCertificateChain(input?: s.CodeSigningCertificateChain | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateName: input["certificateName"],
    inlineDocument: input["inlineDocument"],
  }
}
function toCodeSigningCertificateChain(root: jsonP.JSONValue): s.CodeSigningCertificateChain {
  return jsonP.readObj({
    required: {},
    optional: {
      "certificateName": "s",
      "inlineDocument": "s",
    },
  }, root);
}

function fromProvisioningHook(input?: s.ProvisioningHook | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    payloadVersion: input["payloadVersion"],
    targetArn: input["targetArn"],
  }
}
function toProvisioningHook(root: jsonP.JSONValue): s.ProvisioningHook {
  return jsonP.readObj({
    required: {
      "targetArn": "s",
    },
    optional: {
      "payloadVersion": "s",
    },
  }, root);
}

function fromBehavior(input?: s.Behavior | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    metric: input["metric"],
    metricDimension: fromMetricDimension(input["metricDimension"]),
    criteria: fromBehaviorCriteria(input["criteria"]),
    suppressAlerts: input["suppressAlerts"],
  }
}
function toBehavior(root: jsonP.JSONValue): s.Behavior {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "metric": "s",
      "metricDimension": toMetricDimension,
      "criteria": toBehaviorCriteria,
      "suppressAlerts": "b",
    },
  }, root);
}

function fromMetricDimension(input?: s.MetricDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dimensionName: input["dimensionName"],
    operator: input["operator"],
  }
}
function toMetricDimension(root: jsonP.JSONValue): s.MetricDimension {
  return jsonP.readObj({
    required: {
      "dimensionName": "s",
    },
    optional: {
      "operator": (x: jsonP.JSONValue) => cmnP.readEnum<s.DimensionValueOperator>(x),
    },
  }, root);
}

function fromBehaviorCriteria(input?: s.BehaviorCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    comparisonOperator: input["comparisonOperator"],
    value: fromMetricValue(input["value"]),
    durationSeconds: input["durationSeconds"],
    consecutiveDatapointsToAlarm: input["consecutiveDatapointsToAlarm"],
    consecutiveDatapointsToClear: input["consecutiveDatapointsToClear"],
    statisticalThreshold: fromStatisticalThreshold(input["statisticalThreshold"]),
    mlDetectionConfig: fromMachineLearningDetectionConfig(input["mlDetectionConfig"]),
  }
}
function toBehaviorCriteria(root: jsonP.JSONValue): s.BehaviorCriteria {
  return jsonP.readObj({
    required: {},
    optional: {
      "comparisonOperator": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComparisonOperator>(x),
      "value": toMetricValue,
      "durationSeconds": "n",
      "consecutiveDatapointsToAlarm": "n",
      "consecutiveDatapointsToClear": "n",
      "statisticalThreshold": toStatisticalThreshold,
      "mlDetectionConfig": toMachineLearningDetectionConfig,
    },
  }, root);
}

function fromMetricValue(input?: s.MetricValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    count: input["count"],
    cidrs: input["cidrs"],
    ports: input["ports"],
    number: input["number"],
    numbers: input["numbers"],
    strings: input["strings"],
  }
}
function toMetricValue(root: jsonP.JSONValue): s.MetricValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "count": "n",
      "cidrs": ["s"],
      "ports": ["n"],
      "number": "n",
      "numbers": ["n"],
      "strings": ["s"],
    },
  }, root);
}

function fromStatisticalThreshold(input?: s.StatisticalThreshold | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    statistic: input["statistic"],
  }
}
function toStatisticalThreshold(root: jsonP.JSONValue): s.StatisticalThreshold {
  return jsonP.readObj({
    required: {},
    optional: {
      "statistic": "s",
    },
  }, root);
}

function fromMachineLearningDetectionConfig(input?: s.MachineLearningDetectionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    confidenceLevel: input["confidenceLevel"],
  }
}
function toMachineLearningDetectionConfig(root: jsonP.JSONValue): s.MachineLearningDetectionConfig {
  return jsonP.readObj({
    required: {
      "confidenceLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConfidenceLevel>(x),
    },
    optional: {},
  }, root);
}

function fromAlertTarget(input?: s.AlertTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alertTargetArn: input["alertTargetArn"],
    roleArn: input["roleArn"],
  }
}
function toAlertTarget(root: jsonP.JSONValue): s.AlertTarget {
  return jsonP.readObj({
    required: {
      "alertTargetArn": "s",
      "roleArn": "s",
    },
    optional: {},
  }, root);
}

function fromMetricToRetain(input?: s.MetricToRetain | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    metric: input["metric"],
    metricDimension: fromMetricDimension(input["metricDimension"]),
  }
}
function toMetricToRetain(root: jsonP.JSONValue): s.MetricToRetain {
  return jsonP.readObj({
    required: {
      "metric": "s",
    },
    optional: {
      "metricDimension": toMetricDimension,
    },
  }, root);
}

function fromStreamFile(input?: s.StreamFile | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fileId: input["fileId"],
    s3Location: fromS3Location(input["s3Location"]),
  }
}
function toStreamFile(root: jsonP.JSONValue): s.StreamFile {
  return jsonP.readObj({
    required: {},
    optional: {
      "fileId": "n",
      "s3Location": toS3Location,
    },
  }, root);
}

function fromThingTypeProperties(input?: s.ThingTypeProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    thingTypeDescription: input["thingTypeDescription"],
    searchableAttributes: input["searchableAttributes"],
  }
}
function toThingTypeProperties(root: jsonP.JSONValue): s.ThingTypeProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "thingTypeDescription": "s",
      "searchableAttributes": ["s"],
    },
  }, root);
}

function fromTopicRulePayload(input?: s.TopicRulePayload | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sql: input["sql"],
    description: input["description"],
    actions: input["actions"]?.map(x => fromAction(x)),
    ruleDisabled: input["ruleDisabled"],
    awsIotSqlVersion: input["awsIotSqlVersion"],
    errorAction: fromAction(input["errorAction"]),
  }
}

function fromAction(input?: s.Action | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dynamoDB: fromDynamoDBAction(input["dynamoDB"]),
    dynamoDBv2: fromDynamoDBv2Action(input["dynamoDBv2"]),
    lambda: fromLambdaAction(input["lambda"]),
    sns: fromSnsAction(input["sns"]),
    sqs: fromSqsAction(input["sqs"]),
    kinesis: fromKinesisAction(input["kinesis"]),
    republish: fromRepublishAction(input["republish"]),
    s3: fromS3Action(input["s3"]),
    firehose: fromFirehoseAction(input["firehose"]),
    cloudwatchMetric: fromCloudwatchMetricAction(input["cloudwatchMetric"]),
    cloudwatchAlarm: fromCloudwatchAlarmAction(input["cloudwatchAlarm"]),
    cloudwatchLogs: fromCloudwatchLogsAction(input["cloudwatchLogs"]),
    elasticsearch: fromElasticsearchAction(input["elasticsearch"]),
    salesforce: fromSalesforceAction(input["salesforce"]),
    iotAnalytics: fromIotAnalyticsAction(input["iotAnalytics"]),
    iotEvents: fromIotEventsAction(input["iotEvents"]),
    iotSiteWise: fromIotSiteWiseAction(input["iotSiteWise"]),
    stepFunctions: fromStepFunctionsAction(input["stepFunctions"]),
    timestream: fromTimestreamAction(input["timestream"]),
    http: fromHttpAction(input["http"]),
    kafka: fromKafkaAction(input["kafka"]),
  }
}
function toAction(root: jsonP.JSONValue): s.Action {
  return jsonP.readObj({
    required: {},
    optional: {
      "dynamoDB": toDynamoDBAction,
      "dynamoDBv2": toDynamoDBv2Action,
      "lambda": toLambdaAction,
      "sns": toSnsAction,
      "sqs": toSqsAction,
      "kinesis": toKinesisAction,
      "republish": toRepublishAction,
      "s3": toS3Action,
      "firehose": toFirehoseAction,
      "cloudwatchMetric": toCloudwatchMetricAction,
      "cloudwatchAlarm": toCloudwatchAlarmAction,
      "cloudwatchLogs": toCloudwatchLogsAction,
      "elasticsearch": toElasticsearchAction,
      "salesforce": toSalesforceAction,
      "iotAnalytics": toIotAnalyticsAction,
      "iotEvents": toIotEventsAction,
      "iotSiteWise": toIotSiteWiseAction,
      "stepFunctions": toStepFunctionsAction,
      "timestream": toTimestreamAction,
      "http": toHttpAction,
      "kafka": toKafkaAction,
    },
  }, root);
}

function fromDynamoDBAction(input?: s.DynamoDBAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tableName: input["tableName"],
    roleArn: input["roleArn"],
    operation: input["operation"],
    hashKeyField: input["hashKeyField"],
    hashKeyValue: input["hashKeyValue"],
    hashKeyType: input["hashKeyType"],
    rangeKeyField: input["rangeKeyField"],
    rangeKeyValue: input["rangeKeyValue"],
    rangeKeyType: input["rangeKeyType"],
    payloadField: input["payloadField"],
  }
}
function toDynamoDBAction(root: jsonP.JSONValue): s.DynamoDBAction {
  return jsonP.readObj({
    required: {
      "tableName": "s",
      "roleArn": "s",
      "hashKeyField": "s",
      "hashKeyValue": "s",
    },
    optional: {
      "operation": "s",
      "hashKeyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DynamoKeyType>(x),
      "rangeKeyField": "s",
      "rangeKeyValue": "s",
      "rangeKeyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DynamoKeyType>(x),
      "payloadField": "s",
    },
  }, root);
}

function fromDynamoDBv2Action(input?: s.DynamoDBv2Action | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    putItem: fromPutItemInput(input["putItem"]),
  }
}
function toDynamoDBv2Action(root: jsonP.JSONValue): s.DynamoDBv2Action {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "putItem": toPutItemInput,
    },
    optional: {},
  }, root);
}

function fromPutItemInput(input?: s.PutItemInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tableName: input["tableName"],
  }
}
function toPutItemInput(root: jsonP.JSONValue): s.PutItemInput {
  return jsonP.readObj({
    required: {
      "tableName": "s",
    },
    optional: {},
  }, root);
}

function fromLambdaAction(input?: s.LambdaAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    functionArn: input["functionArn"],
  }
}
function toLambdaAction(root: jsonP.JSONValue): s.LambdaAction {
  return jsonP.readObj({
    required: {
      "functionArn": "s",
    },
    optional: {},
  }, root);
}

function fromSnsAction(input?: s.SnsAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    targetArn: input["targetArn"],
    roleArn: input["roleArn"],
    messageFormat: input["messageFormat"],
  }
}
function toSnsAction(root: jsonP.JSONValue): s.SnsAction {
  return jsonP.readObj({
    required: {
      "targetArn": "s",
      "roleArn": "s",
    },
    optional: {
      "messageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.MessageFormat>(x),
    },
  }, root);
}

function fromSqsAction(input?: s.SqsAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    queueUrl: input["queueUrl"],
    useBase64: input["useBase64"],
  }
}
function toSqsAction(root: jsonP.JSONValue): s.SqsAction {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "queueUrl": "s",
    },
    optional: {
      "useBase64": "b",
    },
  }, root);
}

function fromKinesisAction(input?: s.KinesisAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    streamName: input["streamName"],
    partitionKey: input["partitionKey"],
  }
}
function toKinesisAction(root: jsonP.JSONValue): s.KinesisAction {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "streamName": "s",
    },
    optional: {
      "partitionKey": "s",
    },
  }, root);
}

function fromRepublishAction(input?: s.RepublishAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    topic: input["topic"],
    qos: input["qos"],
  }
}
function toRepublishAction(root: jsonP.JSONValue): s.RepublishAction {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "topic": "s",
    },
    optional: {
      "qos": "n",
    },
  }, root);
}

function fromS3Action(input?: s.S3Action | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    bucketName: input["bucketName"],
    key: input["key"],
    cannedAcl: input["cannedAcl"],
  }
}
function toS3Action(root: jsonP.JSONValue): s.S3Action {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "bucketName": "s",
      "key": "s",
    },
    optional: {
      "cannedAcl": (x: jsonP.JSONValue) => cmnP.readEnum<s.CannedAccessControlList>(x),
    },
  }, root);
}

function fromFirehoseAction(input?: s.FirehoseAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    deliveryStreamName: input["deliveryStreamName"],
    separator: input["separator"],
    batchMode: input["batchMode"],
  }
}
function toFirehoseAction(root: jsonP.JSONValue): s.FirehoseAction {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "deliveryStreamName": "s",
    },
    optional: {
      "separator": "s",
      "batchMode": "b",
    },
  }, root);
}

function fromCloudwatchMetricAction(input?: s.CloudwatchMetricAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    metricNamespace: input["metricNamespace"],
    metricName: input["metricName"],
    metricValue: input["metricValue"],
    metricUnit: input["metricUnit"],
    metricTimestamp: input["metricTimestamp"],
  }
}
function toCloudwatchMetricAction(root: jsonP.JSONValue): s.CloudwatchMetricAction {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "metricNamespace": "s",
      "metricName": "s",
      "metricValue": "s",
      "metricUnit": "s",
    },
    optional: {
      "metricTimestamp": "s",
    },
  }, root);
}

function fromCloudwatchAlarmAction(input?: s.CloudwatchAlarmAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    alarmName: input["alarmName"],
    stateReason: input["stateReason"],
    stateValue: input["stateValue"],
  }
}
function toCloudwatchAlarmAction(root: jsonP.JSONValue): s.CloudwatchAlarmAction {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "alarmName": "s",
      "stateReason": "s",
      "stateValue": "s",
    },
    optional: {},
  }, root);
}

function fromCloudwatchLogsAction(input?: s.CloudwatchLogsAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    logGroupName: input["logGroupName"],
  }
}
function toCloudwatchLogsAction(root: jsonP.JSONValue): s.CloudwatchLogsAction {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "logGroupName": "s",
    },
    optional: {},
  }, root);
}

function fromElasticsearchAction(input?: s.ElasticsearchAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    endpoint: input["endpoint"],
    index: input["index"],
    type: input["type"],
    id: input["id"],
  }
}
function toElasticsearchAction(root: jsonP.JSONValue): s.ElasticsearchAction {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "endpoint": "s",
      "index": "s",
      "type": "s",
      "id": "s",
    },
    optional: {},
  }, root);
}

function fromSalesforceAction(input?: s.SalesforceAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    token: input["token"],
    url: input["url"],
  }
}
function toSalesforceAction(root: jsonP.JSONValue): s.SalesforceAction {
  return jsonP.readObj({
    required: {
      "token": "s",
      "url": "s",
    },
    optional: {},
  }, root);
}

function fromIotAnalyticsAction(input?: s.IotAnalyticsAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channelArn: input["channelArn"],
    channelName: input["channelName"],
    batchMode: input["batchMode"],
    roleArn: input["roleArn"],
  }
}
function toIotAnalyticsAction(root: jsonP.JSONValue): s.IotAnalyticsAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "channelArn": "s",
      "channelName": "s",
      "batchMode": "b",
      "roleArn": "s",
    },
  }, root);
}

function fromIotEventsAction(input?: s.IotEventsAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputName: input["inputName"],
    messageId: input["messageId"],
    batchMode: input["batchMode"],
    roleArn: input["roleArn"],
  }
}
function toIotEventsAction(root: jsonP.JSONValue): s.IotEventsAction {
  return jsonP.readObj({
    required: {
      "inputName": "s",
      "roleArn": "s",
    },
    optional: {
      "messageId": "s",
      "batchMode": "b",
    },
  }, root);
}

function fromIotSiteWiseAction(input?: s.IotSiteWiseAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    putAssetPropertyValueEntries: input["putAssetPropertyValueEntries"]?.map(x => fromPutAssetPropertyValueEntry(x)),
    roleArn: input["roleArn"],
  }
}
function toIotSiteWiseAction(root: jsonP.JSONValue): s.IotSiteWiseAction {
  return jsonP.readObj({
    required: {
      "putAssetPropertyValueEntries": [toPutAssetPropertyValueEntry],
      "roleArn": "s",
    },
    optional: {},
  }, root);
}

function fromPutAssetPropertyValueEntry(input?: s.PutAssetPropertyValueEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    entryId: input["entryId"],
    assetId: input["assetId"],
    propertyId: input["propertyId"],
    propertyAlias: input["propertyAlias"],
    propertyValues: input["propertyValues"]?.map(x => fromAssetPropertyValue(x)),
  }
}
function toPutAssetPropertyValueEntry(root: jsonP.JSONValue): s.PutAssetPropertyValueEntry {
  return jsonP.readObj({
    required: {
      "propertyValues": [toAssetPropertyValue],
    },
    optional: {
      "entryId": "s",
      "assetId": "s",
      "propertyId": "s",
      "propertyAlias": "s",
    },
  }, root);
}

function fromAssetPropertyValue(input?: s.AssetPropertyValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: fromAssetPropertyVariant(input["value"]),
    timestamp: fromAssetPropertyTimestamp(input["timestamp"]),
    quality: input["quality"],
  }
}
function toAssetPropertyValue(root: jsonP.JSONValue): s.AssetPropertyValue {
  return jsonP.readObj({
    required: {
      "value": toAssetPropertyVariant,
      "timestamp": toAssetPropertyTimestamp,
    },
    optional: {
      "quality": "s",
    },
  }, root);
}

function fromAssetPropertyVariant(input?: s.AssetPropertyVariant | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    stringValue: input["stringValue"],
    integerValue: input["integerValue"],
    doubleValue: input["doubleValue"],
    booleanValue: input["booleanValue"],
  }
}
function toAssetPropertyVariant(root: jsonP.JSONValue): s.AssetPropertyVariant {
  return jsonP.readObj({
    required: {},
    optional: {
      "stringValue": "s",
      "integerValue": "s",
      "doubleValue": "s",
      "booleanValue": "s",
    },
  }, root);
}

function fromAssetPropertyTimestamp(input?: s.AssetPropertyTimestamp | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timeInSeconds: input["timeInSeconds"],
    offsetInNanos: input["offsetInNanos"],
  }
}
function toAssetPropertyTimestamp(root: jsonP.JSONValue): s.AssetPropertyTimestamp {
  return jsonP.readObj({
    required: {
      "timeInSeconds": "s",
    },
    optional: {
      "offsetInNanos": "s",
    },
  }, root);
}

function fromStepFunctionsAction(input?: s.StepFunctionsAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    executionNamePrefix: input["executionNamePrefix"],
    stateMachineName: input["stateMachineName"],
    roleArn: input["roleArn"],
  }
}
function toStepFunctionsAction(root: jsonP.JSONValue): s.StepFunctionsAction {
  return jsonP.readObj({
    required: {
      "stateMachineName": "s",
      "roleArn": "s",
    },
    optional: {
      "executionNamePrefix": "s",
    },
  }, root);
}

function fromTimestreamAction(input?: s.TimestreamAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    databaseName: input["databaseName"],
    tableName: input["tableName"],
    dimensions: input["dimensions"]?.map(x => fromTimestreamDimension(x)),
    timestamp: fromTimestreamTimestamp(input["timestamp"]),
  }
}
function toTimestreamAction(root: jsonP.JSONValue): s.TimestreamAction {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "databaseName": "s",
      "tableName": "s",
      "dimensions": [toTimestreamDimension],
    },
    optional: {
      "timestamp": toTimestreamTimestamp,
    },
  }, root);
}

function fromTimestreamDimension(input?: s.TimestreamDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
  }
}
function toTimestreamDimension(root: jsonP.JSONValue): s.TimestreamDimension {
  return jsonP.readObj({
    required: {
      "name": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromTimestreamTimestamp(input?: s.TimestreamTimestamp | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    unit: input["unit"],
  }
}
function toTimestreamTimestamp(root: jsonP.JSONValue): s.TimestreamTimestamp {
  return jsonP.readObj({
    required: {
      "value": "s",
      "unit": "s",
    },
    optional: {},
  }, root);
}

function fromHttpAction(input?: s.HttpAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    url: input["url"],
    confirmationUrl: input["confirmationUrl"],
    headers: input["headers"]?.map(x => fromHttpActionHeader(x)),
    auth: fromHttpAuthorization(input["auth"]),
  }
}
function toHttpAction(root: jsonP.JSONValue): s.HttpAction {
  return jsonP.readObj({
    required: {
      "url": "s",
    },
    optional: {
      "confirmationUrl": "s",
      "headers": [toHttpActionHeader],
      "auth": toHttpAuthorization,
    },
  }, root);
}

function fromHttpActionHeader(input?: s.HttpActionHeader | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toHttpActionHeader(root: jsonP.JSONValue): s.HttpActionHeader {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromHttpAuthorization(input?: s.HttpAuthorization | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sigv4: fromSigV4Authorization(input["sigv4"]),
  }
}
function toHttpAuthorization(root: jsonP.JSONValue): s.HttpAuthorization {
  return jsonP.readObj({
    required: {},
    optional: {
      "sigv4": toSigV4Authorization,
    },
  }, root);
}

function fromSigV4Authorization(input?: s.SigV4Authorization | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    signingRegion: input["signingRegion"],
    serviceName: input["serviceName"],
    roleArn: input["roleArn"],
  }
}
function toSigV4Authorization(root: jsonP.JSONValue): s.SigV4Authorization {
  return jsonP.readObj({
    required: {
      "signingRegion": "s",
      "serviceName": "s",
      "roleArn": "s",
    },
    optional: {},
  }, root);
}

function fromKafkaAction(input?: s.KafkaAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destinationArn: input["destinationArn"],
    topic: input["topic"],
    key: input["key"],
    partition: input["partition"],
    clientProperties: input["clientProperties"],
  }
}
function toKafkaAction(root: jsonP.JSONValue): s.KafkaAction {
  return jsonP.readObj({
    required: {
      "destinationArn": "s",
      "topic": "s",
      "clientProperties": x => jsonP.readMap(String, String, x),
    },
    optional: {
      "key": "s",
      "partition": "s",
    },
  }, root);
}

function fromTopicRuleDestinationConfiguration(input?: s.TopicRuleDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    httpUrlConfiguration: fromHttpUrlDestinationConfiguration(input["httpUrlConfiguration"]),
    vpcConfiguration: fromVpcDestinationConfiguration(input["vpcConfiguration"]),
  }
}

function fromHttpUrlDestinationConfiguration(input?: s.HttpUrlDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    confirmationUrl: input["confirmationUrl"],
  }
}

function fromVpcDestinationConfiguration(input?: s.VpcDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subnetIds: input["subnetIds"],
    securityGroups: input["securityGroups"],
    vpcId: input["vpcId"],
    roleArn: input["roleArn"],
  }
}

function fromRegistrationConfig(input?: s.RegistrationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    templateBody: input["templateBody"],
    roleArn: input["roleArn"],
  }
}
function toRegistrationConfig(root: jsonP.JSONValue): s.RegistrationConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "templateBody": "s",
      "roleArn": "s",
    },
  }, root);
}

function fromLoggingOptionsPayload(input?: s.LoggingOptionsPayload | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    logLevel: input["logLevel"],
  }
}

function fromLogTarget(input?: s.LogTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    targetType: input["targetType"],
    targetName: input["targetName"],
  }
}
function toLogTarget(root: jsonP.JSONValue): s.LogTarget {
  return jsonP.readObj({
    required: {
      "targetType": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogTargetType>(x),
    },
    optional: {
      "targetName": "s",
    },
  }, root);
}

function fromAuditMitigationActionsTaskTarget(input?: s.AuditMitigationActionsTaskTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    auditTaskId: input["auditTaskId"],
    findingIds: input["findingIds"],
    auditCheckToReasonCodeFilter: input["auditCheckToReasonCodeFilter"],
  }
}
function toAuditMitigationActionsTaskTarget(root: jsonP.JSONValue): s.AuditMitigationActionsTaskTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "auditTaskId": "s",
      "findingIds": ["s"],
      "auditCheckToReasonCodeFilter": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
    },
  }, root);
}

function fromDetectMitigationActionsTaskTarget(input?: s.DetectMitigationActionsTaskTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    violationIds: input["violationIds"],
    securityProfileName: input["securityProfileName"],
    behaviorName: input["behaviorName"],
  }
}
function toDetectMitigationActionsTaskTarget(root: jsonP.JSONValue): s.DetectMitigationActionsTaskTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "violationIds": ["s"],
      "securityProfileName": "s",
      "behaviorName": "s",
    },
  }, root);
}

function fromViolationEventOccurrenceRange(input?: s.ViolationEventOccurrenceRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    startTime: jsonP.serializeDate_unixTimestamp(input["startTime"]),
    endTime: jsonP.serializeDate_unixTimestamp(input["endTime"]),
  }
}
function toViolationEventOccurrenceRange(root: jsonP.JSONValue): s.ViolationEventOccurrenceRange {
  return jsonP.readObj({
    required: {
      "startTime": "d",
      "endTime": "d",
    },
    optional: {},
  }, root);
}

function fromAuthInfo(input?: s.AuthInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actionType: input["actionType"],
    resources: input["resources"],
  }
}
function toAuthInfo(root: jsonP.JSONValue): s.AuthInfo {
  return jsonP.readObj({
    required: {
      "resources": ["s"],
    },
    optional: {
      "actionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionType>(x),
    },
  }, root);
}

function fromHttpContext(input?: s.HttpContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    headers: input["headers"],
    queryString: input["queryString"],
  }
}

function fromMqttContext(input?: s.MqttContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    username: input["username"],
    password: serializeBlob(input["password"]),
    clientId: input["clientId"],
  }
}

function fromTlsContext(input?: s.TlsContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serverName: input["serverName"],
  }
}

function fromAuditNotificationTarget(input?: s.AuditNotificationTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    targetArn: input["targetArn"],
    roleArn: input["roleArn"],
    enabled: input["enabled"],
  }
}
function toAuditNotificationTarget(root: jsonP.JSONValue): s.AuditNotificationTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "targetArn": "s",
      "roleArn": "s",
      "enabled": "b",
    },
  }, root);
}

function fromAuditCheckConfiguration(input?: s.AuditCheckConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
  }
}
function toAuditCheckConfiguration(root: jsonP.JSONValue): s.AuditCheckConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "enabled": "b",
    },
  }, root);
}

function fromConfiguration(input?: s.Configuration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
  }
}
function toConfiguration(root: jsonP.JSONValue): s.Configuration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
    },
  }, root);
}

function fromThingIndexingConfiguration(input?: s.ThingIndexingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    thingIndexingMode: input["thingIndexingMode"],
    thingConnectivityIndexingMode: input["thingConnectivityIndexingMode"],
    managedFields: input["managedFields"]?.map(x => fromField(x)),
    customFields: input["customFields"]?.map(x => fromField(x)),
  }
}
function toThingIndexingConfiguration(root: jsonP.JSONValue): s.ThingIndexingConfiguration {
  return jsonP.readObj({
    required: {
      "thingIndexingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThingIndexingMode>(x),
    },
    optional: {
      "thingConnectivityIndexingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThingConnectivityIndexingMode>(x),
      "managedFields": [toField],
      "customFields": [toField],
    },
  }, root);
}

function fromField(input?: s.Field | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    type: input["type"],
  }
}
function toField(root: jsonP.JSONValue): s.Field {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.FieldType>(x),
    },
  }, root);
}

function fromThingGroupIndexingConfiguration(input?: s.ThingGroupIndexingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    thingGroupIndexingMode: input["thingGroupIndexingMode"],
    managedFields: input["managedFields"]?.map(x => fromField(x)),
    customFields: input["customFields"]?.map(x => fromField(x)),
  }
}
function toThingGroupIndexingConfiguration(root: jsonP.JSONValue): s.ThingGroupIndexingConfiguration {
  return jsonP.readObj({
    required: {
      "thingGroupIndexingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThingGroupIndexingMode>(x),
    },
    optional: {
      "managedFields": [toField],
      "customFields": [toField],
    },
  }, root);
}

function toKeyPair(root: jsonP.JSONValue): s.KeyPair {
  return jsonP.readObj({
    required: {},
    optional: {
      "PublicKey": "s",
      "PrivateKey": "s",
    },
  }, root);
}

function toTopicRuleDestination(root: jsonP.JSONValue): s.TopicRuleDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TopicRuleDestinationStatus>(x),
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "statusReason": "s",
      "httpUrlProperties": toHttpUrlDestinationProperties,
      "vpcProperties": toVpcDestinationProperties,
    },
  }, root);
}

function toHttpUrlDestinationProperties(root: jsonP.JSONValue): s.HttpUrlDestinationProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "confirmationUrl": "s",
    },
  }, root);
}

function toVpcDestinationProperties(root: jsonP.JSONValue): s.VpcDestinationProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "subnetIds": ["s"],
      "securityGroups": ["s"],
      "vpcId": "s",
      "roleArn": "s",
    },
  }, root);
}

function toAuditFinding(root: jsonP.JSONValue): s.AuditFinding {
  return jsonP.readObj({
    required: {},
    optional: {
      "findingId": "s",
      "taskId": "s",
      "checkName": "s",
      "taskStartTime": "d",
      "findingTime": "d",
      "severity": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditFindingSeverity>(x),
      "nonCompliantResource": toNonCompliantResource,
      "relatedResources": [toRelatedResource],
      "reasonForNonCompliance": "s",
      "reasonForNonComplianceCode": "s",
      "isSuppressed": "b",
    },
  }, root);
}

function toNonCompliantResource(root: jsonP.JSONValue): s.NonCompliantResource {
  return jsonP.readObj({
    required: {},
    optional: {
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "resourceIdentifier": toResourceIdentifier,
      "additionalInfo": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toRelatedResource(root: jsonP.JSONValue): s.RelatedResource {
  return jsonP.readObj({
    required: {},
    optional: {
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "resourceIdentifier": toResourceIdentifier,
      "additionalInfo": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toTaskStatisticsForAuditCheck(root: jsonP.JSONValue): s.TaskStatisticsForAuditCheck {
  return jsonP.readObj({
    required: {},
    optional: {
      "totalFindingsCount": "n",
      "failedFindingsCount": "n",
      "succeededFindingsCount": "n",
      "skippedFindingsCount": "n",
      "canceledFindingsCount": "n",
    },
  }, root);
}

function toMitigationAction(root: jsonP.JSONValue): s.MitigationAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "id": "s",
      "roleArn": "s",
      "actionParams": toMitigationActionParams,
    },
  }, root);
}

function toTaskStatistics(root: jsonP.JSONValue): s.TaskStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "totalChecks": "n",
      "inProgressChecks": "n",
      "waitingForDataCollectionChecks": "n",
      "compliantChecks": "n",
      "nonCompliantChecks": "n",
      "failedChecks": "n",
      "canceledChecks": "n",
    },
  }, root);
}

function toAuditCheckDetails(root: jsonP.JSONValue): s.AuditCheckDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "checkRunStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditCheckRunStatus>(x),
      "checkCompliant": "b",
      "totalResourcesCount": "n",
      "nonCompliantResourcesCount": "n",
      "suppressedNonCompliantResourcesCount": "n",
      "errorCode": "s",
      "message": "s",
    },
  }, root);
}

function toAuthorizerDescription(root: jsonP.JSONValue): s.AuthorizerDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "authorizerName": "s",
      "authorizerArn": "s",
      "authorizerFunctionArn": "s",
      "tokenKeyName": "s",
      "tokenSigningPublicKeys": x => jsonP.readMap(String, String, x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizerStatus>(x),
      "creationDate": "d",
      "lastModifiedDate": "d",
      "signingDisabled": "b",
    },
  }, root);
}

function toBillingGroupMetadata(root: jsonP.JSONValue): s.BillingGroupMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "creationDate": "d",
    },
  }, root);
}

function toCACertificateDescription(root: jsonP.JSONValue): s.CACertificateDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "certificateArn": "s",
      "certificateId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CACertificateStatus>(x),
      "certificatePem": "s",
      "ownedBy": "s",
      "creationDate": "d",
      "autoRegistrationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoRegistrationStatus>(x),
      "lastModifiedDate": "d",
      "customerVersion": "n",
      "generationId": "s",
      "validity": toCertificateValidity,
    },
  }, root);
}

function toCertificateValidity(root: jsonP.JSONValue): s.CertificateValidity {
  return jsonP.readObj({
    required: {},
    optional: {
      "notBefore": "d",
      "notAfter": "d",
    },
  }, root);
}

function toCertificateDescription(root: jsonP.JSONValue): s.CertificateDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "certificateArn": "s",
      "certificateId": "s",
      "caCertificateId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateStatus>(x),
      "certificatePem": "s",
      "ownedBy": "s",
      "previousOwnedBy": "s",
      "creationDate": "d",
      "lastModifiedDate": "d",
      "customerVersion": "n",
      "transferData": toTransferData,
      "generationId": "s",
      "validity": toCertificateValidity,
      "certificateMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateMode>(x),
    },
  }, root);
}

function toTransferData(root: jsonP.JSONValue): s.TransferData {
  return jsonP.readObj({
    required: {},
    optional: {
      "transferMessage": "s",
      "rejectReason": "s",
      "transferDate": "d",
      "acceptDate": "d",
      "rejectDate": "d",
    },
  }, root);
}

function toDetectMitigationActionsTaskSummary(root: jsonP.JSONValue): s.DetectMitigationActionsTaskSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "taskId": "s",
      "taskStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DetectMitigationActionsTaskStatus>(x),
      "taskStartTime": "d",
      "taskEndTime": "d",
      "target": toDetectMitigationActionsTaskTarget,
      "violationEventOccurrenceRange": toViolationEventOccurrenceRange,
      "onlyActiveViolationsIncluded": "b",
      "suppressedAlertsIncluded": "b",
      "actionsDefinition": [toMitigationAction],
      "taskStatistics": toDetectMitigationActionsTaskStatistics,
    },
  }, root);
}

function toDetectMitigationActionsTaskStatistics(root: jsonP.JSONValue): s.DetectMitigationActionsTaskStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionsExecuted": "n",
      "actionsSkipped": "n",
      "actionsFailed": "n",
    },
  }, root);
}

function toServerCertificateSummary(root: jsonP.JSONValue): s.ServerCertificateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "serverCertificateArn": "s",
      "serverCertificateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ServerCertificateStatus>(x),
      "serverCertificateStatusDetail": "s",
    },
  }, root);
}

function toJob(root: jsonP.JSONValue): s.Job {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobArn": "s",
      "jobId": "s",
      "targetSelection": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetSelection>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "forceCanceled": "b",
      "reasonCode": "s",
      "comment": "s",
      "targets": ["s"],
      "description": "s",
      "presignedUrlConfig": toPresignedUrlConfig,
      "jobExecutionsRolloutConfig": toJobExecutionsRolloutConfig,
      "abortConfig": toAbortConfig,
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "completedAt": "d",
      "jobProcessDetails": toJobProcessDetails,
      "timeoutConfig": toTimeoutConfig,
      "namespaceId": "s",
    },
  }, root);
}

function toJobProcessDetails(root: jsonP.JSONValue): s.JobProcessDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "processingTargets": ["s"],
      "numberOfCanceledThings": "n",
      "numberOfSucceededThings": "n",
      "numberOfFailedThings": "n",
      "numberOfRejectedThings": "n",
      "numberOfQueuedThings": "n",
      "numberOfInProgressThings": "n",
      "numberOfRemovedThings": "n",
      "numberOfTimedOutThings": "n",
    },
  }, root);
}

function toJobExecution(root: jsonP.JSONValue): s.JobExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobExecutionStatus>(x),
      "forceCanceled": "b",
      "statusDetails": toJobExecutionStatusDetails,
      "thingArn": "s",
      "queuedAt": "d",
      "startedAt": "d",
      "lastUpdatedAt": "d",
      "executionNumber": "n",
      "versionNumber": "n",
      "approximateSecondsBeforeTimedOut": "n",
    },
  }, root);
}

function toJobExecutionStatusDetails(root: jsonP.JSONValue): s.JobExecutionStatusDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "detailsMap": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toRoleAliasDescription(root: jsonP.JSONValue): s.RoleAliasDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "roleAlias": "s",
      "roleAliasArn": "s",
      "roleArn": "s",
      "owner": "s",
      "credentialDurationSeconds": "n",
      "creationDate": "d",
      "lastModifiedDate": "d",
    },
  }, root);
}

function toStreamInfo(root: jsonP.JSONValue): s.StreamInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "streamId": "s",
      "streamArn": "s",
      "streamVersion": "n",
      "description": "s",
      "files": [toStreamFile],
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "roleArn": "s",
    },
  }, root);
}

function toThingGroupMetadata(root: jsonP.JSONValue): s.ThingGroupMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "parentGroupName": "s",
      "rootToParentThingGroups": [toGroupNameAndArn],
      "creationDate": "d",
    },
  }, root);
}

function toGroupNameAndArn(root: jsonP.JSONValue): s.GroupNameAndArn {
  return jsonP.readObj({
    required: {},
    optional: {
      "groupName": "s",
      "groupArn": "s",
    },
  }, root);
}

function toThingTypeMetadata(root: jsonP.JSONValue): s.ThingTypeMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "deprecated": "b",
      "deprecationDate": "d",
      "creationDate": "d",
    },
  }, root);
}

function toBehaviorModelTrainingSummary(root: jsonP.JSONValue): s.BehaviorModelTrainingSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "securityProfileName": "s",
      "behaviorName": "s",
      "trainingDataCollectionStartDate": "d",
      "modelStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelStatus>(x),
      "datapointsCollectionPercentage": "n",
      "lastModelRefreshDate": "d",
    },
  }, root);
}

function toEffectivePolicy(root: jsonP.JSONValue): s.EffectivePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "policyName": "s",
      "policyArn": "s",
      "policyDocument": "s",
    },
  }, root);
}

function toOTAUpdateInfo(root: jsonP.JSONValue): s.OTAUpdateInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "otaUpdateId": "s",
      "otaUpdateArn": "s",
      "creationDate": "d",
      "lastModifiedDate": "d",
      "description": "s",
      "targets": ["s"],
      "protocols": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Protocol>(x)],
      "awsJobExecutionsRolloutConfig": toAwsJobExecutionsRolloutConfig,
      "awsJobPresignedUrlConfig": toAwsJobPresignedUrlConfig,
      "targetSelection": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetSelection>(x),
      "otaUpdateFiles": [toOTAUpdateFile],
      "otaUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.OTAUpdateStatus>(x),
      "awsIotJobId": "s",
      "awsIotJobArn": "s",
      "errorInfo": toErrorInfo,
      "additionalParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toErrorInfo(root: jsonP.JSONValue): s.ErrorInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": "s",
      "message": "s",
    },
  }, root);
}

function toPercentPair(root: jsonP.JSONValue): s.PercentPair {
  return jsonP.readObj({
    required: {},
    optional: {
      "percent": "n",
      "value": "n",
    },
  }, root);
}

function toStatistics(root: jsonP.JSONValue): s.Statistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "count": "n",
      "average": "n",
      "sum": "n",
      "minimum": "n",
      "maximum": "n",
      "sumOfSquares": "n",
      "variance": "n",
      "stdDeviation": "n",
    },
  }, root);
}

function toTopicRule(root: jsonP.JSONValue): s.TopicRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "ruleName": "s",
      "sql": "s",
      "description": "s",
      "createdAt": "d",
      "actions": [toAction],
      "ruleDisabled": "b",
      "awsIotSqlVersion": "s",
      "errorAction": toAction,
    },
  }, root);
}

function toActiveViolation(root: jsonP.JSONValue): s.ActiveViolation {
  return jsonP.readObj({
    required: {},
    optional: {
      "violationId": "s",
      "thingName": "s",
      "securityProfileName": "s",
      "behavior": toBehavior,
      "lastViolationValue": toMetricValue,
      "violationEventAdditionalInfo": toViolationEventAdditionalInfo,
      "lastViolationTime": "d",
      "violationStartTime": "d",
    },
  }, root);
}

function toViolationEventAdditionalInfo(root: jsonP.JSONValue): s.ViolationEventAdditionalInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "confidenceLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConfidenceLevel>(x),
    },
  }, root);
}

function toPolicy(root: jsonP.JSONValue): s.Policy {
  return jsonP.readObj({
    required: {},
    optional: {
      "policyName": "s",
      "policyArn": "s",
    },
  }, root);
}

function toAuditMitigationActionExecutionMetadata(root: jsonP.JSONValue): s.AuditMitigationActionExecutionMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "taskId": "s",
      "findingId": "s",
      "actionName": "s",
      "actionId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditMitigationActionsExecutionStatus>(x),
      "startTime": "d",
      "endTime": "d",
      "errorCode": "s",
      "message": "s",
    },
  }, root);
}

function toAuditMitigationActionsTaskMetadata(root: jsonP.JSONValue): s.AuditMitigationActionsTaskMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "taskId": "s",
      "startTime": "d",
      "taskStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditMitigationActionsTaskStatus>(x),
    },
  }, root);
}

function toAuditSuppression(root: jsonP.JSONValue): s.AuditSuppression {
  return jsonP.readObj({
    required: {
      "checkName": "s",
      "resourceIdentifier": toResourceIdentifier,
    },
    optional: {
      "expirationDate": "d",
      "suppressIndefinitely": "b",
      "description": "s",
    },
  }, root);
}

function toAuditTaskMetadata(root: jsonP.JSONValue): s.AuditTaskMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "taskId": "s",
      "taskStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditTaskStatus>(x),
      "taskType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditTaskType>(x),
    },
  }, root);
}

function toAuthorizerSummary(root: jsonP.JSONValue): s.AuthorizerSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "authorizerName": "s",
      "authorizerArn": "s",
    },
  }, root);
}

function toCACertificate(root: jsonP.JSONValue): s.CACertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "certificateArn": "s",
      "certificateId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CACertificateStatus>(x),
      "creationDate": "d",
    },
  }, root);
}

function toCertificate(root: jsonP.JSONValue): s.Certificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "certificateArn": "s",
      "certificateId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateStatus>(x),
      "certificateMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateMode>(x),
      "creationDate": "d",
    },
  }, root);
}

function toDetectMitigationActionExecution(root: jsonP.JSONValue): s.DetectMitigationActionExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "taskId": "s",
      "violationId": "s",
      "actionName": "s",
      "thingName": "s",
      "executionStartDate": "d",
      "executionEndDate": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DetectMitigationActionExecutionStatus>(x),
      "errorCode": "s",
      "message": "s",
    },
  }, root);
}

function toDomainConfigurationSummary(root: jsonP.JSONValue): s.DomainConfigurationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "domainConfigurationName": "s",
      "domainConfigurationArn": "s",
      "serviceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ServiceType>(x),
    },
  }, root);
}

function toJobExecutionSummaryForJob(root: jsonP.JSONValue): s.JobExecutionSummaryForJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "thingArn": "s",
      "jobExecutionSummary": toJobExecutionSummary,
    },
  }, root);
}

function toJobExecutionSummary(root: jsonP.JSONValue): s.JobExecutionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobExecutionStatus>(x),
      "queuedAt": "d",
      "startedAt": "d",
      "lastUpdatedAt": "d",
      "executionNumber": "n",
    },
  }, root);
}

function toJobExecutionSummaryForThing(root: jsonP.JSONValue): s.JobExecutionSummaryForThing {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobId": "s",
      "jobExecutionSummary": toJobExecutionSummary,
    },
  }, root);
}

function toJobSummary(root: jsonP.JSONValue): s.JobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobArn": "s",
      "jobId": "s",
      "thingGroupId": "s",
      "targetSelection": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetSelection>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "completedAt": "d",
    },
  }, root);
}

function toMitigationActionIdentifier(root: jsonP.JSONValue): s.MitigationActionIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionName": "s",
      "actionArn": "s",
      "creationDate": "d",
    },
  }, root);
}

function toOTAUpdateSummary(root: jsonP.JSONValue): s.OTAUpdateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "otaUpdateId": "s",
      "otaUpdateArn": "s",
      "creationDate": "d",
    },
  }, root);
}

function toOutgoingCertificate(root: jsonP.JSONValue): s.OutgoingCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "certificateArn": "s",
      "certificateId": "s",
      "transferredTo": "s",
      "transferDate": "d",
      "transferMessage": "s",
      "creationDate": "d",
    },
  }, root);
}

function toPolicyVersion(root: jsonP.JSONValue): s.PolicyVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "versionId": "s",
      "isDefaultVersion": "b",
      "createDate": "d",
    },
  }, root);
}

function toProvisioningTemplateVersionSummary(root: jsonP.JSONValue): s.ProvisioningTemplateVersionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "versionId": "n",
      "creationDate": "d",
      "isDefaultVersion": "b",
    },
  }, root);
}

function toProvisioningTemplateSummary(root: jsonP.JSONValue): s.ProvisioningTemplateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "templateArn": "s",
      "templateName": "s",
      "description": "s",
      "creationDate": "d",
      "lastModifiedDate": "d",
      "enabled": "b",
    },
  }, root);
}

function toScheduledAuditMetadata(root: jsonP.JSONValue): s.ScheduledAuditMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "scheduledAuditName": "s",
      "scheduledAuditArn": "s",
      "frequency": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuditFrequency>(x),
      "dayOfMonth": "s",
      "dayOfWeek": (x: jsonP.JSONValue) => cmnP.readEnum<s.DayOfWeek>(x),
    },
  }, root);
}

function toSecurityProfileIdentifier(root: jsonP.JSONValue): s.SecurityProfileIdentifier {
  return jsonP.readObj({
    required: {
      "name": "s",
      "arn": "s",
    },
    optional: {},
  }, root);
}

function toSecurityProfileTargetMapping(root: jsonP.JSONValue): s.SecurityProfileTargetMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "securityProfileIdentifier": toSecurityProfileIdentifier,
      "target": toSecurityProfileTarget,
    },
  }, root);
}

function toSecurityProfileTarget(root: jsonP.JSONValue): s.SecurityProfileTarget {
  return jsonP.readObj({
    required: {
      "arn": "s",
    },
    optional: {},
  }, root);
}

function toStreamSummary(root: jsonP.JSONValue): s.StreamSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "streamId": "s",
      "streamArn": "s",
      "streamVersion": "n",
      "description": "s",
    },
  }, root);
}

function toThingTypeDefinition(root: jsonP.JSONValue): s.ThingTypeDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "thingTypeName": "s",
      "thingTypeArn": "s",
      "thingTypeProperties": toThingTypeProperties,
      "thingTypeMetadata": toThingTypeMetadata,
    },
  }, root);
}

function toThingAttribute(root: jsonP.JSONValue): s.ThingAttribute {
  return jsonP.readObj({
    required: {},
    optional: {
      "thingName": "s",
      "thingTypeName": "s",
      "thingArn": "s",
      "attributes": x => jsonP.readMap(String, String, x),
      "version": "n",
    },
  }, root);
}

function toTopicRuleDestinationSummary(root: jsonP.JSONValue): s.TopicRuleDestinationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TopicRuleDestinationStatus>(x),
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "statusReason": "s",
      "httpUrlSummary": toHttpUrlDestinationSummary,
      "vpcDestinationSummary": toVpcDestinationSummary,
    },
  }, root);
}

function toHttpUrlDestinationSummary(root: jsonP.JSONValue): s.HttpUrlDestinationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "confirmationUrl": "s",
    },
  }, root);
}

function toVpcDestinationSummary(root: jsonP.JSONValue): s.VpcDestinationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "subnetIds": ["s"],
      "securityGroups": ["s"],
      "vpcId": "s",
      "roleArn": "s",
    },
  }, root);
}

function toTopicRuleListItem(root: jsonP.JSONValue): s.TopicRuleListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "ruleArn": "s",
      "ruleName": "s",
      "topicPattern": "s",
      "createdAt": "d",
      "ruleDisabled": "b",
    },
  }, root);
}

function toLogTargetConfiguration(root: jsonP.JSONValue): s.LogTargetConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "logTarget": toLogTarget,
      "logLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
    },
  }, root);
}

function toViolationEvent(root: jsonP.JSONValue): s.ViolationEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "violationId": "s",
      "thingName": "s",
      "securityProfileName": "s",
      "behavior": toBehavior,
      "metricValue": toMetricValue,
      "violationEventAdditionalInfo": toViolationEventAdditionalInfo,
      "violationEventType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ViolationEventType>(x),
      "violationEventTime": "d",
    },
  }, root);
}

function toThingDocument(root: jsonP.JSONValue): s.ThingDocument {
  return jsonP.readObj({
    required: {},
    optional: {
      "thingName": "s",
      "thingId": "s",
      "thingTypeName": "s",
      "thingGroupNames": ["s"],
      "attributes": x => jsonP.readMap(String, String, x),
      "shadow": "s",
      "connectivity": toThingConnectivity,
    },
  }, root);
}

function toThingConnectivity(root: jsonP.JSONValue): s.ThingConnectivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "connected": "b",
      "timestamp": "n",
    },
  }, root);
}

function toThingGroupDocument(root: jsonP.JSONValue): s.ThingGroupDocument {
  return jsonP.readObj({
    required: {},
    optional: {
      "thingGroupName": "s",
      "thingGroupId": "s",
      "thingGroupDescription": "s",
      "attributes": x => jsonP.readMap(String, String, x),
      "parentGroupNames": ["s"],
    },
  }, root);
}

function toAuthResult(root: jsonP.JSONValue): s.AuthResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "authInfo": toAuthInfo,
      "allowed": toAllowed,
      "denied": toDenied,
      "authDecision": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthDecision>(x),
      "missingContextValues": ["s"],
    },
  }, root);
}

function toAllowed(root: jsonP.JSONValue): s.Allowed {
  return jsonP.readObj({
    required: {},
    optional: {
      "policies": [toPolicy],
    },
  }, root);
}

function toDenied(root: jsonP.JSONValue): s.Denied {
  return jsonP.readObj({
    required: {},
    optional: {
      "implicitDeny": toImplicitDeny,
      "explicitDeny": toExplicitDeny,
    },
  }, root);
}

function toImplicitDeny(root: jsonP.JSONValue): s.ImplicitDeny {
  return jsonP.readObj({
    required: {},
    optional: {
      "policies": [toPolicy],
    },
  }, root);
}

function toExplicitDeny(root: jsonP.JSONValue): s.ExplicitDeny {
  return jsonP.readObj({
    required: {},
    optional: {
      "policies": [toPolicy],
    },
  }, root);
}

function toValidationError(root: jsonP.JSONValue): s.ValidationError {
  return jsonP.readObj({
    required: {},
    optional: {
      "errorMessage": "s",
    },
  }, root);
}
