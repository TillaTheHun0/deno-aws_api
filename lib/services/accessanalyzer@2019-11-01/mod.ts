// Autogenerated API client for: Access Analyzer

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.91.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class AccessAnalyzer {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AccessAnalyzer.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2019-11-01",
    "endpointPrefix": "access-analyzer",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Access Analyzer",
    "serviceId": "AccessAnalyzer",
    "signatureVersion": "v4",
    "signingName": "access-analyzer",
    "uid": "accessanalyzer-2019-11-01"
  };

  async applyArchiveRule(
    {abortSignal, ...params}: RequestConfig & s.ApplyArchiveRuleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      ruleName: params["ruleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplyArchiveRule",
      method: "PUT",
      requestUri: "/archive-rule",
      responseCode: 200,
    });
  }

  async createAccessPreview(
    {abortSignal, ...params}: RequestConfig & s.CreateAccessPreviewRequest,
  ): Promise<s.CreateAccessPreviewResponse> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      configurations: jsonP.serializeMap(params["configurations"], x => fromConfiguration(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAccessPreview",
      method: "PUT",
      requestUri: "/access-preview",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "id": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createAnalyzer(
    {abortSignal, ...params}: RequestConfig & s.CreateAnalyzerRequest,
  ): Promise<s.CreateAnalyzerResponse> {
    const body: jsonP.JSONObject = {
      analyzerName: params["analyzerName"],
      archiveRules: params["archiveRules"]?.map(x => fromInlineArchiveRule(x)),
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      tags: params["tags"],
      type: params["type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAnalyzer",
      method: "PUT",
      requestUri: "/analyzer",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
      },
    }, await resp.json());
  }

  async createArchiveRule(
    {abortSignal, ...params}: RequestConfig & s.CreateArchiveRuleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      filter: jsonP.serializeMap(params["filter"], x => fromCriterion(x)),
      ruleName: params["ruleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateArchiveRule",
      method: "PUT",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule`,
      responseCode: 200,
    });
  }

  async deleteAnalyzer(
    {abortSignal, ...params}: RequestConfig & s.DeleteAnalyzerRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["clientToken"] != null) query.set("clientToken", params["clientToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteAnalyzer",
      method: "DELETE",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}`,
      responseCode: 200,
    });
  }

  async deleteArchiveRule(
    {abortSignal, ...params}: RequestConfig & s.DeleteArchiveRuleRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["clientToken"] != null) query.set("clientToken", params["clientToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteArchiveRule",
      method: "DELETE",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule/${params["ruleName"]}`,
      responseCode: 200,
    });
  }

  async getAccessPreview(
    {abortSignal, ...params}: RequestConfig & s.GetAccessPreviewRequest,
  ): Promise<s.GetAccessPreviewResponse> {
    const query = new URLSearchParams;
    query.set("analyzerArn", params["analyzerArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetAccessPreview",
      method: "GET",
      requestUri: cmnP.encodePath`/access-preview/${params["accessPreviewId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "accessPreview": toAccessPreview,
      },
      optional: {},
    }, await resp.json());
  }

  async getAnalyzedResource(
    {abortSignal, ...params}: RequestConfig & s.GetAnalyzedResourceRequest,
  ): Promise<s.GetAnalyzedResourceResponse> {
    const query = new URLSearchParams;
    query.set("analyzerArn", params["analyzerArn"]?.toString() ?? "");
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetAnalyzedResource",
      method: "GET",
      requestUri: "/analyzed-resource",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resource": toAnalyzedResource,
      },
    }, await resp.json());
  }

  async getAnalyzer(
    {abortSignal, ...params}: RequestConfig & s.GetAnalyzerRequest,
  ): Promise<s.GetAnalyzerResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAnalyzer",
      method: "GET",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "analyzer": toAnalyzerSummary,
      },
      optional: {},
    }, await resp.json());
  }

  async getArchiveRule(
    {abortSignal, ...params}: RequestConfig & s.GetArchiveRuleRequest,
  ): Promise<s.GetArchiveRuleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetArchiveRule",
      method: "GET",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule/${params["ruleName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "archiveRule": toArchiveRuleSummary,
      },
      optional: {},
    }, await resp.json());
  }

  async getFinding(
    {abortSignal, ...params}: RequestConfig & s.GetFindingRequest,
  ): Promise<s.GetFindingResponse> {
    const query = new URLSearchParams;
    query.set("analyzerArn", params["analyzerArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetFinding",
      method: "GET",
      requestUri: cmnP.encodePath`/finding/${params["id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "finding": toFinding,
      },
    }, await resp.json());
  }

  async listAccessPreviewFindings(
    {abortSignal, ...params}: RequestConfig & s.ListAccessPreviewFindingsRequest,
  ): Promise<s.ListAccessPreviewFindingsResponse> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      filter: jsonP.serializeMap(params["filter"], x => fromCriterion(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAccessPreviewFindings",
      requestUri: cmnP.encodePath`/access-preview/${params["accessPreviewId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "findings": [toAccessPreviewFinding],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAccessPreviews(
    {abortSignal, ...params}: RequestConfig & s.ListAccessPreviewsRequest,
  ): Promise<s.ListAccessPreviewsResponse> {
    const query = new URLSearchParams;
    query.set("analyzerArn", params["analyzerArn"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAccessPreviews",
      method: "GET",
      requestUri: "/access-preview",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "accessPreviews": [toAccessPreviewSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAnalyzedResources(
    {abortSignal, ...params}: RequestConfig & s.ListAnalyzedResourcesRequest,
  ): Promise<s.ListAnalyzedResourcesResponse> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      resourceType: params["resourceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAnalyzedResources",
      requestUri: "/analyzed-resource",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "analyzedResources": [toAnalyzedResourceSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAnalyzers(
    {abortSignal, ...params}: RequestConfig & s.ListAnalyzersRequest = {},
  ): Promise<s.ListAnalyzersResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["type"] != null) query.set("type", params["type"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAnalyzers",
      method: "GET",
      requestUri: "/analyzer",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "analyzers": [toAnalyzerSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listArchiveRules(
    {abortSignal, ...params}: RequestConfig & s.ListArchiveRulesRequest,
  ): Promise<s.ListArchiveRulesResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListArchiveRules",
      method: "GET",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "archiveRules": [toArchiveRuleSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFindings(
    {abortSignal, ...params}: RequestConfig & s.ListFindingsRequest,
  ): Promise<s.ListFindingsResponse> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      filter: jsonP.serializeMap(params["filter"], x => fromCriterion(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      sort: fromSortCriteria(params["sort"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFindings",
      requestUri: "/finding",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "findings": [toFindingSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async startResourceScan(
    {abortSignal, ...params}: RequestConfig & s.StartResourceScanRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartResourceScan",
      requestUri: "/resource/scan",
      responseCode: 200,
    });
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateArchiveRule(
    {abortSignal, ...params}: RequestConfig & s.UpdateArchiveRuleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      filter: jsonP.serializeMap(params["filter"], x => fromCriterion(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateArchiveRule",
      method: "PUT",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule/${params["ruleName"]}`,
      responseCode: 200,
    });
  }

  async updateFindings(
    {abortSignal, ...params}: RequestConfig & s.UpdateFindingsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      ids: params["ids"],
      resourceArn: params["resourceArn"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFindings",
      method: "PUT",
      requestUri: "/finding",
      responseCode: 200,
    });
  }

  async validatePolicy(
    {abortSignal, ...params}: RequestConfig & s.ValidatePolicyRequest,
  ): Promise<s.ValidatePolicyResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      locale: params["locale"],
      policyDocument: params["policyDocument"],
      policyType: params["policyType"],
    };
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ValidatePolicy",
      requestUri: "/policy/validation",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "findings": [toValidatePolicyFinding],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

}

function fromConfiguration(input?: s.Configuration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    iamRole: fromIamRoleConfiguration(input["iamRole"]),
    kmsKey: fromKmsKeyConfiguration(input["kmsKey"]),
    s3Bucket: fromS3BucketConfiguration(input["s3Bucket"]),
    secretsManagerSecret: fromSecretsManagerSecretConfiguration(input["secretsManagerSecret"]),
    sqsQueue: fromSqsQueueConfiguration(input["sqsQueue"]),
  }
}
function toConfiguration(root: jsonP.JSONValue): s.Configuration {
  return jsonP.readObj({
    required: {},
    optional: {
      "iamRole": toIamRoleConfiguration,
      "kmsKey": toKmsKeyConfiguration,
      "s3Bucket": toS3BucketConfiguration,
      "secretsManagerSecret": toSecretsManagerSecretConfiguration,
      "sqsQueue": toSqsQueueConfiguration,
    },
  }, root);
}

function fromIamRoleConfiguration(input?: s.IamRoleConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    trustPolicy: input["trustPolicy"],
  }
}
function toIamRoleConfiguration(root: jsonP.JSONValue): s.IamRoleConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "trustPolicy": "s",
    },
  }, root);
}

function fromKmsKeyConfiguration(input?: s.KmsKeyConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grants: input["grants"]?.map(x => fromKmsGrantConfiguration(x)),
    keyPolicies: input["keyPolicies"],
  }
}
function toKmsKeyConfiguration(root: jsonP.JSONValue): s.KmsKeyConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "grants": [toKmsGrantConfiguration],
      "keyPolicies": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromKmsGrantConfiguration(input?: s.KmsGrantConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constraints: fromKmsGrantConstraints(input["constraints"]),
    granteePrincipal: input["granteePrincipal"],
    issuingAccount: input["issuingAccount"],
    operations: input["operations"],
    retiringPrincipal: input["retiringPrincipal"],
  }
}
function toKmsGrantConfiguration(root: jsonP.JSONValue): s.KmsGrantConfiguration {
  return jsonP.readObj({
    required: {
      "granteePrincipal": "s",
      "issuingAccount": "s",
      "operations": [(x: jsonP.JSONValue) => cmnP.readEnum<s.KmsGrantOperation>(x)],
    },
    optional: {
      "constraints": toKmsGrantConstraints,
      "retiringPrincipal": "s",
    },
  }, root);
}

function fromKmsGrantConstraints(input?: s.KmsGrantConstraints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryptionContextEquals: input["encryptionContextEquals"],
    encryptionContextSubset: input["encryptionContextSubset"],
  }
}
function toKmsGrantConstraints(root: jsonP.JSONValue): s.KmsGrantConstraints {
  return jsonP.readObj({
    required: {},
    optional: {
      "encryptionContextEquals": x => jsonP.readMap(String, String, x),
      "encryptionContextSubset": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromS3BucketConfiguration(input?: s.S3BucketConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessPoints: jsonP.serializeMap(input["accessPoints"], x => fromS3AccessPointConfiguration(x)),
    bucketAclGrants: input["bucketAclGrants"]?.map(x => fromS3BucketAclGrantConfiguration(x)),
    bucketPolicy: input["bucketPolicy"],
    bucketPublicAccessBlock: fromS3PublicAccessBlockConfiguration(input["bucketPublicAccessBlock"]),
  }
}
function toS3BucketConfiguration(root: jsonP.JSONValue): s.S3BucketConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessPoints": x => jsonP.readMap(String, toS3AccessPointConfiguration, x),
      "bucketAclGrants": [toS3BucketAclGrantConfiguration],
      "bucketPolicy": "s",
      "bucketPublicAccessBlock": toS3PublicAccessBlockConfiguration,
    },
  }, root);
}

function fromS3AccessPointConfiguration(input?: s.S3AccessPointConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessPointPolicy: input["accessPointPolicy"],
    networkOrigin: fromNetworkOriginConfiguration(input["networkOrigin"]),
    publicAccessBlock: fromS3PublicAccessBlockConfiguration(input["publicAccessBlock"]),
  }
}
function toS3AccessPointConfiguration(root: jsonP.JSONValue): s.S3AccessPointConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessPointPolicy": "s",
      "networkOrigin": toNetworkOriginConfiguration,
      "publicAccessBlock": toS3PublicAccessBlockConfiguration,
    },
  }, root);
}

function fromNetworkOriginConfiguration(input?: s.NetworkOriginConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    internetConfiguration: fromInternetConfiguration(input["internetConfiguration"]),
    vpcConfiguration: fromVpcConfiguration(input["vpcConfiguration"]),
  }
}
function toNetworkOriginConfiguration(root: jsonP.JSONValue): s.NetworkOriginConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "internetConfiguration": toInternetConfiguration,
      "vpcConfiguration": toVpcConfiguration,
    },
  }, root);
}

function fromInternetConfiguration(input?: s.InternetConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toInternetConfiguration(root: jsonP.JSONValue): s.InternetConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromVpcConfiguration(input?: s.VpcConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    vpcId: input["vpcId"],
  }
}
function toVpcConfiguration(root: jsonP.JSONValue): s.VpcConfiguration {
  return jsonP.readObj({
    required: {
      "vpcId": "s",
    },
    optional: {},
  }, root);
}

function fromS3PublicAccessBlockConfiguration(input?: s.S3PublicAccessBlockConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ignorePublicAcls: input["ignorePublicAcls"],
    restrictPublicBuckets: input["restrictPublicBuckets"],
  }
}
function toS3PublicAccessBlockConfiguration(root: jsonP.JSONValue): s.S3PublicAccessBlockConfiguration {
  return jsonP.readObj({
    required: {
      "ignorePublicAcls": "b",
      "restrictPublicBuckets": "b",
    },
    optional: {},
  }, root);
}

function fromS3BucketAclGrantConfiguration(input?: s.S3BucketAclGrantConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grantee: fromAclGrantee(input["grantee"]),
    permission: input["permission"],
  }
}
function toS3BucketAclGrantConfiguration(root: jsonP.JSONValue): s.S3BucketAclGrantConfiguration {
  return jsonP.readObj({
    required: {
      "grantee": toAclGrantee,
      "permission": (x: jsonP.JSONValue) => cmnP.readEnum<s.AclPermission>(x),
    },
    optional: {},
  }, root);
}

function fromAclGrantee(input?: s.AclGrantee | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["id"],
    uri: input["uri"],
  }
}
function toAclGrantee(root: jsonP.JSONValue): s.AclGrantee {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "uri": "s",
    },
  }, root);
}

function fromSecretsManagerSecretConfiguration(input?: s.SecretsManagerSecretConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    kmsKeyId: input["kmsKeyId"],
    secretPolicy: input["secretPolicy"],
  }
}
function toSecretsManagerSecretConfiguration(root: jsonP.JSONValue): s.SecretsManagerSecretConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "kmsKeyId": "s",
      "secretPolicy": "s",
    },
  }, root);
}

function fromSqsQueueConfiguration(input?: s.SqsQueueConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    queuePolicy: input["queuePolicy"],
  }
}
function toSqsQueueConfiguration(root: jsonP.JSONValue): s.SqsQueueConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "queuePolicy": "s",
    },
  }, root);
}

function fromInlineArchiveRule(input?: s.InlineArchiveRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filter: jsonP.serializeMap(input["filter"], x => fromCriterion(x)),
    ruleName: input["ruleName"],
  }
}

function fromCriterion(input?: s.Criterion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    contains: input["contains"],
    eq: input["eq"],
    exists: input["exists"],
    neq: input["neq"],
  }
}
function toCriterion(root: jsonP.JSONValue): s.Criterion {
  return jsonP.readObj({
    required: {},
    optional: {
      "contains": ["s"],
      "eq": ["s"],
      "exists": "b",
      "neq": ["s"],
    },
  }, root);
}

function fromSortCriteria(input?: s.SortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attributeName: input["attributeName"],
    orderBy: input["orderBy"],
  }
}

function toAccessPreview(root: jsonP.JSONValue): s.AccessPreview {
  return jsonP.readObj({
    required: {
      "analyzerArn": "s",
      "configurations": x => jsonP.readMap(String, toConfiguration, x),
      "createdAt": "d",
      "id": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccessPreviewStatus>(x),
    },
    optional: {
      "statusReason": toAccessPreviewStatusReason,
    },
  }, root);
}

function toAccessPreviewStatusReason(root: jsonP.JSONValue): s.AccessPreviewStatusReason {
  return jsonP.readObj({
    required: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccessPreviewStatusReasonCode>(x),
    },
    optional: {},
  }, root);
}

function toAnalyzedResource(root: jsonP.JSONValue): s.AnalyzedResource {
  return jsonP.readObj({
    required: {
      "analyzedAt": "d",
      "createdAt": "d",
      "isPublic": "b",
      "resourceArn": "s",
      "resourceOwnerAccount": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "updatedAt": "d",
    },
    optional: {
      "actions": ["s"],
      "error": "s",
      "sharedVia": ["s"],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingStatus>(x),
    },
  }, root);
}

function toAnalyzerSummary(root: jsonP.JSONValue): s.AnalyzerSummary {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "name": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AnalyzerStatus>(x),
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.Type>(x),
    },
    optional: {
      "lastResourceAnalyzed": "s",
      "lastResourceAnalyzedAt": "d",
      "statusReason": toStatusReason,
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toStatusReason(root: jsonP.JSONValue): s.StatusReason {
  return jsonP.readObj({
    required: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReasonCode>(x),
    },
    optional: {},
  }, root);
}

function toArchiveRuleSummary(root: jsonP.JSONValue): s.ArchiveRuleSummary {
  return jsonP.readObj({
    required: {
      "createdAt": "d",
      "filter": x => jsonP.readMap(String, toCriterion, x),
      "ruleName": "s",
      "updatedAt": "d",
    },
    optional: {},
  }, root);
}

function toFinding(root: jsonP.JSONValue): s.Finding {
  return jsonP.readObj({
    required: {
      "analyzedAt": "d",
      "condition": x => jsonP.readMap(String, String, x),
      "createdAt": "d",
      "id": "s",
      "resourceOwnerAccount": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingStatus>(x),
      "updatedAt": "d",
    },
    optional: {
      "action": ["s"],
      "error": "s",
      "isPublic": "b",
      "principal": x => jsonP.readMap(String, String, x),
      "resource": "s",
      "sources": [toFindingSource],
    },
  }, root);
}

function toFindingSource(root: jsonP.JSONValue): s.FindingSource {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingSourceType>(x),
    },
    optional: {
      "detail": toFindingSourceDetail,
    },
  }, root);
}

function toFindingSourceDetail(root: jsonP.JSONValue): s.FindingSourceDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessPointArn": "s",
    },
  }, root);
}

function toAccessPreviewFinding(root: jsonP.JSONValue): s.AccessPreviewFinding {
  return jsonP.readObj({
    required: {
      "changeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingChangeType>(x),
      "createdAt": "d",
      "id": "s",
      "resourceOwnerAccount": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingStatus>(x),
    },
    optional: {
      "action": ["s"],
      "condition": x => jsonP.readMap(String, String, x),
      "error": "s",
      "existingFindingId": "s",
      "existingFindingStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingStatus>(x),
      "isPublic": "b",
      "principal": x => jsonP.readMap(String, String, x),
      "resource": "s",
      "sources": [toFindingSource],
    },
  }, root);
}

function toAccessPreviewSummary(root: jsonP.JSONValue): s.AccessPreviewSummary {
  return jsonP.readObj({
    required: {
      "analyzerArn": "s",
      "createdAt": "d",
      "id": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccessPreviewStatus>(x),
    },
    optional: {
      "statusReason": toAccessPreviewStatusReason,
    },
  }, root);
}

function toAnalyzedResourceSummary(root: jsonP.JSONValue): s.AnalyzedResourceSummary {
  return jsonP.readObj({
    required: {
      "resourceArn": "s",
      "resourceOwnerAccount": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
    },
    optional: {},
  }, root);
}

function toFindingSummary(root: jsonP.JSONValue): s.FindingSummary {
  return jsonP.readObj({
    required: {
      "analyzedAt": "d",
      "condition": x => jsonP.readMap(String, String, x),
      "createdAt": "d",
      "id": "s",
      "resourceOwnerAccount": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingStatus>(x),
      "updatedAt": "d",
    },
    optional: {
      "action": ["s"],
      "error": "s",
      "isPublic": "b",
      "principal": x => jsonP.readMap(String, String, x),
      "resource": "s",
      "sources": [toFindingSource],
    },
  }, root);
}

function toValidatePolicyFinding(root: jsonP.JSONValue): s.ValidatePolicyFinding {
  return jsonP.readObj({
    required: {
      "findingDetails": "s",
      "findingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ValidatePolicyFindingType>(x),
      "issueCode": "s",
      "learnMoreLink": "s",
      "locations": [toLocation],
    },
    optional: {},
  }, root);
}

function toLocation(root: jsonP.JSONValue): s.Location {
  return jsonP.readObj({
    required: {
      "path": [toPathElement],
      "span": toSpan,
    },
    optional: {},
  }, root);
}

function toPathElement(root: jsonP.JSONValue): s.PathElement {
  return jsonP.readObj({
    required: {},
    optional: {
      "index": "n",
      "key": "s",
      "substring": toSubstring,
      "value": "s",
    },
  }, root);
}

function toSubstring(root: jsonP.JSONValue): s.Substring {
  return jsonP.readObj({
    required: {
      "length": "n",
      "start": "n",
    },
    optional: {},
  }, root);
}

function toSpan(root: jsonP.JSONValue): s.Span {
  return jsonP.readObj({
    required: {
      "end": toPosition,
      "start": toPosition,
    },
    optional: {},
  }, root);
}

function toPosition(root: jsonP.JSONValue): s.Position {
  return jsonP.readObj({
    required: {
      "column": "n",
      "line": "n",
      "offset": "n",
    },
    optional: {},
  }, root);
}
