// Autogenerated API client for: Access Analyzer

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class AccessAnalyzer {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AccessAnalyzer.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2019-11-01",
    "endpointPrefix": "access-analyzer",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Access Analyzer",
    "serviceId": "AccessAnalyzer",
    "signatureVersion": "v4",
    "signingName": "access-analyzer",
    "uid": "accessanalyzer-2019-11-01"
  };

  async applyArchiveRule(
    {abortSignal, ...params}: RequestConfig & ApplyArchiveRuleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      ruleName: params["ruleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplyArchiveRule",
      method: "PUT",
      requestUri: "/archive-rule",
      responseCode: 200,
    });
  }

  async createAnalyzer(
    {abortSignal, ...params}: RequestConfig & CreateAnalyzerRequest,
  ): Promise<CreateAnalyzerResponse> {
    const body: jsonP.JSONObject = {
      analyzerName: params["analyzerName"],
      archiveRules: params["archiveRules"]?.map(x => fromInlineArchiveRule(x)),
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      tags: params["tags"],
      type: params["type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAnalyzer",
      method: "PUT",
      requestUri: "/analyzer",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
      },
    }, await resp.json());
  }

  async createArchiveRule(
    {abortSignal, ...params}: RequestConfig & CreateArchiveRuleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      filter: jsonP.serializeMap(params["filter"], x => fromCriterion(x)),
      ruleName: params["ruleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateArchiveRule",
      method: "PUT",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule`,
      responseCode: 200,
    });
  }

  async deleteAnalyzer(
    {abortSignal, ...params}: RequestConfig & DeleteAnalyzerRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["clientToken"] != null) query.set("clientToken", params["clientToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteAnalyzer",
      method: "DELETE",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}`,
      responseCode: 200,
    });
  }

  async deleteArchiveRule(
    {abortSignal, ...params}: RequestConfig & DeleteArchiveRuleRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["clientToken"] != null) query.set("clientToken", params["clientToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteArchiveRule",
      method: "DELETE",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule/${params["ruleName"]}`,
      responseCode: 200,
    });
  }

  async getAnalyzedResource(
    {abortSignal, ...params}: RequestConfig & GetAnalyzedResourceRequest,
  ): Promise<GetAnalyzedResourceResponse> {
    const query = new URLSearchParams;
    query.set("analyzerArn", params["analyzerArn"]?.toString() ?? "");
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetAnalyzedResource",
      method: "GET",
      requestUri: "/analyzed-resource",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resource": toAnalyzedResource,
      },
    }, await resp.json());
  }

  async getAnalyzer(
    {abortSignal, ...params}: RequestConfig & GetAnalyzerRequest,
  ): Promise<GetAnalyzerResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAnalyzer",
      method: "GET",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "analyzer": toAnalyzerSummary,
      },
      optional: {},
    }, await resp.json());
  }

  async getArchiveRule(
    {abortSignal, ...params}: RequestConfig & GetArchiveRuleRequest,
  ): Promise<GetArchiveRuleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetArchiveRule",
      method: "GET",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule/${params["ruleName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "archiveRule": toArchiveRuleSummary,
      },
      optional: {},
    }, await resp.json());
  }

  async getFinding(
    {abortSignal, ...params}: RequestConfig & GetFindingRequest,
  ): Promise<GetFindingResponse> {
    const query = new URLSearchParams;
    query.set("analyzerArn", params["analyzerArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetFinding",
      method: "GET",
      requestUri: cmnP.encodePath`/finding/${params["id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "finding": toFinding,
      },
    }, await resp.json());
  }

  async listAnalyzedResources(
    {abortSignal, ...params}: RequestConfig & ListAnalyzedResourcesRequest,
  ): Promise<ListAnalyzedResourcesResponse> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      resourceType: params["resourceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAnalyzedResources",
      requestUri: "/analyzed-resource",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "analyzedResources": [toAnalyzedResourceSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAnalyzers(
    {abortSignal, ...params}: RequestConfig & ListAnalyzersRequest = {},
  ): Promise<ListAnalyzersResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["type"] != null) query.set("type", params["type"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAnalyzers",
      method: "GET",
      requestUri: "/analyzer",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "analyzers": [toAnalyzerSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listArchiveRules(
    {abortSignal, ...params}: RequestConfig & ListArchiveRulesRequest,
  ): Promise<ListArchiveRulesResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListArchiveRules",
      method: "GET",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "archiveRules": [toArchiveRuleSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFindings(
    {abortSignal, ...params}: RequestConfig & ListFindingsRequest,
  ): Promise<ListFindingsResponse> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      filter: jsonP.serializeMap(params["filter"], x => fromCriterion(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      sort: fromSortCriteria(params["sort"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFindings",
      requestUri: "/finding",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "findings": [toFindingSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async startResourceScan(
    {abortSignal, ...params}: RequestConfig & StartResourceScanRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartResourceScan",
      requestUri: "/resource/scan",
      responseCode: 200,
    });
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateArchiveRule(
    {abortSignal, ...params}: RequestConfig & UpdateArchiveRuleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      filter: jsonP.serializeMap(params["filter"], x => fromCriterion(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateArchiveRule",
      method: "PUT",
      requestUri: cmnP.encodePath`/analyzer/${params["analyzerName"]}/archive-rule/${params["ruleName"]}`,
      responseCode: 200,
    });
  }

  async updateFindings(
    {abortSignal, ...params}: RequestConfig & UpdateFindingsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      analyzerArn: params["analyzerArn"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      ids: params["ids"],
      resourceArn: params["resourceArn"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFindings",
      method: "PUT",
      requestUri: "/finding",
      responseCode: 200,
    });
  }

}

// refs: 1 - tags: named, input
export interface ApplyArchiveRuleRequest {
  analyzerArn: string;
  clientToken?: string | null;
  ruleName: string;
}

// refs: 1 - tags: named, input
export interface CreateAnalyzerRequest {
  analyzerName: string;
  archiveRules?: InlineArchiveRule[] | null;
  clientToken?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
  type: Type;
}

// refs: 1 - tags: named, input
export interface CreateArchiveRuleRequest {
  analyzerName: string;
  clientToken?: string | null;
  filter: { [key: string]: Criterion | null | undefined };
  ruleName: string;
}

// refs: 1 - tags: named, input
export interface DeleteAnalyzerRequest {
  analyzerName: string;
  clientToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteArchiveRuleRequest {
  analyzerName: string;
  clientToken?: string | null;
  ruleName: string;
}

// refs: 1 - tags: named, input
export interface GetAnalyzedResourceRequest {
  analyzerArn: string;
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface GetAnalyzerRequest {
  analyzerName: string;
}

// refs: 1 - tags: named, input
export interface GetArchiveRuleRequest {
  analyzerName: string;
  ruleName: string;
}

// refs: 1 - tags: named, input
export interface GetFindingRequest {
  analyzerArn: string;
  id: string;
}

// refs: 1 - tags: named, input
export interface ListAnalyzedResourcesRequest {
  analyzerArn: string;
  maxResults?: number | null;
  nextToken?: string | null;
  resourceType?: ResourceType | null;
}

// refs: 1 - tags: named, input
export interface ListAnalyzersRequest {
  maxResults?: number | null;
  nextToken?: string | null;
  type?: Type | null;
}

// refs: 1 - tags: named, input
export interface ListArchiveRulesRequest {
  analyzerName: string;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListFindingsRequest {
  analyzerArn: string;
  filter?: { [key: string]: Criterion | null | undefined } | null;
  maxResults?: number | null;
  nextToken?: string | null;
  sort?: SortCriteria | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface StartResourceScanRequest {
  analyzerArn: string;
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateArchiveRuleRequest {
  analyzerName: string;
  clientToken?: string | null;
  filter: { [key: string]: Criterion | null | undefined };
  ruleName: string;
}

// refs: 1 - tags: named, input
export interface UpdateFindingsRequest {
  analyzerArn: string;
  clientToken?: string | null;
  ids?: string[] | null;
  resourceArn?: string | null;
  status: FindingStatusUpdate;
}

// refs: 1 - tags: named, output
export interface CreateAnalyzerResponse {
  arn?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAnalyzedResourceResponse {
  resource?: AnalyzedResource | null;
}

// refs: 1 - tags: named, output
export interface GetAnalyzerResponse {
  analyzer: AnalyzerSummary;
}

// refs: 1 - tags: named, output
export interface GetArchiveRuleResponse {
  archiveRule: ArchiveRuleSummary;
}

// refs: 1 - tags: named, output
export interface GetFindingResponse {
  finding?: Finding | null;
}

// refs: 1 - tags: named, output
export interface ListAnalyzedResourcesResponse {
  analyzedResources: AnalyzedResourceSummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAnalyzersResponse {
  analyzers: AnalyzerSummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListArchiveRulesResponse {
  archiveRules: ArchiveRuleSummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListFindingsResponse {
  findings: FindingSummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: input, named, interface
export interface InlineArchiveRule {
  filter: { [key: string]: Criterion | null | undefined };
  ruleName: string;
}
function fromInlineArchiveRule(input?: InlineArchiveRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filter: jsonP.serializeMap(input["filter"], x => fromCriterion(x)),
    ruleName: input["ruleName"],
  }
}

// refs: 6 - tags: input, named, interface, output
export interface Criterion {
  contains?: string[] | null;
  eq?: string[] | null;
  exists?: boolean | null;
  neq?: string[] | null;
}
function fromCriterion(input?: Criterion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    contains: input["contains"],
    eq: input["eq"],
    exists: input["exists"],
    neq: input["neq"],
  }
}
function toCriterion(root: jsonP.JSONValue): Criterion {
  return jsonP.readObj({
    required: {},
    optional: {
      "contains": ["s"],
      "eq": ["s"],
      "exists": "b",
      "neq": ["s"],
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type Type =
| "ACCOUNT"
| "ORGANIZATION"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type ResourceType =
| "AWS::S3::Bucket"
| "AWS::IAM::Role"
| "AWS::SQS::Queue"
| "AWS::Lambda::Function"
| "AWS::Lambda::LayerVersion"
| "AWS::KMS::Key"
| "AWS::SecretsManager::Secret"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SortCriteria {
  attributeName?: string | null;
  orderBy?: OrderBy | null;
}
function fromSortCriteria(input?: SortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attributeName: input["attributeName"],
    orderBy: input["orderBy"],
  }
}

// refs: 1 - tags: input, named, enum
export type OrderBy =
| "ASC"
| "DESC"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type FindingStatusUpdate =
| "ACTIVE"
| "ARCHIVED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AnalyzedResource {
  actions?: string[] | null;
  analyzedAt: Date | number;
  createdAt: Date | number;
  error?: string | null;
  isPublic: boolean;
  resourceArn: string;
  resourceOwnerAccount: string;
  resourceType: ResourceType;
  sharedVia?: string[] | null;
  status?: FindingStatus | null;
  updatedAt: Date | number;
}
function toAnalyzedResource(root: jsonP.JSONValue): AnalyzedResource {
  return jsonP.readObj({
    required: {
      "analyzedAt": "d",
      "createdAt": "d",
      "isPublic": "b",
      "resourceArn": "s",
      "resourceOwnerAccount": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
      "updatedAt": "d",
    },
    optional: {
      "actions": ["s"],
      "error": "s",
      "sharedVia": ["s"],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<FindingStatus>(x),
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type FindingStatus =
| "ACTIVE"
| "ARCHIVED"
| "RESOLVED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface AnalyzerSummary {
  arn: string;
  createdAt: Date | number;
  lastResourceAnalyzed?: string | null;
  lastResourceAnalyzedAt?: Date | number | null;
  name: string;
  status: AnalyzerStatus;
  statusReason?: StatusReason | null;
  tags?: { [key: string]: string | null | undefined } | null;
  type: Type;
}
function toAnalyzerSummary(root: jsonP.JSONValue): AnalyzerSummary {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "name": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<AnalyzerStatus>(x),
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<Type>(x),
    },
    optional: {
      "lastResourceAnalyzed": "s",
      "lastResourceAnalyzedAt": "d",
      "statusReason": toStatusReason,
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type AnalyzerStatus =
| "ACTIVE"
| "CREATING"
| "DISABLED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface StatusReason {
  code: ReasonCode;
}
function toStatusReason(root: jsonP.JSONValue): StatusReason {
  return jsonP.readObj({
    required: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<ReasonCode>(x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ReasonCode =
| "AWS_SERVICE_ACCESS_DISABLED"
| "DELEGATED_ADMINISTRATOR_DEREGISTERED"
| "ORGANIZATION_DELETED"
| "SERVICE_LINKED_ROLE_CREATION_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ArchiveRuleSummary {
  createdAt: Date | number;
  filter: { [key: string]: Criterion | null | undefined };
  ruleName: string;
  updatedAt: Date | number;
}
function toArchiveRuleSummary(root: jsonP.JSONValue): ArchiveRuleSummary {
  return jsonP.readObj({
    required: {
      "createdAt": "d",
      "filter": x => jsonP.readMap(String, toCriterion, x),
      "ruleName": "s",
      "updatedAt": "d",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Finding {
  action?: string[] | null;
  analyzedAt: Date | number;
  condition: { [key: string]: string | null | undefined };
  createdAt: Date | number;
  error?: string | null;
  id: string;
  isPublic?: boolean | null;
  principal?: { [key: string]: string | null | undefined } | null;
  resource?: string | null;
  resourceOwnerAccount: string;
  resourceType: ResourceType;
  sources?: FindingSource[] | null;
  status: FindingStatus;
  updatedAt: Date | number;
}
function toFinding(root: jsonP.JSONValue): Finding {
  return jsonP.readObj({
    required: {
      "analyzedAt": "d",
      "condition": x => jsonP.readMap(String, String, x),
      "createdAt": "d",
      "id": "s",
      "resourceOwnerAccount": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<FindingStatus>(x),
      "updatedAt": "d",
    },
    optional: {
      "action": ["s"],
      "error": "s",
      "isPublic": "b",
      "principal": x => jsonP.readMap(String, String, x),
      "resource": "s",
      "sources": [toFindingSource],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface FindingSource {
  detail?: FindingSourceDetail | null;
  type: FindingSourceType;
}
function toFindingSource(root: jsonP.JSONValue): FindingSource {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<FindingSourceType>(x),
    },
    optional: {
      "detail": toFindingSourceDetail,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface FindingSourceDetail {
  accessPointArn?: string | null;
}
function toFindingSourceDetail(root: jsonP.JSONValue): FindingSourceDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessPointArn": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type FindingSourceType =
| "POLICY"
| "BUCKET_ACL"
| "S3_ACCESS_POINT"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AnalyzedResourceSummary {
  resourceArn: string;
  resourceOwnerAccount: string;
  resourceType: ResourceType;
}
function toAnalyzedResourceSummary(root: jsonP.JSONValue): AnalyzedResourceSummary {
  return jsonP.readObj({
    required: {
      "resourceArn": "s",
      "resourceOwnerAccount": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FindingSummary {
  action?: string[] | null;
  analyzedAt: Date | number;
  condition: { [key: string]: string | null | undefined };
  createdAt: Date | number;
  error?: string | null;
  id: string;
  isPublic?: boolean | null;
  principal?: { [key: string]: string | null | undefined } | null;
  resource?: string | null;
  resourceOwnerAccount: string;
  resourceType: ResourceType;
  sources?: FindingSource[] | null;
  status: FindingStatus;
  updatedAt: Date | number;
}
function toFindingSummary(root: jsonP.JSONValue): FindingSummary {
  return jsonP.readObj({
    required: {
      "analyzedAt": "d",
      "condition": x => jsonP.readMap(String, String, x),
      "createdAt": "d",
      "id": "s",
      "resourceOwnerAccount": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<FindingStatus>(x),
      "updatedAt": "d",
    },
    optional: {
      "action": ["s"],
      "error": "s",
      "isPublic": "b",
      "principal": x => jsonP.readMap(String, String, x),
      "resource": "s",
      "sources": [toFindingSource],
    },
  }, root);
}
