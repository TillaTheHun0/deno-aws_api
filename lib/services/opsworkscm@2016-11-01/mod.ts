// Autogenerated API client for: AWS OpsWorks CM

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class OpsWorksCM {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(OpsWorksCM.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-11-01",
    "endpointPrefix": "opsworks-cm",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "OpsWorksCM",
    "serviceFullName": "AWS OpsWorks CM",
    "serviceId": "OpsWorksCM",
    "signatureVersion": "v4",
    "signingName": "opsworks-cm",
    "targetPrefix": "OpsWorksCM_V2016_11_01",
    "uid": "opsworkscm-2016-11-01"
  };

  async associateNode(
    {abortSignal, ...params}: RequestConfig & s.AssociateNodeRequest,
  ): Promise<s.AssociateNodeResponse> {
    const body: jsonP.JSONObject = {
      ServerName: params["ServerName"],
      NodeName: params["NodeName"],
      EngineAttributes: params["EngineAttributes"]?.map(x => fromEngineAttribute(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateNode",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NodeAssociationStatusToken": "s",
      },
    }, await resp.json());
  }

  async createBackup(
    {abortSignal, ...params}: RequestConfig & s.CreateBackupRequest,
  ): Promise<s.CreateBackupResponse> {
    const body: jsonP.JSONObject = {
      ServerName: params["ServerName"],
      Description: params["Description"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Backup": toBackup,
      },
    }, await resp.json());
  }

  async createServer(
    {abortSignal, ...params}: RequestConfig & s.CreateServerRequest,
  ): Promise<s.CreateServerResponse> {
    const body: jsonP.JSONObject = {
      AssociatePublicIpAddress: params["AssociatePublicIpAddress"],
      CustomDomain: params["CustomDomain"],
      CustomCertificate: params["CustomCertificate"],
      CustomPrivateKey: params["CustomPrivateKey"],
      DisableAutomatedBackup: params["DisableAutomatedBackup"],
      Engine: params["Engine"],
      EngineModel: params["EngineModel"],
      EngineVersion: params["EngineVersion"],
      EngineAttributes: params["EngineAttributes"]?.map(x => fromEngineAttribute(x)),
      BackupRetentionCount: params["BackupRetentionCount"],
      ServerName: params["ServerName"],
      InstanceProfileArn: params["InstanceProfileArn"],
      InstanceType: params["InstanceType"],
      KeyPair: params["KeyPair"],
      PreferredMaintenanceWindow: params["PreferredMaintenanceWindow"],
      PreferredBackupWindow: params["PreferredBackupWindow"],
      SecurityGroupIds: params["SecurityGroupIds"],
      ServiceRoleArn: params["ServiceRoleArn"],
      SubnetIds: params["SubnetIds"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      BackupId: params["BackupId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Server": toServer,
      },
    }, await resp.json());
  }

  async deleteBackup(
    {abortSignal, ...params}: RequestConfig & s.DeleteBackupRequest,
  ): Promise<s.DeleteBackupResponse> {
    const body: jsonP.JSONObject = {
      BackupId: params["BackupId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteServer(
    {abortSignal, ...params}: RequestConfig & s.DeleteServerRequest,
  ): Promise<s.DeleteServerResponse> {
    const body: jsonP.JSONObject = {
      ServerName: params["ServerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeAccountAttributes(
    {abortSignal, ...params}: RequestConfig & s.DescribeAccountAttributesRequest = {},
  ): Promise<s.DescribeAccountAttributesResponse> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": [toAccountAttribute],
      },
    }, await resp.json());
  }

  async describeBackups(
    {abortSignal, ...params}: RequestConfig & s.DescribeBackupsRequest = {},
  ): Promise<s.DescribeBackupsResponse> {
    const body: jsonP.JSONObject = {
      BackupId: params["BackupId"],
      ServerName: params["ServerName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBackups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Backups": [toBackup],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsRequest,
  ): Promise<s.DescribeEventsResponse> {
    const body: jsonP.JSONObject = {
      ServerName: params["ServerName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ServerEvents": [toServerEvent],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeNodeAssociationStatus(
    {abortSignal, ...params}: RequestConfig & s.DescribeNodeAssociationStatusRequest,
  ): Promise<s.DescribeNodeAssociationStatusResponse> {
    const body: jsonP.JSONObject = {
      NodeAssociationStatusToken: params["NodeAssociationStatusToken"],
      ServerName: params["ServerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNodeAssociationStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NodeAssociationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.NodeAssociationStatus>(x),
        "EngineAttributes": [toEngineAttribute],
      },
    }, await resp.json());
  }

  async describeServers(
    {abortSignal, ...params}: RequestConfig & s.DescribeServersRequest = {},
  ): Promise<s.DescribeServersResponse> {
    const body: jsonP.JSONObject = {
      ServerName: params["ServerName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Servers": [toServer],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async disassociateNode(
    {abortSignal, ...params}: RequestConfig & s.DisassociateNodeRequest,
  ): Promise<s.DisassociateNodeResponse> {
    const body: jsonP.JSONObject = {
      ServerName: params["ServerName"],
      NodeName: params["NodeName"],
      EngineAttributes: params["EngineAttributes"]?.map(x => fromEngineAttribute(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateNode",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NodeAssociationStatusToken": "s",
      },
    }, await resp.json());
  }

  async exportServerEngineAttribute(
    {abortSignal, ...params}: RequestConfig & s.ExportServerEngineAttributeRequest,
  ): Promise<s.ExportServerEngineAttributeResponse> {
    const body: jsonP.JSONObject = {
      ExportAttributeName: params["ExportAttributeName"],
      ServerName: params["ServerName"],
      InputAttributes: params["InputAttributes"]?.map(x => fromEngineAttribute(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportServerEngineAttribute",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EngineAttribute": toEngineAttribute,
        "ServerName": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async restoreServer(
    {abortSignal, ...params}: RequestConfig & s.RestoreServerRequest,
  ): Promise<s.RestoreServerResponse> {
    const body: jsonP.JSONObject = {
      BackupId: params["BackupId"],
      ServerName: params["ServerName"],
      InstanceType: params["InstanceType"],
      KeyPair: params["KeyPair"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startMaintenance(
    {abortSignal, ...params}: RequestConfig & s.StartMaintenanceRequest,
  ): Promise<s.StartMaintenanceResponse> {
    const body: jsonP.JSONObject = {
      ServerName: params["ServerName"],
      EngineAttributes: params["EngineAttributes"]?.map(x => fromEngineAttribute(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMaintenance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Server": toServer,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateServer(
    {abortSignal, ...params}: RequestConfig & s.UpdateServerRequest,
  ): Promise<s.UpdateServerResponse> {
    const body: jsonP.JSONObject = {
      DisableAutomatedBackup: params["DisableAutomatedBackup"],
      BackupRetentionCount: params["BackupRetentionCount"],
      ServerName: params["ServerName"],
      PreferredMaintenanceWindow: params["PreferredMaintenanceWindow"],
      PreferredBackupWindow: params["PreferredBackupWindow"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Server": toServer,
      },
    }, await resp.json());
  }

  async updateServerEngineAttributes(
    {abortSignal, ...params}: RequestConfig & s.UpdateServerEngineAttributesRequest,
  ): Promise<s.UpdateServerEngineAttributesResponse> {
    const body: jsonP.JSONObject = {
      ServerName: params["ServerName"],
      AttributeName: params["AttributeName"],
      AttributeValue: params["AttributeValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServerEngineAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Server": toServer,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /**
   * Wait until node is associated or disassociated.
   * Checks state up to 15 times, 15 seconds apart (about 4 minutes max wait time).
   */
  async waitForNodeAssociated(
    params: RequestConfig & s.DescribeNodeAssociationStatusRequest,
  ): Promise<s.DescribeNodeAssociationStatusResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NodeAssociated';
    for (let i = 0; i < 15; i++) {
      const resp = await this.describeNodeAssociationStatus(params);
      const field = resp?.NodeAssociationStatus;
      if (field === "SUCCESS") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

function fromEngineAttribute(input?: s.EngineAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}
function toEngineAttribute(root: jsonP.JSONValue): s.EngineAttribute {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Value": "s",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function toBackup(root: jsonP.JSONValue): s.Backup {
  return jsonP.readObj({
    required: {},
    optional: {
      "BackupArn": "s",
      "BackupId": "s",
      "BackupType": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackupType>(x),
      "CreatedAt": "d",
      "Description": "s",
      "Engine": "s",
      "EngineModel": "s",
      "EngineVersion": "s",
      "InstanceProfileArn": "s",
      "InstanceType": "s",
      "KeyPair": "s",
      "PreferredBackupWindow": "s",
      "PreferredMaintenanceWindow": "s",
      "S3DataSize": "n",
      "S3DataUrl": "s",
      "S3LogUrl": "s",
      "SecurityGroupIds": ["s"],
      "ServerName": "s",
      "ServiceRoleArn": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackupStatus>(x),
      "StatusDescription": "s",
      "SubnetIds": ["s"],
      "ToolsVersion": "s",
      "UserArn": "s",
    },
  }, root);
}

function toServer(root: jsonP.JSONValue): s.Server {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssociatePublicIpAddress": "b",
      "BackupRetentionCount": "n",
      "ServerName": "s",
      "CreatedAt": "d",
      "CloudFormationStackArn": "s",
      "CustomDomain": "s",
      "DisableAutomatedBackup": "b",
      "Endpoint": "s",
      "Engine": "s",
      "EngineModel": "s",
      "EngineAttributes": [toEngineAttribute],
      "EngineVersion": "s",
      "InstanceProfileArn": "s",
      "InstanceType": "s",
      "KeyPair": "s",
      "MaintenanceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceStatus>(x),
      "PreferredMaintenanceWindow": "s",
      "PreferredBackupWindow": "s",
      "SecurityGroupIds": ["s"],
      "ServiceRoleArn": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ServerStatus>(x),
      "StatusReason": "s",
      "SubnetIds": ["s"],
      "ServerArn": "s",
    },
  }, root);
}

function toAccountAttribute(root: jsonP.JSONValue): s.AccountAttribute {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Maximum": "n",
      "Used": "n",
    },
  }, root);
}

function toServerEvent(root: jsonP.JSONValue): s.ServerEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreatedAt": "d",
      "ServerName": "s",
      "Message": "s",
      "LogUrl": "s",
    },
  }, root);
}
