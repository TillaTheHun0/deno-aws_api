// Autogenerated API client for: AWS AppSync

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class AppSync {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AppSync.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-07-25",
    "endpointPrefix": "appsync",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "AWSAppSync",
    "serviceFullName": "AWS AppSync",
    "serviceId": "AppSync",
    "signatureVersion": "v4",
    "signingName": "appsync",
    "uid": "appsync-2017-07-25"
  };

  async createApiCache(
    {abortSignal, ...params}: RequestConfig & s.CreateApiCacheRequest,
  ): Promise<s.CreateApiCacheResponse> {
    const body: jsonP.JSONObject = {
      ttl: params["ttl"],
      transitEncryptionEnabled: params["transitEncryptionEnabled"],
      atRestEncryptionEnabled: params["atRestEncryptionEnabled"],
      apiCachingBehavior: params["apiCachingBehavior"],
      type: params["type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApiCache",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/ApiCaches`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "apiCache": toApiCache,
      },
    }, await resp.json());
  }

  async createApiKey(
    {abortSignal, ...params}: RequestConfig & s.CreateApiKeyRequest,
  ): Promise<s.CreateApiKeyResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      expires: params["expires"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApiKey",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/apikeys`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "apiKey": toApiKey,
      },
    }, await resp.json());
  }

  async createDataSource(
    {abortSignal, ...params}: RequestConfig & s.CreateDataSourceRequest,
  ): Promise<s.CreateDataSourceResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      type: params["type"],
      serviceRoleArn: params["serviceRoleArn"],
      dynamodbConfig: fromDynamodbDataSourceConfig(params["dynamodbConfig"]),
      lambdaConfig: fromLambdaDataSourceConfig(params["lambdaConfig"]),
      elasticsearchConfig: fromElasticsearchDataSourceConfig(params["elasticsearchConfig"]),
      httpConfig: fromHttpDataSourceConfig(params["httpConfig"]),
      relationalDatabaseConfig: fromRelationalDatabaseDataSourceConfig(params["relationalDatabaseConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataSource",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/datasources`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "dataSource": toDataSource,
      },
    }, await resp.json());
  }

  async createFunction(
    {abortSignal, ...params}: RequestConfig & s.CreateFunctionRequest,
  ): Promise<s.CreateFunctionResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      dataSourceName: params["dataSourceName"],
      requestMappingTemplate: params["requestMappingTemplate"],
      responseMappingTemplate: params["responseMappingTemplate"],
      functionVersion: params["functionVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFunction",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/functions`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "functionConfiguration": toFunctionConfiguration,
      },
    }, await resp.json());
  }

  async createGraphqlApi(
    {abortSignal, ...params}: RequestConfig & s.CreateGraphqlApiRequest,
  ): Promise<s.CreateGraphqlApiResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      logConfig: fromLogConfig(params["logConfig"]),
      authenticationType: params["authenticationType"],
      userPoolConfig: fromUserPoolConfig(params["userPoolConfig"]),
      openIDConnectConfig: fromOpenIDConnectConfig(params["openIDConnectConfig"]),
      tags: params["tags"],
      additionalAuthenticationProviders: params["additionalAuthenticationProviders"]?.map(x => fromAdditionalAuthenticationProvider(x)),
      xrayEnabled: params["xrayEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGraphqlApi",
      requestUri: "/v1/apis",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "graphqlApi": toGraphqlApi,
      },
    }, await resp.json());
  }

  async createResolver(
    {abortSignal, ...params}: RequestConfig & s.CreateResolverRequest,
  ): Promise<s.CreateResolverResponse> {
    const body: jsonP.JSONObject = {
      fieldName: params["fieldName"],
      dataSourceName: params["dataSourceName"],
      requestMappingTemplate: params["requestMappingTemplate"],
      responseMappingTemplate: params["responseMappingTemplate"],
      kind: params["kind"],
      pipelineConfig: fromPipelineConfig(params["pipelineConfig"]),
      syncConfig: fromSyncConfig(params["syncConfig"]),
      cachingConfig: fromCachingConfig(params["cachingConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateResolver",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types/${params["typeName"]}/resolvers`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resolver": toResolver,
      },
    }, await resp.json());
  }

  async createType(
    {abortSignal, ...params}: RequestConfig & s.CreateTypeRequest,
  ): Promise<s.CreateTypeResponse> {
    const body: jsonP.JSONObject = {
      definition: params["definition"],
      format: params["format"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateType",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "type": toType,
      },
    }, await resp.json());
  }

  async deleteApiCache(
    {abortSignal, ...params}: RequestConfig & s.DeleteApiCacheRequest,
  ): Promise<s.DeleteApiCacheResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApiCache",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/ApiCaches`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteApiKey(
    {abortSignal, ...params}: RequestConfig & s.DeleteApiKeyRequest,
  ): Promise<s.DeleteApiKeyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApiKey",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/apikeys/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDataSource(
    {abortSignal, ...params}: RequestConfig & s.DeleteDataSourceRequest,
  ): Promise<s.DeleteDataSourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDataSource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/datasources/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteFunction(
    {abortSignal, ...params}: RequestConfig & s.DeleteFunctionRequest,
  ): Promise<s.DeleteFunctionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteFunction",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/functions/${params["functionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteGraphqlApi(
    {abortSignal, ...params}: RequestConfig & s.DeleteGraphqlApiRequest,
  ): Promise<s.DeleteGraphqlApiResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteGraphqlApi",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteResolver(
    {abortSignal, ...params}: RequestConfig & s.DeleteResolverRequest,
  ): Promise<s.DeleteResolverResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteResolver",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types/${params["typeName"]}/resolvers/${params["fieldName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteType(
    {abortSignal, ...params}: RequestConfig & s.DeleteTypeRequest,
  ): Promise<s.DeleteTypeResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteType",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types/${params["typeName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async flushApiCache(
    {abortSignal, ...params}: RequestConfig & s.FlushApiCacheRequest,
  ): Promise<s.FlushApiCacheResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "FlushApiCache",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/FlushCache`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async getApiCache(
    {abortSignal, ...params}: RequestConfig & s.GetApiCacheRequest,
  ): Promise<s.GetApiCacheResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApiCache",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/ApiCaches`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "apiCache": toApiCache,
      },
    }, await resp.json());
  }

  async getDataSource(
    {abortSignal, ...params}: RequestConfig & s.GetDataSourceRequest,
  ): Promise<s.GetDataSourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDataSource",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/datasources/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "dataSource": toDataSource,
      },
    }, await resp.json());
  }

  async getFunction(
    {abortSignal, ...params}: RequestConfig & s.GetFunctionRequest,
  ): Promise<s.GetFunctionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFunction",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/functions/${params["functionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "functionConfiguration": toFunctionConfiguration,
      },
    }, await resp.json());
  }

  async getGraphqlApi(
    {abortSignal, ...params}: RequestConfig & s.GetGraphqlApiRequest,
  ): Promise<s.GetGraphqlApiResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetGraphqlApi",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "graphqlApi": toGraphqlApi,
      },
    }, await resp.json());
  }

  async getIntrospectionSchema(
    {abortSignal, ...params}: RequestConfig & s.GetIntrospectionSchemaRequest,
  ): Promise<s.GetIntrospectionSchemaResponse> {
    const query = new URLSearchParams;
    query.set("format", params["format"]?.toString() ?? "");
    if (params["includeDirectives"] != null) query.set("includeDirectives", params["includeDirectives"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetIntrospectionSchema",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/schema`,
    });
  return {
    schema: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getResolver(
    {abortSignal, ...params}: RequestConfig & s.GetResolverRequest,
  ): Promise<s.GetResolverResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetResolver",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types/${params["typeName"]}/resolvers/${params["fieldName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resolver": toResolver,
      },
    }, await resp.json());
  }

  async getSchemaCreationStatus(
    {abortSignal, ...params}: RequestConfig & s.GetSchemaCreationStatusRequest,
  ): Promise<s.GetSchemaCreationStatusResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSchemaCreationStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/schemacreation`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaStatus>(x),
        "details": "s",
      },
    }, await resp.json());
  }

  async getType(
    {abortSignal, ...params}: RequestConfig & s.GetTypeRequest,
  ): Promise<s.GetTypeResponse> {
    const query = new URLSearchParams;
    query.set("format", params["format"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetType",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types/${params["typeName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "type": toType,
      },
    }, await resp.json());
  }

  async listApiKeys(
    {abortSignal, ...params}: RequestConfig & s.ListApiKeysRequest,
  ): Promise<s.ListApiKeysResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListApiKeys",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/apikeys`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "apiKeys": [toApiKey],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDataSources(
    {abortSignal, ...params}: RequestConfig & s.ListDataSourcesRequest,
  ): Promise<s.ListDataSourcesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDataSources",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/datasources`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "dataSources": [toDataSource],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFunctions(
    {abortSignal, ...params}: RequestConfig & s.ListFunctionsRequest,
  ): Promise<s.ListFunctionsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFunctions",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/functions`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "functions": [toFunctionConfiguration],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listGraphqlApis(
    {abortSignal, ...params}: RequestConfig & s.ListGraphqlApisRequest = {},
  ): Promise<s.ListGraphqlApisResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListGraphqlApis",
      method: "GET",
      requestUri: "/v1/apis",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "graphqlApis": [toGraphqlApi],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listResolvers(
    {abortSignal, ...params}: RequestConfig & s.ListResolversRequest,
  ): Promise<s.ListResolversResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListResolvers",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types/${params["typeName"]}/resolvers`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resolvers": [toResolver],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listResolversByFunction(
    {abortSignal, ...params}: RequestConfig & s.ListResolversByFunctionRequest,
  ): Promise<s.ListResolversByFunctionResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListResolversByFunction",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/functions/${params["functionId"]}/resolvers`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resolvers": [toResolver],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listTypes(
    {abortSignal, ...params}: RequestConfig & s.ListTypesRequest,
  ): Promise<s.ListTypesResponse> {
    const query = new URLSearchParams;
    query.set("format", params["format"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTypes",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "types": [toType],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async startSchemaCreation(
    {abortSignal, ...params}: RequestConfig & s.StartSchemaCreationRequest,
  ): Promise<s.StartSchemaCreationResponse> {
    const body: jsonP.JSONObject = {
      definition: serializeBlob(params["definition"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartSchemaCreation",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/schemacreation`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaStatus>(x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/v1/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateApiCache(
    {abortSignal, ...params}: RequestConfig & s.UpdateApiCacheRequest,
  ): Promise<s.UpdateApiCacheResponse> {
    const body: jsonP.JSONObject = {
      ttl: params["ttl"],
      apiCachingBehavior: params["apiCachingBehavior"],
      type: params["type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApiCache",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/ApiCaches/update`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "apiCache": toApiCache,
      },
    }, await resp.json());
  }

  async updateApiKey(
    {abortSignal, ...params}: RequestConfig & s.UpdateApiKeyRequest,
  ): Promise<s.UpdateApiKeyResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      expires: params["expires"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApiKey",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/apikeys/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "apiKey": toApiKey,
      },
    }, await resp.json());
  }

  async updateDataSource(
    {abortSignal, ...params}: RequestConfig & s.UpdateDataSourceRequest,
  ): Promise<s.UpdateDataSourceResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      type: params["type"],
      serviceRoleArn: params["serviceRoleArn"],
      dynamodbConfig: fromDynamodbDataSourceConfig(params["dynamodbConfig"]),
      lambdaConfig: fromLambdaDataSourceConfig(params["lambdaConfig"]),
      elasticsearchConfig: fromElasticsearchDataSourceConfig(params["elasticsearchConfig"]),
      httpConfig: fromHttpDataSourceConfig(params["httpConfig"]),
      relationalDatabaseConfig: fromRelationalDatabaseDataSourceConfig(params["relationalDatabaseConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataSource",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/datasources/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "dataSource": toDataSource,
      },
    }, await resp.json());
  }

  async updateFunction(
    {abortSignal, ...params}: RequestConfig & s.UpdateFunctionRequest,
  ): Promise<s.UpdateFunctionResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      dataSourceName: params["dataSourceName"],
      requestMappingTemplate: params["requestMappingTemplate"],
      responseMappingTemplate: params["responseMappingTemplate"],
      functionVersion: params["functionVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFunction",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/functions/${params["functionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "functionConfiguration": toFunctionConfiguration,
      },
    }, await resp.json());
  }

  async updateGraphqlApi(
    {abortSignal, ...params}: RequestConfig & s.UpdateGraphqlApiRequest,
  ): Promise<s.UpdateGraphqlApiResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      logConfig: fromLogConfig(params["logConfig"]),
      authenticationType: params["authenticationType"],
      userPoolConfig: fromUserPoolConfig(params["userPoolConfig"]),
      openIDConnectConfig: fromOpenIDConnectConfig(params["openIDConnectConfig"]),
      additionalAuthenticationProviders: params["additionalAuthenticationProviders"]?.map(x => fromAdditionalAuthenticationProvider(x)),
      xrayEnabled: params["xrayEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGraphqlApi",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "graphqlApi": toGraphqlApi,
      },
    }, await resp.json());
  }

  async updateResolver(
    {abortSignal, ...params}: RequestConfig & s.UpdateResolverRequest,
  ): Promise<s.UpdateResolverResponse> {
    const body: jsonP.JSONObject = {
      dataSourceName: params["dataSourceName"],
      requestMappingTemplate: params["requestMappingTemplate"],
      responseMappingTemplate: params["responseMappingTemplate"],
      kind: params["kind"],
      pipelineConfig: fromPipelineConfig(params["pipelineConfig"]),
      syncConfig: fromSyncConfig(params["syncConfig"]),
      cachingConfig: fromCachingConfig(params["cachingConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateResolver",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types/${params["typeName"]}/resolvers/${params["fieldName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resolver": toResolver,
      },
    }, await resp.json());
  }

  async updateType(
    {abortSignal, ...params}: RequestConfig & s.UpdateTypeRequest,
  ): Promise<s.UpdateTypeResponse> {
    const body: jsonP.JSONObject = {
      definition: params["definition"],
      format: params["format"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateType",
      requestUri: cmnP.encodePath`/v1/apis/${params["apiId"]}/types/${params["typeName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "type": toType,
      },
    }, await resp.json());
  }

}

function fromDynamodbDataSourceConfig(input?: s.DynamodbDataSourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tableName: input["tableName"],
    awsRegion: input["awsRegion"],
    useCallerCredentials: input["useCallerCredentials"],
    deltaSyncConfig: fromDeltaSyncConfig(input["deltaSyncConfig"]),
    versioned: input["versioned"],
  }
}
function toDynamodbDataSourceConfig(root: jsonP.JSONValue): s.DynamodbDataSourceConfig {
  return jsonP.readObj({
    required: {
      "tableName": "s",
      "awsRegion": "s",
    },
    optional: {
      "useCallerCredentials": "b",
      "deltaSyncConfig": toDeltaSyncConfig,
      "versioned": "b",
    },
  }, root);
}

function fromDeltaSyncConfig(input?: s.DeltaSyncConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    baseTableTTL: input["baseTableTTL"],
    deltaSyncTableName: input["deltaSyncTableName"],
    deltaSyncTableTTL: input["deltaSyncTableTTL"],
  }
}
function toDeltaSyncConfig(root: jsonP.JSONValue): s.DeltaSyncConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "baseTableTTL": "n",
      "deltaSyncTableName": "s",
      "deltaSyncTableTTL": "n",
    },
  }, root);
}

function fromLambdaDataSourceConfig(input?: s.LambdaDataSourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    lambdaFunctionArn: input["lambdaFunctionArn"],
  }
}
function toLambdaDataSourceConfig(root: jsonP.JSONValue): s.LambdaDataSourceConfig {
  return jsonP.readObj({
    required: {
      "lambdaFunctionArn": "s",
    },
    optional: {},
  }, root);
}

function fromElasticsearchDataSourceConfig(input?: s.ElasticsearchDataSourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    endpoint: input["endpoint"],
    awsRegion: input["awsRegion"],
  }
}
function toElasticsearchDataSourceConfig(root: jsonP.JSONValue): s.ElasticsearchDataSourceConfig {
  return jsonP.readObj({
    required: {
      "endpoint": "s",
      "awsRegion": "s",
    },
    optional: {},
  }, root);
}

function fromHttpDataSourceConfig(input?: s.HttpDataSourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    endpoint: input["endpoint"],
    authorizationConfig: fromAuthorizationConfig(input["authorizationConfig"]),
  }
}
function toHttpDataSourceConfig(root: jsonP.JSONValue): s.HttpDataSourceConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "endpoint": "s",
      "authorizationConfig": toAuthorizationConfig,
    },
  }, root);
}

function fromAuthorizationConfig(input?: s.AuthorizationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    authorizationType: input["authorizationType"],
    awsIamConfig: fromAwsIamConfig(input["awsIamConfig"]),
  }
}
function toAuthorizationConfig(root: jsonP.JSONValue): s.AuthorizationConfig {
  return jsonP.readObj({
    required: {
      "authorizationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizationType>(x),
    },
    optional: {
      "awsIamConfig": toAwsIamConfig,
    },
  }, root);
}

function fromAwsIamConfig(input?: s.AwsIamConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    signingRegion: input["signingRegion"],
    signingServiceName: input["signingServiceName"],
  }
}
function toAwsIamConfig(root: jsonP.JSONValue): s.AwsIamConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "signingRegion": "s",
      "signingServiceName": "s",
    },
  }, root);
}

function fromRelationalDatabaseDataSourceConfig(input?: s.RelationalDatabaseDataSourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    relationalDatabaseSourceType: input["relationalDatabaseSourceType"],
    rdsHttpEndpointConfig: fromRdsHttpEndpointConfig(input["rdsHttpEndpointConfig"]),
  }
}
function toRelationalDatabaseDataSourceConfig(root: jsonP.JSONValue): s.RelationalDatabaseDataSourceConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "relationalDatabaseSourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RelationalDatabaseSourceType>(x),
      "rdsHttpEndpointConfig": toRdsHttpEndpointConfig,
    },
  }, root);
}

function fromRdsHttpEndpointConfig(input?: s.RdsHttpEndpointConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    awsRegion: input["awsRegion"],
    dbClusterIdentifier: input["dbClusterIdentifier"],
    databaseName: input["databaseName"],
    schema: input["schema"],
    awsSecretStoreArn: input["awsSecretStoreArn"],
  }
}
function toRdsHttpEndpointConfig(root: jsonP.JSONValue): s.RdsHttpEndpointConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsRegion": "s",
      "dbClusterIdentifier": "s",
      "databaseName": "s",
      "schema": "s",
      "awsSecretStoreArn": "s",
    },
  }, root);
}

function fromLogConfig(input?: s.LogConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fieldLogLevel: input["fieldLogLevel"],
    cloudWatchLogsRoleArn: input["cloudWatchLogsRoleArn"],
    excludeVerboseContent: input["excludeVerboseContent"],
  }
}
function toLogConfig(root: jsonP.JSONValue): s.LogConfig {
  return jsonP.readObj({
    required: {
      "fieldLogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.FieldLogLevel>(x),
      "cloudWatchLogsRoleArn": "s",
    },
    optional: {
      "excludeVerboseContent": "b",
    },
  }, root);
}

function fromUserPoolConfig(input?: s.UserPoolConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    userPoolId: input["userPoolId"],
    awsRegion: input["awsRegion"],
    defaultAction: input["defaultAction"],
    appIdClientRegex: input["appIdClientRegex"],
  }
}
function toUserPoolConfig(root: jsonP.JSONValue): s.UserPoolConfig {
  return jsonP.readObj({
    required: {
      "userPoolId": "s",
      "awsRegion": "s",
      "defaultAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.DefaultAction>(x),
    },
    optional: {
      "appIdClientRegex": "s",
    },
  }, root);
}

function fromOpenIDConnectConfig(input?: s.OpenIDConnectConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    issuer: input["issuer"],
    clientId: input["clientId"],
    iatTTL: input["iatTTL"],
    authTTL: input["authTTL"],
  }
}
function toOpenIDConnectConfig(root: jsonP.JSONValue): s.OpenIDConnectConfig {
  return jsonP.readObj({
    required: {
      "issuer": "s",
    },
    optional: {
      "clientId": "s",
      "iatTTL": "n",
      "authTTL": "n",
    },
  }, root);
}

function fromAdditionalAuthenticationProvider(input?: s.AdditionalAuthenticationProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    authenticationType: input["authenticationType"],
    openIDConnectConfig: fromOpenIDConnectConfig(input["openIDConnectConfig"]),
    userPoolConfig: fromCognitoUserPoolConfig(input["userPoolConfig"]),
  }
}
function toAdditionalAuthenticationProvider(root: jsonP.JSONValue): s.AdditionalAuthenticationProvider {
  return jsonP.readObj({
    required: {},
    optional: {
      "authenticationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthenticationType>(x),
      "openIDConnectConfig": toOpenIDConnectConfig,
      "userPoolConfig": toCognitoUserPoolConfig,
    },
  }, root);
}

function fromCognitoUserPoolConfig(input?: s.CognitoUserPoolConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    userPoolId: input["userPoolId"],
    awsRegion: input["awsRegion"],
    appIdClientRegex: input["appIdClientRegex"],
  }
}
function toCognitoUserPoolConfig(root: jsonP.JSONValue): s.CognitoUserPoolConfig {
  return jsonP.readObj({
    required: {
      "userPoolId": "s",
      "awsRegion": "s",
    },
    optional: {
      "appIdClientRegex": "s",
    },
  }, root);
}

function fromPipelineConfig(input?: s.PipelineConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    functions: input["functions"],
  }
}
function toPipelineConfig(root: jsonP.JSONValue): s.PipelineConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "functions": ["s"],
    },
  }, root);
}

function fromSyncConfig(input?: s.SyncConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    conflictHandler: input["conflictHandler"],
    conflictDetection: input["conflictDetection"],
    lambdaConflictHandlerConfig: fromLambdaConflictHandlerConfig(input["lambdaConflictHandlerConfig"]),
  }
}
function toSyncConfig(root: jsonP.JSONValue): s.SyncConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "conflictHandler": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConflictHandlerType>(x),
      "conflictDetection": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConflictDetectionType>(x),
      "lambdaConflictHandlerConfig": toLambdaConflictHandlerConfig,
    },
  }, root);
}

function fromLambdaConflictHandlerConfig(input?: s.LambdaConflictHandlerConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    lambdaConflictHandlerArn: input["lambdaConflictHandlerArn"],
  }
}
function toLambdaConflictHandlerConfig(root: jsonP.JSONValue): s.LambdaConflictHandlerConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "lambdaConflictHandlerArn": "s",
    },
  }, root);
}

function fromCachingConfig(input?: s.CachingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ttl: input["ttl"],
    cachingKeys: input["cachingKeys"],
  }
}
function toCachingConfig(root: jsonP.JSONValue): s.CachingConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ttl": "n",
      "cachingKeys": ["s"],
    },
  }, root);
}

function toApiCache(root: jsonP.JSONValue): s.ApiCache {
  return jsonP.readObj({
    required: {},
    optional: {
      "ttl": "n",
      "apiCachingBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApiCachingBehavior>(x),
      "transitEncryptionEnabled": "b",
      "atRestEncryptionEnabled": "b",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApiCacheType>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApiCacheStatus>(x),
    },
  }, root);
}

function toApiKey(root: jsonP.JSONValue): s.ApiKey {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "description": "s",
      "expires": "n",
      "deletes": "n",
    },
  }, root);
}

function toDataSource(root: jsonP.JSONValue): s.DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "dataSourceArn": "s",
      "name": "s",
      "description": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataSourceType>(x),
      "serviceRoleArn": "s",
      "dynamodbConfig": toDynamodbDataSourceConfig,
      "lambdaConfig": toLambdaDataSourceConfig,
      "elasticsearchConfig": toElasticsearchDataSourceConfig,
      "httpConfig": toHttpDataSourceConfig,
      "relationalDatabaseConfig": toRelationalDatabaseDataSourceConfig,
    },
  }, root);
}

function toFunctionConfiguration(root: jsonP.JSONValue): s.FunctionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "functionId": "s",
      "functionArn": "s",
      "name": "s",
      "description": "s",
      "dataSourceName": "s",
      "requestMappingTemplate": "s",
      "responseMappingTemplate": "s",
      "functionVersion": "s",
    },
  }, root);
}

function toGraphqlApi(root: jsonP.JSONValue): s.GraphqlApi {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "apiId": "s",
      "authenticationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthenticationType>(x),
      "logConfig": toLogConfig,
      "userPoolConfig": toUserPoolConfig,
      "openIDConnectConfig": toOpenIDConnectConfig,
      "arn": "s",
      "uris": x => jsonP.readMap(String, String, x),
      "tags": x => jsonP.readMap(String, String, x),
      "additionalAuthenticationProviders": [toAdditionalAuthenticationProvider],
      "xrayEnabled": "b",
      "wafWebAclArn": "s",
    },
  }, root);
}

function toResolver(root: jsonP.JSONValue): s.Resolver {
  return jsonP.readObj({
    required: {},
    optional: {
      "typeName": "s",
      "fieldName": "s",
      "dataSourceName": "s",
      "resolverArn": "s",
      "requestMappingTemplate": "s",
      "responseMappingTemplate": "s",
      "kind": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResolverKind>(x),
      "pipelineConfig": toPipelineConfig,
      "syncConfig": toSyncConfig,
      "cachingConfig": toCachingConfig,
    },
  }, root);
}

function toType(root: jsonP.JSONValue): s.Type {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "arn": "s",
      "definition": "s",
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.TypeDefinitionFormat>(x),
    },
  }, root);
}
