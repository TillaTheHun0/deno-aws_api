// Autogenerated API client for: Amazon Honeycode

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Honeycode {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Honeycode.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2020-03-01",
    "endpointPrefix": "honeycode",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "Honeycode",
    "serviceFullName": "Amazon Honeycode",
    "serviceId": "Honeycode",
    "signatureVersion": "v4",
    "signingName": "honeycode",
    "uid": "honeycode-2020-03-01"
  };

  async batchCreateTableRows(
    {abortSignal, ...params}: RequestConfig & s.BatchCreateTableRowsRequest,
  ): Promise<s.BatchCreateTableRowsResult> {
    const body: jsonP.JSONObject = {
      rowsToCreate: params["rowsToCreate"]?.map(x => fromCreateRowData(x)),
      clientRequestToken: params["clientRequestToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchCreateTableRows",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables/${params["tableId"]}/rows/batchcreate`,
    });
    return jsonP.readObj({
      required: {
        "workbookCursor": "n",
        "createdRows": x => jsonP.readMap(String, String, x),
      },
      optional: {
        "failedBatchItems": [toFailedBatchItem],
      },
    }, await resp.json());
  }

  async batchDeleteTableRows(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteTableRowsRequest,
  ): Promise<s.BatchDeleteTableRowsResult> {
    const body: jsonP.JSONObject = {
      rowIds: params["rowIds"],
      clientRequestToken: params["clientRequestToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteTableRows",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables/${params["tableId"]}/rows/batchdelete`,
    });
    return jsonP.readObj({
      required: {
        "workbookCursor": "n",
      },
      optional: {
        "failedBatchItems": [toFailedBatchItem],
      },
    }, await resp.json());
  }

  async batchUpdateTableRows(
    {abortSignal, ...params}: RequestConfig & s.BatchUpdateTableRowsRequest,
  ): Promise<s.BatchUpdateTableRowsResult> {
    const body: jsonP.JSONObject = {
      rowsToUpdate: params["rowsToUpdate"]?.map(x => fromUpdateRowData(x)),
      clientRequestToken: params["clientRequestToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchUpdateTableRows",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables/${params["tableId"]}/rows/batchupdate`,
    });
    return jsonP.readObj({
      required: {
        "workbookCursor": "n",
      },
      optional: {
        "failedBatchItems": [toFailedBatchItem],
      },
    }, await resp.json());
  }

  async batchUpsertTableRows(
    {abortSignal, ...params}: RequestConfig & s.BatchUpsertTableRowsRequest,
  ): Promise<s.BatchUpsertTableRowsResult> {
    const body: jsonP.JSONObject = {
      rowsToUpsert: params["rowsToUpsert"]?.map(x => fromUpsertRowData(x)),
      clientRequestToken: params["clientRequestToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchUpsertTableRows",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables/${params["tableId"]}/rows/batchupsert`,
    });
    return jsonP.readObj({
      required: {
        "rows": x => jsonP.readMap(String, toUpsertRowsResult, x),
        "workbookCursor": "n",
      },
      optional: {
        "failedBatchItems": [toFailedBatchItem],
      },
    }, await resp.json());
  }

  async describeTableDataImportJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeTableDataImportJobRequest,
  ): Promise<s.DescribeTableDataImportJobResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeTableDataImportJob",
      method: "GET",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables/${params["tableId"]}/import/${params["jobId"]}`,
    });
    return jsonP.readObj({
      required: {
        "jobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TableDataImportJobStatus>(x),
        "message": "s",
        "jobMetadata": toTableDataImportJobMetadata,
      },
      optional: {},
    }, await resp.json());
  }

  async getScreenData(
    {abortSignal, ...params}: RequestConfig & s.GetScreenDataRequest,
  ): Promise<s.GetScreenDataResult> {
    const body: jsonP.JSONObject = {
      workbookId: params["workbookId"],
      appId: params["appId"],
      screenId: params["screenId"],
      variables: jsonP.serializeMap(params["variables"], x => fromVariableValue(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetScreenData",
      requestUri: "/screendata",
    });
    return jsonP.readObj({
      required: {
        "results": x => jsonP.readMap(String, toResultSet, x),
        "workbookCursor": "n",
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async invokeScreenAutomation(
    {abortSignal, ...params}: RequestConfig & s.InvokeScreenAutomationRequest,
  ): Promise<s.InvokeScreenAutomationResult> {
    const body: jsonP.JSONObject = {
      variables: jsonP.serializeMap(params["variables"], x => fromVariableValue(x)),
      rowId: params["rowId"],
      clientRequestToken: params["clientRequestToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InvokeScreenAutomation",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/apps/${params["appId"]}/screens/${params["screenId"]}/automations/${params["screenAutomationId"]}`,
    });
    return jsonP.readObj({
      required: {
        "workbookCursor": "n",
      },
      optional: {},
    }, await resp.json());
  }

  async listTableColumns(
    {abortSignal, ...params}: RequestConfig & s.ListTableColumnsRequest,
  ): Promise<s.ListTableColumnsResult> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTableColumns",
      method: "GET",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables/${params["tableId"]}/columns`,
    });
    return jsonP.readObj({
      required: {
        "tableColumns": [toTableColumn],
      },
      optional: {
        "nextToken": "s",
        "workbookCursor": "n",
      },
    }, await resp.json());
  }

  async listTableRows(
    {abortSignal, ...params}: RequestConfig & s.ListTableRowsRequest,
  ): Promise<s.ListTableRowsResult> {
    const body: jsonP.JSONObject = {
      rowIds: params["rowIds"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTableRows",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables/${params["tableId"]}/rows/list`,
    });
    return jsonP.readObj({
      required: {
        "columnIds": ["s"],
        "rows": [toTableRow],
        "workbookCursor": "n",
      },
      optional: {
        "rowIdsNotFound": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTables(
    {abortSignal, ...params}: RequestConfig & s.ListTablesRequest,
  ): Promise<s.ListTablesResult> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTables",
      method: "GET",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables`,
    });
    return jsonP.readObj({
      required: {
        "tables": [toTable],
      },
      optional: {
        "nextToken": "s",
        "workbookCursor": "n",
      },
    }, await resp.json());
  }

  async queryTableRows(
    {abortSignal, ...params}: RequestConfig & s.QueryTableRowsRequest,
  ): Promise<s.QueryTableRowsResult> {
    const body: jsonP.JSONObject = {
      filterFormula: fromFilter(params["filterFormula"]),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "QueryTableRows",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables/${params["tableId"]}/rows/query`,
    });
    return jsonP.readObj({
      required: {
        "columnIds": ["s"],
        "rows": [toTableRow],
        "workbookCursor": "n",
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async startTableDataImportJob(
    {abortSignal, ...params}: RequestConfig & s.StartTableDataImportJobRequest,
  ): Promise<s.StartTableDataImportJobResult> {
    const body: jsonP.JSONObject = {
      dataSource: fromImportDataSource(params["dataSource"]),
      dataFormat: params["dataFormat"],
      importOptions: fromImportOptions(params["importOptions"]),
      clientRequestToken: params["clientRequestToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTableDataImportJob",
      requestUri: cmnP.encodePath`/workbooks/${params["workbookId"]}/tables/${params["destinationTableId"]}/import`,
    });
    return jsonP.readObj({
      required: {
        "jobId": "s",
        "jobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TableDataImportJobStatus>(x),
      },
      optional: {},
    }, await resp.json());
  }

}

function fromCreateRowData(input?: s.CreateRowData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    batchItemId: input["batchItemId"],
    cellsToCreate: jsonP.serializeMap(input["cellsToCreate"], x => fromCellInput(x)),
  }
}

function fromCellInput(input?: s.CellInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fact: input["fact"],
  }
}

function fromUpdateRowData(input?: s.UpdateRowData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    rowId: input["rowId"],
    cellsToUpdate: jsonP.serializeMap(input["cellsToUpdate"], x => fromCellInput(x)),
  }
}

function fromUpsertRowData(input?: s.UpsertRowData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    batchItemId: input["batchItemId"],
    filter: fromFilter(input["filter"]),
    cellsToUpdate: jsonP.serializeMap(input["cellsToUpdate"], x => fromCellInput(x)),
  }
}

function fromFilter(input?: s.Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    formula: input["formula"],
    contextRowId: input["contextRowId"],
  }
}

function fromVariableValue(input?: s.VariableValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    rawValue: input["rawValue"],
  }
}

function fromImportDataSource(input?: s.ImportDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dataSourceConfig: fromImportDataSourceConfig(input["dataSourceConfig"]),
  }
}
function toImportDataSource(root: jsonP.JSONValue): s.ImportDataSource {
  return jsonP.readObj({
    required: {
      "dataSourceConfig": toImportDataSourceConfig,
    },
    optional: {},
  }, root);
}

function fromImportDataSourceConfig(input?: s.ImportDataSourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dataSourceUrl: input["dataSourceUrl"],
  }
}
function toImportDataSourceConfig(root: jsonP.JSONValue): s.ImportDataSourceConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "dataSourceUrl": "s",
    },
  }, root);
}

function fromImportOptions(input?: s.ImportOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destinationOptions: fromDestinationOptions(input["destinationOptions"]),
    delimitedTextOptions: fromDelimitedTextImportOptions(input["delimitedTextOptions"]),
  }
}
function toImportOptions(root: jsonP.JSONValue): s.ImportOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "destinationOptions": toDestinationOptions,
      "delimitedTextOptions": toDelimitedTextImportOptions,
    },
  }, root);
}

function fromDestinationOptions(input?: s.DestinationOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    columnMap: jsonP.serializeMap(input["columnMap"], x => fromSourceDataColumnProperties(x)),
  }
}
function toDestinationOptions(root: jsonP.JSONValue): s.DestinationOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "columnMap": x => jsonP.readMap(String, toSourceDataColumnProperties, x),
    },
  }, root);
}

function fromSourceDataColumnProperties(input?: s.SourceDataColumnProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    columnIndex: input["columnIndex"],
  }
}
function toSourceDataColumnProperties(root: jsonP.JSONValue): s.SourceDataColumnProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "columnIndex": "n",
    },
  }, root);
}

function fromDelimitedTextImportOptions(input?: s.DelimitedTextImportOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    delimiter: input["delimiter"],
    hasHeaderRow: input["hasHeaderRow"],
    ignoreEmptyRows: input["ignoreEmptyRows"],
    dataCharacterEncoding: input["dataCharacterEncoding"],
  }
}
function toDelimitedTextImportOptions(root: jsonP.JSONValue): s.DelimitedTextImportOptions {
  return jsonP.readObj({
    required: {
      "delimiter": "s",
    },
    optional: {
      "hasHeaderRow": "b",
      "ignoreEmptyRows": "b",
      "dataCharacterEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImportDataCharacterEncoding>(x),
    },
  }, root);
}

function toFailedBatchItem(root: jsonP.JSONValue): s.FailedBatchItem {
  return jsonP.readObj({
    required: {
      "id": "s",
      "errorMessage": "s",
    },
    optional: {},
  }, root);
}

function toUpsertRowsResult(root: jsonP.JSONValue): s.UpsertRowsResult {
  return jsonP.readObj({
    required: {
      "rowIds": ["s"],
      "upsertAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpsertAction>(x),
    },
    optional: {},
  }, root);
}

function toTableDataImportJobMetadata(root: jsonP.JSONValue): s.TableDataImportJobMetadata {
  return jsonP.readObj({
    required: {
      "submitter": toImportJobSubmitter,
      "submitTime": "d",
      "importOptions": toImportOptions,
      "dataSource": toImportDataSource,
    },
    optional: {},
  }, root);
}

function toImportJobSubmitter(root: jsonP.JSONValue): s.ImportJobSubmitter {
  return jsonP.readObj({
    required: {},
    optional: {
      "email": "s",
      "userArn": "s",
    },
  }, root);
}

function toResultSet(root: jsonP.JSONValue): s.ResultSet {
  return jsonP.readObj({
    required: {
      "headers": [toColumnMetadata],
      "rows": [toResultRow],
    },
    optional: {},
  }, root);
}

function toColumnMetadata(root: jsonP.JSONValue): s.ColumnMetadata {
  return jsonP.readObj({
    required: {
      "name": "s",
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.Format>(x),
    },
    optional: {},
  }, root);
}

function toResultRow(root: jsonP.JSONValue): s.ResultRow {
  return jsonP.readObj({
    required: {
      "dataItems": [toDataItem],
    },
    optional: {
      "rowId": "s",
    },
  }, root);
}

function toDataItem(root: jsonP.JSONValue): s.DataItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "overrideFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.Format>(x),
      "rawValue": "s",
      "formattedValue": "s",
    },
  }, root);
}

function toTableColumn(root: jsonP.JSONValue): s.TableColumn {
  return jsonP.readObj({
    required: {},
    optional: {
      "tableColumnId": "s",
      "tableColumnName": "s",
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.Format>(x),
    },
  }, root);
}

function toTableRow(root: jsonP.JSONValue): s.TableRow {
  return jsonP.readObj({
    required: {
      "rowId": "s",
      "cells": [toCell],
    },
    optional: {},
  }, root);
}

function toCell(root: jsonP.JSONValue): s.Cell {
  return jsonP.readObj({
    required: {},
    optional: {
      "formula": "s",
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.Format>(x),
      "rawValue": "s",
      "formattedValue": "s",
    },
  }, root);
}

function toTable(root: jsonP.JSONValue): s.Table {
  return jsonP.readObj({
    required: {},
    optional: {
      "tableId": "s",
      "tableName": "s",
    },
  }, root);
}
