// Autogenerated API client for: AWS Elemental MediaStore Data Plane

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class MediaStoreData {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaStoreData.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-09-01",
    "endpointPrefix": "data.mediastore",
    "protocol": "rest-json",
    "serviceAbbreviation": "MediaStore Data",
    "serviceFullName": "AWS Elemental MediaStore Data Plane",
    "serviceId": "MediaStore Data",
    "signatureVersion": "v4",
    "signingName": "mediastore",
    "uid": "mediastore-data-2017-09-01"
  };

  async deleteObject(
    {abortSignal, ...params}: RequestConfig & DeleteObjectRequest,
  ): Promise<DeleteObjectResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteObject",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Path"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeObject(
    {abortSignal, ...params}: RequestConfig & DescribeObjectRequest,
  ): Promise<DescribeObjectResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeObject",
      method: "HEAD",
      requestUri: cmnP.encodePath`/${params["Path"].split("/")}`,
    });
    return {
      ETag: resp.headers.get("ETag"),
      ContentType: resp.headers.get("Content-Type"),
      ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
      CacheControl: resp.headers.get("Cache-Control"),
      LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
      ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
    };
  }

  async getObject(
    {abortSignal, ...params}: RequestConfig & GetObjectRequest,
  ): Promise<GetObjectResponse> {
    const headers = new Headers;
    if (params["Range"] != null) headers.append("Range", params["Range"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetObject",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Path"].split("/")}`,
    });
  return {
    CacheControl: resp.headers.get("Cache-Control"),
    ContentRange: resp.headers.get("Content-Range"),
    ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
    ContentType: resp.headers.get("Content-Type"),
    ETag: resp.headers.get("ETag"),
    LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
    StatusCode: resp.status,
    Body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async listItems(
    {abortSignal, ...params}: RequestConfig & ListItemsRequest = {},
  ): Promise<ListItemsResponse> {
    const query = new URLSearchParams;
    if (params["Path"] != null) query.set("Path", params["Path"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListItems",
      method: "GET",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putObject(
    {abortSignal, ...params}: RequestConfig & PutObjectRequest,
  ): Promise<PutObjectResponse> {
    const body = typeof params["Body"] === 'string' ? new TextEncoder().encode(params["Body"]) : params["Body"];
    const headers = new Headers;
    if (params["ContentType"] != null) headers.append("Content-Type", params["ContentType"]);
    if (params["CacheControl"] != null) headers.append("Cache-Control", params["CacheControl"]);
    if (params["StorageClass"] != null) headers.append("x-amz-storage-class", params["StorageClass"]);
    if (params["UploadAvailability"] != null) headers.append("x-amz-upload-availability", params["UploadAvailability"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutObject",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Path"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContentSHA256": "s",
        "ETag": "s",
        "StorageClass": (x: jsonP.JSONValue) => cmnP.readEnum<StorageClass>(x),
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface DeleteObjectRequest {
  Path: string;
}

// refs: 1 - tags: named, input
export interface DescribeObjectRequest {
  Path: string;
}

// refs: 1 - tags: named, input
export interface GetObjectRequest {
  Path: string;
  Range?: string | null;
}

// refs: 1 - tags: named, input
export interface ListItemsRequest {
  Path?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PutObjectRequest {
  Body: Uint8Array | string;
  Path: string;
  ContentType?: string | null;
  CacheControl?: string | null;
  StorageClass?: StorageClass | null;
  UploadAvailability?: UploadAvailability | null;
}

// refs: 1 - tags: named, output
export interface DeleteObjectResponse {
}

// refs: 1 - tags: named, output
export interface DescribeObjectResponse {
  ETag?: string | null;
  ContentType?: string | null;
  ContentLength?: number | null;
  CacheControl?: string | null;
  LastModified?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetObjectResponse {
  Body?: Uint8Array | string | null;
  CacheControl?: string | null;
  ContentRange?: string | null;
  ContentLength?: number | null;
  ContentType?: string | null;
  ETag?: string | null;
  LastModified?: Date | number | null;
  StatusCode: number;
}

// refs: 1 - tags: named, output
export interface ListItemsResponse {
  Items?: Item[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutObjectResponse {
  ContentSHA256?: string | null;
  ETag?: string | null;
  StorageClass?: StorageClass | null;
}

// refs: 2 - tags: input, named, enum, output
export type StorageClass =
| "TEMPORAL"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type UploadAvailability =
| "STANDARD"
| "STREAMING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Item {
  Name?: string | null;
  Type?: ItemType | null;
  ETag?: string | null;
  LastModified?: Date | number | null;
  ContentType?: string | null;
  ContentLength?: number | null;
}
function toItem(root: jsonP.JSONValue): Item {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<ItemType>(x),
      "ETag": "s",
      "LastModified": "d",
      "ContentType": "s",
      "ContentLength": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type ItemType =
| "OBJECT"
| "FOLDER"
| cmnP.UnexpectedEnumValue;
