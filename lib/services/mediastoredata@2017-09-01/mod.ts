// Autogenerated API client for: AWS Elemental MediaStore Data Plane

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class MediaStoreData {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaStoreData.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-09-01",
    "endpointPrefix": "data.mediastore",
    "protocol": "rest-json",
    "serviceAbbreviation": "MediaStore Data",
    "serviceFullName": "AWS Elemental MediaStore Data Plane",
    "serviceId": "MediaStore Data",
    "signatureVersion": "v4",
    "signingName": "mediastore",
    "uid": "mediastore-data-2017-09-01"
  };

  async deleteObject(
    {abortSignal, ...params}: RequestConfig & s.DeleteObjectRequest,
  ): Promise<s.DeleteObjectResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteObject",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Path"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeObject(
    {abortSignal, ...params}: RequestConfig & s.DescribeObjectRequest,
  ): Promise<s.DescribeObjectResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeObject",
      method: "HEAD",
      requestUri: cmnP.encodePath`/${params["Path"].split("/")}`,
    });
    return {
      ETag: resp.headers.get("ETag"),
      ContentType: resp.headers.get("Content-Type"),
      ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
      CacheControl: resp.headers.get("Cache-Control"),
      LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
      ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
    };
  }

  async getObject(
    {abortSignal, ...params}: RequestConfig & s.GetObjectRequest,
  ): Promise<s.GetObjectResponse> {
    const headers = new Headers;
    if (params["Range"] != null) headers.append("Range", params["Range"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetObject",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Path"].split("/")}`,
    });
  return {
    CacheControl: resp.headers.get("Cache-Control"),
    ContentRange: resp.headers.get("Content-Range"),
    ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
    ContentType: resp.headers.get("Content-Type"),
    ETag: resp.headers.get("ETag"),
    LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
    StatusCode: resp.status,
    Body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async listItems(
    {abortSignal, ...params}: RequestConfig & s.ListItemsRequest = {},
  ): Promise<s.ListItemsResponse> {
    const query = new URLSearchParams;
    if (params["Path"] != null) query.set("Path", params["Path"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListItems",
      method: "GET",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putObject(
    {abortSignal, ...params}: RequestConfig & s.PutObjectRequest,
  ): Promise<s.PutObjectResponse> {
    const body = typeof params["Body"] === 'string' ? new TextEncoder().encode(params["Body"]) : params["Body"];
    const headers = new Headers;
    if (params["ContentType"] != null) headers.append("Content-Type", params["ContentType"]);
    if (params["CacheControl"] != null) headers.append("Cache-Control", params["CacheControl"]);
    if (params["StorageClass"] != null) headers.append("x-amz-storage-class", params["StorageClass"]);
    if (params["UploadAvailability"] != null) headers.append("x-amz-upload-availability", params["UploadAvailability"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutObject",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Path"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContentSHA256": "s",
        "ETag": "s",
        "StorageClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.StorageClass>(x),
      },
    }, await resp.json());
  }

}

function toItem(root: jsonP.JSONValue): s.Item {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ItemType>(x),
      "ETag": "s",
      "LastModified": "d",
      "ContentType": "s",
      "ContentLength": "n",
    },
  }, root);
}
