// Autogenerated API client for: Amazon AppIntegrations Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class AppIntegrations {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AppIntegrations.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2020-07-29",
    "endpointPrefix": "app-integrations",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon AppIntegrations Service",
    "serviceId": "AppIntegrations",
    "signatureVersion": "v4",
    "signingName": "app-integrations",
    "uid": "appintegrations-2020-07-29"
  };

  async createEventIntegration(
    {abortSignal, ...params}: RequestConfig & CreateEventIntegrationRequest,
  ): Promise<CreateEventIntegrationResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      EventFilter: fromEventFilter(params["EventFilter"]),
      EventBridgeBus: params["EventBridgeBus"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventIntegration",
      requestUri: "/eventIntegrations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventIntegrationArn": "s",
      },
    }, await resp.json());
  }

  async deleteEventIntegration(
    {abortSignal, ...params}: RequestConfig & DeleteEventIntegrationRequest,
  ): Promise<DeleteEventIntegrationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteEventIntegration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/eventIntegrations/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async getEventIntegration(
    {abortSignal, ...params}: RequestConfig & GetEventIntegrationRequest,
  ): Promise<GetEventIntegrationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetEventIntegration",
      method: "GET",
      requestUri: cmnP.encodePath`/eventIntegrations/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Description": "s",
        "EventIntegrationArn": "s",
        "EventBridgeBus": "s",
        "EventFilter": toEventFilter,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listEventIntegrationAssociations(
    {abortSignal, ...params}: RequestConfig & ListEventIntegrationAssociationsRequest,
  ): Promise<ListEventIntegrationAssociationsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListEventIntegrationAssociations",
      method: "GET",
      requestUri: cmnP.encodePath`/eventIntegrations/${params["EventIntegrationName"]}/associations`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventIntegrationAssociations": [toEventIntegrationAssociation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEventIntegrations(
    {abortSignal, ...params}: RequestConfig & ListEventIntegrationsRequest = {},
  ): Promise<ListEventIntegrationsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListEventIntegrations",
      method: "GET",
      requestUri: "/eventIntegrations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventIntegrations": [toEventIntegration],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateEventIntegration(
    {abortSignal, ...params}: RequestConfig & UpdateEventIntegrationRequest,
  ): Promise<UpdateEventIntegrationResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEventIntegration",
      method: "PATCH",
      requestUri: cmnP.encodePath`/eventIntegrations/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CreateEventIntegrationRequest {
  Name: string;
  Description?: string | null;
  EventFilter: EventFilter;
  EventBridgeBus: string;
  ClientToken?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface DeleteEventIntegrationRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetEventIntegrationRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface ListEventIntegrationAssociationsRequest {
  EventIntegrationName: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListEventIntegrationsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateEventIntegrationRequest {
  Name: string;
  Description?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateEventIntegrationResponse {
  EventIntegrationArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteEventIntegrationResponse {
}

// refs: 1 - tags: named, output
export interface GetEventIntegrationResponse {
  Name?: string | null;
  Description?: string | null;
  EventIntegrationArn?: string | null;
  EventBridgeBus?: string | null;
  EventFilter?: EventFilter | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface ListEventIntegrationAssociationsResponse {
  EventIntegrationAssociations?: EventIntegrationAssociation[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListEventIntegrationsResponse {
  EventIntegrations?: EventIntegration[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateEventIntegrationResponse {
}

// refs: 3 - tags: input, named, interface, output
export interface EventFilter {
  Source: string;
}
function fromEventFilter(input?: EventFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Source: input["Source"],
  }
}
function toEventFilter(root: jsonP.JSONValue): EventFilter {
  return jsonP.readObj({
    required: {
      "Source": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EventIntegrationAssociation {
  EventIntegrationAssociationArn?: string | null;
  EventIntegrationAssociationId?: string | null;
  EventIntegrationName?: string | null;
  ClientId?: string | null;
  EventBridgeRuleName?: string | null;
  ClientAssociationMetadata?: { [key: string]: string | null | undefined } | null;
}
function toEventIntegrationAssociation(root: jsonP.JSONValue): EventIntegrationAssociation {
  return jsonP.readObj({
    required: {},
    optional: {
      "EventIntegrationAssociationArn": "s",
      "EventIntegrationAssociationId": "s",
      "EventIntegrationName": "s",
      "ClientId": "s",
      "EventBridgeRuleName": "s",
      "ClientAssociationMetadata": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EventIntegration {
  EventIntegrationArn?: string | null;
  Name?: string | null;
  Description?: string | null;
  EventFilter?: EventFilter | null;
  EventBridgeBus?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}
function toEventIntegration(root: jsonP.JSONValue): EventIntegration {
  return jsonP.readObj({
    required: {},
    optional: {
      "EventIntegrationArn": "s",
      "Name": "s",
      "Description": "s",
      "EventFilter": toEventFilter,
      "EventBridgeBus": "s",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
