// Autogenerated API client for: Amazon Machine Learning

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class MachineLearning {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MachineLearning.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "uid": "machinelearning-2014-12-12",
    "apiVersion": "2014-12-12",
    "endpointPrefix": "machinelearning",
    "jsonVersion": "1.1",
    "serviceFullName": "Amazon Machine Learning",
    "serviceId": "Machine Learning",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonML_20141212",
    "protocol": "json"
  };

  async addTags(
    {abortSignal, ...params}: RequestConfig & s.AddTagsInput,
  ): Promise<s.AddTagsOutput> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"]?.map(x => fromTag(x)),
      ResourceId: params["ResourceId"],
      ResourceType: params["ResourceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceId": "s",
        "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaggableResourceType>(x),
      },
    }, await resp.json());
  }

  async createBatchPrediction(
    {abortSignal, ...params}: RequestConfig & s.CreateBatchPredictionInput,
  ): Promise<s.CreateBatchPredictionOutput> {
    const body: jsonP.JSONObject = {
      BatchPredictionId: params["BatchPredictionId"],
      BatchPredictionName: params["BatchPredictionName"],
      MLModelId: params["MLModelId"],
      BatchPredictionDataSourceId: params["BatchPredictionDataSourceId"],
      OutputUri: params["OutputUri"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBatchPrediction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BatchPredictionId": "s",
      },
    }, await resp.json());
  }

  async createDataSourceFromRDS(
    {abortSignal, ...params}: RequestConfig & s.CreateDataSourceFromRDSInput,
  ): Promise<s.CreateDataSourceFromRDSOutput> {
    const body: jsonP.JSONObject = {
      DataSourceId: params["DataSourceId"],
      DataSourceName: params["DataSourceName"],
      RDSData: fromRDSDataSpec(params["RDSData"]),
      RoleARN: params["RoleARN"],
      ComputeStatistics: params["ComputeStatistics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataSourceFromRDS",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async createDataSourceFromRedshift(
    {abortSignal, ...params}: RequestConfig & s.CreateDataSourceFromRedshiftInput,
  ): Promise<s.CreateDataSourceFromRedshiftOutput> {
    const body: jsonP.JSONObject = {
      DataSourceId: params["DataSourceId"],
      DataSourceName: params["DataSourceName"],
      DataSpec: fromRedshiftDataSpec(params["DataSpec"]),
      RoleARN: params["RoleARN"],
      ComputeStatistics: params["ComputeStatistics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataSourceFromRedshift",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async createDataSourceFromS3(
    {abortSignal, ...params}: RequestConfig & s.CreateDataSourceFromS3Input,
  ): Promise<s.CreateDataSourceFromS3Output> {
    const body: jsonP.JSONObject = {
      DataSourceId: params["DataSourceId"],
      DataSourceName: params["DataSourceName"],
      DataSpec: fromS3DataSpec(params["DataSpec"]),
      ComputeStatistics: params["ComputeStatistics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataSourceFromS3",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async createEvaluation(
    {abortSignal, ...params}: RequestConfig & s.CreateEvaluationInput,
  ): Promise<s.CreateEvaluationOutput> {
    const body: jsonP.JSONObject = {
      EvaluationId: params["EvaluationId"],
      EvaluationName: params["EvaluationName"],
      MLModelId: params["MLModelId"],
      EvaluationDataSourceId: params["EvaluationDataSourceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEvaluation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EvaluationId": "s",
      },
    }, await resp.json());
  }

  async createMLModel(
    {abortSignal, ...params}: RequestConfig & s.CreateMLModelInput,
  ): Promise<s.CreateMLModelOutput> {
    const body: jsonP.JSONObject = {
      MLModelId: params["MLModelId"],
      MLModelName: params["MLModelName"],
      MLModelType: params["MLModelType"],
      Parameters: params["Parameters"],
      TrainingDataSourceId: params["TrainingDataSourceId"],
      Recipe: params["Recipe"],
      RecipeUri: params["RecipeUri"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMLModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
      },
    }, await resp.json());
  }

  async createRealtimeEndpoint(
    {abortSignal, ...params}: RequestConfig & s.CreateRealtimeEndpointInput,
  ): Promise<s.CreateRealtimeEndpointOutput> {
    const body: jsonP.JSONObject = {
      MLModelId: params["MLModelId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRealtimeEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
        "RealtimeEndpointInfo": toRealtimeEndpointInfo,
      },
    }, await resp.json());
  }

  async deleteBatchPrediction(
    {abortSignal, ...params}: RequestConfig & s.DeleteBatchPredictionInput,
  ): Promise<s.DeleteBatchPredictionOutput> {
    const body: jsonP.JSONObject = {
      BatchPredictionId: params["BatchPredictionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBatchPrediction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BatchPredictionId": "s",
      },
    }, await resp.json());
  }

  async deleteDataSource(
    {abortSignal, ...params}: RequestConfig & s.DeleteDataSourceInput,
  ): Promise<s.DeleteDataSourceOutput> {
    const body: jsonP.JSONObject = {
      DataSourceId: params["DataSourceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDataSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async deleteEvaluation(
    {abortSignal, ...params}: RequestConfig & s.DeleteEvaluationInput,
  ): Promise<s.DeleteEvaluationOutput> {
    const body: jsonP.JSONObject = {
      EvaluationId: params["EvaluationId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEvaluation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EvaluationId": "s",
      },
    }, await resp.json());
  }

  async deleteMLModel(
    {abortSignal, ...params}: RequestConfig & s.DeleteMLModelInput,
  ): Promise<s.DeleteMLModelOutput> {
    const body: jsonP.JSONObject = {
      MLModelId: params["MLModelId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMLModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
      },
    }, await resp.json());
  }

  async deleteRealtimeEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DeleteRealtimeEndpointInput,
  ): Promise<s.DeleteRealtimeEndpointOutput> {
    const body: jsonP.JSONObject = {
      MLModelId: params["MLModelId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRealtimeEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
        "RealtimeEndpointInfo": toRealtimeEndpointInfo,
      },
    }, await resp.json());
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & s.DeleteTagsInput,
  ): Promise<s.DeleteTagsOutput> {
    const body: jsonP.JSONObject = {
      TagKeys: params["TagKeys"],
      ResourceId: params["ResourceId"],
      ResourceType: params["ResourceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceId": "s",
        "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaggableResourceType>(x),
      },
    }, await resp.json());
  }

  async describeBatchPredictions(
    {abortSignal, ...params}: RequestConfig & s.DescribeBatchPredictionsInput = {},
  ): Promise<s.DescribeBatchPredictionsOutput> {
    const body: jsonP.JSONObject = {
      FilterVariable: params["FilterVariable"],
      EQ: params["EQ"],
      GT: params["GT"],
      LT: params["LT"],
      GE: params["GE"],
      LE: params["LE"],
      NE: params["NE"],
      Prefix: params["Prefix"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBatchPredictions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toBatchPrediction],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeDataSources(
    {abortSignal, ...params}: RequestConfig & s.DescribeDataSourcesInput = {},
  ): Promise<s.DescribeDataSourcesOutput> {
    const body: jsonP.JSONObject = {
      FilterVariable: params["FilterVariable"],
      EQ: params["EQ"],
      GT: params["GT"],
      LT: params["LT"],
      GE: params["GE"],
      LE: params["LE"],
      NE: params["NE"],
      Prefix: params["Prefix"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDataSources",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toDataSource],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeEvaluations(
    {abortSignal, ...params}: RequestConfig & s.DescribeEvaluationsInput = {},
  ): Promise<s.DescribeEvaluationsOutput> {
    const body: jsonP.JSONObject = {
      FilterVariable: params["FilterVariable"],
      EQ: params["EQ"],
      GT: params["GT"],
      LT: params["LT"],
      GE: params["GE"],
      LE: params["LE"],
      NE: params["NE"],
      Prefix: params["Prefix"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvaluations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toEvaluation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMLModels(
    {abortSignal, ...params}: RequestConfig & s.DescribeMLModelsInput = {},
  ): Promise<s.DescribeMLModelsOutput> {
    const body: jsonP.JSONObject = {
      FilterVariable: params["FilterVariable"],
      EQ: params["EQ"],
      GT: params["GT"],
      LT: params["LT"],
      GE: params["GE"],
      LE: params["LE"],
      NE: params["NE"],
      Prefix: params["Prefix"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMLModels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toMLModel],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & s.DescribeTagsInput,
  ): Promise<s.DescribeTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      ResourceType: params["ResourceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceId": "s",
        "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaggableResourceType>(x),
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async getBatchPrediction(
    {abortSignal, ...params}: RequestConfig & s.GetBatchPredictionInput,
  ): Promise<s.GetBatchPredictionOutput> {
    const body: jsonP.JSONObject = {
      BatchPredictionId: params["BatchPredictionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBatchPrediction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BatchPredictionId": "s",
        "MLModelId": "s",
        "BatchPredictionDataSourceId": "s",
        "InputDataLocationS3": "s",
        "CreatedByIamUser": "s",
        "CreatedAt": "d",
        "LastUpdatedAt": "d",
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityStatus>(x),
        "OutputUri": "s",
        "LogUri": "s",
        "Message": "s",
        "ComputeTime": "n",
        "FinishedAt": "d",
        "StartedAt": "d",
        "TotalRecordCount": "n",
        "InvalidRecordCount": "n",
      },
    }, await resp.json());
  }

  async getDataSource(
    {abortSignal, ...params}: RequestConfig & s.GetDataSourceInput,
  ): Promise<s.GetDataSourceOutput> {
    const body: jsonP.JSONObject = {
      DataSourceId: params["DataSourceId"],
      Verbose: params["Verbose"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDataSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
        "DataLocationS3": "s",
        "DataRearrangement": "s",
        "CreatedByIamUser": "s",
        "CreatedAt": "d",
        "LastUpdatedAt": "d",
        "DataSizeInBytes": "n",
        "NumberOfFiles": "n",
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityStatus>(x),
        "LogUri": "s",
        "Message": "s",
        "RedshiftMetadata": toRedshiftMetadata,
        "RDSMetadata": toRDSMetadata,
        "RoleARN": "s",
        "ComputeStatistics": "b",
        "ComputeTime": "n",
        "FinishedAt": "d",
        "StartedAt": "d",
        "DataSourceSchema": "s",
      },
    }, await resp.json());
  }

  async getEvaluation(
    {abortSignal, ...params}: RequestConfig & s.GetEvaluationInput,
  ): Promise<s.GetEvaluationOutput> {
    const body: jsonP.JSONObject = {
      EvaluationId: params["EvaluationId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEvaluation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EvaluationId": "s",
        "MLModelId": "s",
        "EvaluationDataSourceId": "s",
        "InputDataLocationS3": "s",
        "CreatedByIamUser": "s",
        "CreatedAt": "d",
        "LastUpdatedAt": "d",
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityStatus>(x),
        "PerformanceMetrics": toPerformanceMetrics,
        "LogUri": "s",
        "Message": "s",
        "ComputeTime": "n",
        "FinishedAt": "d",
        "StartedAt": "d",
      },
    }, await resp.json());
  }

  async getMLModel(
    {abortSignal, ...params}: RequestConfig & s.GetMLModelInput,
  ): Promise<s.GetMLModelOutput> {
    const body: jsonP.JSONObject = {
      MLModelId: params["MLModelId"],
      Verbose: params["Verbose"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
        "TrainingDataSourceId": "s",
        "CreatedByIamUser": "s",
        "CreatedAt": "d",
        "LastUpdatedAt": "d",
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityStatus>(x),
        "SizeInBytes": "n",
        "EndpointInfo": toRealtimeEndpointInfo,
        "TrainingParameters": x => jsonP.readMap(String, String, x),
        "InputDataLocationS3": "s",
        "MLModelType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MLModelType>(x),
        "ScoreThreshold": "n",
        "ScoreThresholdLastUpdatedAt": "d",
        "LogUri": "s",
        "Message": "s",
        "ComputeTime": "n",
        "FinishedAt": "d",
        "StartedAt": "d",
        "Recipe": "s",
        "Schema": "s",
      },
    }, await resp.json());
  }

  async predict(
    {abortSignal, ...params}: RequestConfig & s.PredictInput,
  ): Promise<s.PredictOutput> {
    const body: jsonP.JSONObject = {
      MLModelId: params["MLModelId"],
      Record: params["Record"],
      PredictEndpoint: params["PredictEndpoint"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Predict",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Prediction": toPrediction,
      },
    }, await resp.json());
  }

  async updateBatchPrediction(
    {abortSignal, ...params}: RequestConfig & s.UpdateBatchPredictionInput,
  ): Promise<s.UpdateBatchPredictionOutput> {
    const body: jsonP.JSONObject = {
      BatchPredictionId: params["BatchPredictionId"],
      BatchPredictionName: params["BatchPredictionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBatchPrediction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BatchPredictionId": "s",
      },
    }, await resp.json());
  }

  async updateDataSource(
    {abortSignal, ...params}: RequestConfig & s.UpdateDataSourceInput,
  ): Promise<s.UpdateDataSourceOutput> {
    const body: jsonP.JSONObject = {
      DataSourceId: params["DataSourceId"],
      DataSourceName: params["DataSourceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async updateEvaluation(
    {abortSignal, ...params}: RequestConfig & s.UpdateEvaluationInput,
  ): Promise<s.UpdateEvaluationOutput> {
    const body: jsonP.JSONObject = {
      EvaluationId: params["EvaluationId"],
      EvaluationName: params["EvaluationName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEvaluation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EvaluationId": "s",
      },
    }, await resp.json());
  }

  async updateMLModel(
    {abortSignal, ...params}: RequestConfig & s.UpdateMLModelInput,
  ): Promise<s.UpdateMLModelOutput> {
    const body: jsonP.JSONObject = {
      MLModelId: params["MLModelId"],
      MLModelName: params["MLModelName"],
      ScoreThreshold: params["ScoreThreshold"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMLModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDataSourceAvailable(
    params: RequestConfig & s.DescribeDataSourcesInput,
  ): Promise<s.DescribeDataSourcesOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DataSourceAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDataSources(params);
      const field = resp?.Results?.flatMap(x => x?.Status);
      if (field?.every(x => x === "COMPLETED")) return resp;
      if (field?.some(x => x === "FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForMLModelAvailable(
    params: RequestConfig & s.DescribeMLModelsInput,
  ): Promise<s.DescribeMLModelsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MLModelAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeMLModels(params);
      const field = resp?.Results?.flatMap(x => x?.Status);
      if (field?.every(x => x === "COMPLETED")) return resp;
      if (field?.some(x => x === "FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForEvaluationAvailable(
    params: RequestConfig & s.DescribeEvaluationsInput,
  ): Promise<s.DescribeEvaluationsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EvaluationAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeEvaluations(params);
      const field = resp?.Results?.flatMap(x => x?.Status);
      if (field?.every(x => x === "COMPLETED")) return resp;
      if (field?.some(x => x === "FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForBatchPredictionAvailable(
    params: RequestConfig & s.DescribeBatchPredictionsInput,
  ): Promise<s.DescribeBatchPredictionsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state BatchPredictionAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeBatchPredictions(params);
      const field = resp?.Results?.flatMap(x => x?.Status);
      if (field?.every(x => x === "COMPLETED")) return resp;
      if (field?.some(x => x === "FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromRDSDataSpec(input?: s.RDSDataSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseInformation: fromRDSDatabase(input["DatabaseInformation"]),
    SelectSqlQuery: input["SelectSqlQuery"],
    DatabaseCredentials: fromRDSDatabaseCredentials(input["DatabaseCredentials"]),
    S3StagingLocation: input["S3StagingLocation"],
    DataRearrangement: input["DataRearrangement"],
    DataSchema: input["DataSchema"],
    DataSchemaUri: input["DataSchemaUri"],
    ResourceRole: input["ResourceRole"],
    ServiceRole: input["ServiceRole"],
    SubnetId: input["SubnetId"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}

function fromRDSDatabase(input?: s.RDSDatabase | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceIdentifier: input["InstanceIdentifier"],
    DatabaseName: input["DatabaseName"],
  }
}
function toRDSDatabase(root: jsonP.JSONValue): s.RDSDatabase {
  return jsonP.readObj({
    required: {
      "InstanceIdentifier": "s",
      "DatabaseName": "s",
    },
    optional: {},
  }, root);
}

function fromRDSDatabaseCredentials(input?: s.RDSDatabaseCredentials | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Username: input["Username"],
    Password: input["Password"],
  }
}

function fromRedshiftDataSpec(input?: s.RedshiftDataSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseInformation: fromRedshiftDatabase(input["DatabaseInformation"]),
    SelectSqlQuery: input["SelectSqlQuery"],
    DatabaseCredentials: fromRedshiftDatabaseCredentials(input["DatabaseCredentials"]),
    S3StagingLocation: input["S3StagingLocation"],
    DataRearrangement: input["DataRearrangement"],
    DataSchema: input["DataSchema"],
    DataSchemaUri: input["DataSchemaUri"],
  }
}

function fromRedshiftDatabase(input?: s.RedshiftDatabase | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    ClusterIdentifier: input["ClusterIdentifier"],
  }
}
function toRedshiftDatabase(root: jsonP.JSONValue): s.RedshiftDatabase {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
      "ClusterIdentifier": "s",
    },
    optional: {},
  }, root);
}

function fromRedshiftDatabaseCredentials(input?: s.RedshiftDatabaseCredentials | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Username: input["Username"],
    Password: input["Password"],
  }
}

function fromS3DataSpec(input?: s.S3DataSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataLocationS3: input["DataLocationS3"],
    DataRearrangement: input["DataRearrangement"],
    DataSchema: input["DataSchema"],
    DataSchemaLocationS3: input["DataSchemaLocationS3"],
  }
}

function toRealtimeEndpointInfo(root: jsonP.JSONValue): s.RealtimeEndpointInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "PeakRequestsPerSecond": "n",
      "CreatedAt": "d",
      "EndpointUrl": "s",
      "EndpointStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RealtimeEndpointStatus>(x),
    },
  }, root);
}

function toBatchPrediction(root: jsonP.JSONValue): s.BatchPrediction {
  return jsonP.readObj({
    required: {},
    optional: {
      "BatchPredictionId": "s",
      "MLModelId": "s",
      "BatchPredictionDataSourceId": "s",
      "InputDataLocationS3": "s",
      "CreatedByIamUser": "s",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityStatus>(x),
      "OutputUri": "s",
      "Message": "s",
      "ComputeTime": "n",
      "FinishedAt": "d",
      "StartedAt": "d",
      "TotalRecordCount": "n",
      "InvalidRecordCount": "n",
    },
  }, root);
}

function toDataSource(root: jsonP.JSONValue): s.DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "DataSourceId": "s",
      "DataLocationS3": "s",
      "DataRearrangement": "s",
      "CreatedByIamUser": "s",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "DataSizeInBytes": "n",
      "NumberOfFiles": "n",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityStatus>(x),
      "Message": "s",
      "RedshiftMetadata": toRedshiftMetadata,
      "RDSMetadata": toRDSMetadata,
      "RoleARN": "s",
      "ComputeStatistics": "b",
      "ComputeTime": "n",
      "FinishedAt": "d",
      "StartedAt": "d",
    },
  }, root);
}

function toRedshiftMetadata(root: jsonP.JSONValue): s.RedshiftMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "RedshiftDatabase": toRedshiftDatabase,
      "DatabaseUserName": "s",
      "SelectSqlQuery": "s",
    },
  }, root);
}

function toRDSMetadata(root: jsonP.JSONValue): s.RDSMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Database": toRDSDatabase,
      "DatabaseUserName": "s",
      "SelectSqlQuery": "s",
      "ResourceRole": "s",
      "ServiceRole": "s",
      "DataPipelineId": "s",
    },
  }, root);
}

function toEvaluation(root: jsonP.JSONValue): s.Evaluation {
  return jsonP.readObj({
    required: {},
    optional: {
      "EvaluationId": "s",
      "MLModelId": "s",
      "EvaluationDataSourceId": "s",
      "InputDataLocationS3": "s",
      "CreatedByIamUser": "s",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityStatus>(x),
      "PerformanceMetrics": toPerformanceMetrics,
      "Message": "s",
      "ComputeTime": "n",
      "FinishedAt": "d",
      "StartedAt": "d",
    },
  }, root);
}

function toPerformanceMetrics(root: jsonP.JSONValue): s.PerformanceMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "Properties": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toMLModel(root: jsonP.JSONValue): s.MLModel {
  return jsonP.readObj({
    required: {},
    optional: {
      "MLModelId": "s",
      "TrainingDataSourceId": "s",
      "CreatedByIamUser": "s",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityStatus>(x),
      "SizeInBytes": "n",
      "EndpointInfo": toRealtimeEndpointInfo,
      "TrainingParameters": x => jsonP.readMap(String, String, x),
      "InputDataLocationS3": "s",
      "Algorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.Algorithm>(x),
      "MLModelType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MLModelType>(x),
      "ScoreThreshold": "n",
      "ScoreThresholdLastUpdatedAt": "d",
      "Message": "s",
      "ComputeTime": "n",
      "FinishedAt": "d",
      "StartedAt": "d",
    },
  }, root);
}

function toPrediction(root: jsonP.JSONValue): s.Prediction {
  return jsonP.readObj({
    required: {},
    optional: {
      "predictedLabel": "s",
      "predictedValue": "n",
      "predictedScores": x => jsonP.readMap(String, Number, x),
      "details": x => jsonP.readMap(x => cmnP.readEnumReq<s.DetailsAttributes>(x), String, x),
    },
  }, root);
}
