// Autogenerated API client for: Amazon Machine Learning

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class MachineLearning {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MachineLearning.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "uid": "machinelearning-2014-12-12",
    "apiVersion": "2014-12-12",
    "endpointPrefix": "machinelearning",
    "jsonVersion": "1.1",
    "serviceFullName": "Amazon Machine Learning",
    "serviceId": "Machine Learning",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonML_20141212",
    "protocol": "json"
  };

  async addTags(
    {abortSignal, ...params}: RequestConfig & AddTagsInput,
  ): Promise<AddTagsOutput> {
    const body: jsonP.JSONObject = params ? {
      Tags: params["Tags"]?.map(x => fromTag(x)),
      ResourceId: params["ResourceId"],
      ResourceType: params["ResourceType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceId": "s",
        "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<TaggableResourceType>(x),
      },
    }, await resp.json());
  }

  async createBatchPrediction(
    {abortSignal, ...params}: RequestConfig & CreateBatchPredictionInput,
  ): Promise<CreateBatchPredictionOutput> {
    const body: jsonP.JSONObject = params ? {
      BatchPredictionId: params["BatchPredictionId"],
      BatchPredictionName: params["BatchPredictionName"],
      MLModelId: params["MLModelId"],
      BatchPredictionDataSourceId: params["BatchPredictionDataSourceId"],
      OutputUri: params["OutputUri"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBatchPrediction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BatchPredictionId": "s",
      },
    }, await resp.json());
  }

  async createDataSourceFromRDS(
    {abortSignal, ...params}: RequestConfig & CreateDataSourceFromRDSInput,
  ): Promise<CreateDataSourceFromRDSOutput> {
    const body: jsonP.JSONObject = params ? {
      DataSourceId: params["DataSourceId"],
      DataSourceName: params["DataSourceName"],
      RDSData: fromRDSDataSpec(params["RDSData"]),
      RoleARN: params["RoleARN"],
      ComputeStatistics: params["ComputeStatistics"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataSourceFromRDS",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async createDataSourceFromRedshift(
    {abortSignal, ...params}: RequestConfig & CreateDataSourceFromRedshiftInput,
  ): Promise<CreateDataSourceFromRedshiftOutput> {
    const body: jsonP.JSONObject = params ? {
      DataSourceId: params["DataSourceId"],
      DataSourceName: params["DataSourceName"],
      DataSpec: fromRedshiftDataSpec(params["DataSpec"]),
      RoleARN: params["RoleARN"],
      ComputeStatistics: params["ComputeStatistics"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataSourceFromRedshift",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async createDataSourceFromS3(
    {abortSignal, ...params}: RequestConfig & CreateDataSourceFromS3Input,
  ): Promise<CreateDataSourceFromS3Output> {
    const body: jsonP.JSONObject = params ? {
      DataSourceId: params["DataSourceId"],
      DataSourceName: params["DataSourceName"],
      DataSpec: fromS3DataSpec(params["DataSpec"]),
      ComputeStatistics: params["ComputeStatistics"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataSourceFromS3",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async createEvaluation(
    {abortSignal, ...params}: RequestConfig & CreateEvaluationInput,
  ): Promise<CreateEvaluationOutput> {
    const body: jsonP.JSONObject = params ? {
      EvaluationId: params["EvaluationId"],
      EvaluationName: params["EvaluationName"],
      MLModelId: params["MLModelId"],
      EvaluationDataSourceId: params["EvaluationDataSourceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEvaluation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EvaluationId": "s",
      },
    }, await resp.json());
  }

  async createMLModel(
    {abortSignal, ...params}: RequestConfig & CreateMLModelInput,
  ): Promise<CreateMLModelOutput> {
    const body: jsonP.JSONObject = params ? {
      MLModelId: params["MLModelId"],
      MLModelName: params["MLModelName"],
      MLModelType: params["MLModelType"],
      Parameters: params["Parameters"],
      TrainingDataSourceId: params["TrainingDataSourceId"],
      Recipe: params["Recipe"],
      RecipeUri: params["RecipeUri"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMLModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
      },
    }, await resp.json());
  }

  async createRealtimeEndpoint(
    {abortSignal, ...params}: RequestConfig & CreateRealtimeEndpointInput,
  ): Promise<CreateRealtimeEndpointOutput> {
    const body: jsonP.JSONObject = params ? {
      MLModelId: params["MLModelId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRealtimeEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
        "RealtimeEndpointInfo": toRealtimeEndpointInfo,
      },
    }, await resp.json());
  }

  async deleteBatchPrediction(
    {abortSignal, ...params}: RequestConfig & DeleteBatchPredictionInput,
  ): Promise<DeleteBatchPredictionOutput> {
    const body: jsonP.JSONObject = params ? {
      BatchPredictionId: params["BatchPredictionId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBatchPrediction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BatchPredictionId": "s",
      },
    }, await resp.json());
  }

  async deleteDataSource(
    {abortSignal, ...params}: RequestConfig & DeleteDataSourceInput,
  ): Promise<DeleteDataSourceOutput> {
    const body: jsonP.JSONObject = params ? {
      DataSourceId: params["DataSourceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDataSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async deleteEvaluation(
    {abortSignal, ...params}: RequestConfig & DeleteEvaluationInput,
  ): Promise<DeleteEvaluationOutput> {
    const body: jsonP.JSONObject = params ? {
      EvaluationId: params["EvaluationId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEvaluation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EvaluationId": "s",
      },
    }, await resp.json());
  }

  async deleteMLModel(
    {abortSignal, ...params}: RequestConfig & DeleteMLModelInput,
  ): Promise<DeleteMLModelOutput> {
    const body: jsonP.JSONObject = params ? {
      MLModelId: params["MLModelId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMLModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
      },
    }, await resp.json());
  }

  async deleteRealtimeEndpoint(
    {abortSignal, ...params}: RequestConfig & DeleteRealtimeEndpointInput,
  ): Promise<DeleteRealtimeEndpointOutput> {
    const body: jsonP.JSONObject = params ? {
      MLModelId: params["MLModelId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRealtimeEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
        "RealtimeEndpointInfo": toRealtimeEndpointInfo,
      },
    }, await resp.json());
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & DeleteTagsInput,
  ): Promise<DeleteTagsOutput> {
    const body: jsonP.JSONObject = params ? {
      TagKeys: params["TagKeys"],
      ResourceId: params["ResourceId"],
      ResourceType: params["ResourceType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceId": "s",
        "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<TaggableResourceType>(x),
      },
    }, await resp.json());
  }

  async describeBatchPredictions(
    {abortSignal, ...params}: RequestConfig & DescribeBatchPredictionsInput = {},
  ): Promise<DescribeBatchPredictionsOutput> {
    const body: jsonP.JSONObject = params ? {
      FilterVariable: params["FilterVariable"],
      EQ: params["EQ"],
      GT: params["GT"],
      LT: params["LT"],
      GE: params["GE"],
      LE: params["LE"],
      NE: params["NE"],
      Prefix: params["Prefix"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBatchPredictions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toBatchPrediction],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeDataSources(
    {abortSignal, ...params}: RequestConfig & DescribeDataSourcesInput = {},
  ): Promise<DescribeDataSourcesOutput> {
    const body: jsonP.JSONObject = params ? {
      FilterVariable: params["FilterVariable"],
      EQ: params["EQ"],
      GT: params["GT"],
      LT: params["LT"],
      GE: params["GE"],
      LE: params["LE"],
      NE: params["NE"],
      Prefix: params["Prefix"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDataSources",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toDataSource],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeEvaluations(
    {abortSignal, ...params}: RequestConfig & DescribeEvaluationsInput = {},
  ): Promise<DescribeEvaluationsOutput> {
    const body: jsonP.JSONObject = params ? {
      FilterVariable: params["FilterVariable"],
      EQ: params["EQ"],
      GT: params["GT"],
      LT: params["LT"],
      GE: params["GE"],
      LE: params["LE"],
      NE: params["NE"],
      Prefix: params["Prefix"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvaluations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toEvaluation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMLModels(
    {abortSignal, ...params}: RequestConfig & DescribeMLModelsInput = {},
  ): Promise<DescribeMLModelsOutput> {
    const body: jsonP.JSONObject = params ? {
      FilterVariable: params["FilterVariable"],
      EQ: params["EQ"],
      GT: params["GT"],
      LT: params["LT"],
      GE: params["GE"],
      LE: params["LE"],
      NE: params["NE"],
      Prefix: params["Prefix"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMLModels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toMLModel],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & DescribeTagsInput,
  ): Promise<DescribeTagsOutput> {
    const body: jsonP.JSONObject = params ? {
      ResourceId: params["ResourceId"],
      ResourceType: params["ResourceType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceId": "s",
        "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<TaggableResourceType>(x),
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async getBatchPrediction(
    {abortSignal, ...params}: RequestConfig & GetBatchPredictionInput,
  ): Promise<GetBatchPredictionOutput> {
    const body: jsonP.JSONObject = params ? {
      BatchPredictionId: params["BatchPredictionId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBatchPrediction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BatchPredictionId": "s",
        "MLModelId": "s",
        "BatchPredictionDataSourceId": "s",
        "InputDataLocationS3": "s",
        "CreatedByIamUser": "s",
        "CreatedAt": "d",
        "LastUpdatedAt": "d",
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<EntityStatus>(x),
        "OutputUri": "s",
        "LogUri": "s",
        "Message": "s",
        "ComputeTime": "n",
        "FinishedAt": "d",
        "StartedAt": "d",
        "TotalRecordCount": "n",
        "InvalidRecordCount": "n",
      },
    }, await resp.json());
  }

  async getDataSource(
    {abortSignal, ...params}: RequestConfig & GetDataSourceInput,
  ): Promise<GetDataSourceOutput> {
    const body: jsonP.JSONObject = params ? {
      DataSourceId: params["DataSourceId"],
      Verbose: params["Verbose"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDataSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
        "DataLocationS3": "s",
        "DataRearrangement": "s",
        "CreatedByIamUser": "s",
        "CreatedAt": "d",
        "LastUpdatedAt": "d",
        "DataSizeInBytes": "n",
        "NumberOfFiles": "n",
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<EntityStatus>(x),
        "LogUri": "s",
        "Message": "s",
        "RedshiftMetadata": toRedshiftMetadata,
        "RDSMetadata": toRDSMetadata,
        "RoleARN": "s",
        "ComputeStatistics": "b",
        "ComputeTime": "n",
        "FinishedAt": "d",
        "StartedAt": "d",
        "DataSourceSchema": "s",
      },
    }, await resp.json());
  }

  async getEvaluation(
    {abortSignal, ...params}: RequestConfig & GetEvaluationInput,
  ): Promise<GetEvaluationOutput> {
    const body: jsonP.JSONObject = params ? {
      EvaluationId: params["EvaluationId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEvaluation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EvaluationId": "s",
        "MLModelId": "s",
        "EvaluationDataSourceId": "s",
        "InputDataLocationS3": "s",
        "CreatedByIamUser": "s",
        "CreatedAt": "d",
        "LastUpdatedAt": "d",
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<EntityStatus>(x),
        "PerformanceMetrics": toPerformanceMetrics,
        "LogUri": "s",
        "Message": "s",
        "ComputeTime": "n",
        "FinishedAt": "d",
        "StartedAt": "d",
      },
    }, await resp.json());
  }

  async getMLModel(
    {abortSignal, ...params}: RequestConfig & GetMLModelInput,
  ): Promise<GetMLModelOutput> {
    const body: jsonP.JSONObject = params ? {
      MLModelId: params["MLModelId"],
      Verbose: params["Verbose"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
        "TrainingDataSourceId": "s",
        "CreatedByIamUser": "s",
        "CreatedAt": "d",
        "LastUpdatedAt": "d",
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<EntityStatus>(x),
        "SizeInBytes": "n",
        "EndpointInfo": toRealtimeEndpointInfo,
        "TrainingParameters": x => jsonP.readMap(String, String, x),
        "InputDataLocationS3": "s",
        "MLModelType": (x: jsonP.JSONValue) => cmnP.readEnum<MLModelType>(x),
        "ScoreThreshold": "n",
        "ScoreThresholdLastUpdatedAt": "d",
        "LogUri": "s",
        "Message": "s",
        "ComputeTime": "n",
        "FinishedAt": "d",
        "StartedAt": "d",
        "Recipe": "s",
        "Schema": "s",
      },
    }, await resp.json());
  }

  async predict(
    {abortSignal, ...params}: RequestConfig & PredictInput,
  ): Promise<PredictOutput> {
    const body: jsonP.JSONObject = params ? {
      MLModelId: params["MLModelId"],
      Record: params["Record"],
      PredictEndpoint: params["PredictEndpoint"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Predict",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Prediction": toPrediction,
      },
    }, await resp.json());
  }

  async updateBatchPrediction(
    {abortSignal, ...params}: RequestConfig & UpdateBatchPredictionInput,
  ): Promise<UpdateBatchPredictionOutput> {
    const body: jsonP.JSONObject = params ? {
      BatchPredictionId: params["BatchPredictionId"],
      BatchPredictionName: params["BatchPredictionName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBatchPrediction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BatchPredictionId": "s",
      },
    }, await resp.json());
  }

  async updateDataSource(
    {abortSignal, ...params}: RequestConfig & UpdateDataSourceInput,
  ): Promise<UpdateDataSourceOutput> {
    const body: jsonP.JSONObject = params ? {
      DataSourceId: params["DataSourceId"],
      DataSourceName: params["DataSourceName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataSourceId": "s",
      },
    }, await resp.json());
  }

  async updateEvaluation(
    {abortSignal, ...params}: RequestConfig & UpdateEvaluationInput,
  ): Promise<UpdateEvaluationOutput> {
    const body: jsonP.JSONObject = params ? {
      EvaluationId: params["EvaluationId"],
      EvaluationName: params["EvaluationName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEvaluation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EvaluationId": "s",
      },
    }, await resp.json());
  }

  async updateMLModel(
    {abortSignal, ...params}: RequestConfig & UpdateMLModelInput,
  ): Promise<UpdateMLModelOutput> {
    const body: jsonP.JSONObject = params ? {
      MLModelId: params["MLModelId"],
      MLModelName: params["MLModelName"],
      ScoreThreshold: params["ScoreThreshold"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMLModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MLModelId": "s",
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDataSourceAvailable(
    params: RequestConfig & DescribeDataSourcesInput,
  ): Promise<DescribeDataSourcesOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DataSourceAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDataSources(params);
      const field = resp?.Results?.flatMap(x => x?.Status);
      if (field?.every(x => x === "COMPLETED")) return resp;
      if (field?.some(x => x === "FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForMLModelAvailable(
    params: RequestConfig & DescribeMLModelsInput,
  ): Promise<DescribeMLModelsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MLModelAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeMLModels(params);
      const field = resp?.Results?.flatMap(x => x?.Status);
      if (field?.every(x => x === "COMPLETED")) return resp;
      if (field?.some(x => x === "FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForEvaluationAvailable(
    params: RequestConfig & DescribeEvaluationsInput,
  ): Promise<DescribeEvaluationsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EvaluationAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeEvaluations(params);
      const field = resp?.Results?.flatMap(x => x?.Status);
      if (field?.every(x => x === "COMPLETED")) return resp;
      if (field?.some(x => x === "FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForBatchPredictionAvailable(
    params: RequestConfig & DescribeBatchPredictionsInput,
  ): Promise<DescribeBatchPredictionsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state BatchPredictionAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeBatchPredictions(params);
      const field = resp?.Results?.flatMap(x => x?.Status);
      if (field?.every(x => x === "COMPLETED")) return resp;
      if (field?.some(x => x === "FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddTagsInput {
  Tags: Tag[];
  ResourceId: string;
  ResourceType: TaggableResourceType;
}

// refs: 1 - tags: named, input
export interface CreateBatchPredictionInput {
  BatchPredictionId: string;
  BatchPredictionName?: string | null;
  MLModelId: string;
  BatchPredictionDataSourceId: string;
  OutputUri: string;
}

// refs: 1 - tags: named, input
export interface CreateDataSourceFromRDSInput {
  DataSourceId: string;
  DataSourceName?: string | null;
  RDSData: RDSDataSpec;
  RoleARN: string;
  ComputeStatistics?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateDataSourceFromRedshiftInput {
  DataSourceId: string;
  DataSourceName?: string | null;
  DataSpec: RedshiftDataSpec;
  RoleARN: string;
  ComputeStatistics?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateDataSourceFromS3Input {
  DataSourceId: string;
  DataSourceName?: string | null;
  DataSpec: S3DataSpec;
  ComputeStatistics?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateEvaluationInput {
  EvaluationId: string;
  EvaluationName?: string | null;
  MLModelId: string;
  EvaluationDataSourceId: string;
}

// refs: 1 - tags: named, input
export interface CreateMLModelInput {
  MLModelId: string;
  MLModelName?: string | null;
  MLModelType: MLModelType;
  Parameters?: { [key: string]: string | null | undefined } | null;
  TrainingDataSourceId: string;
  Recipe?: string | null;
  RecipeUri?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateRealtimeEndpointInput {
  MLModelId: string;
}

// refs: 1 - tags: named, input
export interface DeleteBatchPredictionInput {
  BatchPredictionId: string;
}

// refs: 1 - tags: named, input
export interface DeleteDataSourceInput {
  DataSourceId: string;
}

// refs: 1 - tags: named, input
export interface DeleteEvaluationInput {
  EvaluationId: string;
}

// refs: 1 - tags: named, input
export interface DeleteMLModelInput {
  MLModelId: string;
}

// refs: 1 - tags: named, input
export interface DeleteRealtimeEndpointInput {
  MLModelId: string;
}

// refs: 1 - tags: named, input
export interface DeleteTagsInput {
  TagKeys: string[];
  ResourceId: string;
  ResourceType: TaggableResourceType;
}

// refs: 1 - tags: named, input
export interface DescribeBatchPredictionsInput {
  FilterVariable?: BatchPredictionFilterVariable | null;
  EQ?: string | null;
  GT?: string | null;
  LT?: string | null;
  GE?: string | null;
  LE?: string | null;
  NE?: string | null;
  Prefix?: string | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeDataSourcesInput {
  FilterVariable?: DataSourceFilterVariable | null;
  EQ?: string | null;
  GT?: string | null;
  LT?: string | null;
  GE?: string | null;
  LE?: string | null;
  NE?: string | null;
  Prefix?: string | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeEvaluationsInput {
  FilterVariable?: EvaluationFilterVariable | null;
  EQ?: string | null;
  GT?: string | null;
  LT?: string | null;
  GE?: string | null;
  LE?: string | null;
  NE?: string | null;
  Prefix?: string | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeMLModelsInput {
  FilterVariable?: MLModelFilterVariable | null;
  EQ?: string | null;
  GT?: string | null;
  LT?: string | null;
  GE?: string | null;
  LE?: string | null;
  NE?: string | null;
  Prefix?: string | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTagsInput {
  ResourceId: string;
  ResourceType: TaggableResourceType;
}

// refs: 1 - tags: named, input
export interface GetBatchPredictionInput {
  BatchPredictionId: string;
}

// refs: 1 - tags: named, input
export interface GetDataSourceInput {
  DataSourceId: string;
  Verbose?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetEvaluationInput {
  EvaluationId: string;
}

// refs: 1 - tags: named, input
export interface GetMLModelInput {
  MLModelId: string;
  Verbose?: boolean | null;
}

// refs: 1 - tags: named, input
export interface PredictInput {
  MLModelId: string;
  Record: { [key: string]: string | null | undefined };
  PredictEndpoint: string;
}

// refs: 1 - tags: named, input
export interface UpdateBatchPredictionInput {
  BatchPredictionId: string;
  BatchPredictionName: string;
}

// refs: 1 - tags: named, input
export interface UpdateDataSourceInput {
  DataSourceId: string;
  DataSourceName: string;
}

// refs: 1 - tags: named, input
export interface UpdateEvaluationInput {
  EvaluationId: string;
  EvaluationName: string;
}

// refs: 1 - tags: named, input
export interface UpdateMLModelInput {
  MLModelId: string;
  MLModelName?: string | null;
  ScoreThreshold?: number | null;
}

// refs: 1 - tags: named, output
export interface AddTagsOutput {
  ResourceId?: string | null;
  ResourceType?: TaggableResourceType | null;
}

// refs: 1 - tags: named, output
export interface CreateBatchPredictionOutput {
  BatchPredictionId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDataSourceFromRDSOutput {
  DataSourceId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDataSourceFromRedshiftOutput {
  DataSourceId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDataSourceFromS3Output {
  DataSourceId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateEvaluationOutput {
  EvaluationId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateMLModelOutput {
  MLModelId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateRealtimeEndpointOutput {
  MLModelId?: string | null;
  RealtimeEndpointInfo?: RealtimeEndpointInfo | null;
}

// refs: 1 - tags: named, output
export interface DeleteBatchPredictionOutput {
  BatchPredictionId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteDataSourceOutput {
  DataSourceId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteEvaluationOutput {
  EvaluationId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteMLModelOutput {
  MLModelId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteRealtimeEndpointOutput {
  MLModelId?: string | null;
  RealtimeEndpointInfo?: RealtimeEndpointInfo | null;
}

// refs: 1 - tags: named, output
export interface DeleteTagsOutput {
  ResourceId?: string | null;
  ResourceType?: TaggableResourceType | null;
}

// refs: 1 - tags: named, output
export interface DescribeBatchPredictionsOutput {
  Results?: BatchPrediction[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeDataSourcesOutput {
  Results?: DataSource[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeEvaluationsOutput {
  Results?: Evaluation[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeMLModelsOutput {
  Results?: MLModel[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTagsOutput {
  ResourceId?: string | null;
  ResourceType?: TaggableResourceType | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface GetBatchPredictionOutput {
  BatchPredictionId?: string | null;
  MLModelId?: string | null;
  BatchPredictionDataSourceId?: string | null;
  InputDataLocationS3?: string | null;
  CreatedByIamUser?: string | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  Name?: string | null;
  Status?: EntityStatus | null;
  OutputUri?: string | null;
  LogUri?: string | null;
  Message?: string | null;
  ComputeTime?: number | null;
  FinishedAt?: Date | number | null;
  StartedAt?: Date | number | null;
  TotalRecordCount?: number | null;
  InvalidRecordCount?: number | null;
}

// refs: 1 - tags: named, output
export interface GetDataSourceOutput {
  DataSourceId?: string | null;
  DataLocationS3?: string | null;
  DataRearrangement?: string | null;
  CreatedByIamUser?: string | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  DataSizeInBytes?: number | null;
  NumberOfFiles?: number | null;
  Name?: string | null;
  Status?: EntityStatus | null;
  LogUri?: string | null;
  Message?: string | null;
  RedshiftMetadata?: RedshiftMetadata | null;
  RDSMetadata?: RDSMetadata | null;
  RoleARN?: string | null;
  ComputeStatistics?: boolean | null;
  ComputeTime?: number | null;
  FinishedAt?: Date | number | null;
  StartedAt?: Date | number | null;
  DataSourceSchema?: string | null;
}

// refs: 1 - tags: named, output
export interface GetEvaluationOutput {
  EvaluationId?: string | null;
  MLModelId?: string | null;
  EvaluationDataSourceId?: string | null;
  InputDataLocationS3?: string | null;
  CreatedByIamUser?: string | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  Name?: string | null;
  Status?: EntityStatus | null;
  PerformanceMetrics?: PerformanceMetrics | null;
  LogUri?: string | null;
  Message?: string | null;
  ComputeTime?: number | null;
  FinishedAt?: Date | number | null;
  StartedAt?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetMLModelOutput {
  MLModelId?: string | null;
  TrainingDataSourceId?: string | null;
  CreatedByIamUser?: string | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  Name?: string | null;
  Status?: EntityStatus | null;
  SizeInBytes?: number | null;
  EndpointInfo?: RealtimeEndpointInfo | null;
  TrainingParameters?: { [key: string]: string | null | undefined } | null;
  InputDataLocationS3?: string | null;
  MLModelType?: MLModelType | null;
  ScoreThreshold?: number | null;
  ScoreThresholdLastUpdatedAt?: Date | number | null;
  LogUri?: string | null;
  Message?: string | null;
  ComputeTime?: number | null;
  FinishedAt?: Date | number | null;
  StartedAt?: Date | number | null;
  Recipe?: string | null;
  Schema?: string | null;
}

// refs: 1 - tags: named, output
export interface PredictOutput {
  Prediction?: Prediction | null;
}

// refs: 1 - tags: named, output
export interface UpdateBatchPredictionOutput {
  BatchPredictionId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateDataSourceOutput {
  DataSourceId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateEvaluationOutput {
  EvaluationId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateMLModelOutput {
  MLModelId?: string | null;
}

// refs: 2 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type TaggableResourceType =
| "BatchPrediction"
| "DataSource"
| "Evaluation"
| "MLModel"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface RDSDataSpec {
  DatabaseInformation: RDSDatabase;
  SelectSqlQuery: string;
  DatabaseCredentials: RDSDatabaseCredentials;
  S3StagingLocation: string;
  DataRearrangement?: string | null;
  DataSchema?: string | null;
  DataSchemaUri?: string | null;
  ResourceRole: string;
  ServiceRole: string;
  SubnetId: string;
  SecurityGroupIds: string[];
}
function fromRDSDataSpec(input?: RDSDataSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseInformation: fromRDSDatabase(input["DatabaseInformation"]),
    SelectSqlQuery: input["SelectSqlQuery"],
    DatabaseCredentials: fromRDSDatabaseCredentials(input["DatabaseCredentials"]),
    S3StagingLocation: input["S3StagingLocation"],
    DataRearrangement: input["DataRearrangement"],
    DataSchema: input["DataSchema"],
    DataSchemaUri: input["DataSchemaUri"],
    ResourceRole: input["ResourceRole"],
    ServiceRole: input["ServiceRole"],
    SubnetId: input["SubnetId"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}

// refs: 3 - tags: input, named, interface, output
export interface RDSDatabase {
  InstanceIdentifier: string;
  DatabaseName: string;
}
function fromRDSDatabase(input?: RDSDatabase | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceIdentifier: input["InstanceIdentifier"],
    DatabaseName: input["DatabaseName"],
  }
}
function toRDSDatabase(root: jsonP.JSONValue): RDSDatabase {
  return jsonP.readObj({
    required: {
      "InstanceIdentifier": "s",
      "DatabaseName": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface RDSDatabaseCredentials {
  Username: string;
  Password: string;
}
function fromRDSDatabaseCredentials(input?: RDSDatabaseCredentials | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Username: input["Username"],
    Password: input["Password"],
  }
}

// refs: 1 - tags: input, named, interface
export interface RedshiftDataSpec {
  DatabaseInformation: RedshiftDatabase;
  SelectSqlQuery: string;
  DatabaseCredentials: RedshiftDatabaseCredentials;
  S3StagingLocation: string;
  DataRearrangement?: string | null;
  DataSchema?: string | null;
  DataSchemaUri?: string | null;
}
function fromRedshiftDataSpec(input?: RedshiftDataSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseInformation: fromRedshiftDatabase(input["DatabaseInformation"]),
    SelectSqlQuery: input["SelectSqlQuery"],
    DatabaseCredentials: fromRedshiftDatabaseCredentials(input["DatabaseCredentials"]),
    S3StagingLocation: input["S3StagingLocation"],
    DataRearrangement: input["DataRearrangement"],
    DataSchema: input["DataSchema"],
    DataSchemaUri: input["DataSchemaUri"],
  }
}

// refs: 3 - tags: input, named, interface, output
export interface RedshiftDatabase {
  DatabaseName: string;
  ClusterIdentifier: string;
}
function fromRedshiftDatabase(input?: RedshiftDatabase | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    ClusterIdentifier: input["ClusterIdentifier"],
  }
}
function toRedshiftDatabase(root: jsonP.JSONValue): RedshiftDatabase {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
      "ClusterIdentifier": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface RedshiftDatabaseCredentials {
  Username: string;
  Password: string;
}
function fromRedshiftDatabaseCredentials(input?: RedshiftDatabaseCredentials | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Username: input["Username"],
    Password: input["Password"],
  }
}

// refs: 1 - tags: input, named, interface
export interface S3DataSpec {
  DataLocationS3: string;
  DataRearrangement?: string | null;
  DataSchema?: string | null;
  DataSchemaLocationS3?: string | null;
}
function fromS3DataSpec(input?: S3DataSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataLocationS3: input["DataLocationS3"],
    DataRearrangement: input["DataRearrangement"],
    DataSchema: input["DataSchema"],
    DataSchemaLocationS3: input["DataSchemaLocationS3"],
  }
}

// refs: 3 - tags: input, named, enum, output
export type MLModelType =
| "REGRESSION"
| "BINARY"
| "MULTICLASS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type BatchPredictionFilterVariable =
| "CreatedAt"
| "LastUpdatedAt"
| "Status"
| "Name"
| "IAMUser"
| "MLModelId"
| "DataSourceId"
| "DataURI"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum
export type SortOrder =
| "asc"
| "dsc"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type DataSourceFilterVariable =
| "CreatedAt"
| "LastUpdatedAt"
| "Status"
| "Name"
| "DataLocationS3"
| "IAMUser"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type EvaluationFilterVariable =
| "CreatedAt"
| "LastUpdatedAt"
| "Status"
| "Name"
| "IAMUser"
| "MLModelId"
| "DataSourceId"
| "DataURI"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type MLModelFilterVariable =
| "CreatedAt"
| "LastUpdatedAt"
| "Status"
| "Name"
| "IAMUser"
| "TrainingDataSourceId"
| "RealtimeEndpointStatus"
| "MLModelType"
| "Algorithm"
| "TrainingDataURI"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface RealtimeEndpointInfo {
  PeakRequestsPerSecond?: number | null;
  CreatedAt?: Date | number | null;
  EndpointUrl?: string | null;
  EndpointStatus?: RealtimeEndpointStatus | null;
}
function toRealtimeEndpointInfo(root: jsonP.JSONValue): RealtimeEndpointInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "PeakRequestsPerSecond": "n",
      "CreatedAt": "d",
      "EndpointUrl": "s",
      "EndpointStatus": (x: jsonP.JSONValue) => cmnP.readEnum<RealtimeEndpointStatus>(x),
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type RealtimeEndpointStatus =
| "NONE"
| "READY"
| "UPDATING"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface BatchPrediction {
  BatchPredictionId?: string | null;
  MLModelId?: string | null;
  BatchPredictionDataSourceId?: string | null;
  InputDataLocationS3?: string | null;
  CreatedByIamUser?: string | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  Name?: string | null;
  Status?: EntityStatus | null;
  OutputUri?: string | null;
  Message?: string | null;
  ComputeTime?: number | null;
  FinishedAt?: Date | number | null;
  StartedAt?: Date | number | null;
  TotalRecordCount?: number | null;
  InvalidRecordCount?: number | null;
}
function toBatchPrediction(root: jsonP.JSONValue): BatchPrediction {
  return jsonP.readObj({
    required: {},
    optional: {
      "BatchPredictionId": "s",
      "MLModelId": "s",
      "BatchPredictionDataSourceId": "s",
      "InputDataLocationS3": "s",
      "CreatedByIamUser": "s",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<EntityStatus>(x),
      "OutputUri": "s",
      "Message": "s",
      "ComputeTime": "n",
      "FinishedAt": "d",
      "StartedAt": "d",
      "TotalRecordCount": "n",
      "InvalidRecordCount": "n",
    },
  }, root);
}

// refs: 8 - tags: output, named, enum
export type EntityStatus =
| "PENDING"
| "INPROGRESS"
| "FAILED"
| "COMPLETED"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DataSource {
  DataSourceId?: string | null;
  DataLocationS3?: string | null;
  DataRearrangement?: string | null;
  CreatedByIamUser?: string | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  DataSizeInBytes?: number | null;
  NumberOfFiles?: number | null;
  Name?: string | null;
  Status?: EntityStatus | null;
  Message?: string | null;
  RedshiftMetadata?: RedshiftMetadata | null;
  RDSMetadata?: RDSMetadata | null;
  RoleARN?: string | null;
  ComputeStatistics?: boolean | null;
  ComputeTime?: number | null;
  FinishedAt?: Date | number | null;
  StartedAt?: Date | number | null;
}
function toDataSource(root: jsonP.JSONValue): DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "DataSourceId": "s",
      "DataLocationS3": "s",
      "DataRearrangement": "s",
      "CreatedByIamUser": "s",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "DataSizeInBytes": "n",
      "NumberOfFiles": "n",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<EntityStatus>(x),
      "Message": "s",
      "RedshiftMetadata": toRedshiftMetadata,
      "RDSMetadata": toRDSMetadata,
      "RoleARN": "s",
      "ComputeStatistics": "b",
      "ComputeTime": "n",
      "FinishedAt": "d",
      "StartedAt": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface RedshiftMetadata {
  RedshiftDatabase?: RedshiftDatabase | null;
  DatabaseUserName?: string | null;
  SelectSqlQuery?: string | null;
}
function toRedshiftMetadata(root: jsonP.JSONValue): RedshiftMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "RedshiftDatabase": toRedshiftDatabase,
      "DatabaseUserName": "s",
      "SelectSqlQuery": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface RDSMetadata {
  Database?: RDSDatabase | null;
  DatabaseUserName?: string | null;
  SelectSqlQuery?: string | null;
  ResourceRole?: string | null;
  ServiceRole?: string | null;
  DataPipelineId?: string | null;
}
function toRDSMetadata(root: jsonP.JSONValue): RDSMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Database": toRDSDatabase,
      "DatabaseUserName": "s",
      "SelectSqlQuery": "s",
      "ResourceRole": "s",
      "ServiceRole": "s",
      "DataPipelineId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Evaluation {
  EvaluationId?: string | null;
  MLModelId?: string | null;
  EvaluationDataSourceId?: string | null;
  InputDataLocationS3?: string | null;
  CreatedByIamUser?: string | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  Name?: string | null;
  Status?: EntityStatus | null;
  PerformanceMetrics?: PerformanceMetrics | null;
  Message?: string | null;
  ComputeTime?: number | null;
  FinishedAt?: Date | number | null;
  StartedAt?: Date | number | null;
}
function toEvaluation(root: jsonP.JSONValue): Evaluation {
  return jsonP.readObj({
    required: {},
    optional: {
      "EvaluationId": "s",
      "MLModelId": "s",
      "EvaluationDataSourceId": "s",
      "InputDataLocationS3": "s",
      "CreatedByIamUser": "s",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<EntityStatus>(x),
      "PerformanceMetrics": toPerformanceMetrics,
      "Message": "s",
      "ComputeTime": "n",
      "FinishedAt": "d",
      "StartedAt": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface PerformanceMetrics {
  Properties?: { [key: string]: string | null | undefined } | null;
}
function toPerformanceMetrics(root: jsonP.JSONValue): PerformanceMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "Properties": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MLModel {
  MLModelId?: string | null;
  TrainingDataSourceId?: string | null;
  CreatedByIamUser?: string | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  Name?: string | null;
  Status?: EntityStatus | null;
  SizeInBytes?: number | null;
  EndpointInfo?: RealtimeEndpointInfo | null;
  TrainingParameters?: { [key: string]: string | null | undefined } | null;
  InputDataLocationS3?: string | null;
  Algorithm?: Algorithm | null;
  MLModelType?: MLModelType | null;
  ScoreThreshold?: number | null;
  ScoreThresholdLastUpdatedAt?: Date | number | null;
  Message?: string | null;
  ComputeTime?: number | null;
  FinishedAt?: Date | number | null;
  StartedAt?: Date | number | null;
}
function toMLModel(root: jsonP.JSONValue): MLModel {
  return jsonP.readObj({
    required: {},
    optional: {
      "MLModelId": "s",
      "TrainingDataSourceId": "s",
      "CreatedByIamUser": "s",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<EntityStatus>(x),
      "SizeInBytes": "n",
      "EndpointInfo": toRealtimeEndpointInfo,
      "TrainingParameters": x => jsonP.readMap(String, String, x),
      "InputDataLocationS3": "s",
      "Algorithm": (x: jsonP.JSONValue) => cmnP.readEnum<Algorithm>(x),
      "MLModelType": (x: jsonP.JSONValue) => cmnP.readEnum<MLModelType>(x),
      "ScoreThreshold": "n",
      "ScoreThresholdLastUpdatedAt": "d",
      "Message": "s",
      "ComputeTime": "n",
      "FinishedAt": "d",
      "StartedAt": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type Algorithm =
| "sgd"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Prediction {
  predictedLabel?: string | null;
  predictedValue?: number | null;
  predictedScores?: { [key: string]: number | null | undefined } | null;
  details?: { [key in DetailsAttributes]: string | null | undefined } | null;
}
function toPrediction(root: jsonP.JSONValue): Prediction {
  return jsonP.readObj({
    required: {},
    optional: {
      "predictedLabel": "s",
      "predictedValue": "n",
      "predictedScores": x => jsonP.readMap(String, Number, x),
      "details": x => jsonP.readMap(x => cmnP.readEnumReq<DetailsAttributes>(x), String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type DetailsAttributes =
| "PredictiveModelType"
| "Algorithm"
| cmnP.UnexpectedEnumValue;
