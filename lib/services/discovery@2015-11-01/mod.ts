// Autogenerated API client for: AWS Application Discovery Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class Discovery {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Discovery.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-11-01",
    "endpointPrefix": "discovery",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Application Discovery Service",
    "serviceId": "Application Discovery Service",
    "signatureVersion": "v4",
    "targetPrefix": "AWSPoseidonService_V2015_11_01",
    "uid": "discovery-2015-11-01"
  };

  async associateConfigurationItemsToApplication(
    {abortSignal, ...params}: RequestConfig & s.AssociateConfigurationItemsToApplicationRequest,
  ): Promise<s.AssociateConfigurationItemsToApplicationResponse> {
    const body: jsonP.JSONObject = {
      applicationConfigurationId: params["applicationConfigurationId"],
      configurationIds: params["configurationIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateConfigurationItemsToApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async batchDeleteImportData(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteImportDataRequest,
  ): Promise<s.BatchDeleteImportDataResponse> {
    const body: jsonP.JSONObject = {
      importTaskIds: params["importTaskIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteImportData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "errors": [toBatchDeleteImportDataError],
      },
    }, await resp.json());
  }

  async createApplication(
    {abortSignal, ...params}: RequestConfig & s.CreateApplicationRequest,
  ): Promise<s.CreateApplicationResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "configurationId": "s",
      },
    }, await resp.json());
  }

  async createTags(
    {abortSignal, ...params}: RequestConfig & s.CreateTagsRequest,
  ): Promise<s.CreateTagsResponse> {
    const body: jsonP.JSONObject = {
      configurationIds: params["configurationIds"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteApplications(
    {abortSignal, ...params}: RequestConfig & s.DeleteApplicationsRequest,
  ): Promise<s.DeleteApplicationsResponse> {
    const body: jsonP.JSONObject = {
      configurationIds: params["configurationIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplications",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & s.DeleteTagsRequest,
  ): Promise<s.DeleteTagsResponse> {
    const body: jsonP.JSONObject = {
      configurationIds: params["configurationIds"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeAgents(
    {abortSignal, ...params}: RequestConfig & s.DescribeAgentsRequest = {},
  ): Promise<s.DescribeAgentsResponse> {
    const body: jsonP.JSONObject = {
      agentIds: params["agentIds"],
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAgents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "agentsInfo": [toAgentInfo],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeConfigurations(
    {abortSignal, ...params}: RequestConfig & s.DescribeConfigurationsRequest,
  ): Promise<s.DescribeConfigurationsResponse> {
    const body: jsonP.JSONObject = {
      configurationIds: params["configurationIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "configurations": [x => jsonP.readMap(String, String, x)],
      },
    }, await resp.json());
  }

  async describeContinuousExports(
    {abortSignal, ...params}: RequestConfig & s.DescribeContinuousExportsRequest = {},
  ): Promise<s.DescribeContinuousExportsResponse> {
    const body: jsonP.JSONObject = {
      exportIds: params["exportIds"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeContinuousExports",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "descriptions": [toContinuousExportDescription],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeExportConfigurations(
    {abortSignal, ...params}: RequestConfig & s.DescribeExportConfigurationsRequest = {},
  ): Promise<s.DescribeExportConfigurationsResponse> {
    const body: jsonP.JSONObject = {
      exportIds: params["exportIds"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExportConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "exportsInfo": [toExportInfo],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeExportTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeExportTasksRequest = {},
  ): Promise<s.DescribeExportTasksResponse> {
    const body: jsonP.JSONObject = {
      exportIds: params["exportIds"],
      filters: params["filters"]?.map(x => fromExportFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExportTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "exportsInfo": [toExportInfo],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeImportTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeImportTasksRequest = {},
  ): Promise<s.DescribeImportTasksResponse> {
    const body: jsonP.JSONObject = {
      filters: params["filters"]?.map(x => fromImportTaskFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImportTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "tasks": [toImportTask],
      },
    }, await resp.json());
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & s.DescribeTagsRequest = {},
  ): Promise<s.DescribeTagsResponse> {
    const body: jsonP.JSONObject = {
      filters: params["filters"]?.map(x => fromTagFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toConfigurationTag],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async disassociateConfigurationItemsFromApplication(
    {abortSignal, ...params}: RequestConfig & s.DisassociateConfigurationItemsFromApplicationRequest,
  ): Promise<s.DisassociateConfigurationItemsFromApplicationResponse> {
    const body: jsonP.JSONObject = {
      applicationConfigurationId: params["applicationConfigurationId"],
      configurationIds: params["configurationIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateConfigurationItemsFromApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async exportConfigurations(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.ExportConfigurationsResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ExportConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "exportId": "s",
      },
    }, await resp.json());
  }

  async getDiscoverySummary(
    {abortSignal, ...params}: RequestConfig & s.GetDiscoverySummaryRequest = {},
  ): Promise<s.GetDiscoverySummaryResponse> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDiscoverySummary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "servers": "n",
        "applications": "n",
        "serversMappedToApplications": "n",
        "serversMappedtoTags": "n",
        "agentSummary": toCustomerAgentInfo,
        "connectorSummary": toCustomerConnectorInfo,
      },
    }, await resp.json());
  }

  async listConfigurations(
    {abortSignal, ...params}: RequestConfig & s.ListConfigurationsRequest,
  ): Promise<s.ListConfigurationsResponse> {
    const body: jsonP.JSONObject = {
      configurationType: params["configurationType"],
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      orderBy: params["orderBy"]?.map(x => fromOrderByElement(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "configurations": [x => jsonP.readMap(String, String, x)],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listServerNeighbors(
    {abortSignal, ...params}: RequestConfig & s.ListServerNeighborsRequest,
  ): Promise<s.ListServerNeighborsResponse> {
    const body: jsonP.JSONObject = {
      configurationId: params["configurationId"],
      portInformationNeeded: params["portInformationNeeded"],
      neighborConfigurationIds: params["neighborConfigurationIds"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListServerNeighbors",
    });
    return jsonP.readObj({
      required: {
        "neighbors": [toNeighborConnectionDetail],
      },
      optional: {
        "nextToken": "s",
        "knownDependencyCount": "n",
      },
    }, await resp.json());
  }

  async startContinuousExport(
    {abortSignal, ...params}: RequestConfig & s.StartContinuousExportRequest = {},
  ): Promise<s.StartContinuousExportResponse> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartContinuousExport",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "exportId": "s",
        "s3Bucket": "s",
        "startTime": "d",
        "dataSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataSource>(x),
        "schemaStorageConfig": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async startDataCollectionByAgentIds(
    {abortSignal, ...params}: RequestConfig & s.StartDataCollectionByAgentIdsRequest,
  ): Promise<s.StartDataCollectionByAgentIdsResponse> {
    const body: jsonP.JSONObject = {
      agentIds: params["agentIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDataCollectionByAgentIds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "agentsConfigurationStatus": [toAgentConfigurationStatus],
      },
    }, await resp.json());
  }

  async startExportTask(
    {abortSignal, ...params}: RequestConfig & s.StartExportTaskRequest = {},
  ): Promise<s.StartExportTaskResponse> {
    const body: jsonP.JSONObject = {
      exportDataFormat: params["exportDataFormat"],
      filters: params["filters"]?.map(x => fromExportFilter(x)),
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartExportTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "exportId": "s",
      },
    }, await resp.json());
  }

  async startImportTask(
    {abortSignal, ...params}: RequestConfig & s.StartImportTaskRequest,
  ): Promise<s.StartImportTaskResponse> {
    const body: jsonP.JSONObject = {
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      name: params["name"],
      importUrl: params["importUrl"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartImportTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "task": toImportTask,
      },
    }, await resp.json());
  }

  async stopContinuousExport(
    {abortSignal, ...params}: RequestConfig & s.StopContinuousExportRequest,
  ): Promise<s.StopContinuousExportResponse> {
    const body: jsonP.JSONObject = {
      exportId: params["exportId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopContinuousExport",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "startTime": "d",
        "stopTime": "d",
      },
    }, await resp.json());
  }

  async stopDataCollectionByAgentIds(
    {abortSignal, ...params}: RequestConfig & s.StopDataCollectionByAgentIdsRequest,
  ): Promise<s.StopDataCollectionByAgentIdsResponse> {
    const body: jsonP.JSONObject = {
      agentIds: params["agentIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopDataCollectionByAgentIds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "agentsConfigurationStatus": [toAgentConfigurationStatus],
      },
    }, await resp.json());
  }

  async updateApplication(
    {abortSignal, ...params}: RequestConfig & s.UpdateApplicationRequest,
  ): Promise<s.UpdateApplicationResponse> {
    const body: jsonP.JSONObject = {
      configurationId: params["configurationId"],
      name: params["name"],
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}

function fromFilter(input?: s.Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
    condition: input["condition"],
  }
}

function fromExportFilter(input?: s.ExportFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
    condition: input["condition"],
  }
}

function fromImportTaskFilter(input?: s.ImportTaskFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
  }
}

function fromTagFilter(input?: s.TagFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
  }
}

function fromOrderByElement(input?: s.OrderByElement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fieldName: input["fieldName"],
    sortOrder: input["sortOrder"],
  }
}

function toBatchDeleteImportDataError(root: jsonP.JSONValue): s.BatchDeleteImportDataError {
  return jsonP.readObj({
    required: {},
    optional: {
      "importTaskId": "s",
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.BatchDeleteImportDataErrorCode>(x),
      "errorDescription": "s",
    },
  }, root);
}

function toAgentInfo(root: jsonP.JSONValue): s.AgentInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "agentId": "s",
      "hostName": "s",
      "agentNetworkInfoList": [toAgentNetworkInfo],
      "connectorId": "s",
      "version": "s",
      "health": (x: jsonP.JSONValue) => cmnP.readEnum<s.AgentStatus>(x),
      "lastHealthPingTime": "s",
      "collectionStatus": "s",
      "agentType": "s",
      "registeredTime": "s",
    },
  }, root);
}

function toAgentNetworkInfo(root: jsonP.JSONValue): s.AgentNetworkInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ipAddress": "s",
      "macAddress": "s",
    },
  }, root);
}

function toContinuousExportDescription(root: jsonP.JSONValue): s.ContinuousExportDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "exportId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContinuousExportStatus>(x),
      "statusDetail": "s",
      "s3Bucket": "s",
      "startTime": "d",
      "stopTime": "d",
      "dataSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataSource>(x),
      "schemaStorageConfig": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toExportInfo(root: jsonP.JSONValue): s.ExportInfo {
  return jsonP.readObj({
    required: {
      "exportId": "s",
      "exportStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExportStatus>(x),
      "statusMessage": "s",
      "exportRequestTime": "d",
    },
    optional: {
      "configurationsDownloadUrl": "s",
      "isTruncated": "b",
      "requestedStartTime": "d",
      "requestedEndTime": "d",
    },
  }, root);
}

function toImportTask(root: jsonP.JSONValue): s.ImportTask {
  return jsonP.readObj({
    required: {},
    optional: {
      "importTaskId": "s",
      "clientRequestToken": "s",
      "name": "s",
      "importUrl": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImportStatus>(x),
      "importRequestTime": "d",
      "importCompletionTime": "d",
      "importDeletedTime": "d",
      "serverImportSuccess": "n",
      "serverImportFailure": "n",
      "applicationImportSuccess": "n",
      "applicationImportFailure": "n",
      "errorsAndFailedEntriesZip": "s",
    },
  }, root);
}

function toConfigurationTag(root: jsonP.JSONValue): s.ConfigurationTag {
  return jsonP.readObj({
    required: {},
    optional: {
      "configurationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConfigurationItemType>(x),
      "configurationId": "s",
      "key": "s",
      "value": "s",
      "timeOfCreation": "d",
    },
  }, root);
}

function toCustomerAgentInfo(root: jsonP.JSONValue): s.CustomerAgentInfo {
  return jsonP.readObj({
    required: {
      "activeAgents": "n",
      "healthyAgents": "n",
      "blackListedAgents": "n",
      "shutdownAgents": "n",
      "unhealthyAgents": "n",
      "totalAgents": "n",
      "unknownAgents": "n",
    },
    optional: {},
  }, root);
}

function toCustomerConnectorInfo(root: jsonP.JSONValue): s.CustomerConnectorInfo {
  return jsonP.readObj({
    required: {
      "activeConnectors": "n",
      "healthyConnectors": "n",
      "blackListedConnectors": "n",
      "shutdownConnectors": "n",
      "unhealthyConnectors": "n",
      "totalConnectors": "n",
      "unknownConnectors": "n",
    },
    optional: {},
  }, root);
}

function toNeighborConnectionDetail(root: jsonP.JSONValue): s.NeighborConnectionDetail {
  return jsonP.readObj({
    required: {
      "sourceServerId": "s",
      "destinationServerId": "s",
      "connectionsCount": "n",
    },
    optional: {
      "destinationPort": "n",
      "transportProtocol": "s",
    },
  }, root);
}

function toAgentConfigurationStatus(root: jsonP.JSONValue): s.AgentConfigurationStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "agentId": "s",
      "operationSucceeded": "b",
      "description": "s",
    },
  }, root);
}
