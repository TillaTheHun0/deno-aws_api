// Autogenerated API client for: Amazon EventBridge

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class EventBridge {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EventBridge.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-10-07",
    "endpointPrefix": "events",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon EventBridge",
    "serviceId": "EventBridge",
    "signatureVersion": "v4",
    "targetPrefix": "AWSEvents",
    "uid": "eventbridge-2015-10-07"
  };

  async activateEventSource(
    {abortSignal, ...params}: RequestConfig & s.ActivateEventSourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ActivateEventSource",
    });
  }

  async cancelReplay(
    {abortSignal, ...params}: RequestConfig & s.CancelReplayRequest,
  ): Promise<s.CancelReplayResponse> {
    const body: jsonP.JSONObject = {
      ReplayName: params["ReplayName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelReplay",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplayArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplayState>(x),
        "StateReason": "s",
      },
    }, await resp.json());
  }

  async createArchive(
    {abortSignal, ...params}: RequestConfig & s.CreateArchiveRequest,
  ): Promise<s.CreateArchiveResponse> {
    const body: jsonP.JSONObject = {
      ArchiveName: params["ArchiveName"],
      EventSourceArn: params["EventSourceArn"],
      Description: params["Description"],
      EventPattern: params["EventPattern"],
      RetentionDays: params["RetentionDays"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateArchive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ArchiveArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArchiveState>(x),
        "StateReason": "s",
        "CreationTime": "d",
      },
    }, await resp.json());
  }

  async createEventBus(
    {abortSignal, ...params}: RequestConfig & s.CreateEventBusRequest,
  ): Promise<s.CreateEventBusResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      EventSourceName: params["EventSourceName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventBus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventBusArn": "s",
      },
    }, await resp.json());
  }

  async createPartnerEventSource(
    {abortSignal, ...params}: RequestConfig & s.CreatePartnerEventSourceRequest,
  ): Promise<s.CreatePartnerEventSourceResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Account: params["Account"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePartnerEventSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventSourceArn": "s",
      },
    }, await resp.json());
  }

  async deactivateEventSource(
    {abortSignal, ...params}: RequestConfig & s.DeactivateEventSourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeactivateEventSource",
    });
  }

  async deleteArchive(
    {abortSignal, ...params}: RequestConfig & s.DeleteArchiveRequest,
  ): Promise<s.DeleteArchiveResponse> {
    const body: jsonP.JSONObject = {
      ArchiveName: params["ArchiveName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteArchive",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteEventBus(
    {abortSignal, ...params}: RequestConfig & s.DeleteEventBusRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventBus",
    });
  }

  async deletePartnerEventSource(
    {abortSignal, ...params}: RequestConfig & s.DeletePartnerEventSourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Account: params["Account"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePartnerEventSource",
    });
  }

  async deleteRule(
    {abortSignal, ...params}: RequestConfig & s.DeleteRuleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      EventBusName: params["EventBusName"],
      Force: params["Force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRule",
    });
  }

  async describeArchive(
    {abortSignal, ...params}: RequestConfig & s.DescribeArchiveRequest,
  ): Promise<s.DescribeArchiveResponse> {
    const body: jsonP.JSONObject = {
      ArchiveName: params["ArchiveName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeArchive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ArchiveArn": "s",
        "ArchiveName": "s",
        "EventSourceArn": "s",
        "Description": "s",
        "EventPattern": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArchiveState>(x),
        "StateReason": "s",
        "RetentionDays": "n",
        "SizeBytes": "n",
        "EventCount": "n",
        "CreationTime": "d",
      },
    }, await resp.json());
  }

  async describeEventBus(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventBusRequest = {},
  ): Promise<s.DescribeEventBusResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventBus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Arn": "s",
        "Policy": "s",
      },
    }, await resp.json());
  }

  async describeEventSource(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventSourceRequest,
  ): Promise<s.DescribeEventSourceResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CreatedBy": "s",
        "CreationTime": "d",
        "ExpirationTime": "d",
        "Name": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventSourceState>(x),
      },
    }, await resp.json());
  }

  async describePartnerEventSource(
    {abortSignal, ...params}: RequestConfig & s.DescribePartnerEventSourceRequest,
  ): Promise<s.DescribePartnerEventSourceResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePartnerEventSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async describeReplay(
    {abortSignal, ...params}: RequestConfig & s.DescribeReplayRequest,
  ): Promise<s.DescribeReplayResponse> {
    const body: jsonP.JSONObject = {
      ReplayName: params["ReplayName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplay",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplayName": "s",
        "ReplayArn": "s",
        "Description": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplayState>(x),
        "StateReason": "s",
        "EventSourceArn": "s",
        "Destination": toReplayDestination,
        "EventStartTime": "d",
        "EventEndTime": "d",
        "EventLastReplayedTime": "d",
        "ReplayStartTime": "d",
        "ReplayEndTime": "d",
      },
    }, await resp.json());
  }

  async describeRule(
    {abortSignal, ...params}: RequestConfig & s.DescribeRuleRequest,
  ): Promise<s.DescribeRuleResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      EventBusName: params["EventBusName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Arn": "s",
        "EventPattern": "s",
        "ScheduleExpression": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.RuleState>(x),
        "Description": "s",
        "RoleArn": "s",
        "ManagedBy": "s",
        "EventBusName": "s",
        "CreatedBy": "s",
      },
    }, await resp.json());
  }

  async disableRule(
    {abortSignal, ...params}: RequestConfig & s.DisableRuleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      EventBusName: params["EventBusName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableRule",
    });
  }

  async enableRule(
    {abortSignal, ...params}: RequestConfig & s.EnableRuleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      EventBusName: params["EventBusName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableRule",
    });
  }

  async listArchives(
    {abortSignal, ...params}: RequestConfig & s.ListArchivesRequest = {},
  ): Promise<s.ListArchivesResponse> {
    const body: jsonP.JSONObject = {
      NamePrefix: params["NamePrefix"],
      EventSourceArn: params["EventSourceArn"],
      State: params["State"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListArchives",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Archives": [toArchive],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEventBuses(
    {abortSignal, ...params}: RequestConfig & s.ListEventBusesRequest = {},
  ): Promise<s.ListEventBusesResponse> {
    const body: jsonP.JSONObject = {
      NamePrefix: params["NamePrefix"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEventBuses",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventBuses": [toEventBus],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEventSources(
    {abortSignal, ...params}: RequestConfig & s.ListEventSourcesRequest = {},
  ): Promise<s.ListEventSourcesResponse> {
    const body: jsonP.JSONObject = {
      NamePrefix: params["NamePrefix"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEventSources",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventSources": [toEventSource],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPartnerEventSourceAccounts(
    {abortSignal, ...params}: RequestConfig & s.ListPartnerEventSourceAccountsRequest,
  ): Promise<s.ListPartnerEventSourceAccountsResponse> {
    const body: jsonP.JSONObject = {
      EventSourceName: params["EventSourceName"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPartnerEventSourceAccounts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PartnerEventSourceAccounts": [toPartnerEventSourceAccount],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPartnerEventSources(
    {abortSignal, ...params}: RequestConfig & s.ListPartnerEventSourcesRequest,
  ): Promise<s.ListPartnerEventSourcesResponse> {
    const body: jsonP.JSONObject = {
      NamePrefix: params["NamePrefix"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPartnerEventSources",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PartnerEventSources": [toPartnerEventSource],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listReplays(
    {abortSignal, ...params}: RequestConfig & s.ListReplaysRequest = {},
  ): Promise<s.ListReplaysResponse> {
    const body: jsonP.JSONObject = {
      NamePrefix: params["NamePrefix"],
      State: params["State"],
      EventSourceArn: params["EventSourceArn"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReplays",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Replays": [toReplay],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listRuleNamesByTarget(
    {abortSignal, ...params}: RequestConfig & s.ListRuleNamesByTargetRequest,
  ): Promise<s.ListRuleNamesByTargetResponse> {
    const body: jsonP.JSONObject = {
      TargetArn: params["TargetArn"],
      EventBusName: params["EventBusName"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRuleNamesByTarget",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RuleNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listRules(
    {abortSignal, ...params}: RequestConfig & s.ListRulesRequest = {},
  ): Promise<s.ListRulesResponse> {
    const body: jsonP.JSONObject = {
      NamePrefix: params["NamePrefix"],
      EventBusName: params["EventBusName"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRules",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Rules": [toRule],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async listTargetsByRule(
    {abortSignal, ...params}: RequestConfig & s.ListTargetsByRuleRequest,
  ): Promise<s.ListTargetsByRuleResponse> {
    const body: jsonP.JSONObject = {
      Rule: params["Rule"],
      EventBusName: params["EventBusName"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTargetsByRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Targets": [toTarget],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putEvents(
    {abortSignal, ...params}: RequestConfig & s.PutEventsRequest,
  ): Promise<s.PutEventsResponse> {
    const body: jsonP.JSONObject = {
      Entries: params["Entries"]?.map(x => fromPutEventsRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FailedEntryCount": "n",
        "Entries": [toPutEventsResultEntry],
      },
    }, await resp.json());
  }

  async putPartnerEvents(
    {abortSignal, ...params}: RequestConfig & s.PutPartnerEventsRequest,
  ): Promise<s.PutPartnerEventsResponse> {
    const body: jsonP.JSONObject = {
      Entries: params["Entries"]?.map(x => fromPutPartnerEventsRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutPartnerEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FailedEntryCount": "n",
        "Entries": [toPutPartnerEventsResultEntry],
      },
    }, await resp.json());
  }

  async putPermission(
    {abortSignal, ...params}: RequestConfig & s.PutPermissionRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EventBusName: params["EventBusName"],
      Action: params["Action"],
      Principal: params["Principal"],
      StatementId: params["StatementId"],
      Condition: fromCondition(params["Condition"]),
      Policy: params["Policy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutPermission",
    });
  }

  async putRule(
    {abortSignal, ...params}: RequestConfig & s.PutRuleRequest,
  ): Promise<s.PutRuleResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ScheduleExpression: params["ScheduleExpression"],
      EventPattern: params["EventPattern"],
      State: params["State"],
      Description: params["Description"],
      RoleArn: params["RoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      EventBusName: params["EventBusName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RuleArn": "s",
      },
    }, await resp.json());
  }

  async putTargets(
    {abortSignal, ...params}: RequestConfig & s.PutTargetsRequest,
  ): Promise<s.PutTargetsResponse> {
    const body: jsonP.JSONObject = {
      Rule: params["Rule"],
      EventBusName: params["EventBusName"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutTargets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FailedEntryCount": "n",
        "FailedEntries": [toPutTargetsResultEntry],
      },
    }, await resp.json());
  }

  async removePermission(
    {abortSignal, ...params}: RequestConfig & s.RemovePermissionRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StatementId: params["StatementId"],
      RemoveAllPermissions: params["RemoveAllPermissions"],
      EventBusName: params["EventBusName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemovePermission",
    });
  }

  async removeTargets(
    {abortSignal, ...params}: RequestConfig & s.RemoveTargetsRequest,
  ): Promise<s.RemoveTargetsResponse> {
    const body: jsonP.JSONObject = {
      Rule: params["Rule"],
      EventBusName: params["EventBusName"],
      Ids: params["Ids"],
      Force: params["Force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTargets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FailedEntryCount": "n",
        "FailedEntries": [toRemoveTargetsResultEntry],
      },
    }, await resp.json());
  }

  async startReplay(
    {abortSignal, ...params}: RequestConfig & s.StartReplayRequest,
  ): Promise<s.StartReplayResponse> {
    const body: jsonP.JSONObject = {
      ReplayName: params["ReplayName"],
      Description: params["Description"],
      EventSourceArn: params["EventSourceArn"],
      EventStartTime: jsonP.serializeDate_unixTimestamp(params["EventStartTime"]),
      EventEndTime: jsonP.serializeDate_unixTimestamp(params["EventEndTime"]),
      Destination: fromReplayDestination(params["Destination"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartReplay",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplayArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplayState>(x),
        "StateReason": "s",
        "ReplayStartTime": "d",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async testEventPattern(
    {abortSignal, ...params}: RequestConfig & s.TestEventPatternRequest,
  ): Promise<s.TestEventPatternResponse> {
    const body: jsonP.JSONObject = {
      EventPattern: params["EventPattern"],
      Event: params["Event"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestEventPattern",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Result": "b",
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateArchive(
    {abortSignal, ...params}: RequestConfig & s.UpdateArchiveRequest,
  ): Promise<s.UpdateArchiveResponse> {
    const body: jsonP.JSONObject = {
      ArchiveName: params["ArchiveName"],
      Description: params["Description"],
      EventPattern: params["EventPattern"],
      RetentionDays: params["RetentionDays"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateArchive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ArchiveArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArchiveState>(x),
        "StateReason": "s",
        "CreationTime": "d",
      },
    }, await resp.json());
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromPutEventsRequestEntry(input?: s.PutEventsRequestEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Time: jsonP.serializeDate_unixTimestamp(input["Time"]),
    Source: input["Source"],
    Resources: input["Resources"],
    DetailType: input["DetailType"],
    Detail: input["Detail"],
    EventBusName: input["EventBusName"],
  }
}

function fromPutPartnerEventsRequestEntry(input?: s.PutPartnerEventsRequestEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Time: jsonP.serializeDate_unixTimestamp(input["Time"]),
    Source: input["Source"],
    Resources: input["Resources"],
    DetailType: input["DetailType"],
    Detail: input["Detail"],
  }
}

function fromCondition(input?: s.Condition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Key: input["Key"],
    Value: input["Value"],
  }
}

function fromTarget(input?: s.Target | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Arn: input["Arn"],
    RoleArn: input["RoleArn"],
    Input: input["Input"],
    InputPath: input["InputPath"],
    InputTransformer: fromInputTransformer(input["InputTransformer"]),
    KinesisParameters: fromKinesisParameters(input["KinesisParameters"]),
    RunCommandParameters: fromRunCommandParameters(input["RunCommandParameters"]),
    EcsParameters: fromEcsParameters(input["EcsParameters"]),
    BatchParameters: fromBatchParameters(input["BatchParameters"]),
    SqsParameters: fromSqsParameters(input["SqsParameters"]),
    HttpParameters: fromHttpParameters(input["HttpParameters"]),
    RedshiftDataParameters: fromRedshiftDataParameters(input["RedshiftDataParameters"]),
    DeadLetterConfig: fromDeadLetterConfig(input["DeadLetterConfig"]),
    RetryPolicy: fromRetryPolicy(input["RetryPolicy"]),
  }
}
function toTarget(root: jsonP.JSONValue): s.Target {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "Arn": "s",
    },
    optional: {
      "RoleArn": "s",
      "Input": "s",
      "InputPath": "s",
      "InputTransformer": toInputTransformer,
      "KinesisParameters": toKinesisParameters,
      "RunCommandParameters": toRunCommandParameters,
      "EcsParameters": toEcsParameters,
      "BatchParameters": toBatchParameters,
      "SqsParameters": toSqsParameters,
      "HttpParameters": toHttpParameters,
      "RedshiftDataParameters": toRedshiftDataParameters,
      "DeadLetterConfig": toDeadLetterConfig,
      "RetryPolicy": toRetryPolicy,
    },
  }, root);
}

function fromInputTransformer(input?: s.InputTransformer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputPathsMap: input["InputPathsMap"],
    InputTemplate: input["InputTemplate"],
  }
}
function toInputTransformer(root: jsonP.JSONValue): s.InputTransformer {
  return jsonP.readObj({
    required: {
      "InputTemplate": "s",
    },
    optional: {
      "InputPathsMap": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromKinesisParameters(input?: s.KinesisParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PartitionKeyPath: input["PartitionKeyPath"],
  }
}
function toKinesisParameters(root: jsonP.JSONValue): s.KinesisParameters {
  return jsonP.readObj({
    required: {
      "PartitionKeyPath": "s",
    },
    optional: {},
  }, root);
}

function fromRunCommandParameters(input?: s.RunCommandParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RunCommandTargets: input["RunCommandTargets"]?.map(x => fromRunCommandTarget(x)),
  }
}
function toRunCommandParameters(root: jsonP.JSONValue): s.RunCommandParameters {
  return jsonP.readObj({
    required: {
      "RunCommandTargets": [toRunCommandTarget],
    },
    optional: {},
  }, root);
}

function fromRunCommandTarget(input?: s.RunCommandTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}
function toRunCommandTarget(root: jsonP.JSONValue): s.RunCommandTarget {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

function fromEcsParameters(input?: s.EcsParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TaskDefinitionArn: input["TaskDefinitionArn"],
    TaskCount: input["TaskCount"],
    LaunchType: input["LaunchType"],
    NetworkConfiguration: fromNetworkConfiguration(input["NetworkConfiguration"]),
    PlatformVersion: input["PlatformVersion"],
    Group: input["Group"],
  }
}
function toEcsParameters(root: jsonP.JSONValue): s.EcsParameters {
  return jsonP.readObj({
    required: {
      "TaskDefinitionArn": "s",
    },
    optional: {
      "TaskCount": "n",
      "LaunchType": (x: jsonP.JSONValue) => cmnP.readEnum<s.LaunchType>(x),
      "NetworkConfiguration": toNetworkConfiguration,
      "PlatformVersion": "s",
      "Group": "s",
    },
  }, root);
}

function fromNetworkConfiguration(input?: s.NetworkConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    awsvpcConfiguration: fromAwsVpcConfiguration(input["awsvpcConfiguration"]),
  }
}
function toNetworkConfiguration(root: jsonP.JSONValue): s.NetworkConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsvpcConfiguration": toAwsVpcConfiguration,
    },
  }, root);
}

function fromAwsVpcConfiguration(input?: s.AwsVpcConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Subnets: input["Subnets"],
    SecurityGroups: input["SecurityGroups"],
    AssignPublicIp: input["AssignPublicIp"],
  }
}
function toAwsVpcConfiguration(root: jsonP.JSONValue): s.AwsVpcConfiguration {
  return jsonP.readObj({
    required: {
      "Subnets": ["s"],
    },
    optional: {
      "SecurityGroups": ["s"],
      "AssignPublicIp": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssignPublicIp>(x),
    },
  }, root);
}

function fromBatchParameters(input?: s.BatchParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobDefinition: input["JobDefinition"],
    JobName: input["JobName"],
    ArrayProperties: fromBatchArrayProperties(input["ArrayProperties"]),
    RetryStrategy: fromBatchRetryStrategy(input["RetryStrategy"]),
  }
}
function toBatchParameters(root: jsonP.JSONValue): s.BatchParameters {
  return jsonP.readObj({
    required: {
      "JobDefinition": "s",
      "JobName": "s",
    },
    optional: {
      "ArrayProperties": toBatchArrayProperties,
      "RetryStrategy": toBatchRetryStrategy,
    },
  }, root);
}

function fromBatchArrayProperties(input?: s.BatchArrayProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Size: input["Size"],
  }
}
function toBatchArrayProperties(root: jsonP.JSONValue): s.BatchArrayProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "Size": "n",
    },
  }, root);
}

function fromBatchRetryStrategy(input?: s.BatchRetryStrategy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attempts: input["Attempts"],
  }
}
function toBatchRetryStrategy(root: jsonP.JSONValue): s.BatchRetryStrategy {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attempts": "n",
    },
  }, root);
}

function fromSqsParameters(input?: s.SqsParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MessageGroupId: input["MessageGroupId"],
  }
}
function toSqsParameters(root: jsonP.JSONValue): s.SqsParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "MessageGroupId": "s",
    },
  }, root);
}

function fromHttpParameters(input?: s.HttpParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PathParameterValues: input["PathParameterValues"],
    HeaderParameters: input["HeaderParameters"],
    QueryStringParameters: input["QueryStringParameters"],
  }
}
function toHttpParameters(root: jsonP.JSONValue): s.HttpParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "PathParameterValues": ["s"],
      "HeaderParameters": x => jsonP.readMap(String, String, x),
      "QueryStringParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromRedshiftDataParameters(input?: s.RedshiftDataParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SecretManagerArn: input["SecretManagerArn"],
    Database: input["Database"],
    DbUser: input["DbUser"],
    Sql: input["Sql"],
    StatementName: input["StatementName"],
    WithEvent: input["WithEvent"],
  }
}
function toRedshiftDataParameters(root: jsonP.JSONValue): s.RedshiftDataParameters {
  return jsonP.readObj({
    required: {
      "Database": "s",
      "Sql": "s",
    },
    optional: {
      "SecretManagerArn": "s",
      "DbUser": "s",
      "StatementName": "s",
      "WithEvent": "b",
    },
  }, root);
}

function fromDeadLetterConfig(input?: s.DeadLetterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
  }
}
function toDeadLetterConfig(root: jsonP.JSONValue): s.DeadLetterConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function fromRetryPolicy(input?: s.RetryPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaximumRetryAttempts: input["MaximumRetryAttempts"],
    MaximumEventAgeInSeconds: input["MaximumEventAgeInSeconds"],
  }
}
function toRetryPolicy(root: jsonP.JSONValue): s.RetryPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaximumRetryAttempts": "n",
      "MaximumEventAgeInSeconds": "n",
    },
  }, root);
}

function fromReplayDestination(input?: s.ReplayDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
    FilterArns: input["FilterArns"],
  }
}
function toReplayDestination(root: jsonP.JSONValue): s.ReplayDestination {
  return jsonP.readObj({
    required: {
      "Arn": "s",
    },
    optional: {
      "FilterArns": ["s"],
    },
  }, root);
}

function toArchive(root: jsonP.JSONValue): s.Archive {
  return jsonP.readObj({
    required: {},
    optional: {
      "ArchiveName": "s",
      "EventSourceArn": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArchiveState>(x),
      "StateReason": "s",
      "RetentionDays": "n",
      "SizeBytes": "n",
      "EventCount": "n",
      "CreationTime": "d",
    },
  }, root);
}

function toEventBus(root: jsonP.JSONValue): s.EventBus {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Arn": "s",
      "Policy": "s",
    },
  }, root);
}

function toEventSource(root: jsonP.JSONValue): s.EventSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CreatedBy": "s",
      "CreationTime": "d",
      "ExpirationTime": "d",
      "Name": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventSourceState>(x),
    },
  }, root);
}

function toPartnerEventSourceAccount(root: jsonP.JSONValue): s.PartnerEventSourceAccount {
  return jsonP.readObj({
    required: {},
    optional: {
      "Account": "s",
      "CreationTime": "d",
      "ExpirationTime": "d",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventSourceState>(x),
    },
  }, root);
}

function toPartnerEventSource(root: jsonP.JSONValue): s.PartnerEventSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Name": "s",
    },
  }, root);
}

function toReplay(root: jsonP.JSONValue): s.Replay {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplayName": "s",
      "EventSourceArn": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplayState>(x),
      "StateReason": "s",
      "EventStartTime": "d",
      "EventEndTime": "d",
      "EventLastReplayedTime": "d",
      "ReplayStartTime": "d",
      "ReplayEndTime": "d",
    },
  }, root);
}

function toRule(root: jsonP.JSONValue): s.Rule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Arn": "s",
      "EventPattern": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.RuleState>(x),
      "Description": "s",
      "ScheduleExpression": "s",
      "RoleArn": "s",
      "ManagedBy": "s",
      "EventBusName": "s",
    },
  }, root);
}

function toPutEventsResultEntry(root: jsonP.JSONValue): s.PutEventsResultEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "EventId": "s",
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

function toPutPartnerEventsResultEntry(root: jsonP.JSONValue): s.PutPartnerEventsResultEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "EventId": "s",
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

function toPutTargetsResultEntry(root: jsonP.JSONValue): s.PutTargetsResultEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetId": "s",
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

function toRemoveTargetsResultEntry(root: jsonP.JSONValue): s.RemoveTargetsResultEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetId": "s",
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}
