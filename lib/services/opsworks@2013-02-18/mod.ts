// Autogenerated API client for: AWS OpsWorks

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class OpsWorks {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(OpsWorks.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2013-02-18",
    "endpointPrefix": "opsworks",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS OpsWorks",
    "serviceId": "OpsWorks",
    "signatureVersion": "v4",
    "targetPrefix": "OpsWorks_20130218",
    "uid": "opsworks-2013-02-18"
  };

  async assignInstance(
    {abortSignal, ...params}: RequestConfig & s.AssignInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      LayerIds: params["LayerIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignInstance",
    });
    await resp.text();
  }

  async assignVolume(
    {abortSignal, ...params}: RequestConfig & s.AssignVolumeRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      VolumeId: params["VolumeId"],
      InstanceId: params["InstanceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignVolume",
    });
    await resp.text();
  }

  async associateElasticIp(
    {abortSignal, ...params}: RequestConfig & s.AssociateElasticIpRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ElasticIp: params["ElasticIp"],
      InstanceId: params["InstanceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateElasticIp",
    });
    await resp.text();
  }

  async attachElasticLoadBalancer(
    {abortSignal, ...params}: RequestConfig & s.AttachElasticLoadBalancerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ElasticLoadBalancerName: params["ElasticLoadBalancerName"],
      LayerId: params["LayerId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachElasticLoadBalancer",
    });
    await resp.text();
  }

  async cloneStack(
    {abortSignal, ...params}: RequestConfig & s.CloneStackRequest,
  ): Promise<s.CloneStackResult> {
    const body: jsonP.JSONObject = {
      SourceStackId: params["SourceStackId"],
      Name: params["Name"],
      Region: params["Region"],
      VpcId: params["VpcId"],
      Attributes: params["Attributes"],
      ServiceRoleArn: params["ServiceRoleArn"],
      DefaultInstanceProfileArn: params["DefaultInstanceProfileArn"],
      DefaultOs: params["DefaultOs"],
      HostnameTheme: params["HostnameTheme"],
      DefaultAvailabilityZone: params["DefaultAvailabilityZone"],
      DefaultSubnetId: params["DefaultSubnetId"],
      CustomJson: params["CustomJson"],
      ConfigurationManager: fromStackConfigurationManager(params["ConfigurationManager"]),
      ChefConfiguration: fromChefConfiguration(params["ChefConfiguration"]),
      UseCustomCookbooks: params["UseCustomCookbooks"],
      UseOpsworksSecurityGroups: params["UseOpsworksSecurityGroups"],
      CustomCookbooksSource: fromSource(params["CustomCookbooksSource"]),
      DefaultSshKeyName: params["DefaultSshKeyName"],
      ClonePermissions: params["ClonePermissions"],
      CloneAppIds: params["CloneAppIds"],
      DefaultRootDeviceType: params["DefaultRootDeviceType"],
      AgentVersion: params["AgentVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CloneStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StackId": "s",
      },
    }, await resp.json());
  }

  async createApp(
    {abortSignal, ...params}: RequestConfig & s.CreateAppRequest,
  ): Promise<s.CreateAppResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      Shortname: params["Shortname"],
      Name: params["Name"],
      Description: params["Description"],
      DataSources: params["DataSources"]?.map(x => fromDataSource(x)),
      Type: params["Type"],
      AppSource: fromSource(params["AppSource"]),
      Domains: params["Domains"],
      EnableSsl: params["EnableSsl"],
      SslConfiguration: fromSslConfiguration(params["SslConfiguration"]),
      Attributes: params["Attributes"],
      Environment: params["Environment"]?.map(x => fromEnvironmentVariable(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppId": "s",
      },
    }, await resp.json());
  }

  async createDeployment(
    {abortSignal, ...params}: RequestConfig & s.CreateDeploymentRequest,
  ): Promise<s.CreateDeploymentResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      AppId: params["AppId"],
      InstanceIds: params["InstanceIds"],
      LayerIds: params["LayerIds"],
      Command: fromDeploymentCommand(params["Command"]),
      Comment: params["Comment"],
      CustomJson: params["CustomJson"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeployment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DeploymentId": "s",
      },
    }, await resp.json());
  }

  async createInstance(
    {abortSignal, ...params}: RequestConfig & s.CreateInstanceRequest,
  ): Promise<s.CreateInstanceResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      LayerIds: params["LayerIds"],
      InstanceType: params["InstanceType"],
      AutoScalingType: params["AutoScalingType"],
      Hostname: params["Hostname"],
      Os: params["Os"],
      AmiId: params["AmiId"],
      SshKeyName: params["SshKeyName"],
      AvailabilityZone: params["AvailabilityZone"],
      VirtualizationType: params["VirtualizationType"],
      SubnetId: params["SubnetId"],
      Architecture: params["Architecture"],
      RootDeviceType: params["RootDeviceType"],
      BlockDeviceMappings: params["BlockDeviceMappings"]?.map(x => fromBlockDeviceMapping(x)),
      InstallUpdatesOnBoot: params["InstallUpdatesOnBoot"],
      EbsOptimized: params["EbsOptimized"],
      AgentVersion: params["AgentVersion"],
      Tenancy: params["Tenancy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceId": "s",
      },
    }, await resp.json());
  }

  async createLayer(
    {abortSignal, ...params}: RequestConfig & s.CreateLayerRequest,
  ): Promise<s.CreateLayerResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      Type: params["Type"],
      Name: params["Name"],
      Shortname: params["Shortname"],
      Attributes: params["Attributes"],
      CloudWatchLogsConfiguration: fromCloudWatchLogsConfiguration(params["CloudWatchLogsConfiguration"]),
      CustomInstanceProfileArn: params["CustomInstanceProfileArn"],
      CustomJson: params["CustomJson"],
      CustomSecurityGroupIds: params["CustomSecurityGroupIds"],
      Packages: params["Packages"],
      VolumeConfigurations: params["VolumeConfigurations"]?.map(x => fromVolumeConfiguration(x)),
      EnableAutoHealing: params["EnableAutoHealing"],
      AutoAssignElasticIps: params["AutoAssignElasticIps"],
      AutoAssignPublicIps: params["AutoAssignPublicIps"],
      CustomRecipes: fromRecipes(params["CustomRecipes"]),
      InstallUpdatesOnBoot: params["InstallUpdatesOnBoot"],
      UseEbsOptimizedInstances: params["UseEbsOptimizedInstances"],
      LifecycleEventConfiguration: fromLifecycleEventConfiguration(params["LifecycleEventConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLayer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LayerId": "s",
      },
    }, await resp.json());
  }

  async createStack(
    {abortSignal, ...params}: RequestConfig & s.CreateStackRequest,
  ): Promise<s.CreateStackResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Region: params["Region"],
      VpcId: params["VpcId"],
      Attributes: params["Attributes"],
      ServiceRoleArn: params["ServiceRoleArn"],
      DefaultInstanceProfileArn: params["DefaultInstanceProfileArn"],
      DefaultOs: params["DefaultOs"],
      HostnameTheme: params["HostnameTheme"],
      DefaultAvailabilityZone: params["DefaultAvailabilityZone"],
      DefaultSubnetId: params["DefaultSubnetId"],
      CustomJson: params["CustomJson"],
      ConfigurationManager: fromStackConfigurationManager(params["ConfigurationManager"]),
      ChefConfiguration: fromChefConfiguration(params["ChefConfiguration"]),
      UseCustomCookbooks: params["UseCustomCookbooks"],
      UseOpsworksSecurityGroups: params["UseOpsworksSecurityGroups"],
      CustomCookbooksSource: fromSource(params["CustomCookbooksSource"]),
      DefaultSshKeyName: params["DefaultSshKeyName"],
      DefaultRootDeviceType: params["DefaultRootDeviceType"],
      AgentVersion: params["AgentVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StackId": "s",
      },
    }, await resp.json());
  }

  async createUserProfile(
    {abortSignal, ...params}: RequestConfig & s.CreateUserProfileRequest,
  ): Promise<s.CreateUserProfileResult> {
    const body: jsonP.JSONObject = {
      IamUserArn: params["IamUserArn"],
      SshUsername: params["SshUsername"],
      SshPublicKey: params["SshPublicKey"],
      AllowSelfManagement: params["AllowSelfManagement"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "IamUserArn": "s",
      },
    }, await resp.json());
  }

  async deleteApp(
    {abortSignal, ...params}: RequestConfig & s.DeleteAppRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AppId: params["AppId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApp",
    });
    await resp.text();
  }

  async deleteInstance(
    {abortSignal, ...params}: RequestConfig & s.DeleteInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      DeleteElasticIp: params["DeleteElasticIp"],
      DeleteVolumes: params["DeleteVolumes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInstance",
    });
    await resp.text();
  }

  async deleteLayer(
    {abortSignal, ...params}: RequestConfig & s.DeleteLayerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      LayerId: params["LayerId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLayer",
    });
    await resp.text();
  }

  async deleteStack(
    {abortSignal, ...params}: RequestConfig & s.DeleteStackRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStack",
    });
    await resp.text();
  }

  async deleteUserProfile(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserProfileRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      IamUserArn: params["IamUserArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserProfile",
    });
    await resp.text();
  }

  async deregisterEcsCluster(
    {abortSignal, ...params}: RequestConfig & s.DeregisterEcsClusterRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EcsClusterArn: params["EcsClusterArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterEcsCluster",
    });
    await resp.text();
  }

  async deregisterElasticIp(
    {abortSignal, ...params}: RequestConfig & s.DeregisterElasticIpRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ElasticIp: params["ElasticIp"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterElasticIp",
    });
    await resp.text();
  }

  async deregisterInstance(
    {abortSignal, ...params}: RequestConfig & s.DeregisterInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterInstance",
    });
    await resp.text();
  }

  async deregisterRdsDbInstance(
    {abortSignal, ...params}: RequestConfig & s.DeregisterRdsDbInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      RdsDbInstanceArn: params["RdsDbInstanceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterRdsDbInstance",
    });
    await resp.text();
  }

  async deregisterVolume(
    {abortSignal, ...params}: RequestConfig & s.DeregisterVolumeRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      VolumeId: params["VolumeId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterVolume",
    });
    await resp.text();
  }

  async describeAgentVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeAgentVersionsRequest = {},
  ): Promise<s.DescribeAgentVersionsResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      ConfigurationManager: fromStackConfigurationManager(params["ConfigurationManager"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAgentVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AgentVersions": [toAgentVersion],
      },
    }, await resp.json());
  }

  async describeApps(
    {abortSignal, ...params}: RequestConfig & s.DescribeAppsRequest = {},
  ): Promise<s.DescribeAppsResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      AppIds: params["AppIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeApps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Apps": [toApp],
      },
    }, await resp.json());
  }

  async describeCommands(
    {abortSignal, ...params}: RequestConfig & s.DescribeCommandsRequest = {},
  ): Promise<s.DescribeCommandsResult> {
    const body: jsonP.JSONObject = {
      DeploymentId: params["DeploymentId"],
      InstanceId: params["InstanceId"],
      CommandIds: params["CommandIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCommands",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Commands": [toCommand],
      },
    }, await resp.json());
  }

  async describeDeployments(
    {abortSignal, ...params}: RequestConfig & s.DescribeDeploymentsRequest = {},
  ): Promise<s.DescribeDeploymentsResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      AppId: params["AppId"],
      DeploymentIds: params["DeploymentIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDeployments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Deployments": [toDeployment],
      },
    }, await resp.json());
  }

  async describeEcsClusters(
    {abortSignal, ...params}: RequestConfig & s.DescribeEcsClustersRequest = {},
  ): Promise<s.DescribeEcsClustersResult> {
    const body: jsonP.JSONObject = {
      EcsClusterArns: params["EcsClusterArns"],
      StackId: params["StackId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEcsClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EcsClusters": [toEcsCluster],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeElasticIps(
    {abortSignal, ...params}: RequestConfig & s.DescribeElasticIpsRequest = {},
  ): Promise<s.DescribeElasticIpsResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      StackId: params["StackId"],
      Ips: params["Ips"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeElasticIps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticIps": [toElasticIp],
      },
    }, await resp.json());
  }

  async describeElasticLoadBalancers(
    {abortSignal, ...params}: RequestConfig & s.DescribeElasticLoadBalancersRequest = {},
  ): Promise<s.DescribeElasticLoadBalancersResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      LayerIds: params["LayerIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeElasticLoadBalancers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticLoadBalancers": [toElasticLoadBalancer],
      },
    }, await resp.json());
  }

  async describeInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstancesRequest = {},
  ): Promise<s.DescribeInstancesResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      LayerId: params["LayerId"],
      InstanceIds: params["InstanceIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Instances": [toInstance],
      },
    }, await resp.json());
  }

  async describeLayers(
    {abortSignal, ...params}: RequestConfig & s.DescribeLayersRequest = {},
  ): Promise<s.DescribeLayersResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      LayerIds: params["LayerIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLayers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Layers": [toLayer],
      },
    }, await resp.json());
  }

  async describeLoadBasedAutoScaling(
    {abortSignal, ...params}: RequestConfig & s.DescribeLoadBasedAutoScalingRequest,
  ): Promise<s.DescribeLoadBasedAutoScalingResult> {
    const body: jsonP.JSONObject = {
      LayerIds: params["LayerIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBasedAutoScaling",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LoadBasedAutoScalingConfigurations": [toLoadBasedAutoScalingConfiguration],
      },
    }, await resp.json());
  }

  async describeMyUserProfile(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeMyUserProfileResult> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeMyUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfile": toSelfUserProfile,
      },
    }, await resp.json());
  }

  async describeOperatingSystems(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeOperatingSystemsResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeOperatingSystems",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "OperatingSystems": [toOperatingSystem],
      },
    }, await resp.json());
  }

  async describePermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribePermissionsRequest = {},
  ): Promise<s.DescribePermissionsResult> {
    const body: jsonP.JSONObject = {
      IamUserArn: params["IamUserArn"],
      StackId: params["StackId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Permissions": [toPermission],
      },
    }, await resp.json());
  }

  async describeRaidArrays(
    {abortSignal, ...params}: RequestConfig & s.DescribeRaidArraysRequest = {},
  ): Promise<s.DescribeRaidArraysResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      StackId: params["StackId"],
      RaidArrayIds: params["RaidArrayIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRaidArrays",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RaidArrays": [toRaidArray],
      },
    }, await resp.json());
  }

  async describeRdsDbInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeRdsDbInstancesRequest,
  ): Promise<s.DescribeRdsDbInstancesResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      RdsDbInstanceArns: params["RdsDbInstanceArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRdsDbInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RdsDbInstances": [toRdsDbInstance],
      },
    }, await resp.json());
  }

  async describeServiceErrors(
    {abortSignal, ...params}: RequestConfig & s.DescribeServiceErrorsRequest = {},
  ): Promise<s.DescribeServiceErrorsResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      InstanceId: params["InstanceId"],
      ServiceErrorIds: params["ServiceErrorIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServiceErrors",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ServiceErrors": [toServiceError],
      },
    }, await resp.json());
  }

  async describeStackProvisioningParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackProvisioningParametersRequest,
  ): Promise<s.DescribeStackProvisioningParametersResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackProvisioningParameters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AgentInstallerUrl": "s",
        "Parameters": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeStackSummary(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackSummaryRequest,
  ): Promise<s.DescribeStackSummaryResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackSummary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StackSummary": toStackSummary,
      },
    }, await resp.json());
  }

  async describeStacks(
    {abortSignal, ...params}: RequestConfig & s.DescribeStacksRequest = {},
  ): Promise<s.DescribeStacksResult> {
    const body: jsonP.JSONObject = {
      StackIds: params["StackIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStacks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Stacks": [toStack],
      },
    }, await resp.json());
  }

  async describeTimeBasedAutoScaling(
    {abortSignal, ...params}: RequestConfig & s.DescribeTimeBasedAutoScalingRequest,
  ): Promise<s.DescribeTimeBasedAutoScalingResult> {
    const body: jsonP.JSONObject = {
      InstanceIds: params["InstanceIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTimeBasedAutoScaling",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TimeBasedAutoScalingConfigurations": [toTimeBasedAutoScalingConfiguration],
      },
    }, await resp.json());
  }

  async describeUserProfiles(
    {abortSignal, ...params}: RequestConfig & s.DescribeUserProfilesRequest = {},
  ): Promise<s.DescribeUserProfilesResult> {
    const body: jsonP.JSONObject = {
      IamUserArns: params["IamUserArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserProfiles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfiles": [toUserProfile],
      },
    }, await resp.json());
  }

  async describeVolumes(
    {abortSignal, ...params}: RequestConfig & s.DescribeVolumesRequest = {},
  ): Promise<s.DescribeVolumesResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      StackId: params["StackId"],
      RaidArrayId: params["RaidArrayId"],
      VolumeIds: params["VolumeIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Volumes": [toVolume],
      },
    }, await resp.json());
  }

  async detachElasticLoadBalancer(
    {abortSignal, ...params}: RequestConfig & s.DetachElasticLoadBalancerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ElasticLoadBalancerName: params["ElasticLoadBalancerName"],
      LayerId: params["LayerId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachElasticLoadBalancer",
    });
    await resp.text();
  }

  async disassociateElasticIp(
    {abortSignal, ...params}: RequestConfig & s.DisassociateElasticIpRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ElasticIp: params["ElasticIp"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateElasticIp",
    });
    await resp.text();
  }

  async getHostnameSuggestion(
    {abortSignal, ...params}: RequestConfig & s.GetHostnameSuggestionRequest,
  ): Promise<s.GetHostnameSuggestionResult> {
    const body: jsonP.JSONObject = {
      LayerId: params["LayerId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetHostnameSuggestion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LayerId": "s",
        "Hostname": "s",
      },
    }, await resp.json());
  }

  async grantAccess(
    {abortSignal, ...params}: RequestConfig & s.GrantAccessRequest,
  ): Promise<s.GrantAccessResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      ValidForInMinutes: params["ValidForInMinutes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GrantAccess",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TemporaryCredential": toTemporaryCredential,
      },
    }, await resp.json());
  }

  async listTags(
    {abortSignal, ...params}: RequestConfig & s.ListTagsRequest,
  ): Promise<s.ListTagsResult> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async rebootInstance(
    {abortSignal, ...params}: RequestConfig & s.RebootInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootInstance",
    });
    await resp.text();
  }

  async registerEcsCluster(
    {abortSignal, ...params}: RequestConfig & s.RegisterEcsClusterRequest,
  ): Promise<s.RegisterEcsClusterResult> {
    const body: jsonP.JSONObject = {
      EcsClusterArn: params["EcsClusterArn"],
      StackId: params["StackId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterEcsCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EcsClusterArn": "s",
      },
    }, await resp.json());
  }

  async registerElasticIp(
    {abortSignal, ...params}: RequestConfig & s.RegisterElasticIpRequest,
  ): Promise<s.RegisterElasticIpResult> {
    const body: jsonP.JSONObject = {
      ElasticIp: params["ElasticIp"],
      StackId: params["StackId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterElasticIp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticIp": "s",
      },
    }, await resp.json());
  }

  async registerInstance(
    {abortSignal, ...params}: RequestConfig & s.RegisterInstanceRequest,
  ): Promise<s.RegisterInstanceResult> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      Hostname: params["Hostname"],
      PublicIp: params["PublicIp"],
      PrivateIp: params["PrivateIp"],
      RsaPublicKey: params["RsaPublicKey"],
      RsaPublicKeyFingerprint: params["RsaPublicKeyFingerprint"],
      InstanceIdentity: fromInstanceIdentity(params["InstanceIdentity"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceId": "s",
      },
    }, await resp.json());
  }

  async registerRdsDbInstance(
    {abortSignal, ...params}: RequestConfig & s.RegisterRdsDbInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      RdsDbInstanceArn: params["RdsDbInstanceArn"],
      DbUser: params["DbUser"],
      DbPassword: params["DbPassword"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterRdsDbInstance",
    });
    await resp.text();
  }

  async registerVolume(
    {abortSignal, ...params}: RequestConfig & s.RegisterVolumeRequest,
  ): Promise<s.RegisterVolumeResult> {
    const body: jsonP.JSONObject = {
      Ec2VolumeId: params["Ec2VolumeId"],
      StackId: params["StackId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeId": "s",
      },
    }, await resp.json());
  }

  async setLoadBasedAutoScaling(
    {abortSignal, ...params}: RequestConfig & s.SetLoadBasedAutoScalingRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      LayerId: params["LayerId"],
      Enable: params["Enable"],
      UpScaling: fromAutoScalingThresholds(params["UpScaling"]),
      DownScaling: fromAutoScalingThresholds(params["DownScaling"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetLoadBasedAutoScaling",
    });
    await resp.text();
  }

  async setPermission(
    {abortSignal, ...params}: RequestConfig & s.SetPermissionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      IamUserArn: params["IamUserArn"],
      AllowSsh: params["AllowSsh"],
      AllowSudo: params["AllowSudo"],
      Level: params["Level"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetPermission",
    });
    await resp.text();
  }

  async setTimeBasedAutoScaling(
    {abortSignal, ...params}: RequestConfig & s.SetTimeBasedAutoScalingRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      AutoScalingSchedule: fromWeeklyAutoScalingSchedule(params["AutoScalingSchedule"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetTimeBasedAutoScaling",
    });
    await resp.text();
  }

  async startInstance(
    {abortSignal, ...params}: RequestConfig & s.StartInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartInstance",
    });
    await resp.text();
  }

  async startStack(
    {abortSignal, ...params}: RequestConfig & s.StartStackRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartStack",
    });
    await resp.text();
  }

  async stopInstance(
    {abortSignal, ...params}: RequestConfig & s.StopInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      Force: params["Force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopInstance",
    });
    await resp.text();
  }

  async stopStack(
    {abortSignal, ...params}: RequestConfig & s.StopStackRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopStack",
    });
    await resp.text();
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    await resp.text();
  }

  async unassignInstance(
    {abortSignal, ...params}: RequestConfig & s.UnassignInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnassignInstance",
    });
    await resp.text();
  }

  async unassignVolume(
    {abortSignal, ...params}: RequestConfig & s.UnassignVolumeRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      VolumeId: params["VolumeId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnassignVolume",
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    await resp.text();
  }

  async updateApp(
    {abortSignal, ...params}: RequestConfig & s.UpdateAppRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AppId: params["AppId"],
      Name: params["Name"],
      Description: params["Description"],
      DataSources: params["DataSources"]?.map(x => fromDataSource(x)),
      Type: params["Type"],
      AppSource: fromSource(params["AppSource"]),
      Domains: params["Domains"],
      EnableSsl: params["EnableSsl"],
      SslConfiguration: fromSslConfiguration(params["SslConfiguration"]),
      Attributes: params["Attributes"],
      Environment: params["Environment"]?.map(x => fromEnvironmentVariable(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApp",
    });
    await resp.text();
  }

  async updateElasticIp(
    {abortSignal, ...params}: RequestConfig & s.UpdateElasticIpRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ElasticIp: params["ElasticIp"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateElasticIp",
    });
    await resp.text();
  }

  async updateInstance(
    {abortSignal, ...params}: RequestConfig & s.UpdateInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      LayerIds: params["LayerIds"],
      InstanceType: params["InstanceType"],
      AutoScalingType: params["AutoScalingType"],
      Hostname: params["Hostname"],
      Os: params["Os"],
      AmiId: params["AmiId"],
      SshKeyName: params["SshKeyName"],
      Architecture: params["Architecture"],
      InstallUpdatesOnBoot: params["InstallUpdatesOnBoot"],
      EbsOptimized: params["EbsOptimized"],
      AgentVersion: params["AgentVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInstance",
    });
    await resp.text();
  }

  async updateLayer(
    {abortSignal, ...params}: RequestConfig & s.UpdateLayerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      LayerId: params["LayerId"],
      Name: params["Name"],
      Shortname: params["Shortname"],
      Attributes: params["Attributes"],
      CloudWatchLogsConfiguration: fromCloudWatchLogsConfiguration(params["CloudWatchLogsConfiguration"]),
      CustomInstanceProfileArn: params["CustomInstanceProfileArn"],
      CustomJson: params["CustomJson"],
      CustomSecurityGroupIds: params["CustomSecurityGroupIds"],
      Packages: params["Packages"],
      VolumeConfigurations: params["VolumeConfigurations"]?.map(x => fromVolumeConfiguration(x)),
      EnableAutoHealing: params["EnableAutoHealing"],
      AutoAssignElasticIps: params["AutoAssignElasticIps"],
      AutoAssignPublicIps: params["AutoAssignPublicIps"],
      CustomRecipes: fromRecipes(params["CustomRecipes"]),
      InstallUpdatesOnBoot: params["InstallUpdatesOnBoot"],
      UseEbsOptimizedInstances: params["UseEbsOptimizedInstances"],
      LifecycleEventConfiguration: fromLifecycleEventConfiguration(params["LifecycleEventConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateLayer",
    });
    await resp.text();
  }

  async updateMyUserProfile(
    {abortSignal, ...params}: RequestConfig & s.UpdateMyUserProfileRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      SshPublicKey: params["SshPublicKey"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMyUserProfile",
    });
    await resp.text();
  }

  async updateRdsDbInstance(
    {abortSignal, ...params}: RequestConfig & s.UpdateRdsDbInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      RdsDbInstanceArn: params["RdsDbInstanceArn"],
      DbUser: params["DbUser"],
      DbPassword: params["DbPassword"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRdsDbInstance",
    });
    await resp.text();
  }

  async updateStack(
    {abortSignal, ...params}: RequestConfig & s.UpdateStackRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StackId: params["StackId"],
      Name: params["Name"],
      Attributes: params["Attributes"],
      ServiceRoleArn: params["ServiceRoleArn"],
      DefaultInstanceProfileArn: params["DefaultInstanceProfileArn"],
      DefaultOs: params["DefaultOs"],
      HostnameTheme: params["HostnameTheme"],
      DefaultAvailabilityZone: params["DefaultAvailabilityZone"],
      DefaultSubnetId: params["DefaultSubnetId"],
      CustomJson: params["CustomJson"],
      ConfigurationManager: fromStackConfigurationManager(params["ConfigurationManager"]),
      ChefConfiguration: fromChefConfiguration(params["ChefConfiguration"]),
      UseCustomCookbooks: params["UseCustomCookbooks"],
      CustomCookbooksSource: fromSource(params["CustomCookbooksSource"]),
      DefaultSshKeyName: params["DefaultSshKeyName"],
      DefaultRootDeviceType: params["DefaultRootDeviceType"],
      UseOpsworksSecurityGroups: params["UseOpsworksSecurityGroups"],
      AgentVersion: params["AgentVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStack",
    });
    await resp.text();
  }

  async updateUserProfile(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserProfileRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      IamUserArn: params["IamUserArn"],
      SshUsername: params["SshUsername"],
      SshPublicKey: params["SshPublicKey"],
      AllowSelfManagement: params["AllowSelfManagement"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserProfile",
    });
    await resp.text();
  }

  async updateVolume(
    {abortSignal, ...params}: RequestConfig & s.UpdateVolumeRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      VolumeId: params["VolumeId"],
      Name: params["Name"],
      MountPoint: params["MountPoint"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVolume",
    });
    await resp.text();
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForAppExists(
    params: RequestConfig & s.DescribeAppsRequest,
  ): Promise<s.DescribeAppsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AppExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeApps(params);
        return resp; // for status 200
      } catch (err) {
        if (["Http400"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a deployment has completed successfully.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForDeploymentSuccessful(
    params: RequestConfig & s.DescribeDeploymentsRequest,
  ): Promise<s.DescribeDeploymentsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DeploymentSuccessful';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeDeployments(params);
      const field = resp?.Deployments?.flatMap(x => x?.Status);
      if (field?.every(x => x === "successful")) return resp;
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until OpsWorks instance is online.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForInstanceOnline(
    params: RequestConfig & s.DescribeInstancesRequest,
  ): Promise<s.DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceOnline';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Instances?.flatMap(x => x?.Status);
      if (field?.every(x => x === "online")) return resp;
      if (field?.some(x => x === "setup_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "shutting_down")) throw new Error(errMessage);
      if (field?.some(x => x === "start_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "stopped")) throw new Error(errMessage);
      if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      if (field?.some(x => x === "terminating")) throw new Error(errMessage);
      if (field?.some(x => x === "terminated")) throw new Error(errMessage);
      if (field?.some(x => x === "stop_failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until OpsWorks instance is registered.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForInstanceRegistered(
    params: RequestConfig & s.DescribeInstancesRequest,
  ): Promise<s.DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceRegistered';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Instances?.flatMap(x => x?.Status);
      if (field?.every(x => x === "registered")) return resp;
      if (field?.some(x => x === "setup_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "shutting_down")) throw new Error(errMessage);
      if (field?.some(x => x === "stopped")) throw new Error(errMessage);
      if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      if (field?.some(x => x === "terminating")) throw new Error(errMessage);
      if (field?.some(x => x === "terminated")) throw new Error(errMessage);
      if (field?.some(x => x === "stop_failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until OpsWorks instance is stopped.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForInstanceStopped(
    params: RequestConfig & s.DescribeInstancesRequest,
  ): Promise<s.DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceStopped';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Instances?.flatMap(x => x?.Status);
      if (field?.every(x => x === "stopped")) return resp;
      if (field?.some(x => x === "booting")) throw new Error(errMessage);
      if (field?.some(x => x === "pending")) throw new Error(errMessage);
      if (field?.some(x => x === "rebooting")) throw new Error(errMessage);
      if (field?.some(x => x === "requested")) throw new Error(errMessage);
      if (field?.some(x => x === "running_setup")) throw new Error(errMessage);
      if (field?.some(x => x === "setup_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "start_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "stop_failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until OpsWorks instance is terminated.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForInstanceTerminated(
    params: RequestConfig & s.DescribeInstancesRequest,
  ): Promise<Error | s.DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceTerminated';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstances(params);
        const field = resp?.Instances?.flatMap(x => x?.Status);
        if (field?.every(x => x === "terminated")) return resp;
        if (field?.some(x => x === "booting")) throw new Error(errMessage);
        if (field?.some(x => x === "online")) throw new Error(errMessage);
        if (field?.some(x => x === "pending")) throw new Error(errMessage);
        if (field?.some(x => x === "rebooting")) throw new Error(errMessage);
        if (field?.some(x => x === "requested")) throw new Error(errMessage);
        if (field?.some(x => x === "running_setup")) throw new Error(errMessage);
        if (field?.some(x => x === "setup_failed")) throw new Error(errMessage);
        if (field?.some(x => x === "start_failed")) throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

function fromStackConfigurationManager(input?: s.StackConfigurationManager | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Version: input["Version"],
  }
}
function toStackConfigurationManager(root: jsonP.JSONValue): s.StackConfigurationManager {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Version": "s",
    },
  }, root);
}

function fromChefConfiguration(input?: s.ChefConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ManageBerkshelf: input["ManageBerkshelf"],
    BerkshelfVersion: input["BerkshelfVersion"],
  }
}
function toChefConfiguration(root: jsonP.JSONValue): s.ChefConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManageBerkshelf": "b",
      "BerkshelfVersion": "s",
    },
  }, root);
}

function fromSource(input?: s.Source | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Url: input["Url"],
    Username: input["Username"],
    Password: input["Password"],
    SshKey: input["SshKey"],
    Revision: input["Revision"],
  }
}
function toSource(root: jsonP.JSONValue): s.Source {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.SourceType>(x),
      "Url": "s",
      "Username": "s",
      "Password": "s",
      "SshKey": "s",
      "Revision": "s",
    },
  }, root);
}

function fromDataSource(input?: s.DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Arn: input["Arn"],
    DatabaseName: input["DatabaseName"],
  }
}
function toDataSource(root: jsonP.JSONValue): s.DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": "s",
      "Arn": "s",
      "DatabaseName": "s",
    },
  }, root);
}

function fromSslConfiguration(input?: s.SslConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Certificate: input["Certificate"],
    PrivateKey: input["PrivateKey"],
    Chain: input["Chain"],
  }
}
function toSslConfiguration(root: jsonP.JSONValue): s.SslConfiguration {
  return jsonP.readObj({
    required: {
      "Certificate": "s",
      "PrivateKey": "s",
    },
    optional: {
      "Chain": "s",
    },
  }, root);
}

function fromEnvironmentVariable(input?: s.EnvironmentVariable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Secure: input["Secure"],
  }
}
function toEnvironmentVariable(root: jsonP.JSONValue): s.EnvironmentVariable {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {
      "Secure": "b",
    },
  }, root);
}

function fromDeploymentCommand(input?: s.DeploymentCommand | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Args: input["Args"],
  }
}
function toDeploymentCommand(root: jsonP.JSONValue): s.DeploymentCommand {
  return jsonP.readObj({
    required: {
      "Name": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentCommandName>(x),
    },
    optional: {
      "Args": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
    },
  }, root);
}

function fromBlockDeviceMapping(input?: s.BlockDeviceMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DeviceName: input["DeviceName"],
    NoDevice: input["NoDevice"],
    VirtualName: input["VirtualName"],
    Ebs: fromEbsBlockDevice(input["Ebs"]),
  }
}
function toBlockDeviceMapping(root: jsonP.JSONValue): s.BlockDeviceMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeviceName": "s",
      "NoDevice": "s",
      "VirtualName": "s",
      "Ebs": toEbsBlockDevice,
    },
  }, root);
}

function fromEbsBlockDevice(input?: s.EbsBlockDevice | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SnapshotId: input["SnapshotId"],
    Iops: input["Iops"],
    VolumeSize: input["VolumeSize"],
    VolumeType: input["VolumeType"],
    DeleteOnTermination: input["DeleteOnTermination"],
  }
}
function toEbsBlockDevice(root: jsonP.JSONValue): s.EbsBlockDevice {
  return jsonP.readObj({
    required: {},
    optional: {
      "SnapshotId": "s",
      "Iops": "n",
      "VolumeSize": "n",
      "VolumeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.VolumeType>(x),
      "DeleteOnTermination": "b",
    },
  }, root);
}

function fromCloudWatchLogsConfiguration(input?: s.CloudWatchLogsConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    LogStreams: input["LogStreams"]?.map(x => fromCloudWatchLogsLogStream(x)),
  }
}
function toCloudWatchLogsConfiguration(root: jsonP.JSONValue): s.CloudWatchLogsConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "LogStreams": [toCloudWatchLogsLogStream],
    },
  }, root);
}

function fromCloudWatchLogsLogStream(input?: s.CloudWatchLogsLogStream | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LogGroupName: input["LogGroupName"],
    DatetimeFormat: input["DatetimeFormat"],
    TimeZone: input["TimeZone"],
    File: input["File"],
    FileFingerprintLines: input["FileFingerprintLines"],
    MultiLineStartPattern: input["MultiLineStartPattern"],
    InitialPosition: input["InitialPosition"],
    Encoding: input["Encoding"],
    BufferDuration: input["BufferDuration"],
    BatchCount: input["BatchCount"],
    BatchSize: input["BatchSize"],
  }
}
function toCloudWatchLogsLogStream(root: jsonP.JSONValue): s.CloudWatchLogsLogStream {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogGroupName": "s",
      "DatetimeFormat": "s",
      "TimeZone": (x: jsonP.JSONValue) => cmnP.readEnum<s.CloudWatchLogsTimeZone>(x),
      "File": "s",
      "FileFingerprintLines": "s",
      "MultiLineStartPattern": "s",
      "InitialPosition": (x: jsonP.JSONValue) => cmnP.readEnum<s.CloudWatchLogsInitialPosition>(x),
      "Encoding": (x: jsonP.JSONValue) => cmnP.readEnum<s.CloudWatchLogsEncoding>(x),
      "BufferDuration": "n",
      "BatchCount": "n",
      "BatchSize": "n",
    },
  }, root);
}

function fromVolumeConfiguration(input?: s.VolumeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MountPoint: input["MountPoint"],
    RaidLevel: input["RaidLevel"],
    NumberOfDisks: input["NumberOfDisks"],
    Size: input["Size"],
    VolumeType: input["VolumeType"],
    Iops: input["Iops"],
    Encrypted: input["Encrypted"],
  }
}
function toVolumeConfiguration(root: jsonP.JSONValue): s.VolumeConfiguration {
  return jsonP.readObj({
    required: {
      "MountPoint": "s",
      "NumberOfDisks": "n",
      "Size": "n",
    },
    optional: {
      "RaidLevel": "n",
      "VolumeType": "s",
      "Iops": "n",
      "Encrypted": "b",
    },
  }, root);
}

function fromRecipes(input?: s.Recipes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Setup: input["Setup"],
    Configure: input["Configure"],
    Deploy: input["Deploy"],
    Undeploy: input["Undeploy"],
    Shutdown: input["Shutdown"],
  }
}
function toRecipes(root: jsonP.JSONValue): s.Recipes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Setup": ["s"],
      "Configure": ["s"],
      "Deploy": ["s"],
      "Undeploy": ["s"],
      "Shutdown": ["s"],
    },
  }, root);
}

function fromLifecycleEventConfiguration(input?: s.LifecycleEventConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Shutdown: fromShutdownEventConfiguration(input["Shutdown"]),
  }
}
function toLifecycleEventConfiguration(root: jsonP.JSONValue): s.LifecycleEventConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Shutdown": toShutdownEventConfiguration,
    },
  }, root);
}

function fromShutdownEventConfiguration(input?: s.ShutdownEventConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExecutionTimeout: input["ExecutionTimeout"],
    DelayUntilElbConnectionsDrained: input["DelayUntilElbConnectionsDrained"],
  }
}
function toShutdownEventConfiguration(root: jsonP.JSONValue): s.ShutdownEventConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExecutionTimeout": "n",
      "DelayUntilElbConnectionsDrained": "b",
    },
  }, root);
}

function fromInstanceIdentity(input?: s.InstanceIdentity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Document: input["Document"],
    Signature: input["Signature"],
  }
}

function fromAutoScalingThresholds(input?: s.AutoScalingThresholds | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceCount: input["InstanceCount"],
    ThresholdsWaitTime: input["ThresholdsWaitTime"],
    IgnoreMetricsTime: input["IgnoreMetricsTime"],
    CpuThreshold: input["CpuThreshold"],
    MemoryThreshold: input["MemoryThreshold"],
    LoadThreshold: input["LoadThreshold"],
    Alarms: input["Alarms"],
  }
}
function toAutoScalingThresholds(root: jsonP.JSONValue): s.AutoScalingThresholds {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceCount": "n",
      "ThresholdsWaitTime": "n",
      "IgnoreMetricsTime": "n",
      "CpuThreshold": "n",
      "MemoryThreshold": "n",
      "LoadThreshold": "n",
      "Alarms": ["s"],
    },
  }, root);
}

function fromWeeklyAutoScalingSchedule(input?: s.WeeklyAutoScalingSchedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Monday: input["Monday"],
    Tuesday: input["Tuesday"],
    Wednesday: input["Wednesday"],
    Thursday: input["Thursday"],
    Friday: input["Friday"],
    Saturday: input["Saturday"],
    Sunday: input["Sunday"],
  }
}
function toWeeklyAutoScalingSchedule(root: jsonP.JSONValue): s.WeeklyAutoScalingSchedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Monday": x => jsonP.readMap(String, String, x),
      "Tuesday": x => jsonP.readMap(String, String, x),
      "Wednesday": x => jsonP.readMap(String, String, x),
      "Thursday": x => jsonP.readMap(String, String, x),
      "Friday": x => jsonP.readMap(String, String, x),
      "Saturday": x => jsonP.readMap(String, String, x),
      "Sunday": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toAgentVersion(root: jsonP.JSONValue): s.AgentVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Version": "s",
      "ConfigurationManager": toStackConfigurationManager,
    },
  }, root);
}

function toApp(root: jsonP.JSONValue): s.App {
  return jsonP.readObj({
    required: {},
    optional: {
      "AppId": "s",
      "StackId": "s",
      "Shortname": "s",
      "Name": "s",
      "Description": "s",
      "DataSources": [toDataSource],
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.AppType>(x),
      "AppSource": toSource,
      "Domains": ["s"],
      "EnableSsl": "b",
      "SslConfiguration": toSslConfiguration,
      "Attributes": x => jsonP.readMap(x => cmnP.readEnumReq<s.AppAttributesKeys>(x), String, x),
      "CreatedAt": "s",
      "Environment": [toEnvironmentVariable],
    },
  }, root);
}

function toCommand(root: jsonP.JSONValue): s.Command {
  return jsonP.readObj({
    required: {},
    optional: {
      "CommandId": "s",
      "InstanceId": "s",
      "DeploymentId": "s",
      "CreatedAt": "s",
      "AcknowledgedAt": "s",
      "CompletedAt": "s",
      "Status": "s",
      "ExitCode": "n",
      "LogUrl": "s",
      "Type": "s",
    },
  }, root);
}

function toDeployment(root: jsonP.JSONValue): s.Deployment {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeploymentId": "s",
      "StackId": "s",
      "AppId": "s",
      "CreatedAt": "s",
      "CompletedAt": "s",
      "Duration": "n",
      "IamUserArn": "s",
      "Comment": "s",
      "Command": toDeploymentCommand,
      "Status": "s",
      "CustomJson": "s",
      "InstanceIds": ["s"],
    },
  }, root);
}

function toEcsCluster(root: jsonP.JSONValue): s.EcsCluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "EcsClusterArn": "s",
      "EcsClusterName": "s",
      "StackId": "s",
      "RegisteredAt": "s",
    },
  }, root);
}

function toElasticIp(root: jsonP.JSONValue): s.ElasticIp {
  return jsonP.readObj({
    required: {},
    optional: {
      "Ip": "s",
      "Name": "s",
      "Domain": "s",
      "Region": "s",
      "InstanceId": "s",
    },
  }, root);
}

function toElasticLoadBalancer(root: jsonP.JSONValue): s.ElasticLoadBalancer {
  return jsonP.readObj({
    required: {},
    optional: {
      "ElasticLoadBalancerName": "s",
      "Region": "s",
      "DnsName": "s",
      "StackId": "s",
      "LayerId": "s",
      "VpcId": "s",
      "AvailabilityZones": ["s"],
      "SubnetIds": ["s"],
      "Ec2InstanceIds": ["s"],
    },
  }, root);
}

function toInstance(root: jsonP.JSONValue): s.Instance {
  return jsonP.readObj({
    required: {},
    optional: {
      "AgentVersion": "s",
      "AmiId": "s",
      "Architecture": (x: jsonP.JSONValue) => cmnP.readEnum<s.Architecture>(x),
      "Arn": "s",
      "AutoScalingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoScalingType>(x),
      "AvailabilityZone": "s",
      "BlockDeviceMappings": [toBlockDeviceMapping],
      "CreatedAt": "s",
      "EbsOptimized": "b",
      "Ec2InstanceId": "s",
      "EcsClusterArn": "s",
      "EcsContainerInstanceArn": "s",
      "ElasticIp": "s",
      "Hostname": "s",
      "InfrastructureClass": "s",
      "InstallUpdatesOnBoot": "b",
      "InstanceId": "s",
      "InstanceProfileArn": "s",
      "InstanceType": "s",
      "LastServiceErrorId": "s",
      "LayerIds": ["s"],
      "Os": "s",
      "Platform": "s",
      "PrivateDns": "s",
      "PrivateIp": "s",
      "PublicDns": "s",
      "PublicIp": "s",
      "RegisteredBy": "s",
      "ReportedAgentVersion": "s",
      "ReportedOs": toReportedOs,
      "RootDeviceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RootDeviceType>(x),
      "RootDeviceVolumeId": "s",
      "SecurityGroupIds": ["s"],
      "SshHostDsaKeyFingerprint": "s",
      "SshHostRsaKeyFingerprint": "s",
      "SshKeyName": "s",
      "StackId": "s",
      "Status": "s",
      "SubnetId": "s",
      "Tenancy": "s",
      "VirtualizationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualizationType>(x),
    },
  }, root);
}

function toReportedOs(root: jsonP.JSONValue): s.ReportedOs {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "Name": "s",
      "Version": "s",
    },
  }, root);
}

function toLayer(root: jsonP.JSONValue): s.Layer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "StackId": "s",
      "LayerId": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.LayerType>(x),
      "Name": "s",
      "Shortname": "s",
      "Attributes": x => jsonP.readMap(x => cmnP.readEnumReq<s.LayerAttributesKeys>(x), String, x),
      "CloudWatchLogsConfiguration": toCloudWatchLogsConfiguration,
      "CustomInstanceProfileArn": "s",
      "CustomJson": "s",
      "CustomSecurityGroupIds": ["s"],
      "DefaultSecurityGroupNames": ["s"],
      "Packages": ["s"],
      "VolumeConfigurations": [toVolumeConfiguration],
      "EnableAutoHealing": "b",
      "AutoAssignElasticIps": "b",
      "AutoAssignPublicIps": "b",
      "DefaultRecipes": toRecipes,
      "CustomRecipes": toRecipes,
      "CreatedAt": "s",
      "InstallUpdatesOnBoot": "b",
      "UseEbsOptimizedInstances": "b",
      "LifecycleEventConfiguration": toLifecycleEventConfiguration,
    },
  }, root);
}

function toLoadBasedAutoScalingConfiguration(root: jsonP.JSONValue): s.LoadBasedAutoScalingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "LayerId": "s",
      "Enable": "b",
      "UpScaling": toAutoScalingThresholds,
      "DownScaling": toAutoScalingThresholds,
    },
  }, root);
}

function toSelfUserProfile(root: jsonP.JSONValue): s.SelfUserProfile {
  return jsonP.readObj({
    required: {},
    optional: {
      "IamUserArn": "s",
      "Name": "s",
      "SshUsername": "s",
      "SshPublicKey": "s",
    },
  }, root);
}

function toOperatingSystem(root: jsonP.JSONValue): s.OperatingSystem {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Type": "s",
      "ConfigurationManagers": [toOperatingSystemConfigurationManager],
      "ReportedName": "s",
      "ReportedVersion": "s",
      "Supported": "b",
    },
  }, root);
}

function toOperatingSystemConfigurationManager(root: jsonP.JSONValue): s.OperatingSystemConfigurationManager {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Version": "s",
    },
  }, root);
}

function toPermission(root: jsonP.JSONValue): s.Permission {
  return jsonP.readObj({
    required: {},
    optional: {
      "StackId": "s",
      "IamUserArn": "s",
      "AllowSsh": "b",
      "AllowSudo": "b",
      "Level": "s",
    },
  }, root);
}

function toRaidArray(root: jsonP.JSONValue): s.RaidArray {
  return jsonP.readObj({
    required: {},
    optional: {
      "RaidArrayId": "s",
      "InstanceId": "s",
      "Name": "s",
      "RaidLevel": "n",
      "NumberOfDisks": "n",
      "Size": "n",
      "Device": "s",
      "MountPoint": "s",
      "AvailabilityZone": "s",
      "CreatedAt": "s",
      "StackId": "s",
      "VolumeType": "s",
      "Iops": "n",
    },
  }, root);
}

function toRdsDbInstance(root: jsonP.JSONValue): s.RdsDbInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "RdsDbInstanceArn": "s",
      "DbInstanceIdentifier": "s",
      "DbUser": "s",
      "DbPassword": "s",
      "Region": "s",
      "Address": "s",
      "Engine": "s",
      "StackId": "s",
      "MissingOnRds": "b",
    },
  }, root);
}

function toServiceError(root: jsonP.JSONValue): s.ServiceError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServiceErrorId": "s",
      "StackId": "s",
      "InstanceId": "s",
      "Type": "s",
      "Message": "s",
      "CreatedAt": "s",
    },
  }, root);
}

function toStackSummary(root: jsonP.JSONValue): s.StackSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "StackId": "s",
      "Name": "s",
      "Arn": "s",
      "LayersCount": "n",
      "AppsCount": "n",
      "InstancesCount": toInstancesCount,
    },
  }, root);
}

function toInstancesCount(root: jsonP.JSONValue): s.InstancesCount {
  return jsonP.readObj({
    required: {},
    optional: {
      "Assigning": "n",
      "Booting": "n",
      "ConnectionLost": "n",
      "Deregistering": "n",
      "Online": "n",
      "Pending": "n",
      "Rebooting": "n",
      "Registered": "n",
      "Registering": "n",
      "Requested": "n",
      "RunningSetup": "n",
      "SetupFailed": "n",
      "ShuttingDown": "n",
      "StartFailed": "n",
      "StopFailed": "n",
      "Stopped": "n",
      "Stopping": "n",
      "Terminated": "n",
      "Terminating": "n",
      "Unassigning": "n",
    },
  }, root);
}

function toStack(root: jsonP.JSONValue): s.Stack {
  return jsonP.readObj({
    required: {},
    optional: {
      "StackId": "s",
      "Name": "s",
      "Arn": "s",
      "Region": "s",
      "VpcId": "s",
      "Attributes": x => jsonP.readMap(x => cmnP.readEnumReq<s.StackAttributesKeys>(x), String, x),
      "ServiceRoleArn": "s",
      "DefaultInstanceProfileArn": "s",
      "DefaultOs": "s",
      "HostnameTheme": "s",
      "DefaultAvailabilityZone": "s",
      "DefaultSubnetId": "s",
      "CustomJson": "s",
      "ConfigurationManager": toStackConfigurationManager,
      "ChefConfiguration": toChefConfiguration,
      "UseCustomCookbooks": "b",
      "UseOpsworksSecurityGroups": "b",
      "CustomCookbooksSource": toSource,
      "DefaultSshKeyName": "s",
      "CreatedAt": "s",
      "DefaultRootDeviceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RootDeviceType>(x),
      "AgentVersion": "s",
    },
  }, root);
}

function toTimeBasedAutoScalingConfiguration(root: jsonP.JSONValue): s.TimeBasedAutoScalingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceId": "s",
      "AutoScalingSchedule": toWeeklyAutoScalingSchedule,
    },
  }, root);
}

function toUserProfile(root: jsonP.JSONValue): s.UserProfile {
  return jsonP.readObj({
    required: {},
    optional: {
      "IamUserArn": "s",
      "Name": "s",
      "SshUsername": "s",
      "SshPublicKey": "s",
      "AllowSelfManagement": "b",
    },
  }, root);
}

function toVolume(root: jsonP.JSONValue): s.Volume {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeId": "s",
      "Ec2VolumeId": "s",
      "Name": "s",
      "RaidArrayId": "s",
      "InstanceId": "s",
      "Status": "s",
      "Size": "n",
      "Device": "s",
      "MountPoint": "s",
      "Region": "s",
      "AvailabilityZone": "s",
      "VolumeType": "s",
      "Iops": "n",
      "Encrypted": "b",
    },
  }, root);
}

function toTemporaryCredential(root: jsonP.JSONValue): s.TemporaryCredential {
  return jsonP.readObj({
    required: {},
    optional: {
      "Username": "s",
      "Password": "s",
      "ValidForInMinutes": "n",
      "InstanceId": "s",
    },
  }, root);
}
