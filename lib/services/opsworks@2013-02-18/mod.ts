// Autogenerated API client for: AWS OpsWorks

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class OpsWorks {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(OpsWorks.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2013-02-18",
    "endpointPrefix": "opsworks",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS OpsWorks",
    "serviceId": "OpsWorks",
    "signatureVersion": "v4",
    "targetPrefix": "OpsWorks_20130218",
    "uid": "opsworks-2013-02-18"
  };

  async assignInstance(
    {abortSignal, ...params}: RequestConfig & AssignInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
      LayerIds: params["LayerIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignInstance",
    });
  }

  async assignVolume(
    {abortSignal, ...params}: RequestConfig & AssignVolumeRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      VolumeId: params["VolumeId"],
      InstanceId: params["InstanceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignVolume",
    });
  }

  async associateElasticIp(
    {abortSignal, ...params}: RequestConfig & AssociateElasticIpRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ElasticIp: params["ElasticIp"],
      InstanceId: params["InstanceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateElasticIp",
    });
  }

  async attachElasticLoadBalancer(
    {abortSignal, ...params}: RequestConfig & AttachElasticLoadBalancerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ElasticLoadBalancerName: params["ElasticLoadBalancerName"],
      LayerId: params["LayerId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachElasticLoadBalancer",
    });
  }

  async cloneStack(
    {abortSignal, ...params}: RequestConfig & CloneStackRequest,
  ): Promise<CloneStackResult> {
    const body: jsonP.JSONObject = params ? {
      SourceStackId: params["SourceStackId"],
      Name: params["Name"],
      Region: params["Region"],
      VpcId: params["VpcId"],
      Attributes: params["Attributes"],
      ServiceRoleArn: params["ServiceRoleArn"],
      DefaultInstanceProfileArn: params["DefaultInstanceProfileArn"],
      DefaultOs: params["DefaultOs"],
      HostnameTheme: params["HostnameTheme"],
      DefaultAvailabilityZone: params["DefaultAvailabilityZone"],
      DefaultSubnetId: params["DefaultSubnetId"],
      CustomJson: params["CustomJson"],
      ConfigurationManager: fromStackConfigurationManager(params["ConfigurationManager"]),
      ChefConfiguration: fromChefConfiguration(params["ChefConfiguration"]),
      UseCustomCookbooks: params["UseCustomCookbooks"],
      UseOpsworksSecurityGroups: params["UseOpsworksSecurityGroups"],
      CustomCookbooksSource: fromSource(params["CustomCookbooksSource"]),
      DefaultSshKeyName: params["DefaultSshKeyName"],
      ClonePermissions: params["ClonePermissions"],
      CloneAppIds: params["CloneAppIds"],
      DefaultRootDeviceType: params["DefaultRootDeviceType"],
      AgentVersion: params["AgentVersion"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CloneStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StackId": "s",
      },
    }, await resp.json());
  }

  async createApp(
    {abortSignal, ...params}: RequestConfig & CreateAppRequest,
  ): Promise<CreateAppResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      Shortname: params["Shortname"],
      Name: params["Name"],
      Description: params["Description"],
      DataSources: params["DataSources"]?.map(x => fromDataSource(x)),
      Type: params["Type"],
      AppSource: fromSource(params["AppSource"]),
      Domains: params["Domains"],
      EnableSsl: params["EnableSsl"],
      SslConfiguration: fromSslConfiguration(params["SslConfiguration"]),
      Attributes: params["Attributes"],
      Environment: params["Environment"]?.map(x => fromEnvironmentVariable(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppId": "s",
      },
    }, await resp.json());
  }

  async createDeployment(
    {abortSignal, ...params}: RequestConfig & CreateDeploymentRequest,
  ): Promise<CreateDeploymentResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      AppId: params["AppId"],
      InstanceIds: params["InstanceIds"],
      LayerIds: params["LayerIds"],
      Command: fromDeploymentCommand(params["Command"]),
      Comment: params["Comment"],
      CustomJson: params["CustomJson"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeployment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DeploymentId": "s",
      },
    }, await resp.json());
  }

  async createInstance(
    {abortSignal, ...params}: RequestConfig & CreateInstanceRequest,
  ): Promise<CreateInstanceResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      LayerIds: params["LayerIds"],
      InstanceType: params["InstanceType"],
      AutoScalingType: params["AutoScalingType"],
      Hostname: params["Hostname"],
      Os: params["Os"],
      AmiId: params["AmiId"],
      SshKeyName: params["SshKeyName"],
      AvailabilityZone: params["AvailabilityZone"],
      VirtualizationType: params["VirtualizationType"],
      SubnetId: params["SubnetId"],
      Architecture: params["Architecture"],
      RootDeviceType: params["RootDeviceType"],
      BlockDeviceMappings: params["BlockDeviceMappings"]?.map(x => fromBlockDeviceMapping(x)),
      InstallUpdatesOnBoot: params["InstallUpdatesOnBoot"],
      EbsOptimized: params["EbsOptimized"],
      AgentVersion: params["AgentVersion"],
      Tenancy: params["Tenancy"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceId": "s",
      },
    }, await resp.json());
  }

  async createLayer(
    {abortSignal, ...params}: RequestConfig & CreateLayerRequest,
  ): Promise<CreateLayerResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      Type: params["Type"],
      Name: params["Name"],
      Shortname: params["Shortname"],
      Attributes: params["Attributes"],
      CloudWatchLogsConfiguration: fromCloudWatchLogsConfiguration(params["CloudWatchLogsConfiguration"]),
      CustomInstanceProfileArn: params["CustomInstanceProfileArn"],
      CustomJson: params["CustomJson"],
      CustomSecurityGroupIds: params["CustomSecurityGroupIds"],
      Packages: params["Packages"],
      VolumeConfigurations: params["VolumeConfigurations"]?.map(x => fromVolumeConfiguration(x)),
      EnableAutoHealing: params["EnableAutoHealing"],
      AutoAssignElasticIps: params["AutoAssignElasticIps"],
      AutoAssignPublicIps: params["AutoAssignPublicIps"],
      CustomRecipes: fromRecipes(params["CustomRecipes"]),
      InstallUpdatesOnBoot: params["InstallUpdatesOnBoot"],
      UseEbsOptimizedInstances: params["UseEbsOptimizedInstances"],
      LifecycleEventConfiguration: fromLifecycleEventConfiguration(params["LifecycleEventConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLayer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LayerId": "s",
      },
    }, await resp.json());
  }

  async createStack(
    {abortSignal, ...params}: RequestConfig & CreateStackRequest,
  ): Promise<CreateStackResult> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Region: params["Region"],
      VpcId: params["VpcId"],
      Attributes: params["Attributes"],
      ServiceRoleArn: params["ServiceRoleArn"],
      DefaultInstanceProfileArn: params["DefaultInstanceProfileArn"],
      DefaultOs: params["DefaultOs"],
      HostnameTheme: params["HostnameTheme"],
      DefaultAvailabilityZone: params["DefaultAvailabilityZone"],
      DefaultSubnetId: params["DefaultSubnetId"],
      CustomJson: params["CustomJson"],
      ConfigurationManager: fromStackConfigurationManager(params["ConfigurationManager"]),
      ChefConfiguration: fromChefConfiguration(params["ChefConfiguration"]),
      UseCustomCookbooks: params["UseCustomCookbooks"],
      UseOpsworksSecurityGroups: params["UseOpsworksSecurityGroups"],
      CustomCookbooksSource: fromSource(params["CustomCookbooksSource"]),
      DefaultSshKeyName: params["DefaultSshKeyName"],
      DefaultRootDeviceType: params["DefaultRootDeviceType"],
      AgentVersion: params["AgentVersion"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StackId": "s",
      },
    }, await resp.json());
  }

  async createUserProfile(
    {abortSignal, ...params}: RequestConfig & CreateUserProfileRequest,
  ): Promise<CreateUserProfileResult> {
    const body: jsonP.JSONObject = params ? {
      IamUserArn: params["IamUserArn"],
      SshUsername: params["SshUsername"],
      SshPublicKey: params["SshPublicKey"],
      AllowSelfManagement: params["AllowSelfManagement"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "IamUserArn": "s",
      },
    }, await resp.json());
  }

  async deleteApp(
    {abortSignal, ...params}: RequestConfig & DeleteAppRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      AppId: params["AppId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApp",
    });
  }

  async deleteInstance(
    {abortSignal, ...params}: RequestConfig & DeleteInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
      DeleteElasticIp: params["DeleteElasticIp"],
      DeleteVolumes: params["DeleteVolumes"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInstance",
    });
  }

  async deleteLayer(
    {abortSignal, ...params}: RequestConfig & DeleteLayerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      LayerId: params["LayerId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLayer",
    });
  }

  async deleteStack(
    {abortSignal, ...params}: RequestConfig & DeleteStackRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStack",
    });
  }

  async deleteUserProfile(
    {abortSignal, ...params}: RequestConfig & DeleteUserProfileRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      IamUserArn: params["IamUserArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserProfile",
    });
  }

  async deregisterEcsCluster(
    {abortSignal, ...params}: RequestConfig & DeregisterEcsClusterRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      EcsClusterArn: params["EcsClusterArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterEcsCluster",
    });
  }

  async deregisterElasticIp(
    {abortSignal, ...params}: RequestConfig & DeregisterElasticIpRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ElasticIp: params["ElasticIp"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterElasticIp",
    });
  }

  async deregisterInstance(
    {abortSignal, ...params}: RequestConfig & DeregisterInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterInstance",
    });
  }

  async deregisterRdsDbInstance(
    {abortSignal, ...params}: RequestConfig & DeregisterRdsDbInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      RdsDbInstanceArn: params["RdsDbInstanceArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterRdsDbInstance",
    });
  }

  async deregisterVolume(
    {abortSignal, ...params}: RequestConfig & DeregisterVolumeRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      VolumeId: params["VolumeId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterVolume",
    });
  }

  async describeAgentVersions(
    {abortSignal, ...params}: RequestConfig & DescribeAgentVersionsRequest = {},
  ): Promise<DescribeAgentVersionsResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      ConfigurationManager: fromStackConfigurationManager(params["ConfigurationManager"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAgentVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AgentVersions": [toAgentVersion],
      },
    }, await resp.json());
  }

  async describeApps(
    {abortSignal, ...params}: RequestConfig & DescribeAppsRequest = {},
  ): Promise<DescribeAppsResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      AppIds: params["AppIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeApps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Apps": [toApp],
      },
    }, await resp.json());
  }

  async describeCommands(
    {abortSignal, ...params}: RequestConfig & DescribeCommandsRequest = {},
  ): Promise<DescribeCommandsResult> {
    const body: jsonP.JSONObject = params ? {
      DeploymentId: params["DeploymentId"],
      InstanceId: params["InstanceId"],
      CommandIds: params["CommandIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCommands",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Commands": [toCommand],
      },
    }, await resp.json());
  }

  async describeDeployments(
    {abortSignal, ...params}: RequestConfig & DescribeDeploymentsRequest = {},
  ): Promise<DescribeDeploymentsResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      AppId: params["AppId"],
      DeploymentIds: params["DeploymentIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDeployments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Deployments": [toDeployment],
      },
    }, await resp.json());
  }

  async describeEcsClusters(
    {abortSignal, ...params}: RequestConfig & DescribeEcsClustersRequest = {},
  ): Promise<DescribeEcsClustersResult> {
    const body: jsonP.JSONObject = params ? {
      EcsClusterArns: params["EcsClusterArns"],
      StackId: params["StackId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEcsClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EcsClusters": [toEcsCluster],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeElasticIps(
    {abortSignal, ...params}: RequestConfig & DescribeElasticIpsRequest = {},
  ): Promise<DescribeElasticIpsResult> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
      StackId: params["StackId"],
      Ips: params["Ips"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeElasticIps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticIps": [toElasticIp],
      },
    }, await resp.json());
  }

  async describeElasticLoadBalancers(
    {abortSignal, ...params}: RequestConfig & DescribeElasticLoadBalancersRequest = {},
  ): Promise<DescribeElasticLoadBalancersResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      LayerIds: params["LayerIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeElasticLoadBalancers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticLoadBalancers": [toElasticLoadBalancer],
      },
    }, await resp.json());
  }

  async describeInstances(
    {abortSignal, ...params}: RequestConfig & DescribeInstancesRequest = {},
  ): Promise<DescribeInstancesResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      LayerId: params["LayerId"],
      InstanceIds: params["InstanceIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Instances": [toInstance],
      },
    }, await resp.json());
  }

  async describeLayers(
    {abortSignal, ...params}: RequestConfig & DescribeLayersRequest = {},
  ): Promise<DescribeLayersResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      LayerIds: params["LayerIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLayers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Layers": [toLayer],
      },
    }, await resp.json());
  }

  async describeLoadBasedAutoScaling(
    {abortSignal, ...params}: RequestConfig & DescribeLoadBasedAutoScalingRequest,
  ): Promise<DescribeLoadBasedAutoScalingResult> {
    const body: jsonP.JSONObject = params ? {
      LayerIds: params["LayerIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBasedAutoScaling",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LoadBasedAutoScalingConfigurations": [toLoadBasedAutoScalingConfiguration],
      },
    }, await resp.json());
  }

  async describeMyUserProfile(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<DescribeMyUserProfileResult> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeMyUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfile": toSelfUserProfile,
      },
    }, await resp.json());
  }

  async describeOperatingSystems(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<DescribeOperatingSystemsResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeOperatingSystems",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "OperatingSystems": [toOperatingSystem],
      },
    }, await resp.json());
  }

  async describePermissions(
    {abortSignal, ...params}: RequestConfig & DescribePermissionsRequest = {},
  ): Promise<DescribePermissionsResult> {
    const body: jsonP.JSONObject = params ? {
      IamUserArn: params["IamUserArn"],
      StackId: params["StackId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Permissions": [toPermission],
      },
    }, await resp.json());
  }

  async describeRaidArrays(
    {abortSignal, ...params}: RequestConfig & DescribeRaidArraysRequest = {},
  ): Promise<DescribeRaidArraysResult> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
      StackId: params["StackId"],
      RaidArrayIds: params["RaidArrayIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRaidArrays",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RaidArrays": [toRaidArray],
      },
    }, await resp.json());
  }

  async describeRdsDbInstances(
    {abortSignal, ...params}: RequestConfig & DescribeRdsDbInstancesRequest,
  ): Promise<DescribeRdsDbInstancesResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      RdsDbInstanceArns: params["RdsDbInstanceArns"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRdsDbInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RdsDbInstances": [toRdsDbInstance],
      },
    }, await resp.json());
  }

  async describeServiceErrors(
    {abortSignal, ...params}: RequestConfig & DescribeServiceErrorsRequest = {},
  ): Promise<DescribeServiceErrorsResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      InstanceId: params["InstanceId"],
      ServiceErrorIds: params["ServiceErrorIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServiceErrors",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ServiceErrors": [toServiceError],
      },
    }, await resp.json());
  }

  async describeStackProvisioningParameters(
    {abortSignal, ...params}: RequestConfig & DescribeStackProvisioningParametersRequest,
  ): Promise<DescribeStackProvisioningParametersResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackProvisioningParameters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AgentInstallerUrl": "s",
        "Parameters": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeStackSummary(
    {abortSignal, ...params}: RequestConfig & DescribeStackSummaryRequest,
  ): Promise<DescribeStackSummaryResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackSummary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StackSummary": toStackSummary,
      },
    }, await resp.json());
  }

  async describeStacks(
    {abortSignal, ...params}: RequestConfig & DescribeStacksRequest = {},
  ): Promise<DescribeStacksResult> {
    const body: jsonP.JSONObject = params ? {
      StackIds: params["StackIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStacks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Stacks": [toStack],
      },
    }, await resp.json());
  }

  async describeTimeBasedAutoScaling(
    {abortSignal, ...params}: RequestConfig & DescribeTimeBasedAutoScalingRequest,
  ): Promise<DescribeTimeBasedAutoScalingResult> {
    const body: jsonP.JSONObject = params ? {
      InstanceIds: params["InstanceIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTimeBasedAutoScaling",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TimeBasedAutoScalingConfigurations": [toTimeBasedAutoScalingConfiguration],
      },
    }, await resp.json());
  }

  async describeUserProfiles(
    {abortSignal, ...params}: RequestConfig & DescribeUserProfilesRequest = {},
  ): Promise<DescribeUserProfilesResult> {
    const body: jsonP.JSONObject = params ? {
      IamUserArns: params["IamUserArns"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserProfiles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfiles": [toUserProfile],
      },
    }, await resp.json());
  }

  async describeVolumes(
    {abortSignal, ...params}: RequestConfig & DescribeVolumesRequest = {},
  ): Promise<DescribeVolumesResult> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
      StackId: params["StackId"],
      RaidArrayId: params["RaidArrayId"],
      VolumeIds: params["VolumeIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Volumes": [toVolume],
      },
    }, await resp.json());
  }

  async detachElasticLoadBalancer(
    {abortSignal, ...params}: RequestConfig & DetachElasticLoadBalancerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ElasticLoadBalancerName: params["ElasticLoadBalancerName"],
      LayerId: params["LayerId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachElasticLoadBalancer",
    });
  }

  async disassociateElasticIp(
    {abortSignal, ...params}: RequestConfig & DisassociateElasticIpRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ElasticIp: params["ElasticIp"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateElasticIp",
    });
  }

  async getHostnameSuggestion(
    {abortSignal, ...params}: RequestConfig & GetHostnameSuggestionRequest,
  ): Promise<GetHostnameSuggestionResult> {
    const body: jsonP.JSONObject = params ? {
      LayerId: params["LayerId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetHostnameSuggestion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LayerId": "s",
        "Hostname": "s",
      },
    }, await resp.json());
  }

  async grantAccess(
    {abortSignal, ...params}: RequestConfig & GrantAccessRequest,
  ): Promise<GrantAccessResult> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
      ValidForInMinutes: params["ValidForInMinutes"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GrantAccess",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TemporaryCredential": toTemporaryCredential,
      },
    }, await resp.json());
  }

  async listTags(
    {abortSignal, ...params}: RequestConfig & ListTagsRequest,
  ): Promise<ListTagsResult> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async rebootInstance(
    {abortSignal, ...params}: RequestConfig & RebootInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootInstance",
    });
  }

  async registerEcsCluster(
    {abortSignal, ...params}: RequestConfig & RegisterEcsClusterRequest,
  ): Promise<RegisterEcsClusterResult> {
    const body: jsonP.JSONObject = params ? {
      EcsClusterArn: params["EcsClusterArn"],
      StackId: params["StackId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterEcsCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EcsClusterArn": "s",
      },
    }, await resp.json());
  }

  async registerElasticIp(
    {abortSignal, ...params}: RequestConfig & RegisterElasticIpRequest,
  ): Promise<RegisterElasticIpResult> {
    const body: jsonP.JSONObject = params ? {
      ElasticIp: params["ElasticIp"],
      StackId: params["StackId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterElasticIp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticIp": "s",
      },
    }, await resp.json());
  }

  async registerInstance(
    {abortSignal, ...params}: RequestConfig & RegisterInstanceRequest,
  ): Promise<RegisterInstanceResult> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      Hostname: params["Hostname"],
      PublicIp: params["PublicIp"],
      PrivateIp: params["PrivateIp"],
      RsaPublicKey: params["RsaPublicKey"],
      RsaPublicKeyFingerprint: params["RsaPublicKeyFingerprint"],
      InstanceIdentity: fromInstanceIdentity(params["InstanceIdentity"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceId": "s",
      },
    }, await resp.json());
  }

  async registerRdsDbInstance(
    {abortSignal, ...params}: RequestConfig & RegisterRdsDbInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      RdsDbInstanceArn: params["RdsDbInstanceArn"],
      DbUser: params["DbUser"],
      DbPassword: params["DbPassword"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterRdsDbInstance",
    });
  }

  async registerVolume(
    {abortSignal, ...params}: RequestConfig & RegisterVolumeRequest,
  ): Promise<RegisterVolumeResult> {
    const body: jsonP.JSONObject = params ? {
      Ec2VolumeId: params["Ec2VolumeId"],
      StackId: params["StackId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeId": "s",
      },
    }, await resp.json());
  }

  async setLoadBasedAutoScaling(
    {abortSignal, ...params}: RequestConfig & SetLoadBasedAutoScalingRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      LayerId: params["LayerId"],
      Enable: params["Enable"],
      UpScaling: fromAutoScalingThresholds(params["UpScaling"]),
      DownScaling: fromAutoScalingThresholds(params["DownScaling"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetLoadBasedAutoScaling",
    });
  }

  async setPermission(
    {abortSignal, ...params}: RequestConfig & SetPermissionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      IamUserArn: params["IamUserArn"],
      AllowSsh: params["AllowSsh"],
      AllowSudo: params["AllowSudo"],
      Level: params["Level"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetPermission",
    });
  }

  async setTimeBasedAutoScaling(
    {abortSignal, ...params}: RequestConfig & SetTimeBasedAutoScalingRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
      AutoScalingSchedule: fromWeeklyAutoScalingSchedule(params["AutoScalingSchedule"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetTimeBasedAutoScaling",
    });
  }

  async startInstance(
    {abortSignal, ...params}: RequestConfig & StartInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartInstance",
    });
  }

  async startStack(
    {abortSignal, ...params}: RequestConfig & StartStackRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartStack",
    });
  }

  async stopInstance(
    {abortSignal, ...params}: RequestConfig & StopInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
      Force: params["Force"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopInstance",
    });
  }

  async stopStack(
    {abortSignal, ...params}: RequestConfig & StopStackRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopStack",
    });
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
  }

  async unassignInstance(
    {abortSignal, ...params}: RequestConfig & UnassignInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnassignInstance",
    });
  }

  async unassignVolume(
    {abortSignal, ...params}: RequestConfig & UnassignVolumeRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      VolumeId: params["VolumeId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnassignVolume",
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
  }

  async updateApp(
    {abortSignal, ...params}: RequestConfig & UpdateAppRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      AppId: params["AppId"],
      Name: params["Name"],
      Description: params["Description"],
      DataSources: params["DataSources"]?.map(x => fromDataSource(x)),
      Type: params["Type"],
      AppSource: fromSource(params["AppSource"]),
      Domains: params["Domains"],
      EnableSsl: params["EnableSsl"],
      SslConfiguration: fromSslConfiguration(params["SslConfiguration"]),
      Attributes: params["Attributes"],
      Environment: params["Environment"]?.map(x => fromEnvironmentVariable(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApp",
    });
  }

  async updateElasticIp(
    {abortSignal, ...params}: RequestConfig & UpdateElasticIpRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ElasticIp: params["ElasticIp"],
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateElasticIp",
    });
  }

  async updateInstance(
    {abortSignal, ...params}: RequestConfig & UpdateInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      InstanceId: params["InstanceId"],
      LayerIds: params["LayerIds"],
      InstanceType: params["InstanceType"],
      AutoScalingType: params["AutoScalingType"],
      Hostname: params["Hostname"],
      Os: params["Os"],
      AmiId: params["AmiId"],
      SshKeyName: params["SshKeyName"],
      Architecture: params["Architecture"],
      InstallUpdatesOnBoot: params["InstallUpdatesOnBoot"],
      EbsOptimized: params["EbsOptimized"],
      AgentVersion: params["AgentVersion"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInstance",
    });
  }

  async updateLayer(
    {abortSignal, ...params}: RequestConfig & UpdateLayerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      LayerId: params["LayerId"],
      Name: params["Name"],
      Shortname: params["Shortname"],
      Attributes: params["Attributes"],
      CloudWatchLogsConfiguration: fromCloudWatchLogsConfiguration(params["CloudWatchLogsConfiguration"]),
      CustomInstanceProfileArn: params["CustomInstanceProfileArn"],
      CustomJson: params["CustomJson"],
      CustomSecurityGroupIds: params["CustomSecurityGroupIds"],
      Packages: params["Packages"],
      VolumeConfigurations: params["VolumeConfigurations"]?.map(x => fromVolumeConfiguration(x)),
      EnableAutoHealing: params["EnableAutoHealing"],
      AutoAssignElasticIps: params["AutoAssignElasticIps"],
      AutoAssignPublicIps: params["AutoAssignPublicIps"],
      CustomRecipes: fromRecipes(params["CustomRecipes"]),
      InstallUpdatesOnBoot: params["InstallUpdatesOnBoot"],
      UseEbsOptimizedInstances: params["UseEbsOptimizedInstances"],
      LifecycleEventConfiguration: fromLifecycleEventConfiguration(params["LifecycleEventConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateLayer",
    });
  }

  async updateMyUserProfile(
    {abortSignal, ...params}: RequestConfig & UpdateMyUserProfileRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      SshPublicKey: params["SshPublicKey"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMyUserProfile",
    });
  }

  async updateRdsDbInstance(
    {abortSignal, ...params}: RequestConfig & UpdateRdsDbInstanceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      RdsDbInstanceArn: params["RdsDbInstanceArn"],
      DbUser: params["DbUser"],
      DbPassword: params["DbPassword"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRdsDbInstance",
    });
  }

  async updateStack(
    {abortSignal, ...params}: RequestConfig & UpdateStackRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      StackId: params["StackId"],
      Name: params["Name"],
      Attributes: params["Attributes"],
      ServiceRoleArn: params["ServiceRoleArn"],
      DefaultInstanceProfileArn: params["DefaultInstanceProfileArn"],
      DefaultOs: params["DefaultOs"],
      HostnameTheme: params["HostnameTheme"],
      DefaultAvailabilityZone: params["DefaultAvailabilityZone"],
      DefaultSubnetId: params["DefaultSubnetId"],
      CustomJson: params["CustomJson"],
      ConfigurationManager: fromStackConfigurationManager(params["ConfigurationManager"]),
      ChefConfiguration: fromChefConfiguration(params["ChefConfiguration"]),
      UseCustomCookbooks: params["UseCustomCookbooks"],
      CustomCookbooksSource: fromSource(params["CustomCookbooksSource"]),
      DefaultSshKeyName: params["DefaultSshKeyName"],
      DefaultRootDeviceType: params["DefaultRootDeviceType"],
      UseOpsworksSecurityGroups: params["UseOpsworksSecurityGroups"],
      AgentVersion: params["AgentVersion"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStack",
    });
  }

  async updateUserProfile(
    {abortSignal, ...params}: RequestConfig & UpdateUserProfileRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      IamUserArn: params["IamUserArn"],
      SshUsername: params["SshUsername"],
      SshPublicKey: params["SshPublicKey"],
      AllowSelfManagement: params["AllowSelfManagement"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserProfile",
    });
  }

  async updateVolume(
    {abortSignal, ...params}: RequestConfig & UpdateVolumeRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      VolumeId: params["VolumeId"],
      Name: params["Name"],
      MountPoint: params["MountPoint"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVolume",
    });
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForAppExists(
    params: RequestConfig & DescribeAppsRequest,
  ): Promise<DescribeAppsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AppExists';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeApps(params);
      return resp; // for status 200
      // TODO: if (statusCode == 400) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a deployment has completed successfully.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForDeploymentSuccessful(
    params: RequestConfig & DescribeDeploymentsRequest,
  ): Promise<DescribeDeploymentsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DeploymentSuccessful';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeDeployments(params);
      const field = resp?.Deployments?.flatMap(x => x?.Status);
      if (field?.every(x => x === "successful")) return resp;
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until OpsWorks instance is online.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForInstanceOnline(
    params: RequestConfig & DescribeInstancesRequest,
  ): Promise<DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceOnline';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Instances?.flatMap(x => x?.Status);
      if (field?.every(x => x === "online")) return resp;
      if (field?.some(x => x === "setup_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "shutting_down")) throw new Error(errMessage);
      if (field?.some(x => x === "start_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "stopped")) throw new Error(errMessage);
      if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      if (field?.some(x => x === "terminating")) throw new Error(errMessage);
      if (field?.some(x => x === "terminated")) throw new Error(errMessage);
      if (field?.some(x => x === "stop_failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until OpsWorks instance is registered.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForInstanceRegistered(
    params: RequestConfig & DescribeInstancesRequest,
  ): Promise<DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceRegistered';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Instances?.flatMap(x => x?.Status);
      if (field?.every(x => x === "registered")) return resp;
      if (field?.some(x => x === "setup_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "shutting_down")) throw new Error(errMessage);
      if (field?.some(x => x === "stopped")) throw new Error(errMessage);
      if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      if (field?.some(x => x === "terminating")) throw new Error(errMessage);
      if (field?.some(x => x === "terminated")) throw new Error(errMessage);
      if (field?.some(x => x === "stop_failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until OpsWorks instance is stopped.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForInstanceStopped(
    params: RequestConfig & DescribeInstancesRequest,
  ): Promise<DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceStopped';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Instances?.flatMap(x => x?.Status);
      if (field?.every(x => x === "stopped")) return resp;
      if (field?.some(x => x === "booting")) throw new Error(errMessage);
      if (field?.some(x => x === "pending")) throw new Error(errMessage);
      if (field?.some(x => x === "rebooting")) throw new Error(errMessage);
      if (field?.some(x => x === "requested")) throw new Error(errMessage);
      if (field?.some(x => x === "running_setup")) throw new Error(errMessage);
      if (field?.some(x => x === "setup_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "start_failed")) throw new Error(errMessage);
      if (field?.some(x => x === "stop_failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until OpsWorks instance is terminated.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForInstanceTerminated(
    params: RequestConfig & DescribeInstancesRequest,
  ): Promise<Error | DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceTerminated';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstances(params);
        const field = resp?.Instances?.flatMap(x => x?.Status);
        if (field?.every(x => x === "terminated")) return resp;
        if (field?.some(x => x === "booting")) throw new Error(errMessage);
        if (field?.some(x => x === "online")) throw new Error(errMessage);
        if (field?.some(x => x === "pending")) throw new Error(errMessage);
        if (field?.some(x => x === "rebooting")) throw new Error(errMessage);
        if (field?.some(x => x === "requested")) throw new Error(errMessage);
        if (field?.some(x => x === "running_setup")) throw new Error(errMessage);
        if (field?.some(x => x === "setup_failed")) throw new Error(errMessage);
        if (field?.some(x => x === "start_failed")) throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AssignInstanceRequest {
  InstanceId: string;
  LayerIds: string[];
}

// refs: 1 - tags: named, input
export interface AssignVolumeRequest {
  VolumeId: string;
  InstanceId?: string | null;
}

// refs: 1 - tags: named, input
export interface AssociateElasticIpRequest {
  ElasticIp: string;
  InstanceId?: string | null;
}

// refs: 1 - tags: named, input
export interface AttachElasticLoadBalancerRequest {
  ElasticLoadBalancerName: string;
  LayerId: string;
}

// refs: 1 - tags: named, input
export interface CloneStackRequest {
  SourceStackId: string;
  Name?: string | null;
  Region?: string | null;
  VpcId?: string | null;
  Attributes?: { [key in StackAttributesKeys]: string | null | undefined } | null;
  ServiceRoleArn: string;
  DefaultInstanceProfileArn?: string | null;
  DefaultOs?: string | null;
  HostnameTheme?: string | null;
  DefaultAvailabilityZone?: string | null;
  DefaultSubnetId?: string | null;
  CustomJson?: string | null;
  ConfigurationManager?: StackConfigurationManager | null;
  ChefConfiguration?: ChefConfiguration | null;
  UseCustomCookbooks?: boolean | null;
  UseOpsworksSecurityGroups?: boolean | null;
  CustomCookbooksSource?: Source | null;
  DefaultSshKeyName?: string | null;
  ClonePermissions?: boolean | null;
  CloneAppIds?: string[] | null;
  DefaultRootDeviceType?: RootDeviceType | null;
  AgentVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateAppRequest {
  StackId: string;
  Shortname?: string | null;
  Name: string;
  Description?: string | null;
  DataSources?: DataSource[] | null;
  Type: AppType;
  AppSource?: Source | null;
  Domains?: string[] | null;
  EnableSsl?: boolean | null;
  SslConfiguration?: SslConfiguration | null;
  Attributes?: { [key in AppAttributesKeys]: string | null | undefined } | null;
  Environment?: EnvironmentVariable[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDeploymentRequest {
  StackId: string;
  AppId?: string | null;
  InstanceIds?: string[] | null;
  LayerIds?: string[] | null;
  Command: DeploymentCommand;
  Comment?: string | null;
  CustomJson?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateInstanceRequest {
  StackId: string;
  LayerIds: string[];
  InstanceType: string;
  AutoScalingType?: AutoScalingType | null;
  Hostname?: string | null;
  Os?: string | null;
  AmiId?: string | null;
  SshKeyName?: string | null;
  AvailabilityZone?: string | null;
  VirtualizationType?: string | null;
  SubnetId?: string | null;
  Architecture?: Architecture | null;
  RootDeviceType?: RootDeviceType | null;
  BlockDeviceMappings?: BlockDeviceMapping[] | null;
  InstallUpdatesOnBoot?: boolean | null;
  EbsOptimized?: boolean | null;
  AgentVersion?: string | null;
  Tenancy?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateLayerRequest {
  StackId: string;
  Type: LayerType;
  Name: string;
  Shortname: string;
  Attributes?: { [key in LayerAttributesKeys]: string | null | undefined } | null;
  CloudWatchLogsConfiguration?: CloudWatchLogsConfiguration | null;
  CustomInstanceProfileArn?: string | null;
  CustomJson?: string | null;
  CustomSecurityGroupIds?: string[] | null;
  Packages?: string[] | null;
  VolumeConfigurations?: VolumeConfiguration[] | null;
  EnableAutoHealing?: boolean | null;
  AutoAssignElasticIps?: boolean | null;
  AutoAssignPublicIps?: boolean | null;
  CustomRecipes?: Recipes | null;
  InstallUpdatesOnBoot?: boolean | null;
  UseEbsOptimizedInstances?: boolean | null;
  LifecycleEventConfiguration?: LifecycleEventConfiguration | null;
}

// refs: 1 - tags: named, input
export interface CreateStackRequest {
  Name: string;
  Region: string;
  VpcId?: string | null;
  Attributes?: { [key in StackAttributesKeys]: string | null | undefined } | null;
  ServiceRoleArn: string;
  DefaultInstanceProfileArn: string;
  DefaultOs?: string | null;
  HostnameTheme?: string | null;
  DefaultAvailabilityZone?: string | null;
  DefaultSubnetId?: string | null;
  CustomJson?: string | null;
  ConfigurationManager?: StackConfigurationManager | null;
  ChefConfiguration?: ChefConfiguration | null;
  UseCustomCookbooks?: boolean | null;
  UseOpsworksSecurityGroups?: boolean | null;
  CustomCookbooksSource?: Source | null;
  DefaultSshKeyName?: string | null;
  DefaultRootDeviceType?: RootDeviceType | null;
  AgentVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateUserProfileRequest {
  IamUserArn: string;
  SshUsername?: string | null;
  SshPublicKey?: string | null;
  AllowSelfManagement?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteAppRequest {
  AppId: string;
}

// refs: 1 - tags: named, input
export interface DeleteInstanceRequest {
  InstanceId: string;
  DeleteElasticIp?: boolean | null;
  DeleteVolumes?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteLayerRequest {
  LayerId: string;
}

// refs: 1 - tags: named, input
export interface DeleteStackRequest {
  StackId: string;
}

// refs: 1 - tags: named, input
export interface DeleteUserProfileRequest {
  IamUserArn: string;
}

// refs: 1 - tags: named, input
export interface DeregisterEcsClusterRequest {
  EcsClusterArn: string;
}

// refs: 1 - tags: named, input
export interface DeregisterElasticIpRequest {
  ElasticIp: string;
}

// refs: 1 - tags: named, input
export interface DeregisterInstanceRequest {
  InstanceId: string;
}

// refs: 1 - tags: named, input
export interface DeregisterRdsDbInstanceRequest {
  RdsDbInstanceArn: string;
}

// refs: 1 - tags: named, input
export interface DeregisterVolumeRequest {
  VolumeId: string;
}

// refs: 1 - tags: named, input
export interface DescribeAgentVersionsRequest {
  StackId?: string | null;
  ConfigurationManager?: StackConfigurationManager | null;
}

// refs: 1 - tags: named, input
export interface DescribeAppsRequest {
  StackId?: string | null;
  AppIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeCommandsRequest {
  DeploymentId?: string | null;
  InstanceId?: string | null;
  CommandIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeDeploymentsRequest {
  StackId?: string | null;
  AppId?: string | null;
  DeploymentIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeEcsClustersRequest {
  EcsClusterArns?: string[] | null;
  StackId?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeElasticIpsRequest {
  InstanceId?: string | null;
  StackId?: string | null;
  Ips?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeElasticLoadBalancersRequest {
  StackId?: string | null;
  LayerIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstancesRequest {
  StackId?: string | null;
  LayerId?: string | null;
  InstanceIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeLayersRequest {
  StackId?: string | null;
  LayerIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeLoadBasedAutoScalingRequest {
  LayerIds: string[];
}

// refs: 1 - tags: named, input
export interface DescribePermissionsRequest {
  IamUserArn?: string | null;
  StackId?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeRaidArraysRequest {
  InstanceId?: string | null;
  StackId?: string | null;
  RaidArrayIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeRdsDbInstancesRequest {
  StackId: string;
  RdsDbInstanceArns?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeServiceErrorsRequest {
  StackId?: string | null;
  InstanceId?: string | null;
  ServiceErrorIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeStackProvisioningParametersRequest {
  StackId: string;
}

// refs: 1 - tags: named, input
export interface DescribeStackSummaryRequest {
  StackId: string;
}

// refs: 1 - tags: named, input
export interface DescribeStacksRequest {
  StackIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeTimeBasedAutoScalingRequest {
  InstanceIds: string[];
}

// refs: 1 - tags: named, input
export interface DescribeUserProfilesRequest {
  IamUserArns?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeVolumesRequest {
  InstanceId?: string | null;
  StackId?: string | null;
  RaidArrayId?: string | null;
  VolumeIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DetachElasticLoadBalancerRequest {
  ElasticLoadBalancerName: string;
  LayerId: string;
}

// refs: 1 - tags: named, input
export interface DisassociateElasticIpRequest {
  ElasticIp: string;
}

// refs: 1 - tags: named, input
export interface GetHostnameSuggestionRequest {
  LayerId: string;
}

// refs: 1 - tags: named, input
export interface GrantAccessRequest {
  InstanceId: string;
  ValidForInMinutes?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsRequest {
  ResourceArn: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface RebootInstanceRequest {
  InstanceId: string;
}

// refs: 1 - tags: named, input
export interface RegisterEcsClusterRequest {
  EcsClusterArn: string;
  StackId: string;
}

// refs: 1 - tags: named, input
export interface RegisterElasticIpRequest {
  ElasticIp: string;
  StackId: string;
}

// refs: 1 - tags: named, input
export interface RegisterInstanceRequest {
  StackId: string;
  Hostname?: string | null;
  PublicIp?: string | null;
  PrivateIp?: string | null;
  RsaPublicKey?: string | null;
  RsaPublicKeyFingerprint?: string | null;
  InstanceIdentity?: InstanceIdentity | null;
}

// refs: 1 - tags: named, input
export interface RegisterRdsDbInstanceRequest {
  StackId: string;
  RdsDbInstanceArn: string;
  DbUser: string;
  DbPassword: string;
}

// refs: 1 - tags: named, input
export interface RegisterVolumeRequest {
  Ec2VolumeId?: string | null;
  StackId: string;
}

// refs: 1 - tags: named, input
export interface SetLoadBasedAutoScalingRequest {
  LayerId: string;
  Enable?: boolean | null;
  UpScaling?: AutoScalingThresholds | null;
  DownScaling?: AutoScalingThresholds | null;
}

// refs: 1 - tags: named, input
export interface SetPermissionRequest {
  StackId: string;
  IamUserArn: string;
  AllowSsh?: boolean | null;
  AllowSudo?: boolean | null;
  Level?: string | null;
}

// refs: 1 - tags: named, input
export interface SetTimeBasedAutoScalingRequest {
  InstanceId: string;
  AutoScalingSchedule?: WeeklyAutoScalingSchedule | null;
}

// refs: 1 - tags: named, input
export interface StartInstanceRequest {
  InstanceId: string;
}

// refs: 1 - tags: named, input
export interface StartStackRequest {
  StackId: string;
}

// refs: 1 - tags: named, input
export interface StopInstanceRequest {
  InstanceId: string;
  Force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StopStackRequest {
  StackId: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceArn: string;
  Tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UnassignInstanceRequest {
  InstanceId: string;
}

// refs: 1 - tags: named, input
export interface UnassignVolumeRequest {
  VolumeId: string;
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateAppRequest {
  AppId: string;
  Name?: string | null;
  Description?: string | null;
  DataSources?: DataSource[] | null;
  Type?: AppType | null;
  AppSource?: Source | null;
  Domains?: string[] | null;
  EnableSsl?: boolean | null;
  SslConfiguration?: SslConfiguration | null;
  Attributes?: { [key in AppAttributesKeys]: string | null | undefined } | null;
  Environment?: EnvironmentVariable[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateElasticIpRequest {
  ElasticIp: string;
  Name?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateInstanceRequest {
  InstanceId: string;
  LayerIds?: string[] | null;
  InstanceType?: string | null;
  AutoScalingType?: AutoScalingType | null;
  Hostname?: string | null;
  Os?: string | null;
  AmiId?: string | null;
  SshKeyName?: string | null;
  Architecture?: Architecture | null;
  InstallUpdatesOnBoot?: boolean | null;
  EbsOptimized?: boolean | null;
  AgentVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateLayerRequest {
  LayerId: string;
  Name?: string | null;
  Shortname?: string | null;
  Attributes?: { [key in LayerAttributesKeys]: string | null | undefined } | null;
  CloudWatchLogsConfiguration?: CloudWatchLogsConfiguration | null;
  CustomInstanceProfileArn?: string | null;
  CustomJson?: string | null;
  CustomSecurityGroupIds?: string[] | null;
  Packages?: string[] | null;
  VolumeConfigurations?: VolumeConfiguration[] | null;
  EnableAutoHealing?: boolean | null;
  AutoAssignElasticIps?: boolean | null;
  AutoAssignPublicIps?: boolean | null;
  CustomRecipes?: Recipes | null;
  InstallUpdatesOnBoot?: boolean | null;
  UseEbsOptimizedInstances?: boolean | null;
  LifecycleEventConfiguration?: LifecycleEventConfiguration | null;
}

// refs: 1 - tags: named, input
export interface UpdateMyUserProfileRequest {
  SshPublicKey?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateRdsDbInstanceRequest {
  RdsDbInstanceArn: string;
  DbUser?: string | null;
  DbPassword?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateStackRequest {
  StackId: string;
  Name?: string | null;
  Attributes?: { [key in StackAttributesKeys]: string | null | undefined } | null;
  ServiceRoleArn?: string | null;
  DefaultInstanceProfileArn?: string | null;
  DefaultOs?: string | null;
  HostnameTheme?: string | null;
  DefaultAvailabilityZone?: string | null;
  DefaultSubnetId?: string | null;
  CustomJson?: string | null;
  ConfigurationManager?: StackConfigurationManager | null;
  ChefConfiguration?: ChefConfiguration | null;
  UseCustomCookbooks?: boolean | null;
  CustomCookbooksSource?: Source | null;
  DefaultSshKeyName?: string | null;
  DefaultRootDeviceType?: RootDeviceType | null;
  UseOpsworksSecurityGroups?: boolean | null;
  AgentVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateUserProfileRequest {
  IamUserArn: string;
  SshUsername?: string | null;
  SshPublicKey?: string | null;
  AllowSelfManagement?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UpdateVolumeRequest {
  VolumeId: string;
  Name?: string | null;
  MountPoint?: string | null;
}

// refs: 1 - tags: named, output
export interface CloneStackResult {
  StackId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateAppResult {
  AppId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDeploymentResult {
  DeploymentId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateInstanceResult {
  InstanceId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateLayerResult {
  LayerId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateStackResult {
  StackId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateUserProfileResult {
  IamUserArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeAgentVersionsResult {
  AgentVersions?: AgentVersion[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeAppsResult {
  Apps?: App[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeCommandsResult {
  Commands?: Command[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeDeploymentsResult {
  Deployments?: Deployment[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeEcsClustersResult {
  EcsClusters?: EcsCluster[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeElasticIpsResult {
  ElasticIps?: ElasticIp[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeElasticLoadBalancersResult {
  ElasticLoadBalancers?: ElasticLoadBalancer[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeInstancesResult {
  Instances?: Instance[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeLayersResult {
  Layers?: Layer[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeLoadBasedAutoScalingResult {
  LoadBasedAutoScalingConfigurations?: LoadBasedAutoScalingConfiguration[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeMyUserProfileResult {
  UserProfile?: SelfUserProfile | null;
}

// refs: 1 - tags: named, output
export interface DescribeOperatingSystemsResponse {
  OperatingSystems?: OperatingSystem[] | null;
}

// refs: 1 - tags: named, output
export interface DescribePermissionsResult {
  Permissions?: Permission[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeRaidArraysResult {
  RaidArrays?: RaidArray[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeRdsDbInstancesResult {
  RdsDbInstances?: RdsDbInstance[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeServiceErrorsResult {
  ServiceErrors?: ServiceError[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeStackProvisioningParametersResult {
  AgentInstallerUrl?: string | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface DescribeStackSummaryResult {
  StackSummary?: StackSummary | null;
}

// refs: 1 - tags: named, output
export interface DescribeStacksResult {
  Stacks?: Stack[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeTimeBasedAutoScalingResult {
  TimeBasedAutoScalingConfigurations?: TimeBasedAutoScalingConfiguration[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeUserProfilesResult {
  UserProfiles?: UserProfile[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeVolumesResult {
  Volumes?: Volume[] | null;
}

// refs: 1 - tags: named, output
export interface GetHostnameSuggestionResult {
  LayerId?: string | null;
  Hostname?: string | null;
}

// refs: 1 - tags: named, output
export interface GrantAccessResult {
  TemporaryCredential?: TemporaryCredential | null;
}

// refs: 1 - tags: named, output
export interface ListTagsResult {
  Tags?: { [key: string]: string | null | undefined } | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface RegisterEcsClusterResult {
  EcsClusterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface RegisterElasticIpResult {
  ElasticIp?: string | null;
}

// refs: 1 - tags: named, output
export interface RegisterInstanceResult {
  InstanceId?: string | null;
}

// refs: 1 - tags: named, output
export interface RegisterVolumeResult {
  VolumeId?: string | null;
}

// refs: 4 - tags: input, named, enum, output
export type StackAttributesKeys =
| "Color"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface StackConfigurationManager {
  Name?: string | null;
  Version?: string | null;
}
function fromStackConfigurationManager(input?: StackConfigurationManager | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Version: input["Version"],
  }
}
function toStackConfigurationManager(root: jsonP.JSONValue): StackConfigurationManager {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Version": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ChefConfiguration {
  ManageBerkshelf?: boolean | null;
  BerkshelfVersion?: string | null;
}
function fromChefConfiguration(input?: ChefConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ManageBerkshelf: input["ManageBerkshelf"],
    BerkshelfVersion: input["BerkshelfVersion"],
  }
}
function toChefConfiguration(root: jsonP.JSONValue): ChefConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManageBerkshelf": "b",
      "BerkshelfVersion": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface Source {
  Type?: SourceType | null;
  Url?: string | null;
  Username?: string | null;
  Password?: string | null;
  SshKey?: string | null;
  Revision?: string | null;
}
function fromSource(input?: Source | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Url: input["Url"],
    Username: input["Username"],
    Password: input["Password"],
    SshKey: input["SshKey"],
    Revision: input["Revision"],
  }
}
function toSource(root: jsonP.JSONValue): Source {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<SourceType>(x),
      "Url": "s",
      "Username": "s",
      "Password": "s",
      "SshKey": "s",
      "Revision": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type SourceType =
| "git"
| "svn"
| "archive"
| "s3"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type RootDeviceType =
| "ebs"
| "instance-store"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface DataSource {
  Type?: string | null;
  Arn?: string | null;
  DatabaseName?: string | null;
}
function fromDataSource(input?: DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Arn: input["Arn"],
    DatabaseName: input["DatabaseName"],
  }
}
function toDataSource(root: jsonP.JSONValue): DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": "s",
      "Arn": "s",
      "DatabaseName": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type AppType =
| "aws-flow-ruby"
| "java"
| "rails"
| "php"
| "nodejs"
| "static"
| "other"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface SslConfiguration {
  Certificate: string;
  PrivateKey: string;
  Chain?: string | null;
}
function fromSslConfiguration(input?: SslConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Certificate: input["Certificate"],
    PrivateKey: input["PrivateKey"],
    Chain: input["Chain"],
  }
}
function toSslConfiguration(root: jsonP.JSONValue): SslConfiguration {
  return jsonP.readObj({
    required: {
      "Certificate": "s",
      "PrivateKey": "s",
    },
    optional: {
      "Chain": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type AppAttributesKeys =
| "DocumentRoot"
| "RailsEnv"
| "AutoBundleOnDeploy"
| "AwsFlowRubySettings"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface EnvironmentVariable {
  Key: string;
  Value: string;
  Secure?: boolean | null;
}
function fromEnvironmentVariable(input?: EnvironmentVariable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Secure: input["Secure"],
  }
}
function toEnvironmentVariable(root: jsonP.JSONValue): EnvironmentVariable {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {
      "Secure": "b",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface DeploymentCommand {
  Name: DeploymentCommandName;
  Args?: { [key: string]: string[] | null | undefined } | null;
}
function fromDeploymentCommand(input?: DeploymentCommand | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Args: input["Args"],
  }
}
function toDeploymentCommand(root: jsonP.JSONValue): DeploymentCommand {
  return jsonP.readObj({
    required: {
      "Name": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentCommandName>(x),
    },
    optional: {
      "Args": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type DeploymentCommandName =
| "install_dependencies"
| "update_dependencies"
| "update_custom_cookbooks"
| "execute_recipes"
| "configure"
| "setup"
| "deploy"
| "rollback"
| "start"
| "stop"
| "restart"
| "undeploy"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type AutoScalingType =
| "load"
| "timer"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type Architecture =
| "x86_64"
| "i386"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface BlockDeviceMapping {
  DeviceName?: string | null;
  NoDevice?: string | null;
  VirtualName?: string | null;
  Ebs?: EbsBlockDevice | null;
}
function fromBlockDeviceMapping(input?: BlockDeviceMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DeviceName: input["DeviceName"],
    NoDevice: input["NoDevice"],
    VirtualName: input["VirtualName"],
    Ebs: fromEbsBlockDevice(input["Ebs"]),
  }
}
function toBlockDeviceMapping(root: jsonP.JSONValue): BlockDeviceMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeviceName": "s",
      "NoDevice": "s",
      "VirtualName": "s",
      "Ebs": toEbsBlockDevice,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface EbsBlockDevice {
  SnapshotId?: string | null;
  Iops?: number | null;
  VolumeSize?: number | null;
  VolumeType?: VolumeType | null;
  DeleteOnTermination?: boolean | null;
}
function fromEbsBlockDevice(input?: EbsBlockDevice | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SnapshotId: input["SnapshotId"],
    Iops: input["Iops"],
    VolumeSize: input["VolumeSize"],
    VolumeType: input["VolumeType"],
    DeleteOnTermination: input["DeleteOnTermination"],
  }
}
function toEbsBlockDevice(root: jsonP.JSONValue): EbsBlockDevice {
  return jsonP.readObj({
    required: {},
    optional: {
      "SnapshotId": "s",
      "Iops": "n",
      "VolumeSize": "n",
      "VolumeType": (x: jsonP.JSONValue) => cmnP.readEnum<VolumeType>(x),
      "DeleteOnTermination": "b",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type VolumeType =
| "gp2"
| "io1"
| "standard"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type LayerType =
| "aws-flow-ruby"
| "ecs-cluster"
| "java-app"
| "lb"
| "web"
| "php-app"
| "rails-app"
| "nodejs-app"
| "memcached"
| "db-master"
| "monitoring-master"
| "custom"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type LayerAttributesKeys =
| "EcsClusterArn"
| "EnableHaproxyStats"
| "HaproxyStatsUrl"
| "HaproxyStatsUser"
| "HaproxyStatsPassword"
| "HaproxyHealthCheckUrl"
| "HaproxyHealthCheckMethod"
| "MysqlRootPassword"
| "MysqlRootPasswordUbiquitous"
| "GangliaUrl"
| "GangliaUser"
| "GangliaPassword"
| "MemcachedMemory"
| "NodejsVersion"
| "RubyVersion"
| "RubygemsVersion"
| "ManageBundler"
| "BundlerVersion"
| "RailsStack"
| "PassengerVersion"
| "Jvm"
| "JvmVersion"
| "JvmOptions"
| "JavaAppServer"
| "JavaAppServerVersion"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface CloudWatchLogsConfiguration {
  Enabled?: boolean | null;
  LogStreams?: CloudWatchLogsLogStream[] | null;
}
function fromCloudWatchLogsConfiguration(input?: CloudWatchLogsConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    LogStreams: input["LogStreams"]?.map(x => fromCloudWatchLogsLogStream(x)),
  }
}
function toCloudWatchLogsConfiguration(root: jsonP.JSONValue): CloudWatchLogsConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "LogStreams": [toCloudWatchLogsLogStream],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface CloudWatchLogsLogStream {
  LogGroupName?: string | null;
  DatetimeFormat?: string | null;
  TimeZone?: CloudWatchLogsTimeZone | null;
  File?: string | null;
  FileFingerprintLines?: string | null;
  MultiLineStartPattern?: string | null;
  InitialPosition?: CloudWatchLogsInitialPosition | null;
  Encoding?: CloudWatchLogsEncoding | null;
  BufferDuration?: number | null;
  BatchCount?: number | null;
  BatchSize?: number | null;
}
function fromCloudWatchLogsLogStream(input?: CloudWatchLogsLogStream | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LogGroupName: input["LogGroupName"],
    DatetimeFormat: input["DatetimeFormat"],
    TimeZone: input["TimeZone"],
    File: input["File"],
    FileFingerprintLines: input["FileFingerprintLines"],
    MultiLineStartPattern: input["MultiLineStartPattern"],
    InitialPosition: input["InitialPosition"],
    Encoding: input["Encoding"],
    BufferDuration: input["BufferDuration"],
    BatchCount: input["BatchCount"],
    BatchSize: input["BatchSize"],
  }
}
function toCloudWatchLogsLogStream(root: jsonP.JSONValue): CloudWatchLogsLogStream {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogGroupName": "s",
      "DatetimeFormat": "s",
      "TimeZone": (x: jsonP.JSONValue) => cmnP.readEnum<CloudWatchLogsTimeZone>(x),
      "File": "s",
      "FileFingerprintLines": "s",
      "MultiLineStartPattern": "s",
      "InitialPosition": (x: jsonP.JSONValue) => cmnP.readEnum<CloudWatchLogsInitialPosition>(x),
      "Encoding": (x: jsonP.JSONValue) => cmnP.readEnum<CloudWatchLogsEncoding>(x),
      "BufferDuration": "n",
      "BatchCount": "n",
      "BatchSize": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type CloudWatchLogsTimeZone =
| "LOCAL"
| "UTC"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type CloudWatchLogsInitialPosition =
| "start_of_file"
| "end_of_file"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type CloudWatchLogsEncoding =
| "ascii"
| "big5"
| "big5hkscs"
| "cp037"
| "cp424"
| "cp437"
| "cp500"
| "cp720"
| "cp737"
| "cp775"
| "cp850"
| "cp852"
| "cp855"
| "cp856"
| "cp857"
| "cp858"
| "cp860"
| "cp861"
| "cp862"
| "cp863"
| "cp864"
| "cp865"
| "cp866"
| "cp869"
| "cp874"
| "cp875"
| "cp932"
| "cp949"
| "cp950"
| "cp1006"
| "cp1026"
| "cp1140"
| "cp1250"
| "cp1251"
| "cp1252"
| "cp1253"
| "cp1254"
| "cp1255"
| "cp1256"
| "cp1257"
| "cp1258"
| "euc_jp"
| "euc_jis_2004"
| "euc_jisx0213"
| "euc_kr"
| "gb2312"
| "gbk"
| "gb18030"
| "hz"
| "iso2022_jp"
| "iso2022_jp_1"
| "iso2022_jp_2"
| "iso2022_jp_2004"
| "iso2022_jp_3"
| "iso2022_jp_ext"
| "iso2022_kr"
| "latin_1"
| "iso8859_2"
| "iso8859_3"
| "iso8859_4"
| "iso8859_5"
| "iso8859_6"
| "iso8859_7"
| "iso8859_8"
| "iso8859_9"
| "iso8859_10"
| "iso8859_13"
| "iso8859_14"
| "iso8859_15"
| "iso8859_16"
| "johab"
| "koi8_r"
| "koi8_u"
| "mac_cyrillic"
| "mac_greek"
| "mac_iceland"
| "mac_latin2"
| "mac_roman"
| "mac_turkish"
| "ptcp154"
| "shift_jis"
| "shift_jis_2004"
| "shift_jisx0213"
| "utf_32"
| "utf_32_be"
| "utf_32_le"
| "utf_16"
| "utf_16_be"
| "utf_16_le"
| "utf_7"
| "utf_8"
| "utf_8_sig"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface VolumeConfiguration {
  MountPoint: string;
  RaidLevel?: number | null;
  NumberOfDisks: number;
  Size: number;
  VolumeType?: string | null;
  Iops?: number | null;
  Encrypted?: boolean | null;
}
function fromVolumeConfiguration(input?: VolumeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MountPoint: input["MountPoint"],
    RaidLevel: input["RaidLevel"],
    NumberOfDisks: input["NumberOfDisks"],
    Size: input["Size"],
    VolumeType: input["VolumeType"],
    Iops: input["Iops"],
    Encrypted: input["Encrypted"],
  }
}
function toVolumeConfiguration(root: jsonP.JSONValue): VolumeConfiguration {
  return jsonP.readObj({
    required: {
      "MountPoint": "s",
      "NumberOfDisks": "n",
      "Size": "n",
    },
    optional: {
      "RaidLevel": "n",
      "VolumeType": "s",
      "Iops": "n",
      "Encrypted": "b",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Recipes {
  Setup?: string[] | null;
  Configure?: string[] | null;
  Deploy?: string[] | null;
  Undeploy?: string[] | null;
  Shutdown?: string[] | null;
}
function fromRecipes(input?: Recipes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Setup: input["Setup"],
    Configure: input["Configure"],
    Deploy: input["Deploy"],
    Undeploy: input["Undeploy"],
    Shutdown: input["Shutdown"],
  }
}
function toRecipes(root: jsonP.JSONValue): Recipes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Setup": ["s"],
      "Configure": ["s"],
      "Deploy": ["s"],
      "Undeploy": ["s"],
      "Shutdown": ["s"],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface LifecycleEventConfiguration {
  Shutdown?: ShutdownEventConfiguration | null;
}
function fromLifecycleEventConfiguration(input?: LifecycleEventConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Shutdown: fromShutdownEventConfiguration(input["Shutdown"]),
  }
}
function toLifecycleEventConfiguration(root: jsonP.JSONValue): LifecycleEventConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Shutdown": toShutdownEventConfiguration,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ShutdownEventConfiguration {
  ExecutionTimeout?: number | null;
  DelayUntilElbConnectionsDrained?: boolean | null;
}
function fromShutdownEventConfiguration(input?: ShutdownEventConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExecutionTimeout: input["ExecutionTimeout"],
    DelayUntilElbConnectionsDrained: input["DelayUntilElbConnectionsDrained"],
  }
}
function toShutdownEventConfiguration(root: jsonP.JSONValue): ShutdownEventConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExecutionTimeout": "n",
      "DelayUntilElbConnectionsDrained": "b",
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface InstanceIdentity {
  Document?: string | null;
  Signature?: string | null;
}
function fromInstanceIdentity(input?: InstanceIdentity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Document: input["Document"],
    Signature: input["Signature"],
  }
}

// refs: 4 - tags: input, named, interface, output
export interface AutoScalingThresholds {
  InstanceCount?: number | null;
  ThresholdsWaitTime?: number | null;
  IgnoreMetricsTime?: number | null;
  CpuThreshold?: number | null;
  MemoryThreshold?: number | null;
  LoadThreshold?: number | null;
  Alarms?: string[] | null;
}
function fromAutoScalingThresholds(input?: AutoScalingThresholds | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceCount: input["InstanceCount"],
    ThresholdsWaitTime: input["ThresholdsWaitTime"],
    IgnoreMetricsTime: input["IgnoreMetricsTime"],
    CpuThreshold: input["CpuThreshold"],
    MemoryThreshold: input["MemoryThreshold"],
    LoadThreshold: input["LoadThreshold"],
    Alarms: input["Alarms"],
  }
}
function toAutoScalingThresholds(root: jsonP.JSONValue): AutoScalingThresholds {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceCount": "n",
      "ThresholdsWaitTime": "n",
      "IgnoreMetricsTime": "n",
      "CpuThreshold": "n",
      "MemoryThreshold": "n",
      "LoadThreshold": "n",
      "Alarms": ["s"],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface WeeklyAutoScalingSchedule {
  Monday?: { [key: string]: string | null | undefined } | null;
  Tuesday?: { [key: string]: string | null | undefined } | null;
  Wednesday?: { [key: string]: string | null | undefined } | null;
  Thursday?: { [key: string]: string | null | undefined } | null;
  Friday?: { [key: string]: string | null | undefined } | null;
  Saturday?: { [key: string]: string | null | undefined } | null;
  Sunday?: { [key: string]: string | null | undefined } | null;
}
function fromWeeklyAutoScalingSchedule(input?: WeeklyAutoScalingSchedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Monday: input["Monday"],
    Tuesday: input["Tuesday"],
    Wednesday: input["Wednesday"],
    Thursday: input["Thursday"],
    Friday: input["Friday"],
    Saturday: input["Saturday"],
    Sunday: input["Sunday"],
  }
}
function toWeeklyAutoScalingSchedule(root: jsonP.JSONValue): WeeklyAutoScalingSchedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Monday": x => jsonP.readMap(String, String, x),
      "Tuesday": x => jsonP.readMap(String, String, x),
      "Wednesday": x => jsonP.readMap(String, String, x),
      "Thursday": x => jsonP.readMap(String, String, x),
      "Friday": x => jsonP.readMap(String, String, x),
      "Saturday": x => jsonP.readMap(String, String, x),
      "Sunday": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AgentVersion {
  Version?: string | null;
  ConfigurationManager?: StackConfigurationManager | null;
}
function toAgentVersion(root: jsonP.JSONValue): AgentVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Version": "s",
      "ConfigurationManager": toStackConfigurationManager,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface App {
  AppId?: string | null;
  StackId?: string | null;
  Shortname?: string | null;
  Name?: string | null;
  Description?: string | null;
  DataSources?: DataSource[] | null;
  Type?: AppType | null;
  AppSource?: Source | null;
  Domains?: string[] | null;
  EnableSsl?: boolean | null;
  SslConfiguration?: SslConfiguration | null;
  Attributes?: { [key in AppAttributesKeys]: string | null | undefined } | null;
  CreatedAt?: string | null;
  Environment?: EnvironmentVariable[] | null;
}
function toApp(root: jsonP.JSONValue): App {
  return jsonP.readObj({
    required: {},
    optional: {
      "AppId": "s",
      "StackId": "s",
      "Shortname": "s",
      "Name": "s",
      "Description": "s",
      "DataSources": [toDataSource],
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<AppType>(x),
      "AppSource": toSource,
      "Domains": ["s"],
      "EnableSsl": "b",
      "SslConfiguration": toSslConfiguration,
      "Attributes": x => jsonP.readMap(x => cmnP.readEnumReq<AppAttributesKeys>(x), String, x),
      "CreatedAt": "s",
      "Environment": [toEnvironmentVariable],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Command {
  CommandId?: string | null;
  InstanceId?: string | null;
  DeploymentId?: string | null;
  CreatedAt?: string | null;
  AcknowledgedAt?: string | null;
  CompletedAt?: string | null;
  Status?: string | null;
  ExitCode?: number | null;
  LogUrl?: string | null;
  Type?: string | null;
}
function toCommand(root: jsonP.JSONValue): Command {
  return jsonP.readObj({
    required: {},
    optional: {
      "CommandId": "s",
      "InstanceId": "s",
      "DeploymentId": "s",
      "CreatedAt": "s",
      "AcknowledgedAt": "s",
      "CompletedAt": "s",
      "Status": "s",
      "ExitCode": "n",
      "LogUrl": "s",
      "Type": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Deployment {
  DeploymentId?: string | null;
  StackId?: string | null;
  AppId?: string | null;
  CreatedAt?: string | null;
  CompletedAt?: string | null;
  Duration?: number | null;
  IamUserArn?: string | null;
  Comment?: string | null;
  Command?: DeploymentCommand | null;
  Status?: string | null;
  CustomJson?: string | null;
  InstanceIds?: string[] | null;
}
function toDeployment(root: jsonP.JSONValue): Deployment {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeploymentId": "s",
      "StackId": "s",
      "AppId": "s",
      "CreatedAt": "s",
      "CompletedAt": "s",
      "Duration": "n",
      "IamUserArn": "s",
      "Comment": "s",
      "Command": toDeploymentCommand,
      "Status": "s",
      "CustomJson": "s",
      "InstanceIds": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EcsCluster {
  EcsClusterArn?: string | null;
  EcsClusterName?: string | null;
  StackId?: string | null;
  RegisteredAt?: string | null;
}
function toEcsCluster(root: jsonP.JSONValue): EcsCluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "EcsClusterArn": "s",
      "EcsClusterName": "s",
      "StackId": "s",
      "RegisteredAt": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ElasticIp {
  Ip?: string | null;
  Name?: string | null;
  Domain?: string | null;
  Region?: string | null;
  InstanceId?: string | null;
}
function toElasticIp(root: jsonP.JSONValue): ElasticIp {
  return jsonP.readObj({
    required: {},
    optional: {
      "Ip": "s",
      "Name": "s",
      "Domain": "s",
      "Region": "s",
      "InstanceId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ElasticLoadBalancer {
  ElasticLoadBalancerName?: string | null;
  Region?: string | null;
  DnsName?: string | null;
  StackId?: string | null;
  LayerId?: string | null;
  VpcId?: string | null;
  AvailabilityZones?: string[] | null;
  SubnetIds?: string[] | null;
  Ec2InstanceIds?: string[] | null;
}
function toElasticLoadBalancer(root: jsonP.JSONValue): ElasticLoadBalancer {
  return jsonP.readObj({
    required: {},
    optional: {
      "ElasticLoadBalancerName": "s",
      "Region": "s",
      "DnsName": "s",
      "StackId": "s",
      "LayerId": "s",
      "VpcId": "s",
      "AvailabilityZones": ["s"],
      "SubnetIds": ["s"],
      "Ec2InstanceIds": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Instance {
  AgentVersion?: string | null;
  AmiId?: string | null;
  Architecture?: Architecture | null;
  Arn?: string | null;
  AutoScalingType?: AutoScalingType | null;
  AvailabilityZone?: string | null;
  BlockDeviceMappings?: BlockDeviceMapping[] | null;
  CreatedAt?: string | null;
  EbsOptimized?: boolean | null;
  Ec2InstanceId?: string | null;
  EcsClusterArn?: string | null;
  EcsContainerInstanceArn?: string | null;
  ElasticIp?: string | null;
  Hostname?: string | null;
  InfrastructureClass?: string | null;
  InstallUpdatesOnBoot?: boolean | null;
  InstanceId?: string | null;
  InstanceProfileArn?: string | null;
  InstanceType?: string | null;
  LastServiceErrorId?: string | null;
  LayerIds?: string[] | null;
  Os?: string | null;
  Platform?: string | null;
  PrivateDns?: string | null;
  PrivateIp?: string | null;
  PublicDns?: string | null;
  PublicIp?: string | null;
  RegisteredBy?: string | null;
  ReportedAgentVersion?: string | null;
  ReportedOs?: ReportedOs | null;
  RootDeviceType?: RootDeviceType | null;
  RootDeviceVolumeId?: string | null;
  SecurityGroupIds?: string[] | null;
  SshHostDsaKeyFingerprint?: string | null;
  SshHostRsaKeyFingerprint?: string | null;
  SshKeyName?: string | null;
  StackId?: string | null;
  Status?: string | null;
  SubnetId?: string | null;
  Tenancy?: string | null;
  VirtualizationType?: VirtualizationType | null;
}
function toInstance(root: jsonP.JSONValue): Instance {
  return jsonP.readObj({
    required: {},
    optional: {
      "AgentVersion": "s",
      "AmiId": "s",
      "Architecture": (x: jsonP.JSONValue) => cmnP.readEnum<Architecture>(x),
      "Arn": "s",
      "AutoScalingType": (x: jsonP.JSONValue) => cmnP.readEnum<AutoScalingType>(x),
      "AvailabilityZone": "s",
      "BlockDeviceMappings": [toBlockDeviceMapping],
      "CreatedAt": "s",
      "EbsOptimized": "b",
      "Ec2InstanceId": "s",
      "EcsClusterArn": "s",
      "EcsContainerInstanceArn": "s",
      "ElasticIp": "s",
      "Hostname": "s",
      "InfrastructureClass": "s",
      "InstallUpdatesOnBoot": "b",
      "InstanceId": "s",
      "InstanceProfileArn": "s",
      "InstanceType": "s",
      "LastServiceErrorId": "s",
      "LayerIds": ["s"],
      "Os": "s",
      "Platform": "s",
      "PrivateDns": "s",
      "PrivateIp": "s",
      "PublicDns": "s",
      "PublicIp": "s",
      "RegisteredBy": "s",
      "ReportedAgentVersion": "s",
      "ReportedOs": toReportedOs,
      "RootDeviceType": (x: jsonP.JSONValue) => cmnP.readEnum<RootDeviceType>(x),
      "RootDeviceVolumeId": "s",
      "SecurityGroupIds": ["s"],
      "SshHostDsaKeyFingerprint": "s",
      "SshHostRsaKeyFingerprint": "s",
      "SshKeyName": "s",
      "StackId": "s",
      "Status": "s",
      "SubnetId": "s",
      "Tenancy": "s",
      "VirtualizationType": (x: jsonP.JSONValue) => cmnP.readEnum<VirtualizationType>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReportedOs {
  Family?: string | null;
  Name?: string | null;
  Version?: string | null;
}
function toReportedOs(root: jsonP.JSONValue): ReportedOs {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "Name": "s",
      "Version": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type VirtualizationType =
| "paravirtual"
| "hvm"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Layer {
  Arn?: string | null;
  StackId?: string | null;
  LayerId?: string | null;
  Type?: LayerType | null;
  Name?: string | null;
  Shortname?: string | null;
  Attributes?: { [key in LayerAttributesKeys]: string | null | undefined } | null;
  CloudWatchLogsConfiguration?: CloudWatchLogsConfiguration | null;
  CustomInstanceProfileArn?: string | null;
  CustomJson?: string | null;
  CustomSecurityGroupIds?: string[] | null;
  DefaultSecurityGroupNames?: string[] | null;
  Packages?: string[] | null;
  VolumeConfigurations?: VolumeConfiguration[] | null;
  EnableAutoHealing?: boolean | null;
  AutoAssignElasticIps?: boolean | null;
  AutoAssignPublicIps?: boolean | null;
  DefaultRecipes?: Recipes | null;
  CustomRecipes?: Recipes | null;
  CreatedAt?: string | null;
  InstallUpdatesOnBoot?: boolean | null;
  UseEbsOptimizedInstances?: boolean | null;
  LifecycleEventConfiguration?: LifecycleEventConfiguration | null;
}
function toLayer(root: jsonP.JSONValue): Layer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "StackId": "s",
      "LayerId": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<LayerType>(x),
      "Name": "s",
      "Shortname": "s",
      "Attributes": x => jsonP.readMap(x => cmnP.readEnumReq<LayerAttributesKeys>(x), String, x),
      "CloudWatchLogsConfiguration": toCloudWatchLogsConfiguration,
      "CustomInstanceProfileArn": "s",
      "CustomJson": "s",
      "CustomSecurityGroupIds": ["s"],
      "DefaultSecurityGroupNames": ["s"],
      "Packages": ["s"],
      "VolumeConfigurations": [toVolumeConfiguration],
      "EnableAutoHealing": "b",
      "AutoAssignElasticIps": "b",
      "AutoAssignPublicIps": "b",
      "DefaultRecipes": toRecipes,
      "CustomRecipes": toRecipes,
      "CreatedAt": "s",
      "InstallUpdatesOnBoot": "b",
      "UseEbsOptimizedInstances": "b",
      "LifecycleEventConfiguration": toLifecycleEventConfiguration,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface LoadBasedAutoScalingConfiguration {
  LayerId?: string | null;
  Enable?: boolean | null;
  UpScaling?: AutoScalingThresholds | null;
  DownScaling?: AutoScalingThresholds | null;
}
function toLoadBasedAutoScalingConfiguration(root: jsonP.JSONValue): LoadBasedAutoScalingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "LayerId": "s",
      "Enable": "b",
      "UpScaling": toAutoScalingThresholds,
      "DownScaling": toAutoScalingThresholds,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SelfUserProfile {
  IamUserArn?: string | null;
  Name?: string | null;
  SshUsername?: string | null;
  SshPublicKey?: string | null;
}
function toSelfUserProfile(root: jsonP.JSONValue): SelfUserProfile {
  return jsonP.readObj({
    required: {},
    optional: {
      "IamUserArn": "s",
      "Name": "s",
      "SshUsername": "s",
      "SshPublicKey": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface OperatingSystem {
  Name?: string | null;
  Id?: string | null;
  Type?: string | null;
  ConfigurationManagers?: OperatingSystemConfigurationManager[] | null;
  ReportedName?: string | null;
  ReportedVersion?: string | null;
  Supported?: boolean | null;
}
function toOperatingSystem(root: jsonP.JSONValue): OperatingSystem {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Type": "s",
      "ConfigurationManagers": [toOperatingSystemConfigurationManager],
      "ReportedName": "s",
      "ReportedVersion": "s",
      "Supported": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface OperatingSystemConfigurationManager {
  Name?: string | null;
  Version?: string | null;
}
function toOperatingSystemConfigurationManager(root: jsonP.JSONValue): OperatingSystemConfigurationManager {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Version": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Permission {
  StackId?: string | null;
  IamUserArn?: string | null;
  AllowSsh?: boolean | null;
  AllowSudo?: boolean | null;
  Level?: string | null;
}
function toPermission(root: jsonP.JSONValue): Permission {
  return jsonP.readObj({
    required: {},
    optional: {
      "StackId": "s",
      "IamUserArn": "s",
      "AllowSsh": "b",
      "AllowSudo": "b",
      "Level": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RaidArray {
  RaidArrayId?: string | null;
  InstanceId?: string | null;
  Name?: string | null;
  RaidLevel?: number | null;
  NumberOfDisks?: number | null;
  Size?: number | null;
  Device?: string | null;
  MountPoint?: string | null;
  AvailabilityZone?: string | null;
  CreatedAt?: string | null;
  StackId?: string | null;
  VolumeType?: string | null;
  Iops?: number | null;
}
function toRaidArray(root: jsonP.JSONValue): RaidArray {
  return jsonP.readObj({
    required: {},
    optional: {
      "RaidArrayId": "s",
      "InstanceId": "s",
      "Name": "s",
      "RaidLevel": "n",
      "NumberOfDisks": "n",
      "Size": "n",
      "Device": "s",
      "MountPoint": "s",
      "AvailabilityZone": "s",
      "CreatedAt": "s",
      "StackId": "s",
      "VolumeType": "s",
      "Iops": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RdsDbInstance {
  RdsDbInstanceArn?: string | null;
  DbInstanceIdentifier?: string | null;
  DbUser?: string | null;
  DbPassword?: string | null;
  Region?: string | null;
  Address?: string | null;
  Engine?: string | null;
  StackId?: string | null;
  MissingOnRds?: boolean | null;
}
function toRdsDbInstance(root: jsonP.JSONValue): RdsDbInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "RdsDbInstanceArn": "s",
      "DbInstanceIdentifier": "s",
      "DbUser": "s",
      "DbPassword": "s",
      "Region": "s",
      "Address": "s",
      "Engine": "s",
      "StackId": "s",
      "MissingOnRds": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ServiceError {
  ServiceErrorId?: string | null;
  StackId?: string | null;
  InstanceId?: string | null;
  Type?: string | null;
  Message?: string | null;
  CreatedAt?: string | null;
}
function toServiceError(root: jsonP.JSONValue): ServiceError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServiceErrorId": "s",
      "StackId": "s",
      "InstanceId": "s",
      "Type": "s",
      "Message": "s",
      "CreatedAt": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StackSummary {
  StackId?: string | null;
  Name?: string | null;
  Arn?: string | null;
  LayersCount?: number | null;
  AppsCount?: number | null;
  InstancesCount?: InstancesCount | null;
}
function toStackSummary(root: jsonP.JSONValue): StackSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "StackId": "s",
      "Name": "s",
      "Arn": "s",
      "LayersCount": "n",
      "AppsCount": "n",
      "InstancesCount": toInstancesCount,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstancesCount {
  Assigning?: number | null;
  Booting?: number | null;
  ConnectionLost?: number | null;
  Deregistering?: number | null;
  Online?: number | null;
  Pending?: number | null;
  Rebooting?: number | null;
  Registered?: number | null;
  Registering?: number | null;
  Requested?: number | null;
  RunningSetup?: number | null;
  SetupFailed?: number | null;
  ShuttingDown?: number | null;
  StartFailed?: number | null;
  StopFailed?: number | null;
  Stopped?: number | null;
  Stopping?: number | null;
  Terminated?: number | null;
  Terminating?: number | null;
  Unassigning?: number | null;
}
function toInstancesCount(root: jsonP.JSONValue): InstancesCount {
  return jsonP.readObj({
    required: {},
    optional: {
      "Assigning": "n",
      "Booting": "n",
      "ConnectionLost": "n",
      "Deregistering": "n",
      "Online": "n",
      "Pending": "n",
      "Rebooting": "n",
      "Registered": "n",
      "Registering": "n",
      "Requested": "n",
      "RunningSetup": "n",
      "SetupFailed": "n",
      "ShuttingDown": "n",
      "StartFailed": "n",
      "StopFailed": "n",
      "Stopped": "n",
      "Stopping": "n",
      "Terminated": "n",
      "Terminating": "n",
      "Unassigning": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Stack {
  StackId?: string | null;
  Name?: string | null;
  Arn?: string | null;
  Region?: string | null;
  VpcId?: string | null;
  Attributes?: { [key in StackAttributesKeys]: string | null | undefined } | null;
  ServiceRoleArn?: string | null;
  DefaultInstanceProfileArn?: string | null;
  DefaultOs?: string | null;
  HostnameTheme?: string | null;
  DefaultAvailabilityZone?: string | null;
  DefaultSubnetId?: string | null;
  CustomJson?: string | null;
  ConfigurationManager?: StackConfigurationManager | null;
  ChefConfiguration?: ChefConfiguration | null;
  UseCustomCookbooks?: boolean | null;
  UseOpsworksSecurityGroups?: boolean | null;
  CustomCookbooksSource?: Source | null;
  DefaultSshKeyName?: string | null;
  CreatedAt?: string | null;
  DefaultRootDeviceType?: RootDeviceType | null;
  AgentVersion?: string | null;
}
function toStack(root: jsonP.JSONValue): Stack {
  return jsonP.readObj({
    required: {},
    optional: {
      "StackId": "s",
      "Name": "s",
      "Arn": "s",
      "Region": "s",
      "VpcId": "s",
      "Attributes": x => jsonP.readMap(x => cmnP.readEnumReq<StackAttributesKeys>(x), String, x),
      "ServiceRoleArn": "s",
      "DefaultInstanceProfileArn": "s",
      "DefaultOs": "s",
      "HostnameTheme": "s",
      "DefaultAvailabilityZone": "s",
      "DefaultSubnetId": "s",
      "CustomJson": "s",
      "ConfigurationManager": toStackConfigurationManager,
      "ChefConfiguration": toChefConfiguration,
      "UseCustomCookbooks": "b",
      "UseOpsworksSecurityGroups": "b",
      "CustomCookbooksSource": toSource,
      "DefaultSshKeyName": "s",
      "CreatedAt": "s",
      "DefaultRootDeviceType": (x: jsonP.JSONValue) => cmnP.readEnum<RootDeviceType>(x),
      "AgentVersion": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TimeBasedAutoScalingConfiguration {
  InstanceId?: string | null;
  AutoScalingSchedule?: WeeklyAutoScalingSchedule | null;
}
function toTimeBasedAutoScalingConfiguration(root: jsonP.JSONValue): TimeBasedAutoScalingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceId": "s",
      "AutoScalingSchedule": toWeeklyAutoScalingSchedule,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UserProfile {
  IamUserArn?: string | null;
  Name?: string | null;
  SshUsername?: string | null;
  SshPublicKey?: string | null;
  AllowSelfManagement?: boolean | null;
}
function toUserProfile(root: jsonP.JSONValue): UserProfile {
  return jsonP.readObj({
    required: {},
    optional: {
      "IamUserArn": "s",
      "Name": "s",
      "SshUsername": "s",
      "SshPublicKey": "s",
      "AllowSelfManagement": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Volume {
  VolumeId?: string | null;
  Ec2VolumeId?: string | null;
  Name?: string | null;
  RaidArrayId?: string | null;
  InstanceId?: string | null;
  Status?: string | null;
  Size?: number | null;
  Device?: string | null;
  MountPoint?: string | null;
  Region?: string | null;
  AvailabilityZone?: string | null;
  VolumeType?: string | null;
  Iops?: number | null;
  Encrypted?: boolean | null;
}
function toVolume(root: jsonP.JSONValue): Volume {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeId": "s",
      "Ec2VolumeId": "s",
      "Name": "s",
      "RaidArrayId": "s",
      "InstanceId": "s",
      "Status": "s",
      "Size": "n",
      "Device": "s",
      "MountPoint": "s",
      "Region": "s",
      "AvailabilityZone": "s",
      "VolumeType": "s",
      "Iops": "n",
      "Encrypted": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TemporaryCredential {
  Username?: string | null;
  Password?: string | null;
  ValidForInMinutes?: number | null;
  InstanceId?: string | null;
}
function toTemporaryCredential(root: jsonP.JSONValue): TemporaryCredential {
  return jsonP.readObj({
    required: {},
    optional: {
      "Username": "s",
      "Password": "s",
      "ValidForInMinutes": "n",
      "InstanceId": "s",
    },
  }, root);
}
