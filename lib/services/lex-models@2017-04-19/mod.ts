// Autogenerated API client for: Amazon Lex Model Building Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class LexModelBuildingService {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(LexModelBuildingService.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-04-19",
    "endpointPrefix": "models.lex",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Lex Model Building Service",
    "serviceId": "Lex Model Building Service",
    "signatureVersion": "v4",
    "signingName": "lex",
    "uid": "lex-models-2017-04-19"
  };

  async createBotVersion(
    {abortSignal, ...params}: RequestConfig & CreateBotVersionRequest,
  ): Promise<CreateBotVersionResponse> {
    const body: jsonP.JSONObject = params ? {
      checksum: params["checksum"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBotVersion",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions`,
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "intents": [toIntent],
          "clarificationPrompt": toPrompt,
          "abortStatement": toStatement,
          "status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
          "failureReason": "s",
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "idleSessionTTLInSeconds": "n",
          "voiceId": "s",
          "checksum": "s",
          "version": "s",
          "locale": (x: jsonP.JSONValue) => cmnP.readEnum<Locale>(x),
          "childDirected": "b",
          "enableModelImprovements": "b",
          "detectSentiment": "b",
        },
      }, await resp.json()),
  };
  }

  async createIntentVersion(
    {abortSignal, ...params}: RequestConfig & CreateIntentVersionRequest,
  ): Promise<CreateIntentVersionResponse> {
    const body: jsonP.JSONObject = params ? {
      checksum: params["checksum"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateIntentVersion",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions`,
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "slots": [toSlot],
          "sampleUtterances": ["s"],
          "confirmationPrompt": toPrompt,
          "rejectionStatement": toStatement,
          "followUpPrompt": toFollowUpPrompt,
          "conclusionStatement": toStatement,
          "dialogCodeHook": toCodeHook,
          "fulfillmentActivity": toFulfillmentActivity,
          "parentIntentSignature": "s",
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "version": "s",
          "checksum": "s",
          "kendraConfiguration": toKendraConfiguration,
        },
      }, await resp.json()),
  };
  }

  async createSlotTypeVersion(
    {abortSignal, ...params}: RequestConfig & CreateSlotTypeVersionRequest,
  ): Promise<CreateSlotTypeVersionResponse> {
    const body: jsonP.JSONObject = params ? {
      checksum: params["checksum"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSlotTypeVersion",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/versions`,
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "enumerationValues": [toEnumerationValue],
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "version": "s",
          "checksum": "s",
          "valueSelectionStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<SlotValueSelectionStrategy>(x),
          "parentSlotTypeSignature": "s",
          "slotTypeConfigurations": [toSlotTypeConfiguration],
        },
      }, await resp.json()),
  };
  }

  async deleteBot(
    {abortSignal, ...params}: RequestConfig & DeleteBotRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBot",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteBotAlias(
    {abortSignal, ...params}: RequestConfig & DeleteBotAliasRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBotAlias",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteBotChannelAssociation(
    {abortSignal, ...params}: RequestConfig & DeleteBotChannelAssociationRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBotChannelAssociation",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["botAlias"]}/channels/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteBotVersion(
    {abortSignal, ...params}: RequestConfig & DeleteBotVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBotVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions/${params["version"]}`,
      responseCode: 204,
    });
  }

  async deleteIntent(
    {abortSignal, ...params}: RequestConfig & DeleteIntentRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntent",
      method: "DELETE",
      requestUri: cmnP.encodePath`/intents/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteIntentVersion(
    {abortSignal, ...params}: RequestConfig & DeleteIntentVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntentVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions/${params["version"]}`,
      responseCode: 204,
    });
  }

  async deleteSlotType(
    {abortSignal, ...params}: RequestConfig & DeleteSlotTypeRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSlotType",
      method: "DELETE",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteSlotTypeVersion(
    {abortSignal, ...params}: RequestConfig & DeleteSlotTypeVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSlotTypeVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/version/${params["version"]}`,
      responseCode: 204,
    });
  }

  async deleteUtterances(
    {abortSignal, ...params}: RequestConfig & DeleteUtterancesRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteUtterances",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/utterances/${params["userId"]}`,
      responseCode: 204,
    });
  }

  async getBot(
    {abortSignal, ...params}: RequestConfig & GetBotRequest,
  ): Promise<GetBotResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBot",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions/${params["versionOrAlias"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "intents": [toIntent],
          "enableModelImprovements": "b",
          "nluIntentConfidenceThreshold": "n",
          "clarificationPrompt": toPrompt,
          "abortStatement": toStatement,
          "status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
          "failureReason": "s",
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "idleSessionTTLInSeconds": "n",
          "voiceId": "s",
          "checksum": "s",
          "version": "s",
          "locale": (x: jsonP.JSONValue) => cmnP.readEnum<Locale>(x),
          "childDirected": "b",
          "detectSentiment": "b",
        },
      }, await resp.json()),
  };
  }

  async getBotAlias(
    {abortSignal, ...params}: RequestConfig & GetBotAliasRequest,
  ): Promise<GetBotAliasResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBotAlias",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["name"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "botVersion": "s",
          "botName": "s",
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "checksum": "s",
          "conversationLogs": toConversationLogsResponse,
        },
      }, await resp.json()),
  };
  }

  async getBotAliases(
    {abortSignal, ...params}: RequestConfig & GetBotAliasesRequest,
  ): Promise<GetBotAliasesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBotAliases",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "BotAliases": [toBotAliasMetadata],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getBotChannelAssociation(
    {abortSignal, ...params}: RequestConfig & GetBotChannelAssociationRequest,
  ): Promise<GetBotChannelAssociationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBotChannelAssociation",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["botAlias"]}/channels/${params["name"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "botAlias": "s",
          "botName": "s",
          "createdDate": "d",
          "type": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelType>(x),
          "botConfiguration": x => jsonP.readMap(String, String, x),
          "status": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelStatus>(x),
          "failureReason": "s",
        },
      }, await resp.json()),
  };
  }

  async getBotChannelAssociations(
    {abortSignal, ...params}: RequestConfig & GetBotChannelAssociationsRequest,
  ): Promise<GetBotChannelAssociationsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBotChannelAssociations",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["botAlias"]}/channels/`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "botChannelAssociations": [toBotChannelAssociation],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getBotVersions(
    {abortSignal, ...params}: RequestConfig & GetBotVersionsRequest,
  ): Promise<GetBotVersionsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBotVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions/`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "bots": [toBotMetadata],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getBots(
    {abortSignal, ...params}: RequestConfig & GetBotsRequest = {},
  ): Promise<GetBotsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBots",
      method: "GET",
      requestUri: "/bots/",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "bots": [toBotMetadata],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getBuiltinIntent(
    {abortSignal, ...params}: RequestConfig & GetBuiltinIntentRequest,
  ): Promise<GetBuiltinIntentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBuiltinIntent",
      method: "GET",
      requestUri: cmnP.encodePath`/builtins/intents/${params["signature"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "signature": "s",
          "supportedLocales": [(x: jsonP.JSONValue) => cmnP.readEnum<Locale>(x)],
          "slots": [toBuiltinIntentSlot],
        },
      }, await resp.json()),
  };
  }

  async getBuiltinIntents(
    {abortSignal, ...params}: RequestConfig & GetBuiltinIntentsRequest = {},
  ): Promise<GetBuiltinIntentsResponse> {
    const query = new URLSearchParams;
    if (params["locale"] != null) query.set("locale", params["locale"]?.toString() ?? "");
    if (params["signatureContains"] != null) query.set("signatureContains", params["signatureContains"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBuiltinIntents",
      method: "GET",
      requestUri: "/builtins/intents/",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "intents": [toBuiltinIntentMetadata],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getBuiltinSlotTypes(
    {abortSignal, ...params}: RequestConfig & GetBuiltinSlotTypesRequest = {},
  ): Promise<GetBuiltinSlotTypesResponse> {
    const query = new URLSearchParams;
    if (params["locale"] != null) query.set("locale", params["locale"]?.toString() ?? "");
    if (params["signatureContains"] != null) query.set("signatureContains", params["signatureContains"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBuiltinSlotTypes",
      method: "GET",
      requestUri: "/builtins/slottypes/",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "slotTypes": [toBuiltinSlotTypeMetadata],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getExport(
    {abortSignal, ...params}: RequestConfig & GetExportRequest,
  ): Promise<GetExportResponse> {
    const query = new URLSearchParams;
    query.set("name", params["name"]?.toString() ?? "");
    query.set("version", params["version"]?.toString() ?? "");
    query.set("resourceType", params["resourceType"]?.toString() ?? "");
    query.set("exportType", params["exportType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetExport",
      method: "GET",
      requestUri: "/exports/",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "version": "s",
          "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
          "exportType": (x: jsonP.JSONValue) => cmnP.readEnum<ExportType>(x),
          "exportStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ExportStatus>(x),
          "failureReason": "s",
          "url": "s",
        },
      }, await resp.json()),
  };
  }

  async getImport(
    {abortSignal, ...params}: RequestConfig & GetImportRequest,
  ): Promise<GetImportResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetImport",
      method: "GET",
      requestUri: cmnP.encodePath`/imports/${params["importId"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
          "mergeStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<MergeStrategy>(x),
          "importId": "s",
          "importStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ImportStatus>(x),
          "failureReason": ["s"],
          "createdDate": "d",
        },
      }, await resp.json()),
  };
  }

  async getIntent(
    {abortSignal, ...params}: RequestConfig & GetIntentRequest,
  ): Promise<GetIntentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetIntent",
      method: "GET",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions/${params["version"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "slots": [toSlot],
          "sampleUtterances": ["s"],
          "confirmationPrompt": toPrompt,
          "rejectionStatement": toStatement,
          "followUpPrompt": toFollowUpPrompt,
          "conclusionStatement": toStatement,
          "dialogCodeHook": toCodeHook,
          "fulfillmentActivity": toFulfillmentActivity,
          "parentIntentSignature": "s",
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "version": "s",
          "checksum": "s",
          "kendraConfiguration": toKendraConfiguration,
        },
      }, await resp.json()),
  };
  }

  async getIntentVersions(
    {abortSignal, ...params}: RequestConfig & GetIntentVersionsRequest,
  ): Promise<GetIntentVersionsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetIntentVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions/`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "intents": [toIntentMetadata],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getIntents(
    {abortSignal, ...params}: RequestConfig & GetIntentsRequest = {},
  ): Promise<GetIntentsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetIntents",
      method: "GET",
      requestUri: "/intents/",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "intents": [toIntentMetadata],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getSlotType(
    {abortSignal, ...params}: RequestConfig & GetSlotTypeRequest,
  ): Promise<GetSlotTypeResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSlotType",
      method: "GET",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/versions/${params["version"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "enumerationValues": [toEnumerationValue],
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "version": "s",
          "checksum": "s",
          "valueSelectionStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<SlotValueSelectionStrategy>(x),
          "parentSlotTypeSignature": "s",
          "slotTypeConfigurations": [toSlotTypeConfiguration],
        },
      }, await resp.json()),
  };
  }

  async getSlotTypeVersions(
    {abortSignal, ...params}: RequestConfig & GetSlotTypeVersionsRequest,
  ): Promise<GetSlotTypeVersionsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSlotTypeVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/versions/`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "slotTypes": [toSlotTypeMetadata],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getSlotTypes(
    {abortSignal, ...params}: RequestConfig & GetSlotTypesRequest = {},
  ): Promise<GetSlotTypesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSlotTypes",
      method: "GET",
      requestUri: "/slottypes/",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "slotTypes": [toSlotTypeMetadata],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getUtterancesView(
    {abortSignal, ...params}: RequestConfig & GetUtterancesViewRequest,
  ): Promise<GetUtterancesViewResponse> {
    const query = new URLSearchParams;
    for (const item of params["botVersions"]) {
      query.append("bot_versions", item?.toString() ?? "");
    }
    query.set("status_type", params["statusType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUtterancesView",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/utterances?view=aggregation`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "botName": "s",
          "utterances": [toUtteranceList],
        },
      }, await resp.json()),
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "tags": [toTag],
        },
      }, await resp.json()),
  };
  }

  async putBot(
    {abortSignal, ...params}: RequestConfig & PutBotRequest,
  ): Promise<PutBotResponse> {
    const body: jsonP.JSONObject = params ? {
      description: params["description"],
      intents: params["intents"]?.map(x => fromIntent(x)),
      enableModelImprovements: params["enableModelImprovements"],
      nluIntentConfidenceThreshold: params["nluIntentConfidenceThreshold"],
      clarificationPrompt: fromPrompt(params["clarificationPrompt"]),
      abortStatement: fromStatement(params["abortStatement"]),
      idleSessionTTLInSeconds: params["idleSessionTTLInSeconds"],
      voiceId: params["voiceId"],
      checksum: params["checksum"],
      processBehavior: params["processBehavior"],
      locale: params["locale"],
      childDirected: params["childDirected"],
      detectSentiment: params["detectSentiment"],
      createVersion: params["createVersion"],
      tags: params["tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutBot",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions/$LATEST`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "intents": [toIntent],
          "enableModelImprovements": "b",
          "nluIntentConfidenceThreshold": "n",
          "clarificationPrompt": toPrompt,
          "abortStatement": toStatement,
          "status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
          "failureReason": "s",
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "idleSessionTTLInSeconds": "n",
          "voiceId": "s",
          "checksum": "s",
          "version": "s",
          "locale": (x: jsonP.JSONValue) => cmnP.readEnum<Locale>(x),
          "childDirected": "b",
          "createVersion": "b",
          "detectSentiment": "b",
          "tags": [toTag],
        },
      }, await resp.json()),
  };
  }

  async putBotAlias(
    {abortSignal, ...params}: RequestConfig & PutBotAliasRequest,
  ): Promise<PutBotAliasResponse> {
    const body: jsonP.JSONObject = params ? {
      description: params["description"],
      botVersion: params["botVersion"],
      checksum: params["checksum"],
      conversationLogs: fromConversationLogsRequest(params["conversationLogs"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutBotAlias",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["name"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "botVersion": "s",
          "botName": "s",
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "checksum": "s",
          "conversationLogs": toConversationLogsResponse,
          "tags": [toTag],
        },
      }, await resp.json()),
  };
  }

  async putIntent(
    {abortSignal, ...params}: RequestConfig & PutIntentRequest,
  ): Promise<PutIntentResponse> {
    const body: jsonP.JSONObject = params ? {
      description: params["description"],
      slots: params["slots"]?.map(x => fromSlot(x)),
      sampleUtterances: params["sampleUtterances"],
      confirmationPrompt: fromPrompt(params["confirmationPrompt"]),
      rejectionStatement: fromStatement(params["rejectionStatement"]),
      followUpPrompt: fromFollowUpPrompt(params["followUpPrompt"]),
      conclusionStatement: fromStatement(params["conclusionStatement"]),
      dialogCodeHook: fromCodeHook(params["dialogCodeHook"]),
      fulfillmentActivity: fromFulfillmentActivity(params["fulfillmentActivity"]),
      parentIntentSignature: params["parentIntentSignature"],
      checksum: params["checksum"],
      createVersion: params["createVersion"],
      kendraConfiguration: fromKendraConfiguration(params["kendraConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutIntent",
      method: "PUT",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions/$LATEST`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "slots": [toSlot],
          "sampleUtterances": ["s"],
          "confirmationPrompt": toPrompt,
          "rejectionStatement": toStatement,
          "followUpPrompt": toFollowUpPrompt,
          "conclusionStatement": toStatement,
          "dialogCodeHook": toCodeHook,
          "fulfillmentActivity": toFulfillmentActivity,
          "parentIntentSignature": "s",
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "version": "s",
          "checksum": "s",
          "createVersion": "b",
          "kendraConfiguration": toKendraConfiguration,
        },
      }, await resp.json()),
  };
  }

  async putSlotType(
    {abortSignal, ...params}: RequestConfig & PutSlotTypeRequest,
  ): Promise<PutSlotTypeResponse> {
    const body: jsonP.JSONObject = params ? {
      description: params["description"],
      enumerationValues: params["enumerationValues"]?.map(x => fromEnumerationValue(x)),
      checksum: params["checksum"],
      valueSelectionStrategy: params["valueSelectionStrategy"],
      createVersion: params["createVersion"],
      parentSlotTypeSignature: params["parentSlotTypeSignature"],
      slotTypeConfigurations: params["slotTypeConfigurations"]?.map(x => fromSlotTypeConfiguration(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutSlotType",
      method: "PUT",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/versions/$LATEST`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "description": "s",
          "enumerationValues": [toEnumerationValue],
          "lastUpdatedDate": "d",
          "createdDate": "d",
          "version": "s",
          "checksum": "s",
          "valueSelectionStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<SlotValueSelectionStrategy>(x),
          "createVersion": "b",
          "parentSlotTypeSignature": "s",
          "slotTypeConfigurations": [toSlotTypeConfiguration],
        },
      }, await resp.json()),
  };
  }

  async startImport(
    {abortSignal, ...params}: RequestConfig & StartImportRequest,
  ): Promise<StartImportResponse> {
    const body: jsonP.JSONObject = params ? {
      payload: jsonP.serializeBlob(params["payload"]),
      resourceType: params["resourceType"],
      mergeStrategy: params["mergeStrategy"],
      tags: params["tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartImport",
      requestUri: "/imports/",
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "name": "s",
          "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
          "mergeStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<MergeStrategy>(x),
          "importId": "s",
          "importStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ImportStatus>(x),
          "tags": [toTag],
          "createdDate": "d",
        },
      }, await resp.json()),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      tags: params["tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface CreateBotVersionRequest {
  name: string;
  checksum?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateIntentVersionRequest {
  name: string;
  checksum?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateSlotTypeVersionRequest {
  name: string;
  checksum?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBotRequest {
  name: string;
}

// refs: 1 - tags: named, input
export interface DeleteBotAliasRequest {
  name: string;
  botName: string;
}

// refs: 1 - tags: named, input
export interface DeleteBotChannelAssociationRequest {
  name: string;
  botName: string;
  botAlias: string;
}

// refs: 1 - tags: named, input
export interface DeleteBotVersionRequest {
  name: string;
  version: string;
}

// refs: 1 - tags: named, input
export interface DeleteIntentRequest {
  name: string;
}

// refs: 1 - tags: named, input
export interface DeleteIntentVersionRequest {
  name: string;
  version: string;
}

// refs: 1 - tags: named, input
export interface DeleteSlotTypeRequest {
  name: string;
}

// refs: 1 - tags: named, input
export interface DeleteSlotTypeVersionRequest {
  name: string;
  version: string;
}

// refs: 1 - tags: named, input
export interface DeleteUtterancesRequest {
  botName: string;
  userId: string;
}

// refs: 1 - tags: named, input
export interface GetBotRequest {
  name: string;
  versionOrAlias: string;
}

// refs: 1 - tags: named, input
export interface GetBotAliasRequest {
  name: string;
  botName: string;
}

// refs: 1 - tags: named, input
export interface GetBotAliasesRequest {
  botName: string;
  nextToken?: string | null;
  maxResults?: number | null;
  nameContains?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBotChannelAssociationRequest {
  name: string;
  botName: string;
  botAlias: string;
}

// refs: 1 - tags: named, input
export interface GetBotChannelAssociationsRequest {
  botName: string;
  botAlias: string;
  nextToken?: string | null;
  maxResults?: number | null;
  nameContains?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBotVersionsRequest {
  name: string;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetBotsRequest {
  nextToken?: string | null;
  maxResults?: number | null;
  nameContains?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBuiltinIntentRequest {
  signature: string;
}

// refs: 1 - tags: named, input
export interface GetBuiltinIntentsRequest {
  locale?: Locale | null;
  signatureContains?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetBuiltinSlotTypesRequest {
  locale?: Locale | null;
  signatureContains?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetExportRequest {
  name: string;
  version: string;
  resourceType: ResourceType;
  exportType: ExportType;
}

// refs: 1 - tags: named, input
export interface GetImportRequest {
  importId: string;
}

// refs: 1 - tags: named, input
export interface GetIntentRequest {
  name: string;
  version: string;
}

// refs: 1 - tags: named, input
export interface GetIntentVersionsRequest {
  name: string;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetIntentsRequest {
  nextToken?: string | null;
  maxResults?: number | null;
  nameContains?: string | null;
}

// refs: 1 - tags: named, input
export interface GetSlotTypeRequest {
  name: string;
  version: string;
}

// refs: 1 - tags: named, input
export interface GetSlotTypeVersionsRequest {
  name: string;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetSlotTypesRequest {
  nextToken?: string | null;
  maxResults?: number | null;
  nameContains?: string | null;
}

// refs: 1 - tags: named, input
export interface GetUtterancesViewRequest {
  botName: string;
  botVersions: string[];
  statusType: StatusType;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface PutBotRequest {
  name: string;
  description?: string | null;
  intents?: Intent[] | null;
  enableModelImprovements?: boolean | null;
  nluIntentConfidenceThreshold?: number | null;
  clarificationPrompt?: Prompt | null;
  abortStatement?: Statement | null;
  idleSessionTTLInSeconds?: number | null;
  voiceId?: string | null;
  checksum?: string | null;
  processBehavior?: ProcessBehavior | null;
  locale: Locale;
  childDirected: boolean;
  detectSentiment?: boolean | null;
  createVersion?: boolean | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface PutBotAliasRequest {
  name: string;
  description?: string | null;
  botVersion: string;
  botName: string;
  checksum?: string | null;
  conversationLogs?: ConversationLogsRequest | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface PutIntentRequest {
  name: string;
  description?: string | null;
  slots?: Slot[] | null;
  sampleUtterances?: string[] | null;
  confirmationPrompt?: Prompt | null;
  rejectionStatement?: Statement | null;
  followUpPrompt?: FollowUpPrompt | null;
  conclusionStatement?: Statement | null;
  dialogCodeHook?: CodeHook | null;
  fulfillmentActivity?: FulfillmentActivity | null;
  parentIntentSignature?: string | null;
  checksum?: string | null;
  createVersion?: boolean | null;
  kendraConfiguration?: KendraConfiguration | null;
}

// refs: 1 - tags: named, input
export interface PutSlotTypeRequest {
  name: string;
  description?: string | null;
  enumerationValues?: EnumerationValue[] | null;
  checksum?: string | null;
  valueSelectionStrategy?: SlotValueSelectionStrategy | null;
  createVersion?: boolean | null;
  parentSlotTypeSignature?: string | null;
  slotTypeConfigurations?: SlotTypeConfiguration[] | null;
}

// refs: 1 - tags: named, input
export interface StartImportRequest {
  payload: Uint8Array | string;
  resourceType: ResourceType;
  mergeStrategy: MergeStrategy;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, output
export interface CreateBotVersionResponse {
  name?: string | null;
  description?: string | null;
  intents?: Intent[] | null;
  clarificationPrompt?: Prompt | null;
  abortStatement?: Statement | null;
  status?: Status | null;
  failureReason?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  idleSessionTTLInSeconds?: number | null;
  voiceId?: string | null;
  checksum?: string | null;
  version?: string | null;
  locale?: Locale | null;
  childDirected?: boolean | null;
  enableModelImprovements?: boolean | null;
  detectSentiment?: boolean | null;
}

// refs: 1 - tags: named, output
export interface CreateIntentVersionResponse {
  name?: string | null;
  description?: string | null;
  slots?: Slot[] | null;
  sampleUtterances?: string[] | null;
  confirmationPrompt?: Prompt | null;
  rejectionStatement?: Statement | null;
  followUpPrompt?: FollowUpPrompt | null;
  conclusionStatement?: Statement | null;
  dialogCodeHook?: CodeHook | null;
  fulfillmentActivity?: FulfillmentActivity | null;
  parentIntentSignature?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  version?: string | null;
  checksum?: string | null;
  kendraConfiguration?: KendraConfiguration | null;
}

// refs: 1 - tags: named, output
export interface CreateSlotTypeVersionResponse {
  name?: string | null;
  description?: string | null;
  enumerationValues?: EnumerationValue[] | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  version?: string | null;
  checksum?: string | null;
  valueSelectionStrategy?: SlotValueSelectionStrategy | null;
  parentSlotTypeSignature?: string | null;
  slotTypeConfigurations?: SlotTypeConfiguration[] | null;
}

// refs: 1 - tags: named, output
export interface GetBotResponse {
  name?: string | null;
  description?: string | null;
  intents?: Intent[] | null;
  enableModelImprovements?: boolean | null;
  nluIntentConfidenceThreshold?: number | null;
  clarificationPrompt?: Prompt | null;
  abortStatement?: Statement | null;
  status?: Status | null;
  failureReason?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  idleSessionTTLInSeconds?: number | null;
  voiceId?: string | null;
  checksum?: string | null;
  version?: string | null;
  locale?: Locale | null;
  childDirected?: boolean | null;
  detectSentiment?: boolean | null;
}

// refs: 1 - tags: named, output
export interface GetBotAliasResponse {
  name?: string | null;
  description?: string | null;
  botVersion?: string | null;
  botName?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  checksum?: string | null;
  conversationLogs?: ConversationLogsResponse | null;
}

// refs: 1 - tags: named, output
export interface GetBotAliasesResponse {
  BotAliases?: BotAliasMetadata[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetBotChannelAssociationResponse {
  name?: string | null;
  description?: string | null;
  botAlias?: string | null;
  botName?: string | null;
  createdDate?: Date | number | null;
  type?: ChannelType | null;
  botConfiguration?: { [key: string]: string | null | undefined } | null;
  status?: ChannelStatus | null;
  failureReason?: string | null;
}

// refs: 1 - tags: named, output
export interface GetBotChannelAssociationsResponse {
  botChannelAssociations?: BotChannelAssociation[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetBotVersionsResponse {
  bots?: BotMetadata[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetBotsResponse {
  bots?: BotMetadata[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetBuiltinIntentResponse {
  signature?: string | null;
  supportedLocales?: Locale[] | null;
  slots?: BuiltinIntentSlot[] | null;
}

// refs: 1 - tags: named, output
export interface GetBuiltinIntentsResponse {
  intents?: BuiltinIntentMetadata[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetBuiltinSlotTypesResponse {
  slotTypes?: BuiltinSlotTypeMetadata[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetExportResponse {
  name?: string | null;
  version?: string | null;
  resourceType?: ResourceType | null;
  exportType?: ExportType | null;
  exportStatus?: ExportStatus | null;
  failureReason?: string | null;
  url?: string | null;
}

// refs: 1 - tags: named, output
export interface GetImportResponse {
  name?: string | null;
  resourceType?: ResourceType | null;
  mergeStrategy?: MergeStrategy | null;
  importId?: string | null;
  importStatus?: ImportStatus | null;
  failureReason?: string[] | null;
  createdDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetIntentResponse {
  name?: string | null;
  description?: string | null;
  slots?: Slot[] | null;
  sampleUtterances?: string[] | null;
  confirmationPrompt?: Prompt | null;
  rejectionStatement?: Statement | null;
  followUpPrompt?: FollowUpPrompt | null;
  conclusionStatement?: Statement | null;
  dialogCodeHook?: CodeHook | null;
  fulfillmentActivity?: FulfillmentActivity | null;
  parentIntentSignature?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  version?: string | null;
  checksum?: string | null;
  kendraConfiguration?: KendraConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetIntentVersionsResponse {
  intents?: IntentMetadata[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetIntentsResponse {
  intents?: IntentMetadata[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSlotTypeResponse {
  name?: string | null;
  description?: string | null;
  enumerationValues?: EnumerationValue[] | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  version?: string | null;
  checksum?: string | null;
  valueSelectionStrategy?: SlotValueSelectionStrategy | null;
  parentSlotTypeSignature?: string | null;
  slotTypeConfigurations?: SlotTypeConfiguration[] | null;
}

// refs: 1 - tags: named, output
export interface GetSlotTypeVersionsResponse {
  slotTypes?: SlotTypeMetadata[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSlotTypesResponse {
  slotTypes?: SlotTypeMetadata[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetUtterancesViewResponse {
  botName?: string | null;
  utterances?: UtteranceList[] | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface PutBotResponse {
  name?: string | null;
  description?: string | null;
  intents?: Intent[] | null;
  enableModelImprovements?: boolean | null;
  nluIntentConfidenceThreshold?: number | null;
  clarificationPrompt?: Prompt | null;
  abortStatement?: Statement | null;
  status?: Status | null;
  failureReason?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  idleSessionTTLInSeconds?: number | null;
  voiceId?: string | null;
  checksum?: string | null;
  version?: string | null;
  locale?: Locale | null;
  childDirected?: boolean | null;
  createVersion?: boolean | null;
  detectSentiment?: boolean | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface PutBotAliasResponse {
  name?: string | null;
  description?: string | null;
  botVersion?: string | null;
  botName?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  checksum?: string | null;
  conversationLogs?: ConversationLogsResponse | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface PutIntentResponse {
  name?: string | null;
  description?: string | null;
  slots?: Slot[] | null;
  sampleUtterances?: string[] | null;
  confirmationPrompt?: Prompt | null;
  rejectionStatement?: Statement | null;
  followUpPrompt?: FollowUpPrompt | null;
  conclusionStatement?: Statement | null;
  dialogCodeHook?: CodeHook | null;
  fulfillmentActivity?: FulfillmentActivity | null;
  parentIntentSignature?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  version?: string | null;
  checksum?: string | null;
  createVersion?: boolean | null;
  kendraConfiguration?: KendraConfiguration | null;
}

// refs: 1 - tags: named, output
export interface PutSlotTypeResponse {
  name?: string | null;
  description?: string | null;
  enumerationValues?: EnumerationValue[] | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  version?: string | null;
  checksum?: string | null;
  valueSelectionStrategy?: SlotValueSelectionStrategy | null;
  createVersion?: boolean | null;
  parentSlotTypeSignature?: string | null;
  slotTypeConfigurations?: SlotTypeConfiguration[] | null;
}

// refs: 1 - tags: named, output
export interface StartImportResponse {
  name?: string | null;
  resourceType?: ResourceType | null;
  mergeStrategy?: MergeStrategy | null;
  importId?: string | null;
  importStatus?: ImportStatus | null;
  tags?: Tag[] | null;
  createdDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 9 - tags: input, named, enum, output
export type Locale =
| "de-DE"
| "en-AU"
| "en-GB"
| "en-US"
| "es-US"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type ResourceType =
| "BOT"
| "INTENT"
| "SLOT_TYPE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ExportType =
| "ALEXA_SKILLS_KIT"
| "LEX"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type StatusType =
| "Detected"
| "Missed"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Intent {
  intentName: string;
  intentVersion: string;
}
function fromIntent(input?: Intent | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    intentName: input["intentName"],
    intentVersion: input["intentVersion"],
  }
}
function toIntent(root: jsonP.JSONValue): Intent {
  return jsonP.readObj({
    required: {
      "intentName": "s",
      "intentVersion": "s",
    },
    optional: {},
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface Prompt {
  messages: Message[];
  maxAttempts: number;
  responseCard?: string | null;
}
function fromPrompt(input?: Prompt | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messages: input["messages"]?.map(x => fromMessage(x)),
    maxAttempts: input["maxAttempts"],
    responseCard: input["responseCard"],
  }
}
function toPrompt(root: jsonP.JSONValue): Prompt {
  return jsonP.readObj({
    required: {
      "messages": [toMessage],
      "maxAttempts": "n",
    },
    optional: {
      "responseCard": "s",
    },
  }, root);
}

// refs: 32 - tags: input, named, interface, output
export interface Message {
  contentType: ContentType;
  content: string;
  groupNumber?: number | null;
}
function fromMessage(input?: Message | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    contentType: input["contentType"],
    content: input["content"],
    groupNumber: input["groupNumber"],
  }
}
function toMessage(root: jsonP.JSONValue): Message {
  return jsonP.readObj({
    required: {
      "contentType": (x: jsonP.JSONValue) => cmnP.readEnum<ContentType>(x),
      "content": "s",
    },
    optional: {
      "groupNumber": "n",
    },
  }, root);
}

// refs: 32 - tags: input, named, enum, output
export type ContentType =
| "PlainText"
| "SSML"
| "CustomPayload"
| cmnP.UnexpectedEnumValue;

// refs: 16 - tags: input, named, interface, output
export interface Statement {
  messages: Message[];
  responseCard?: string | null;
}
function fromStatement(input?: Statement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messages: input["messages"]?.map(x => fromMessage(x)),
    responseCard: input["responseCard"],
  }
}
function toStatement(root: jsonP.JSONValue): Statement {
  return jsonP.readObj({
    required: {
      "messages": [toMessage],
    },
    optional: {
      "responseCard": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, enum
export type ProcessBehavior =
| "SAVE"
| "BUILD"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface Tag {
  key: string;
  value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface ConversationLogsRequest {
  logSettings: LogSettingsRequest[];
  iamRoleArn: string;
}
function fromConversationLogsRequest(input?: ConversationLogsRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logSettings: input["logSettings"]?.map(x => fromLogSettingsRequest(x)),
    iamRoleArn: input["iamRoleArn"],
  }
}

// refs: 1 - tags: input, named, interface
export interface LogSettingsRequest {
  logType: LogType;
  destination: Destination;
  kmsKeyArn?: string | null;
  resourceArn: string;
}
function fromLogSettingsRequest(input?: LogSettingsRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logType: input["logType"],
    destination: input["destination"],
    kmsKeyArn: input["kmsKeyArn"],
    resourceArn: input["resourceArn"],
  }
}

// refs: 4 - tags: input, named, enum, output
export type LogType =
| "AUDIO"
| "TEXT"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type Destination =
| "CLOUDWATCH_LOGS"
| "S3"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Slot {
  name: string;
  description?: string | null;
  slotConstraint: SlotConstraint;
  slotType?: string | null;
  slotTypeVersion?: string | null;
  valueElicitationPrompt?: Prompt | null;
  priority?: number | null;
  sampleUtterances?: string[] | null;
  responseCard?: string | null;
  obfuscationSetting?: ObfuscationSetting | null;
}
function fromSlot(input?: Slot | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    description: input["description"],
    slotConstraint: input["slotConstraint"],
    slotType: input["slotType"],
    slotTypeVersion: input["slotTypeVersion"],
    valueElicitationPrompt: fromPrompt(input["valueElicitationPrompt"]),
    priority: input["priority"],
    sampleUtterances: input["sampleUtterances"],
    responseCard: input["responseCard"],
    obfuscationSetting: input["obfuscationSetting"],
  }
}
function toSlot(root: jsonP.JSONValue): Slot {
  return jsonP.readObj({
    required: {
      "name": "s",
      "slotConstraint": (x: jsonP.JSONValue) => cmnP.readEnum<SlotConstraint>(x),
    },
    optional: {
      "description": "s",
      "slotType": "s",
      "slotTypeVersion": "s",
      "valueElicitationPrompt": toPrompt,
      "priority": "n",
      "sampleUtterances": ["s"],
      "responseCard": "s",
      "obfuscationSetting": (x: jsonP.JSONValue) => cmnP.readEnum<ObfuscationSetting>(x),
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type SlotConstraint =
| "Required"
| "Optional"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type ObfuscationSetting =
| "NONE"
| "DEFAULT_OBFUSCATION"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface FollowUpPrompt {
  prompt: Prompt;
  rejectionStatement: Statement;
}
function fromFollowUpPrompt(input?: FollowUpPrompt | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    prompt: fromPrompt(input["prompt"]),
    rejectionStatement: fromStatement(input["rejectionStatement"]),
  }
}
function toFollowUpPrompt(root: jsonP.JSONValue): FollowUpPrompt {
  return jsonP.readObj({
    required: {
      "prompt": toPrompt,
      "rejectionStatement": toStatement,
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface CodeHook {
  uri: string;
  messageVersion: string;
}
function fromCodeHook(input?: CodeHook | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    uri: input["uri"],
    messageVersion: input["messageVersion"],
  }
}
function toCodeHook(root: jsonP.JSONValue): CodeHook {
  return jsonP.readObj({
    required: {
      "uri": "s",
      "messageVersion": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface FulfillmentActivity {
  type: FulfillmentActivityType;
  codeHook?: CodeHook | null;
}
function fromFulfillmentActivity(input?: FulfillmentActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    codeHook: fromCodeHook(input["codeHook"]),
  }
}
function toFulfillmentActivity(root: jsonP.JSONValue): FulfillmentActivity {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<FulfillmentActivityType>(x),
    },
    optional: {
      "codeHook": toCodeHook,
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type FulfillmentActivityType =
| "ReturnIntent"
| "CodeHook"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface KendraConfiguration {
  kendraIndex: string;
  queryFilterString?: string | null;
  role: string;
}
function fromKendraConfiguration(input?: KendraConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    kendraIndex: input["kendraIndex"],
    queryFilterString: input["queryFilterString"],
    role: input["role"],
  }
}
function toKendraConfiguration(root: jsonP.JSONValue): KendraConfiguration {
  return jsonP.readObj({
    required: {
      "kendraIndex": "s",
      "role": "s",
    },
    optional: {
      "queryFilterString": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface EnumerationValue {
  value: string;
  synonyms?: string[] | null;
}
function fromEnumerationValue(input?: EnumerationValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    synonyms: input["synonyms"],
  }
}
function toEnumerationValue(root: jsonP.JSONValue): EnumerationValue {
  return jsonP.readObj({
    required: {
      "value": "s",
    },
    optional: {
      "synonyms": ["s"],
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type SlotValueSelectionStrategy =
| "ORIGINAL_VALUE"
| "TOP_RESOLUTION"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface SlotTypeConfiguration {
  regexConfiguration?: SlotTypeRegexConfiguration | null;
}
function fromSlotTypeConfiguration(input?: SlotTypeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    regexConfiguration: fromSlotTypeRegexConfiguration(input["regexConfiguration"]),
  }
}
function toSlotTypeConfiguration(root: jsonP.JSONValue): SlotTypeConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "regexConfiguration": toSlotTypeRegexConfiguration,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface SlotTypeRegexConfiguration {
  pattern: string;
}
function fromSlotTypeRegexConfiguration(input?: SlotTypeRegexConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pattern: input["pattern"],
  }
}
function toSlotTypeRegexConfiguration(root: jsonP.JSONValue): SlotTypeRegexConfiguration {
  return jsonP.readObj({
    required: {
      "pattern": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type MergeStrategy =
| "OVERWRITE_LATEST"
| "FAIL_ON_CONFLICT"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, enum
export type Status =
| "BUILDING"
| "READY"
| "READY_BASIC_TESTING"
| "FAILED"
| "NOT_BUILT"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface ConversationLogsResponse {
  logSettings?: LogSettingsResponse[] | null;
  iamRoleArn?: string | null;
}
function toConversationLogsResponse(root: jsonP.JSONValue): ConversationLogsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "logSettings": [toLogSettingsResponse],
      "iamRoleArn": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface LogSettingsResponse {
  logType?: LogType | null;
  destination?: Destination | null;
  kmsKeyArn?: string | null;
  resourceArn?: string | null;
  resourcePrefix?: string | null;
}
function toLogSettingsResponse(root: jsonP.JSONValue): LogSettingsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "logType": (x: jsonP.JSONValue) => cmnP.readEnum<LogType>(x),
      "destination": (x: jsonP.JSONValue) => cmnP.readEnum<Destination>(x),
      "kmsKeyArn": "s",
      "resourceArn": "s",
      "resourcePrefix": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BotAliasMetadata {
  name?: string | null;
  description?: string | null;
  botVersion?: string | null;
  botName?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  checksum?: string | null;
  conversationLogs?: ConversationLogsResponse | null;
}
function toBotAliasMetadata(root: jsonP.JSONValue): BotAliasMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "botVersion": "s",
      "botName": "s",
      "lastUpdatedDate": "d",
      "createdDate": "d",
      "checksum": "s",
      "conversationLogs": toConversationLogsResponse,
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ChannelType =
| "Facebook"
| "Slack"
| "Twilio-Sms"
| "Kik"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ChannelStatus =
| "IN_PROGRESS"
| "CREATED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface BotChannelAssociation {
  name?: string | null;
  description?: string | null;
  botAlias?: string | null;
  botName?: string | null;
  createdDate?: Date | number | null;
  type?: ChannelType | null;
  botConfiguration?: { [key: string]: string | null | undefined } | null;
  status?: ChannelStatus | null;
  failureReason?: string | null;
}
function toBotChannelAssociation(root: jsonP.JSONValue): BotChannelAssociation {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "botAlias": "s",
      "botName": "s",
      "createdDate": "d",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelType>(x),
      "botConfiguration": x => jsonP.readMap(String, String, x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelStatus>(x),
      "failureReason": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface BotMetadata {
  name?: string | null;
  description?: string | null;
  status?: Status | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  version?: string | null;
}
function toBotMetadata(root: jsonP.JSONValue): BotMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
      "lastUpdatedDate": "d",
      "createdDate": "d",
      "version": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BuiltinIntentSlot {
  name?: string | null;
}
function toBuiltinIntentSlot(root: jsonP.JSONValue): BuiltinIntentSlot {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BuiltinIntentMetadata {
  signature?: string | null;
  supportedLocales?: Locale[] | null;
}
function toBuiltinIntentMetadata(root: jsonP.JSONValue): BuiltinIntentMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "signature": "s",
      "supportedLocales": [(x: jsonP.JSONValue) => cmnP.readEnum<Locale>(x)],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BuiltinSlotTypeMetadata {
  signature?: string | null;
  supportedLocales?: Locale[] | null;
}
function toBuiltinSlotTypeMetadata(root: jsonP.JSONValue): BuiltinSlotTypeMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "signature": "s",
      "supportedLocales": [(x: jsonP.JSONValue) => cmnP.readEnum<Locale>(x)],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type ExportStatus =
| "IN_PROGRESS"
| "READY"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ImportStatus =
| "IN_PROGRESS"
| "COMPLETE"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface IntentMetadata {
  name?: string | null;
  description?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  version?: string | null;
}
function toIntentMetadata(root: jsonP.JSONValue): IntentMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "lastUpdatedDate": "d",
      "createdDate": "d",
      "version": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SlotTypeMetadata {
  name?: string | null;
  description?: string | null;
  lastUpdatedDate?: Date | number | null;
  createdDate?: Date | number | null;
  version?: string | null;
}
function toSlotTypeMetadata(root: jsonP.JSONValue): SlotTypeMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "lastUpdatedDate": "d",
      "createdDate": "d",
      "version": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UtteranceList {
  botVersion?: string | null;
  utterances?: UtteranceData[] | null;
}
function toUtteranceList(root: jsonP.JSONValue): UtteranceList {
  return jsonP.readObj({
    required: {},
    optional: {
      "botVersion": "s",
      "utterances": [toUtteranceData],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UtteranceData {
  utteranceString?: string | null;
  count?: number | null;
  distinctUsers?: number | null;
  firstUtteredDate?: Date | number | null;
  lastUtteredDate?: Date | number | null;
}
function toUtteranceData(root: jsonP.JSONValue): UtteranceData {
  return jsonP.readObj({
    required: {},
    optional: {
      "utteranceString": "s",
      "count": "n",
      "distinctUsers": "n",
      "firstUtteredDate": "d",
      "lastUtteredDate": "d",
    },
  }, root);
}
