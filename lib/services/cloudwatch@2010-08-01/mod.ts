// Autogenerated API client for: Amazon CloudWatch

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";
function parseBlob(input: string | null | undefined) {
  if (input == null) return input;
  return Base64.decode(input);
}

export default class CloudWatch {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudWatch.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2010-08-01",
    "endpointPrefix": "monitoring",
    "protocol": "query",
    "serviceAbbreviation": "CloudWatch",
    "serviceFullName": "Amazon CloudWatch",
    "serviceId": "CloudWatch",
    "signatureVersion": "v4",
    "uid": "monitoring-2010-08-01",
    "xmlNamespace": "http://monitoring.amazonaws.com/doc/2010-08-01/"
  };

  async deleteAlarms(
    {abortSignal, ...params}: RequestConfig & s.DeleteAlarmsInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AlarmNames"]) qsP.appendList(body, prefix+"AlarmNames", params["AlarmNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAlarms",
    });
  }

  async deleteAnomalyDetector(
    {abortSignal, ...params}: RequestConfig & s.DeleteAnomalyDetectorInput,
  ): Promise<s.DeleteAnomalyDetectorOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    body.append(prefix+"Stat", (params["Stat"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAnomalyDetector",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteAnomalyDetectorResult");
    return {};
  }

  async deleteDashboards(
    {abortSignal, ...params}: RequestConfig & s.DeleteDashboardsInput,
  ): Promise<s.DeleteDashboardsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DashboardNames"]) qsP.appendList(body, prefix+"DashboardNames", params["DashboardNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDashboards",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDashboardsResult");
    return {};
  }

  async deleteInsightRules(
    {abortSignal, ...params}: RequestConfig & s.DeleteInsightRulesInput,
  ): Promise<s.DeleteInsightRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["RuleNames"]) qsP.appendList(body, prefix+"RuleNames", params["RuleNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInsightRules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteInsightRulesResult");
    return {
      Failures: xml.getList("Failures", "member").map(PartialFailure_Parse),
    };
  }

  async describeAlarmHistory(
    {abortSignal, ...params}: RequestConfig & s.DescribeAlarmHistoryInput = {},
  ): Promise<s.DescribeAlarmHistoryOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AlarmName" in params) body.append(prefix+"AlarmName", (params["AlarmName"] ?? '').toString());
    if (params["AlarmTypes"]) qsP.appendList(body, prefix+"AlarmTypes", params["AlarmTypes"], {"entryPrefix":".member."})
    if ("HistoryItemType" in params) body.append(prefix+"HistoryItemType", (params["HistoryItemType"] ?? '').toString());
    if ("StartDate" in params) body.append(prefix+"StartDate", qsP.encodeDate_iso8601(params["StartDate"]));
    if ("EndDate" in params) body.append(prefix+"EndDate", qsP.encodeDate_iso8601(params["EndDate"]));
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("ScanBy" in params) body.append(prefix+"ScanBy", (params["ScanBy"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlarmHistory",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAlarmHistoryResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AlarmHistoryItems: xml.getList("AlarmHistoryItems", "member").map(AlarmHistoryItem_Parse),
    };
  }

  async describeAlarms(
    {abortSignal, ...params}: RequestConfig & s.DescribeAlarmsInput = {},
  ): Promise<s.DescribeAlarmsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AlarmNames"]) qsP.appendList(body, prefix+"AlarmNames", params["AlarmNames"], {"entryPrefix":".member."})
    if ("AlarmNamePrefix" in params) body.append(prefix+"AlarmNamePrefix", (params["AlarmNamePrefix"] ?? '').toString());
    if (params["AlarmTypes"]) qsP.appendList(body, prefix+"AlarmTypes", params["AlarmTypes"], {"entryPrefix":".member."})
    if ("ChildrenOfAlarmName" in params) body.append(prefix+"ChildrenOfAlarmName", (params["ChildrenOfAlarmName"] ?? '').toString());
    if ("ParentsOfAlarmName" in params) body.append(prefix+"ParentsOfAlarmName", (params["ParentsOfAlarmName"] ?? '').toString());
    if ("StateValue" in params) body.append(prefix+"StateValue", (params["StateValue"] ?? '').toString());
    if ("ActionPrefix" in params) body.append(prefix+"ActionPrefix", (params["ActionPrefix"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlarms",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAlarmsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      CompositeAlarms: xml.getList("CompositeAlarms", "member").map(CompositeAlarm_Parse),
      MetricAlarms: xml.getList("MetricAlarms", "member").map(MetricAlarm_Parse),
    };
  }

  async describeAlarmsForMetric(
    {abortSignal, ...params}: RequestConfig & s.DescribeAlarmsForMetricInput,
  ): Promise<s.DescribeAlarmsForMetricOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if ("Statistic" in params) body.append(prefix+"Statistic", (params["Statistic"] ?? '').toString());
    if ("ExtendedStatistic" in params) body.append(prefix+"ExtendedStatistic", (params["ExtendedStatistic"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    if ("Period" in params) body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if ("Unit" in params) body.append(prefix+"Unit", (params["Unit"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlarmsForMetric",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAlarmsForMetricResult");
    return {
      MetricAlarms: xml.getList("MetricAlarms", "member").map(MetricAlarm_Parse),
    };
  }

  async describeAnomalyDetectors(
    {abortSignal, ...params}: RequestConfig & s.DescribeAnomalyDetectorsInput = {},
  ): Promise<s.DescribeAnomalyDetectorsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("Namespace" in params) body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if ("MetricName" in params) body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAnomalyDetectors",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAnomalyDetectorsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AnomalyDetectors: xml.getList("AnomalyDetectors", "member").map(AnomalyDetector_Parse),
    };
  }

  async describeInsightRules(
    {abortSignal, ...params}: RequestConfig & s.DescribeInsightRulesInput = {},
  ): Promise<s.DescribeInsightRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInsightRules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeInsightRulesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      InsightRules: xml.getList("InsightRules", "member").map(InsightRule_Parse),
    };
  }

  async disableAlarmActions(
    {abortSignal, ...params}: RequestConfig & s.DisableAlarmActionsInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AlarmNames"]) qsP.appendList(body, prefix+"AlarmNames", params["AlarmNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableAlarmActions",
    });
  }

  async disableInsightRules(
    {abortSignal, ...params}: RequestConfig & s.DisableInsightRulesInput,
  ): Promise<s.DisableInsightRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["RuleNames"]) qsP.appendList(body, prefix+"RuleNames", params["RuleNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableInsightRules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DisableInsightRulesResult");
    return {
      Failures: xml.getList("Failures", "member").map(PartialFailure_Parse),
    };
  }

  async enableAlarmActions(
    {abortSignal, ...params}: RequestConfig & s.EnableAlarmActionsInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AlarmNames"]) qsP.appendList(body, prefix+"AlarmNames", params["AlarmNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableAlarmActions",
    });
  }

  async enableInsightRules(
    {abortSignal, ...params}: RequestConfig & s.EnableInsightRulesInput,
  ): Promise<s.EnableInsightRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["RuleNames"]) qsP.appendList(body, prefix+"RuleNames", params["RuleNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableInsightRules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EnableInsightRulesResult");
    return {
      Failures: xml.getList("Failures", "member").map(PartialFailure_Parse),
    };
  }

  async getDashboard(
    {abortSignal, ...params}: RequestConfig & s.GetDashboardInput,
  ): Promise<s.GetDashboardOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DashboardName", (params["DashboardName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDashboard",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetDashboardResult");
    return xml.strings({
      optional: {"DashboardArn":true,"DashboardBody":true,"DashboardName":true},
    });
  }

  async getInsightRuleReport(
    {abortSignal, ...params}: RequestConfig & s.GetInsightRuleReportInput,
  ): Promise<s.GetInsightRuleReportOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if ("MaxContributorCount" in params) body.append(prefix+"MaxContributorCount", (params["MaxContributorCount"] ?? '').toString());
    if (params["Metrics"]) qsP.appendList(body, prefix+"Metrics", params["Metrics"], {"entryPrefix":".member."})
    if ("OrderBy" in params) body.append(prefix+"OrderBy", (params["OrderBy"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInsightRuleReport",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetInsightRuleReportResult");
    return {
      ...xml.strings({
        optional: {"AggregationStatistic":true},
      }),
      KeyLabels: xml.getList("KeyLabels", "member").map(x => x.content ?? ''),
      AggregateValue: xml.first("AggregateValue", false, x => parseFloat(x.content ?? '0')),
      ApproximateUniqueCount: xml.first("ApproximateUniqueCount", false, x => parseInt(x.content ?? '0')),
      Contributors: xml.getList("Contributors", "member").map(InsightRuleContributor_Parse),
      MetricDatapoints: xml.getList("MetricDatapoints", "member").map(InsightRuleMetricDatapoint_Parse),
    };
  }

  async getMetricData(
    {abortSignal, ...params}: RequestConfig & s.GetMetricDataInput,
  ): Promise<s.GetMetricDataOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["MetricDataQueries"]) qsP.appendList(body, prefix+"MetricDataQueries", params["MetricDataQueries"], {"appender":MetricDataQuery_Serialize,"entryPrefix":".member."})
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("ScanBy" in params) body.append(prefix+"ScanBy", (params["ScanBy"] ?? '').toString());
    if ("MaxDatapoints" in params) body.append(prefix+"MaxDatapoints", (params["MaxDatapoints"] ?? '').toString());
    if (params["LabelOptions"] != null) LabelOptions_Serialize(body, prefix+"LabelOptions", params["LabelOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMetricData",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetMetricDataResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      MetricDataResults: xml.getList("MetricDataResults", "member").map(MetricDataResult_Parse),
      Messages: xml.getList("Messages", "member").map(MessageData_Parse),
    };
  }

  async getMetricStatistics(
    {abortSignal, ...params}: RequestConfig & s.GetMetricStatisticsInput,
  ): Promise<s.GetMetricStatisticsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if (params["Statistics"]) qsP.appendList(body, prefix+"Statistics", params["Statistics"], {"entryPrefix":".member."})
    if (params["ExtendedStatistics"]) qsP.appendList(body, prefix+"ExtendedStatistics", params["ExtendedStatistics"], {"entryPrefix":".member."})
    if ("Unit" in params) body.append(prefix+"Unit", (params["Unit"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMetricStatistics",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetMetricStatisticsResult");
    return {
      ...xml.strings({
        optional: {"Label":true},
      }),
      Datapoints: xml.getList("Datapoints", "member").map(Datapoint_Parse),
    };
  }

  async getMetricWidgetImage(
    {abortSignal, ...params}: RequestConfig & s.GetMetricWidgetImageInput,
  ): Promise<s.GetMetricWidgetImageOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"MetricWidget", (params["MetricWidget"] ?? '').toString());
    if ("OutputFormat" in params) body.append(prefix+"OutputFormat", (params["OutputFormat"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMetricWidgetImage",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetMetricWidgetImageResult");
    return {
      MetricWidgetImage: xml.first("MetricWidgetImage", false, x => parseBlob(x.content) ?? ''),
    };
  }

  async listDashboards(
    {abortSignal, ...params}: RequestConfig & s.ListDashboardsInput = {},
  ): Promise<s.ListDashboardsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DashboardNamePrefix" in params) body.append(prefix+"DashboardNamePrefix", (params["DashboardNamePrefix"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDashboards",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListDashboardsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      DashboardEntries: xml.getList("DashboardEntries", "member").map(DashboardEntry_Parse),
    };
  }

  async listMetrics(
    {abortSignal, ...params}: RequestConfig & s.ListMetricsInput = {},
  ): Promise<s.ListMetricsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Namespace" in params) body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if ("MetricName" in params) body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":DimensionFilter_Serialize,"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("RecentlyActive" in params) body.append(prefix+"RecentlyActive", (params["RecentlyActive"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMetrics",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListMetricsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Metrics: xml.getList("Metrics", "member").map(Metric_Parse),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceInput,
  ): Promise<s.ListTagsForResourceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceARN", (params["ResourceARN"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTagsForResourceResult");
    return {
      Tags: xml.getList("Tags", "member").map(Tag_Parse),
    };
  }

  async putAnomalyDetector(
    {abortSignal, ...params}: RequestConfig & s.PutAnomalyDetectorInput,
  ): Promise<s.PutAnomalyDetectorOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    body.append(prefix+"Stat", (params["Stat"] ?? '').toString());
    if (params["Configuration"] != null) AnomalyDetectorConfiguration_Serialize(body, prefix+"Configuration", params["Configuration"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAnomalyDetector",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PutAnomalyDetectorResult");
    return {};
  }

  async putCompositeAlarm(
    {abortSignal, ...params}: RequestConfig & s.PutCompositeAlarmInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ActionsEnabled" in params) body.append(prefix+"ActionsEnabled", (params["ActionsEnabled"] ?? '').toString());
    if (params["AlarmActions"]) qsP.appendList(body, prefix+"AlarmActions", params["AlarmActions"], {"entryPrefix":".member."})
    if ("AlarmDescription" in params) body.append(prefix+"AlarmDescription", (params["AlarmDescription"] ?? '').toString());
    body.append(prefix+"AlarmName", (params["AlarmName"] ?? '').toString());
    body.append(prefix+"AlarmRule", (params["AlarmRule"] ?? '').toString());
    if (params["InsufficientDataActions"]) qsP.appendList(body, prefix+"InsufficientDataActions", params["InsufficientDataActions"], {"entryPrefix":".member."})
    if (params["OKActions"]) qsP.appendList(body, prefix+"OKActions", params["OKActions"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutCompositeAlarm",
    });
  }

  async putDashboard(
    {abortSignal, ...params}: RequestConfig & s.PutDashboardInput,
  ): Promise<s.PutDashboardOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DashboardName", (params["DashboardName"] ?? '').toString());
    body.append(prefix+"DashboardBody", (params["DashboardBody"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDashboard",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PutDashboardResult");
    return {
      DashboardValidationMessages: xml.getList("DashboardValidationMessages", "member").map(DashboardValidationMessage_Parse),
    };
  }

  async putInsightRule(
    {abortSignal, ...params}: RequestConfig & s.PutInsightRuleInput,
  ): Promise<s.PutInsightRuleOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    if ("RuleState" in params) body.append(prefix+"RuleState", (params["RuleState"] ?? '').toString());
    body.append(prefix+"RuleDefinition", (params["RuleDefinition"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutInsightRule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PutInsightRuleResult");
    return {};
  }

  async putMetricAlarm(
    {abortSignal, ...params}: RequestConfig & s.PutMetricAlarmInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AlarmName", (params["AlarmName"] ?? '').toString());
    if ("AlarmDescription" in params) body.append(prefix+"AlarmDescription", (params["AlarmDescription"] ?? '').toString());
    if ("ActionsEnabled" in params) body.append(prefix+"ActionsEnabled", (params["ActionsEnabled"] ?? '').toString());
    if (params["OKActions"]) qsP.appendList(body, prefix+"OKActions", params["OKActions"], {"entryPrefix":".member."})
    if (params["AlarmActions"]) qsP.appendList(body, prefix+"AlarmActions", params["AlarmActions"], {"entryPrefix":".member."})
    if (params["InsufficientDataActions"]) qsP.appendList(body, prefix+"InsufficientDataActions", params["InsufficientDataActions"], {"entryPrefix":".member."})
    if ("MetricName" in params) body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if ("Namespace" in params) body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if ("Statistic" in params) body.append(prefix+"Statistic", (params["Statistic"] ?? '').toString());
    if ("ExtendedStatistic" in params) body.append(prefix+"ExtendedStatistic", (params["ExtendedStatistic"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    if ("Period" in params) body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if ("Unit" in params) body.append(prefix+"Unit", (params["Unit"] ?? '').toString());
    body.append(prefix+"EvaluationPeriods", (params["EvaluationPeriods"] ?? '').toString());
    if ("DatapointsToAlarm" in params) body.append(prefix+"DatapointsToAlarm", (params["DatapointsToAlarm"] ?? '').toString());
    if ("Threshold" in params) body.append(prefix+"Threshold", (params["Threshold"] ?? '').toString());
    body.append(prefix+"ComparisonOperator", (params["ComparisonOperator"] ?? '').toString());
    if ("TreatMissingData" in params) body.append(prefix+"TreatMissingData", (params["TreatMissingData"] ?? '').toString());
    if ("EvaluateLowSampleCountPercentile" in params) body.append(prefix+"EvaluateLowSampleCountPercentile", (params["EvaluateLowSampleCountPercentile"] ?? '').toString());
    if (params["Metrics"]) qsP.appendList(body, prefix+"Metrics", params["Metrics"], {"appender":MetricDataQuery_Serialize,"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("ThresholdMetricId" in params) body.append(prefix+"ThresholdMetricId", (params["ThresholdMetricId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMetricAlarm",
    });
  }

  async putMetricData(
    {abortSignal, ...params}: RequestConfig & s.PutMetricDataInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if (params["MetricData"]) qsP.appendList(body, prefix+"MetricData", params["MetricData"], {"appender":MetricDatum_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMetricData",
    });
  }

  async setAlarmState(
    {abortSignal, ...params}: RequestConfig & s.SetAlarmStateInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AlarmName", (params["AlarmName"] ?? '').toString());
    body.append(prefix+"StateValue", (params["StateValue"] ?? '').toString());
    body.append(prefix+"StateReason", (params["StateReason"] ?? '').toString());
    if ("StateReasonData" in params) body.append(prefix+"StateReasonData", (params["StateReasonData"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetAlarmState",
    });
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceInput,
  ): Promise<s.TagResourceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceARN", (params["ResourceARN"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "TagResourceResult");
    return {};
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceInput,
  ): Promise<s.UntagResourceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceARN", (params["ResourceARN"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UntagResourceResult");
    return {};
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 5 seconds apart (about 4 minutes max wait time). */
  async waitForAlarmExists(
    params: RequestConfig & s.DescribeAlarmsInput,
  ): Promise<s.DescribeAlarmsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AlarmExists';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeAlarms(params);
      if ((resp?.MetricAlarms || '').length > 0) return resp;
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 5 seconds apart (about 4 minutes max wait time). */
  async waitForCompositeAlarmExists(
    params: RequestConfig & s.DescribeAlarmsInput,
  ): Promise<s.DescribeAlarmsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CompositeAlarmExists';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeAlarms(params);
      if ((resp?.CompositeAlarms || '').length > 0) return resp;
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

function Dimension_Serialize(body: URLSearchParams, prefix: string, params: s.Dimension) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Dimension_Parse(node: xmlP.XmlNode): s.Dimension {
  return node.strings({
    required: {"Name":true,"Value":true},
  });
}

function MetricDataQuery_Serialize(body: URLSearchParams, prefix: string, params: s.MetricDataQuery) {
    body.append(prefix+".Id", (params["Id"] ?? '').toString());
    if (params["MetricStat"] != null) MetricStat_Serialize(body, prefix+".MetricStat", params["MetricStat"]);
    if ("Expression" in params) body.append(prefix+".Expression", (params["Expression"] ?? '').toString());
    if ("Label" in params) body.append(prefix+".Label", (params["Label"] ?? '').toString());
    if ("ReturnData" in params) body.append(prefix+".ReturnData", (params["ReturnData"] ?? '').toString());
    if ("Period" in params) body.append(prefix+".Period", (params["Period"] ?? '').toString());
}
function MetricDataQuery_Parse(node: xmlP.XmlNode): s.MetricDataQuery {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"Expression":true,"Label":true},
    }),
    MetricStat: node.first("MetricStat", false, MetricStat_Parse),
    ReturnData: node.first("ReturnData", false, x => x.content === 'true'),
    Period: node.first("Period", false, x => parseInt(x.content ?? '0')),
  };
}

function MetricStat_Serialize(body: URLSearchParams, prefix: string, params: s.MetricStat) {
    Metric_Serialize(body, prefix+".Metric", params["Metric"]);
    body.append(prefix+".Period", (params["Period"] ?? '').toString());
    body.append(prefix+".Stat", (params["Stat"] ?? '').toString());
    if ("Unit" in params) body.append(prefix+".Unit", (params["Unit"] ?? '').toString());
}
function MetricStat_Parse(node: xmlP.XmlNode): s.MetricStat {
  return {
    ...node.strings({
      required: {"Stat":true},
    }),
    Metric: node.first("Metric", true, Metric_Parse),
    Period: node.first("Period", true, x => parseInt(x.content ?? '0')),
    Unit: node.first("Unit", false, x => (x.content ?? '') as s.StandardUnit),
  };
}

function Metric_Serialize(body: URLSearchParams, prefix: string, params: s.Metric) {
    if ("Namespace" in params) body.append(prefix+".Namespace", (params["Namespace"] ?? '').toString());
    if ("MetricName" in params) body.append(prefix+".MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+".Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
}
function Metric_Parse(node: xmlP.XmlNode): s.Metric {
  return {
    ...node.strings({
      optional: {"Namespace":true,"MetricName":true},
    }),
    Dimensions: node.getList("Dimensions", "member").map(Dimension_Parse),
  };
}

function LabelOptions_Serialize(body: URLSearchParams, prefix: string, params: s.LabelOptions) {
    if ("Timezone" in params) body.append(prefix+".Timezone", (params["Timezone"] ?? '').toString());
}

function DimensionFilter_Serialize(body: URLSearchParams, prefix: string, params: s.DimensionFilter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function AnomalyDetectorConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.AnomalyDetectorConfiguration) {
    if (params["ExcludedTimeRanges"]) qsP.appendList(body, prefix+".ExcludedTimeRanges", params["ExcludedTimeRanges"], {"appender":Range_Serialize,"entryPrefix":".member."})
    if ("MetricTimezone" in params) body.append(prefix+".MetricTimezone", (params["MetricTimezone"] ?? '').toString());
}
function AnomalyDetectorConfiguration_Parse(node: xmlP.XmlNode): s.AnomalyDetectorConfiguration {
  return {
    ...node.strings({
      optional: {"MetricTimezone":true},
    }),
    ExcludedTimeRanges: node.getList("ExcludedTimeRanges", "member").map(Range_Parse),
  };
}

function Range_Serialize(body: URLSearchParams, prefix: string, params: s.Range) {
    body.append(prefix+".StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+".EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
}
function Range_Parse(node: xmlP.XmlNode): s.Range {
  return {
    StartTime: node.first("StartTime", true, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

function MetricDatum_Serialize(body: URLSearchParams, prefix: string, params: s.MetricDatum) {
    body.append(prefix+".MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+".Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    if ("Timestamp" in params) body.append(prefix+".Timestamp", qsP.encodeDate_iso8601(params["Timestamp"]));
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if (params["StatisticValues"] != null) StatisticSet_Serialize(body, prefix+".StatisticValues", params["StatisticValues"]);
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
    if (params["Counts"]) qsP.appendList(body, prefix+".Counts", params["Counts"], {"entryPrefix":".member."})
    if ("Unit" in params) body.append(prefix+".Unit", (params["Unit"] ?? '').toString());
    if ("StorageResolution" in params) body.append(prefix+".StorageResolution", (params["StorageResolution"] ?? '').toString());
}

function StatisticSet_Serialize(body: URLSearchParams, prefix: string, params: s.StatisticSet) {
    body.append(prefix+".SampleCount", (params["SampleCount"] ?? '').toString());
    body.append(prefix+".Sum", (params["Sum"] ?? '').toString());
    body.append(prefix+".Minimum", (params["Minimum"] ?? '').toString());
    body.append(prefix+".Maximum", (params["Maximum"] ?? '').toString());
}

function PartialFailure_Parse(node: xmlP.XmlNode): s.PartialFailure {
  return node.strings({
    optional: {"FailureResource":true,"ExceptionType":true,"FailureCode":true,"FailureDescription":true},
  });
}

function AlarmHistoryItem_Parse(node: xmlP.XmlNode): s.AlarmHistoryItem {
  return {
    ...node.strings({
      optional: {"AlarmName":true,"HistorySummary":true,"HistoryData":true},
    }),
    AlarmType: node.first("AlarmType", false, x => (x.content ?? '') as s.AlarmType),
    Timestamp: node.first("Timestamp", false, x => xmlP.parseTimestamp(x.content)),
    HistoryItemType: node.first("HistoryItemType", false, x => (x.content ?? '') as s.HistoryItemType),
  };
}

function CompositeAlarm_Parse(node: xmlP.XmlNode): s.CompositeAlarm {
  return {
    ...node.strings({
      optional: {"AlarmArn":true,"AlarmDescription":true,"AlarmName":true,"AlarmRule":true,"StateReason":true,"StateReasonData":true},
    }),
    ActionsEnabled: node.first("ActionsEnabled", false, x => x.content === 'true'),
    AlarmActions: node.getList("AlarmActions", "member").map(x => x.content ?? ''),
    AlarmConfigurationUpdatedTimestamp: node.first("AlarmConfigurationUpdatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    InsufficientDataActions: node.getList("InsufficientDataActions", "member").map(x => x.content ?? ''),
    OKActions: node.getList("OKActions", "member").map(x => x.content ?? ''),
    StateUpdatedTimestamp: node.first("StateUpdatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    StateValue: node.first("StateValue", false, x => (x.content ?? '') as s.StateValue),
  };
}

function MetricAlarm_Parse(node: xmlP.XmlNode): s.MetricAlarm {
  return {
    ...node.strings({
      optional: {"AlarmName":true,"AlarmArn":true,"AlarmDescription":true,"StateReason":true,"StateReasonData":true,"MetricName":true,"Namespace":true,"ExtendedStatistic":true,"TreatMissingData":true,"EvaluateLowSampleCountPercentile":true,"ThresholdMetricId":true},
    }),
    AlarmConfigurationUpdatedTimestamp: node.first("AlarmConfigurationUpdatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    ActionsEnabled: node.first("ActionsEnabled", false, x => x.content === 'true'),
    OKActions: node.getList("OKActions", "member").map(x => x.content ?? ''),
    AlarmActions: node.getList("AlarmActions", "member").map(x => x.content ?? ''),
    InsufficientDataActions: node.getList("InsufficientDataActions", "member").map(x => x.content ?? ''),
    StateValue: node.first("StateValue", false, x => (x.content ?? '') as s.StateValue),
    StateUpdatedTimestamp: node.first("StateUpdatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    Statistic: node.first("Statistic", false, x => (x.content ?? '') as s.Statistic),
    Dimensions: node.getList("Dimensions", "member").map(Dimension_Parse),
    Period: node.first("Period", false, x => parseInt(x.content ?? '0')),
    Unit: node.first("Unit", false, x => (x.content ?? '') as s.StandardUnit),
    EvaluationPeriods: node.first("EvaluationPeriods", false, x => parseInt(x.content ?? '0')),
    DatapointsToAlarm: node.first("DatapointsToAlarm", false, x => parseInt(x.content ?? '0')),
    Threshold: node.first("Threshold", false, x => parseFloat(x.content ?? '0')),
    ComparisonOperator: node.first("ComparisonOperator", false, x => (x.content ?? '') as s.ComparisonOperator),
    Metrics: node.getList("Metrics", "member").map(MetricDataQuery_Parse),
  };
}

function AnomalyDetector_Parse(node: xmlP.XmlNode): s.AnomalyDetector {
  return {
    ...node.strings({
      optional: {"Namespace":true,"MetricName":true,"Stat":true},
    }),
    Dimensions: node.getList("Dimensions", "member").map(Dimension_Parse),
    Configuration: node.first("Configuration", false, AnomalyDetectorConfiguration_Parse),
    StateValue: node.first("StateValue", false, x => (x.content ?? '') as s.AnomalyDetectorStateValue),
  };
}

function InsightRule_Parse(node: xmlP.XmlNode): s.InsightRule {
  return node.strings({
    required: {"Name":true,"State":true,"Schema":true,"Definition":true},
  });
}

function InsightRuleContributor_Parse(node: xmlP.XmlNode): s.InsightRuleContributor {
  return {
    Keys: node.getList("Keys", "member").map(x => x.content ?? ''),
    ApproximateAggregateValue: node.first("ApproximateAggregateValue", true, x => parseFloat(x.content ?? '0')),
    Datapoints: node.getList("Datapoints", "member").map(InsightRuleContributorDatapoint_Parse),
  };
}

function InsightRuleContributorDatapoint_Parse(node: xmlP.XmlNode): s.InsightRuleContributorDatapoint {
  return {
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    ApproximateValue: node.first("ApproximateValue", true, x => parseFloat(x.content ?? '0')),
  };
}

function InsightRuleMetricDatapoint_Parse(node: xmlP.XmlNode): s.InsightRuleMetricDatapoint {
  return {
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    UniqueContributors: node.first("UniqueContributors", false, x => parseFloat(x.content ?? '0')),
    MaxContributorValue: node.first("MaxContributorValue", false, x => parseFloat(x.content ?? '0')),
    SampleCount: node.first("SampleCount", false, x => parseFloat(x.content ?? '0')),
    Average: node.first("Average", false, x => parseFloat(x.content ?? '0')),
    Sum: node.first("Sum", false, x => parseFloat(x.content ?? '0')),
    Minimum: node.first("Minimum", false, x => parseFloat(x.content ?? '0')),
    Maximum: node.first("Maximum", false, x => parseFloat(x.content ?? '0')),
  };
}

function MetricDataResult_Parse(node: xmlP.XmlNode): s.MetricDataResult {
  return {
    ...node.strings({
      optional: {"Id":true,"Label":true},
    }),
    Timestamps: node.getList("Timestamps", "member").map(x => xmlP.parseTimestamp(x.content)),
    Values: node.getList("Values", "member").map(x => parseFloat(x.content ?? '0')),
    StatusCode: node.first("StatusCode", false, x => (x.content ?? '') as s.StatusCode),
    Messages: node.getList("Messages", "member").map(MessageData_Parse),
  };
}

function MessageData_Parse(node: xmlP.XmlNode): s.MessageData {
  return node.strings({
    optional: {"Code":true,"Value":true},
  });
}

function Datapoint_Parse(node: xmlP.XmlNode): s.Datapoint {
  return {
    Timestamp: node.first("Timestamp", false, x => xmlP.parseTimestamp(x.content)),
    SampleCount: node.first("SampleCount", false, x => parseFloat(x.content ?? '0')),
    Average: node.first("Average", false, x => parseFloat(x.content ?? '0')),
    Sum: node.first("Sum", false, x => parseFloat(x.content ?? '0')),
    Minimum: node.first("Minimum", false, x => parseFloat(x.content ?? '0')),
    Maximum: node.first("Maximum", false, x => parseFloat(x.content ?? '0')),
    Unit: node.first("Unit", false, x => (x.content ?? '') as s.StandardUnit),
    ExtendedStatistics: xmlP.readXmlMap(node.getList("ExtendedStatistics", "entry"), x => parseFloat(x.content ?? '0'), {}),
  };
}

function DashboardEntry_Parse(node: xmlP.XmlNode): s.DashboardEntry {
  return {
    ...node.strings({
      optional: {"DashboardName":true,"DashboardArn":true},
    }),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
  };
}

function DashboardValidationMessage_Parse(node: xmlP.XmlNode): s.DashboardValidationMessage {
  return node.strings({
    optional: {"DataPath":true,"Message":true},
  });
}
