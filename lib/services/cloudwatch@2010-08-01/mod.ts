// Autogenerated API client for: Amazon CloudWatch

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as Base64 from "https://deno.land/x/base64@v0.2.1/mod.ts";

export default class CloudWatch {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudWatch.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2010-08-01",
    "endpointPrefix": "monitoring",
    "protocol": "query",
    "serviceAbbreviation": "CloudWatch",
    "serviceFullName": "Amazon CloudWatch",
    "serviceId": "CloudWatch",
    "signatureVersion": "v4",
    "uid": "monitoring-2010-08-01",
    "xmlNamespace": "http://monitoring.amazonaws.com/doc/2010-08-01/"
  };

  async deleteAlarms(
    {abortSignal, ...params}: RequestConfig & DeleteAlarmsInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AlarmNames"]) qsP.appendList(body, prefix+"AlarmNames", params["AlarmNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAlarms",
    });
  }

  async deleteAnomalyDetector(
    {abortSignal, ...params}: RequestConfig & DeleteAnomalyDetectorInput,
  ): Promise<DeleteAnomalyDetectorOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    body.append(prefix+"Stat", (params["Stat"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAnomalyDetector",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteAnomalyDetectorResult");
    return {};
  }

  async deleteDashboards(
    {abortSignal, ...params}: RequestConfig & DeleteDashboardsInput,
  ): Promise<DeleteDashboardsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DashboardNames"]) qsP.appendList(body, prefix+"DashboardNames", params["DashboardNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDashboards",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDashboardsResult");
    return {};
  }

  async deleteInsightRules(
    {abortSignal, ...params}: RequestConfig & DeleteInsightRulesInput,
  ): Promise<DeleteInsightRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["RuleNames"]) qsP.appendList(body, prefix+"RuleNames", params["RuleNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInsightRules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteInsightRulesResult");
    return {
      Failures: xml.getList("Failures", "member").map(PartialFailure_Parse),
    };
  }

  async describeAlarmHistory(
    {abortSignal, ...params}: RequestConfig & DescribeAlarmHistoryInput = {},
  ): Promise<DescribeAlarmHistoryOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AlarmName" in params) body.append(prefix+"AlarmName", (params["AlarmName"] ?? '').toString());
    if (params["AlarmTypes"]) qsP.appendList(body, prefix+"AlarmTypes", params["AlarmTypes"], {"entryPrefix":".member."})
    if ("HistoryItemType" in params) body.append(prefix+"HistoryItemType", (params["HistoryItemType"] ?? '').toString());
    if ("StartDate" in params) body.append(prefix+"StartDate", qsP.encodeDate_iso8601(params["StartDate"]));
    if ("EndDate" in params) body.append(prefix+"EndDate", qsP.encodeDate_iso8601(params["EndDate"]));
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("ScanBy" in params) body.append(prefix+"ScanBy", (params["ScanBy"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlarmHistory",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAlarmHistoryResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AlarmHistoryItems: xml.getList("AlarmHistoryItems", "member").map(AlarmHistoryItem_Parse),
    };
  }

  async describeAlarms(
    {abortSignal, ...params}: RequestConfig & DescribeAlarmsInput = {},
  ): Promise<DescribeAlarmsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AlarmNames"]) qsP.appendList(body, prefix+"AlarmNames", params["AlarmNames"], {"entryPrefix":".member."})
    if ("AlarmNamePrefix" in params) body.append(prefix+"AlarmNamePrefix", (params["AlarmNamePrefix"] ?? '').toString());
    if (params["AlarmTypes"]) qsP.appendList(body, prefix+"AlarmTypes", params["AlarmTypes"], {"entryPrefix":".member."})
    if ("ChildrenOfAlarmName" in params) body.append(prefix+"ChildrenOfAlarmName", (params["ChildrenOfAlarmName"] ?? '').toString());
    if ("ParentsOfAlarmName" in params) body.append(prefix+"ParentsOfAlarmName", (params["ParentsOfAlarmName"] ?? '').toString());
    if ("StateValue" in params) body.append(prefix+"StateValue", (params["StateValue"] ?? '').toString());
    if ("ActionPrefix" in params) body.append(prefix+"ActionPrefix", (params["ActionPrefix"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlarms",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAlarmsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      CompositeAlarms: xml.getList("CompositeAlarms", "member").map(CompositeAlarm_Parse),
      MetricAlarms: xml.getList("MetricAlarms", "member").map(MetricAlarm_Parse),
    };
  }

  async describeAlarmsForMetric(
    {abortSignal, ...params}: RequestConfig & DescribeAlarmsForMetricInput,
  ): Promise<DescribeAlarmsForMetricOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if ("Statistic" in params) body.append(prefix+"Statistic", (params["Statistic"] ?? '').toString());
    if ("ExtendedStatistic" in params) body.append(prefix+"ExtendedStatistic", (params["ExtendedStatistic"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    if ("Period" in params) body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if ("Unit" in params) body.append(prefix+"Unit", (params["Unit"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlarmsForMetric",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAlarmsForMetricResult");
    return {
      MetricAlarms: xml.getList("MetricAlarms", "member").map(MetricAlarm_Parse),
    };
  }

  async describeAnomalyDetectors(
    {abortSignal, ...params}: RequestConfig & DescribeAnomalyDetectorsInput = {},
  ): Promise<DescribeAnomalyDetectorsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("Namespace" in params) body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if ("MetricName" in params) body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAnomalyDetectors",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAnomalyDetectorsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AnomalyDetectors: xml.getList("AnomalyDetectors", "member").map(AnomalyDetector_Parse),
    };
  }

  async describeInsightRules(
    {abortSignal, ...params}: RequestConfig & DescribeInsightRulesInput = {},
  ): Promise<DescribeInsightRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInsightRules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeInsightRulesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      InsightRules: xml.getList("InsightRules", "member").map(InsightRule_Parse),
    };
  }

  async disableAlarmActions(
    {abortSignal, ...params}: RequestConfig & DisableAlarmActionsInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AlarmNames"]) qsP.appendList(body, prefix+"AlarmNames", params["AlarmNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableAlarmActions",
    });
  }

  async disableInsightRules(
    {abortSignal, ...params}: RequestConfig & DisableInsightRulesInput,
  ): Promise<DisableInsightRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["RuleNames"]) qsP.appendList(body, prefix+"RuleNames", params["RuleNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableInsightRules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DisableInsightRulesResult");
    return {
      Failures: xml.getList("Failures", "member").map(PartialFailure_Parse),
    };
  }

  async enableAlarmActions(
    {abortSignal, ...params}: RequestConfig & EnableAlarmActionsInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AlarmNames"]) qsP.appendList(body, prefix+"AlarmNames", params["AlarmNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableAlarmActions",
    });
  }

  async enableInsightRules(
    {abortSignal, ...params}: RequestConfig & EnableInsightRulesInput,
  ): Promise<EnableInsightRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["RuleNames"]) qsP.appendList(body, prefix+"RuleNames", params["RuleNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableInsightRules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EnableInsightRulesResult");
    return {
      Failures: xml.getList("Failures", "member").map(PartialFailure_Parse),
    };
  }

  async getDashboard(
    {abortSignal, ...params}: RequestConfig & GetDashboardInput,
  ): Promise<GetDashboardOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DashboardName", (params["DashboardName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDashboard",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetDashboardResult");
    return xml.strings({
      optional: {"DashboardArn":true,"DashboardBody":true,"DashboardName":true},
    });
  }

  async getInsightRuleReport(
    {abortSignal, ...params}: RequestConfig & GetInsightRuleReportInput,
  ): Promise<GetInsightRuleReportOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if ("MaxContributorCount" in params) body.append(prefix+"MaxContributorCount", (params["MaxContributorCount"] ?? '').toString());
    if (params["Metrics"]) qsP.appendList(body, prefix+"Metrics", params["Metrics"], {"entryPrefix":".member."})
    if ("OrderBy" in params) body.append(prefix+"OrderBy", (params["OrderBy"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInsightRuleReport",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetInsightRuleReportResult");
    return {
      ...xml.strings({
        optional: {"AggregationStatistic":true},
      }),
      KeyLabels: xml.getList("KeyLabels", "member").map(x => x.content ?? ''),
      AggregateValue: xml.first("AggregateValue", false, x => parseFloat(x.content ?? '0')),
      ApproximateUniqueCount: xml.first("ApproximateUniqueCount", false, x => parseInt(x.content ?? '0')),
      Contributors: xml.getList("Contributors", "member").map(InsightRuleContributor_Parse),
      MetricDatapoints: xml.getList("MetricDatapoints", "member").map(InsightRuleMetricDatapoint_Parse),
    };
  }

  async getMetricData(
    {abortSignal, ...params}: RequestConfig & GetMetricDataInput,
  ): Promise<GetMetricDataOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["MetricDataQueries"]) qsP.appendList(body, prefix+"MetricDataQueries", params["MetricDataQueries"], {"appender":MetricDataQuery_Serialize,"entryPrefix":".member."})
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("ScanBy" in params) body.append(prefix+"ScanBy", (params["ScanBy"] ?? '').toString());
    if ("MaxDatapoints" in params) body.append(prefix+"MaxDatapoints", (params["MaxDatapoints"] ?? '').toString());
    if (params["LabelOptions"] != null) LabelOptions_Serialize(body, prefix+"LabelOptions", params["LabelOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMetricData",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetMetricDataResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      MetricDataResults: xml.getList("MetricDataResults", "member").map(MetricDataResult_Parse),
      Messages: xml.getList("Messages", "member").map(MessageData_Parse),
    };
  }

  async getMetricStatistics(
    {abortSignal, ...params}: RequestConfig & GetMetricStatisticsInput,
  ): Promise<GetMetricStatisticsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if (params["Statistics"]) qsP.appendList(body, prefix+"Statistics", params["Statistics"], {"entryPrefix":".member."})
    if (params["ExtendedStatistics"]) qsP.appendList(body, prefix+"ExtendedStatistics", params["ExtendedStatistics"], {"entryPrefix":".member."})
    if ("Unit" in params) body.append(prefix+"Unit", (params["Unit"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMetricStatistics",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetMetricStatisticsResult");
    return {
      ...xml.strings({
        optional: {"Label":true},
      }),
      Datapoints: xml.getList("Datapoints", "member").map(Datapoint_Parse),
    };
  }

  async getMetricWidgetImage(
    {abortSignal, ...params}: RequestConfig & GetMetricWidgetImageInput,
  ): Promise<GetMetricWidgetImageOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"MetricWidget", (params["MetricWidget"] ?? '').toString());
    if ("OutputFormat" in params) body.append(prefix+"OutputFormat", (params["OutputFormat"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMetricWidgetImage",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetMetricWidgetImageResult");
    return {
      MetricWidgetImage: xml.first("MetricWidgetImage", false, x => Base64.toUint8Array(x.content ?? '')),
    };
  }

  async listDashboards(
    {abortSignal, ...params}: RequestConfig & ListDashboardsInput = {},
  ): Promise<ListDashboardsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DashboardNamePrefix" in params) body.append(prefix+"DashboardNamePrefix", (params["DashboardNamePrefix"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDashboards",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListDashboardsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      DashboardEntries: xml.getList("DashboardEntries", "member").map(DashboardEntry_Parse),
    };
  }

  async listMetrics(
    {abortSignal, ...params}: RequestConfig & ListMetricsInput = {},
  ): Promise<ListMetricsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Namespace" in params) body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if ("MetricName" in params) body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":DimensionFilter_Serialize,"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("RecentlyActive" in params) body.append(prefix+"RecentlyActive", (params["RecentlyActive"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMetrics",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListMetricsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Metrics: xml.getList("Metrics", "member").map(Metric_Parse),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceInput,
  ): Promise<ListTagsForResourceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceARN", (params["ResourceARN"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTagsForResourceResult");
    return {
      Tags: xml.getList("Tags", "member").map(Tag_Parse),
    };
  }

  async putAnomalyDetector(
    {abortSignal, ...params}: RequestConfig & PutAnomalyDetectorInput,
  ): Promise<PutAnomalyDetectorOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    body.append(prefix+"Stat", (params["Stat"] ?? '').toString());
    if (params["Configuration"] != null) AnomalyDetectorConfiguration_Serialize(body, prefix+"Configuration", params["Configuration"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAnomalyDetector",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PutAnomalyDetectorResult");
    return {};
  }

  async putCompositeAlarm(
    {abortSignal, ...params}: RequestConfig & PutCompositeAlarmInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ActionsEnabled" in params) body.append(prefix+"ActionsEnabled", (params["ActionsEnabled"] ?? '').toString());
    if (params["AlarmActions"]) qsP.appendList(body, prefix+"AlarmActions", params["AlarmActions"], {"entryPrefix":".member."})
    if ("AlarmDescription" in params) body.append(prefix+"AlarmDescription", (params["AlarmDescription"] ?? '').toString());
    body.append(prefix+"AlarmName", (params["AlarmName"] ?? '').toString());
    body.append(prefix+"AlarmRule", (params["AlarmRule"] ?? '').toString());
    if (params["InsufficientDataActions"]) qsP.appendList(body, prefix+"InsufficientDataActions", params["InsufficientDataActions"], {"entryPrefix":".member."})
    if (params["OKActions"]) qsP.appendList(body, prefix+"OKActions", params["OKActions"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutCompositeAlarm",
    });
  }

  async putDashboard(
    {abortSignal, ...params}: RequestConfig & PutDashboardInput,
  ): Promise<PutDashboardOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DashboardName", (params["DashboardName"] ?? '').toString());
    body.append(prefix+"DashboardBody", (params["DashboardBody"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDashboard",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PutDashboardResult");
    return {
      DashboardValidationMessages: xml.getList("DashboardValidationMessages", "member").map(DashboardValidationMessage_Parse),
    };
  }

  async putInsightRule(
    {abortSignal, ...params}: RequestConfig & PutInsightRuleInput,
  ): Promise<PutInsightRuleOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    if ("RuleState" in params) body.append(prefix+"RuleState", (params["RuleState"] ?? '').toString());
    body.append(prefix+"RuleDefinition", (params["RuleDefinition"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutInsightRule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PutInsightRuleResult");
    return {};
  }

  async putMetricAlarm(
    {abortSignal, ...params}: RequestConfig & PutMetricAlarmInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AlarmName", (params["AlarmName"] ?? '').toString());
    if ("AlarmDescription" in params) body.append(prefix+"AlarmDescription", (params["AlarmDescription"] ?? '').toString());
    if ("ActionsEnabled" in params) body.append(prefix+"ActionsEnabled", (params["ActionsEnabled"] ?? '').toString());
    if (params["OKActions"]) qsP.appendList(body, prefix+"OKActions", params["OKActions"], {"entryPrefix":".member."})
    if (params["AlarmActions"]) qsP.appendList(body, prefix+"AlarmActions", params["AlarmActions"], {"entryPrefix":".member."})
    if (params["InsufficientDataActions"]) qsP.appendList(body, prefix+"InsufficientDataActions", params["InsufficientDataActions"], {"entryPrefix":".member."})
    if ("MetricName" in params) body.append(prefix+"MetricName", (params["MetricName"] ?? '').toString());
    if ("Namespace" in params) body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if ("Statistic" in params) body.append(prefix+"Statistic", (params["Statistic"] ?? '').toString());
    if ("ExtendedStatistic" in params) body.append(prefix+"ExtendedStatistic", (params["ExtendedStatistic"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+"Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    if ("Period" in params) body.append(prefix+"Period", (params["Period"] ?? '').toString());
    if ("Unit" in params) body.append(prefix+"Unit", (params["Unit"] ?? '').toString());
    body.append(prefix+"EvaluationPeriods", (params["EvaluationPeriods"] ?? '').toString());
    if ("DatapointsToAlarm" in params) body.append(prefix+"DatapointsToAlarm", (params["DatapointsToAlarm"] ?? '').toString());
    if ("Threshold" in params) body.append(prefix+"Threshold", (params["Threshold"] ?? '').toString());
    body.append(prefix+"ComparisonOperator", (params["ComparisonOperator"] ?? '').toString());
    if ("TreatMissingData" in params) body.append(prefix+"TreatMissingData", (params["TreatMissingData"] ?? '').toString());
    if ("EvaluateLowSampleCountPercentile" in params) body.append(prefix+"EvaluateLowSampleCountPercentile", (params["EvaluateLowSampleCountPercentile"] ?? '').toString());
    if (params["Metrics"]) qsP.appendList(body, prefix+"Metrics", params["Metrics"], {"appender":MetricDataQuery_Serialize,"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("ThresholdMetricId" in params) body.append(prefix+"ThresholdMetricId", (params["ThresholdMetricId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMetricAlarm",
    });
  }

  async putMetricData(
    {abortSignal, ...params}: RequestConfig & PutMetricDataInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Namespace", (params["Namespace"] ?? '').toString());
    if (params["MetricData"]) qsP.appendList(body, prefix+"MetricData", params["MetricData"], {"appender":MetricDatum_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMetricData",
    });
  }

  async setAlarmState(
    {abortSignal, ...params}: RequestConfig & SetAlarmStateInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AlarmName", (params["AlarmName"] ?? '').toString());
    body.append(prefix+"StateValue", (params["StateValue"] ?? '').toString());
    body.append(prefix+"StateReason", (params["StateReason"] ?? '').toString());
    if ("StateReasonData" in params) body.append(prefix+"StateReasonData", (params["StateReasonData"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetAlarmState",
    });
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceInput,
  ): Promise<TagResourceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceARN", (params["ResourceARN"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "TagResourceResult");
    return {};
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceInput,
  ): Promise<UntagResourceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceARN", (params["ResourceARN"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UntagResourceResult");
    return {};
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 5 seconds apart (about 4 minutes max wait time). */
  async waitForAlarmExists(
    params: RequestConfig & DescribeAlarmsInput,
  ): Promise<DescribeAlarmsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AlarmExists';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeAlarms(params);
      if ((resp?.MetricAlarms || '').length > 0) return resp;
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 5 seconds apart (about 4 minutes max wait time). */
  async waitForCompositeAlarmExists(
    params: RequestConfig & DescribeAlarmsInput,
  ): Promise<DescribeAlarmsOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CompositeAlarmExists';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeAlarms(params);
      if ((resp?.CompositeAlarms || '').length > 0) return resp;
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface DeleteAlarmsInput {
  AlarmNames: string[];
}

// refs: 1 - tags: named, input
export interface DeleteAnomalyDetectorInput {
  Namespace: string;
  MetricName: string;
  Dimensions?: Dimension[] | null;
  Stat: string;
}

// refs: 1 - tags: named, input
export interface DeleteDashboardsInput {
  DashboardNames: string[];
}

// refs: 1 - tags: named, input
export interface DeleteInsightRulesInput {
  RuleNames: string[];
}

// refs: 1 - tags: named, input
export interface DescribeAlarmHistoryInput {
  AlarmName?: string | null;
  AlarmTypes?: AlarmType[] | null;
  HistoryItemType?: HistoryItemType | null;
  StartDate?: Date | number | null;
  EndDate?: Date | number | null;
  MaxRecords?: number | null;
  NextToken?: string | null;
  ScanBy?: ScanBy | null;
}

// refs: 1 - tags: named, input
export interface DescribeAlarmsInput {
  AlarmNames?: string[] | null;
  AlarmNamePrefix?: string | null;
  AlarmTypes?: AlarmType[] | null;
  ChildrenOfAlarmName?: string | null;
  ParentsOfAlarmName?: string | null;
  StateValue?: StateValue | null;
  ActionPrefix?: string | null;
  MaxRecords?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeAlarmsForMetricInput {
  MetricName: string;
  Namespace: string;
  Statistic?: Statistic | null;
  ExtendedStatistic?: string | null;
  Dimensions?: Dimension[] | null;
  Period?: number | null;
  Unit?: StandardUnit | null;
}

// refs: 1 - tags: named, input
export interface DescribeAnomalyDetectorsInput {
  NextToken?: string | null;
  MaxResults?: number | null;
  Namespace?: string | null;
  MetricName?: string | null;
  Dimensions?: Dimension[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeInsightRulesInput {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DisableAlarmActionsInput {
  AlarmNames: string[];
}

// refs: 1 - tags: named, input
export interface DisableInsightRulesInput {
  RuleNames: string[];
}

// refs: 1 - tags: named, input
export interface EnableAlarmActionsInput {
  AlarmNames: string[];
}

// refs: 1 - tags: named, input
export interface EnableInsightRulesInput {
  RuleNames: string[];
}

// refs: 1 - tags: named, input
export interface GetDashboardInput {
  DashboardName: string;
}

// refs: 1 - tags: named, input
export interface GetInsightRuleReportInput {
  RuleName: string;
  StartTime: Date | number;
  EndTime: Date | number;
  Period: number;
  MaxContributorCount?: number | null;
  Metrics?: string[] | null;
  OrderBy?: string | null;
}

// refs: 1 - tags: named, input
export interface GetMetricDataInput {
  MetricDataQueries: MetricDataQuery[];
  StartTime: Date | number;
  EndTime: Date | number;
  NextToken?: string | null;
  ScanBy?: ScanBy | null;
  MaxDatapoints?: number | null;
  LabelOptions?: LabelOptions | null;
}

// refs: 1 - tags: named, input
export interface GetMetricStatisticsInput {
  Namespace: string;
  MetricName: string;
  Dimensions?: Dimension[] | null;
  StartTime: Date | number;
  EndTime: Date | number;
  Period: number;
  Statistics?: Statistic[] | null;
  ExtendedStatistics?: string[] | null;
  Unit?: StandardUnit | null;
}

// refs: 1 - tags: named, input
export interface GetMetricWidgetImageInput {
  MetricWidget: string;
  OutputFormat?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDashboardsInput {
  DashboardNamePrefix?: string | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListMetricsInput {
  Namespace?: string | null;
  MetricName?: string | null;
  Dimensions?: DimensionFilter[] | null;
  NextToken?: string | null;
  RecentlyActive?: RecentlyActive | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceInput {
  ResourceARN: string;
}

// refs: 1 - tags: named, input
export interface PutAnomalyDetectorInput {
  Namespace: string;
  MetricName: string;
  Dimensions?: Dimension[] | null;
  Stat: string;
  Configuration?: AnomalyDetectorConfiguration | null;
}

// refs: 1 - tags: named, input
export interface PutCompositeAlarmInput {
  ActionsEnabled?: boolean | null;
  AlarmActions?: string[] | null;
  AlarmDescription?: string | null;
  AlarmName: string;
  AlarmRule: string;
  InsufficientDataActions?: string[] | null;
  OKActions?: string[] | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface PutDashboardInput {
  DashboardName: string;
  DashboardBody: string;
}

// refs: 1 - tags: named, input
export interface PutInsightRuleInput {
  RuleName: string;
  RuleState?: string | null;
  RuleDefinition: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface PutMetricAlarmInput {
  AlarmName: string;
  AlarmDescription?: string | null;
  ActionsEnabled?: boolean | null;
  OKActions?: string[] | null;
  AlarmActions?: string[] | null;
  InsufficientDataActions?: string[] | null;
  MetricName?: string | null;
  Namespace?: string | null;
  Statistic?: Statistic | null;
  ExtendedStatistic?: string | null;
  Dimensions?: Dimension[] | null;
  Period?: number | null;
  Unit?: StandardUnit | null;
  EvaluationPeriods: number;
  DatapointsToAlarm?: number | null;
  Threshold?: number | null;
  ComparisonOperator: ComparisonOperator;
  TreatMissingData?: string | null;
  EvaluateLowSampleCountPercentile?: string | null;
  Metrics?: MetricDataQuery[] | null;
  Tags?: Tag[] | null;
  ThresholdMetricId?: string | null;
}

// refs: 1 - tags: named, input
export interface PutMetricDataInput {
  Namespace: string;
  MetricData: MetricDatum[];
}

// refs: 1 - tags: named, input
export interface SetAlarmStateInput {
  AlarmName: string;
  StateValue: StateValue;
  StateReason: string;
  StateReasonData?: string | null;
}

// refs: 1 - tags: named, input
export interface TagResourceInput {
  ResourceARN: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceInput {
  ResourceARN: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, output
export interface DeleteAnomalyDetectorOutput {
}

// refs: 1 - tags: named, output
export interface DeleteDashboardsOutput {
}

// refs: 1 - tags: named, output
export interface DeleteInsightRulesOutput {
  Failures: PartialFailure[];
}

// refs: 1 - tags: named, output
export interface DescribeAlarmHistoryOutput {
  AlarmHistoryItems: AlarmHistoryItem[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeAlarmsOutput {
  CompositeAlarms: CompositeAlarm[];
  MetricAlarms: MetricAlarm[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeAlarmsForMetricOutput {
  MetricAlarms: MetricAlarm[];
}

// refs: 1 - tags: named, output
export interface DescribeAnomalyDetectorsOutput {
  AnomalyDetectors: AnomalyDetector[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeInsightRulesOutput {
  NextToken?: string | null;
  InsightRules: InsightRule[];
}

// refs: 1 - tags: named, output
export interface DisableInsightRulesOutput {
  Failures: PartialFailure[];
}

// refs: 1 - tags: named, output
export interface EnableInsightRulesOutput {
  Failures: PartialFailure[];
}

// refs: 1 - tags: named, output
export interface GetDashboardOutput {
  DashboardArn?: string | null;
  DashboardBody?: string | null;
  DashboardName?: string | null;
}

// refs: 1 - tags: named, output
export interface GetInsightRuleReportOutput {
  KeyLabels: string[];
  AggregationStatistic?: string | null;
  AggregateValue?: number | null;
  ApproximateUniqueCount?: number | null;
  Contributors: InsightRuleContributor[];
  MetricDatapoints: InsightRuleMetricDatapoint[];
}

// refs: 1 - tags: named, output
export interface GetMetricDataOutput {
  MetricDataResults: MetricDataResult[];
  NextToken?: string | null;
  Messages: MessageData[];
}

// refs: 1 - tags: named, output
export interface GetMetricStatisticsOutput {
  Label?: string | null;
  Datapoints: Datapoint[];
}

// refs: 1 - tags: named, output
export interface GetMetricWidgetImageOutput {
  MetricWidgetImage?: Uint8Array | string | null;
}

// refs: 1 - tags: named, output
export interface ListDashboardsOutput {
  DashboardEntries: DashboardEntry[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListMetricsOutput {
  Metrics: Metric[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceOutput {
  Tags: Tag[];
}

// refs: 1 - tags: named, output
export interface PutAnomalyDetectorOutput {
}

// refs: 1 - tags: named, output
export interface PutDashboardOutput {
  DashboardValidationMessages: DashboardValidationMessage[];
}

// refs: 1 - tags: named, output
export interface PutInsightRuleOutput {
}

// refs: 1 - tags: named, output
export interface TagResourceOutput {
}

// refs: 1 - tags: named, output
export interface UntagResourceOutput {
}

// refs: 15 - tags: input, named, interface, output
export interface Dimension {
  Name: string;
  Value: string;
}
function Dimension_Serialize(body: URLSearchParams, prefix: string, params: Dimension) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Dimension_Parse(node: xmlP.XmlNode): Dimension {
  return node.strings({
    required: {"Name":true,"Value":true},
  });
}

// refs: 3 - tags: input, named, enum, output
export type AlarmType =
| "CompositeAlarm"
| "MetricAlarm"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type HistoryItemType =
| "ConfigurationUpdate"
| "StateUpdate"
| "Action"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type ScanBy =
| "TimestampDescending"
| "TimestampAscending"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type StateValue =
| "OK"
| "ALARM"
| "INSUFFICIENT_DATA"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type Statistic =
| "SampleCount"
| "Average"
| "Sum"
| "Minimum"
| "Maximum"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, enum, output
export type StandardUnit =
| "Seconds"
| "Microseconds"
| "Milliseconds"
| "Bytes"
| "Kilobytes"
| "Megabytes"
| "Gigabytes"
| "Terabytes"
| "Bits"
| "Kilobits"
| "Megabits"
| "Gigabits"
| "Terabits"
| "Percent"
| "Count"
| "Bytes/Second"
| "Kilobytes/Second"
| "Megabytes/Second"
| "Gigabytes/Second"
| "Terabytes/Second"
| "Bits/Second"
| "Kilobits/Second"
| "Megabits/Second"
| "Gigabits/Second"
| "Terabits/Second"
| "Count/Second"
| "None"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface MetricDataQuery {
  Id: string;
  MetricStat?: MetricStat | null;
  Expression?: string | null;
  Label?: string | null;
  ReturnData?: boolean | null;
  Period?: number | null;
}
function MetricDataQuery_Serialize(body: URLSearchParams, prefix: string, params: MetricDataQuery) {
    body.append(prefix+".Id", (params["Id"] ?? '').toString());
    if (params["MetricStat"] != null) MetricStat_Serialize(body, prefix+".MetricStat", params["MetricStat"]);
    if ("Expression" in params) body.append(prefix+".Expression", (params["Expression"] ?? '').toString());
    if ("Label" in params) body.append(prefix+".Label", (params["Label"] ?? '').toString());
    if ("ReturnData" in params) body.append(prefix+".ReturnData", (params["ReturnData"] ?? '').toString());
    if ("Period" in params) body.append(prefix+".Period", (params["Period"] ?? '').toString());
}
function MetricDataQuery_Parse(node: xmlP.XmlNode): MetricDataQuery {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"Expression":true,"Label":true},
    }),
    MetricStat: node.first("MetricStat", false, MetricStat_Parse),
    ReturnData: node.first("ReturnData", false, x => x.content === 'true'),
    Period: node.first("Period", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface MetricStat {
  Metric: Metric;
  Period: number;
  Stat: string;
  Unit?: StandardUnit | null;
}
function MetricStat_Serialize(body: URLSearchParams, prefix: string, params: MetricStat) {
    Metric_Serialize(body, prefix+".Metric", params["Metric"]);
    body.append(prefix+".Period", (params["Period"] ?? '').toString());
    body.append(prefix+".Stat", (params["Stat"] ?? '').toString());
    if ("Unit" in params) body.append(prefix+".Unit", (params["Unit"] ?? '').toString());
}
function MetricStat_Parse(node: xmlP.XmlNode): MetricStat {
  return {
    ...node.strings({
      required: {"Stat":true},
    }),
    Metric: node.first("Metric", true, Metric_Parse),
    Period: node.first("Period", true, x => parseInt(x.content ?? '0')),
    Unit: node.first("Unit", false, x => (x.content ?? '') as StandardUnit),
  };
}

// refs: 5 - tags: input, named, interface, output
export interface Metric {
  Namespace?: string | null;
  MetricName?: string | null;
  Dimensions: Dimension[];
}
function Metric_Serialize(body: URLSearchParams, prefix: string, params: Metric) {
    if ("Namespace" in params) body.append(prefix+".Namespace", (params["Namespace"] ?? '').toString());
    if ("MetricName" in params) body.append(prefix+".MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+".Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
}
function Metric_Parse(node: xmlP.XmlNode): Metric {
  return {
    ...node.strings({
      optional: {"Namespace":true,"MetricName":true},
    }),
    Dimensions: node.getList("Dimensions", "member").map(Dimension_Parse),
  };
}

// refs: 1 - tags: input, named, interface
export interface LabelOptions {
  Timezone?: string | null;
}
function LabelOptions_Serialize(body: URLSearchParams, prefix: string, params: LabelOptions) {
    if ("Timezone" in params) body.append(prefix+".Timezone", (params["Timezone"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface DimensionFilter {
  Name: string;
  Value?: string | null;
}
function DimensionFilter_Serialize(body: URLSearchParams, prefix: string, params: DimensionFilter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 1 - tags: input, named, enum
export type RecentlyActive =
| "PT3H"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface AnomalyDetectorConfiguration {
  ExcludedTimeRanges: Range[];
  MetricTimezone?: string | null;
}
function AnomalyDetectorConfiguration_Serialize(body: URLSearchParams, prefix: string, params: AnomalyDetectorConfiguration) {
    if (params["ExcludedTimeRanges"]) qsP.appendList(body, prefix+".ExcludedTimeRanges", params["ExcludedTimeRanges"], {"appender":Range_Serialize,"entryPrefix":".member."})
    if ("MetricTimezone" in params) body.append(prefix+".MetricTimezone", (params["MetricTimezone"] ?? '').toString());
}
function AnomalyDetectorConfiguration_Parse(node: xmlP.XmlNode): AnomalyDetectorConfiguration {
  return {
    ...node.strings({
      optional: {"MetricTimezone":true},
    }),
    ExcludedTimeRanges: node.getList("ExcludedTimeRanges", "member").map(Range_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface Range {
  StartTime: Date | number;
  EndTime: Date | number;
}
function Range_Serialize(body: URLSearchParams, prefix: string, params: Range) {
    body.append(prefix+".StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+".EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
}
function Range_Parse(node: xmlP.XmlNode): Range {
  return {
    StartTime: node.first("StartTime", true, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", true, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 5 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

// refs: 3 - tags: input, named, enum, output
export type ComparisonOperator =
| "GreaterThanOrEqualToThreshold"
| "GreaterThanThreshold"
| "LessThanThreshold"
| "LessThanOrEqualToThreshold"
| "LessThanLowerOrGreaterThanUpperThreshold"
| "LessThanLowerThreshold"
| "GreaterThanUpperThreshold"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface MetricDatum {
  MetricName: string;
  Dimensions?: Dimension[] | null;
  Timestamp?: Date | number | null;
  Value?: number | null;
  StatisticValues?: StatisticSet | null;
  Values?: number[] | null;
  Counts?: number[] | null;
  Unit?: StandardUnit | null;
  StorageResolution?: number | null;
}
function MetricDatum_Serialize(body: URLSearchParams, prefix: string, params: MetricDatum) {
    body.append(prefix+".MetricName", (params["MetricName"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+".Dimensions", params["Dimensions"], {"appender":Dimension_Serialize,"entryPrefix":".member."})
    if ("Timestamp" in params) body.append(prefix+".Timestamp", qsP.encodeDate_iso8601(params["Timestamp"]));
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if (params["StatisticValues"] != null) StatisticSet_Serialize(body, prefix+".StatisticValues", params["StatisticValues"]);
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
    if (params["Counts"]) qsP.appendList(body, prefix+".Counts", params["Counts"], {"entryPrefix":".member."})
    if ("Unit" in params) body.append(prefix+".Unit", (params["Unit"] ?? '').toString());
    if ("StorageResolution" in params) body.append(prefix+".StorageResolution", (params["StorageResolution"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface StatisticSet {
  SampleCount: number;
  Sum: number;
  Minimum: number;
  Maximum: number;
}
function StatisticSet_Serialize(body: URLSearchParams, prefix: string, params: StatisticSet) {
    body.append(prefix+".SampleCount", (params["SampleCount"] ?? '').toString());
    body.append(prefix+".Sum", (params["Sum"] ?? '').toString());
    body.append(prefix+".Minimum", (params["Minimum"] ?? '').toString());
    body.append(prefix+".Maximum", (params["Maximum"] ?? '').toString());
}

// refs: 3 - tags: output, named, interface
export interface PartialFailure {
  FailureResource?: string | null;
  ExceptionType?: string | null;
  FailureCode?: string | null;
  FailureDescription?: string | null;
}
function PartialFailure_Parse(node: xmlP.XmlNode): PartialFailure {
  return node.strings({
    optional: {"FailureResource":true,"ExceptionType":true,"FailureCode":true,"FailureDescription":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface AlarmHistoryItem {
  AlarmName?: string | null;
  AlarmType?: AlarmType | null;
  Timestamp?: Date | number | null;
  HistoryItemType?: HistoryItemType | null;
  HistorySummary?: string | null;
  HistoryData?: string | null;
}
function AlarmHistoryItem_Parse(node: xmlP.XmlNode): AlarmHistoryItem {
  return {
    ...node.strings({
      optional: {"AlarmName":true,"HistorySummary":true,"HistoryData":true},
    }),
    AlarmType: node.first("AlarmType", false, x => (x.content ?? '') as AlarmType),
    Timestamp: node.first("Timestamp", false, x => xmlP.parseTimestamp(x.content)),
    HistoryItemType: node.first("HistoryItemType", false, x => (x.content ?? '') as HistoryItemType),
  };
}

// refs: 1 - tags: output, named, interface
export interface CompositeAlarm {
  ActionsEnabled?: boolean | null;
  AlarmActions: string[];
  AlarmArn?: string | null;
  AlarmConfigurationUpdatedTimestamp?: Date | number | null;
  AlarmDescription?: string | null;
  AlarmName?: string | null;
  AlarmRule?: string | null;
  InsufficientDataActions: string[];
  OKActions: string[];
  StateReason?: string | null;
  StateReasonData?: string | null;
  StateUpdatedTimestamp?: Date | number | null;
  StateValue?: StateValue | null;
}
function CompositeAlarm_Parse(node: xmlP.XmlNode): CompositeAlarm {
  return {
    ...node.strings({
      optional: {"AlarmArn":true,"AlarmDescription":true,"AlarmName":true,"AlarmRule":true,"StateReason":true,"StateReasonData":true},
    }),
    ActionsEnabled: node.first("ActionsEnabled", false, x => x.content === 'true'),
    AlarmActions: node.getList("AlarmActions", "member").map(x => x.content ?? ''),
    AlarmConfigurationUpdatedTimestamp: node.first("AlarmConfigurationUpdatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    InsufficientDataActions: node.getList("InsufficientDataActions", "member").map(x => x.content ?? ''),
    OKActions: node.getList("OKActions", "member").map(x => x.content ?? ''),
    StateUpdatedTimestamp: node.first("StateUpdatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    StateValue: node.first("StateValue", false, x => (x.content ?? '') as StateValue),
  };
}

// refs: 2 - tags: output, named, interface
export interface MetricAlarm {
  AlarmName?: string | null;
  AlarmArn?: string | null;
  AlarmDescription?: string | null;
  AlarmConfigurationUpdatedTimestamp?: Date | number | null;
  ActionsEnabled?: boolean | null;
  OKActions: string[];
  AlarmActions: string[];
  InsufficientDataActions: string[];
  StateValue?: StateValue | null;
  StateReason?: string | null;
  StateReasonData?: string | null;
  StateUpdatedTimestamp?: Date | number | null;
  MetricName?: string | null;
  Namespace?: string | null;
  Statistic?: Statistic | null;
  ExtendedStatistic?: string | null;
  Dimensions: Dimension[];
  Period?: number | null;
  Unit?: StandardUnit | null;
  EvaluationPeriods?: number | null;
  DatapointsToAlarm?: number | null;
  Threshold?: number | null;
  ComparisonOperator?: ComparisonOperator | null;
  TreatMissingData?: string | null;
  EvaluateLowSampleCountPercentile?: string | null;
  Metrics: MetricDataQuery[];
  ThresholdMetricId?: string | null;
}
function MetricAlarm_Parse(node: xmlP.XmlNode): MetricAlarm {
  return {
    ...node.strings({
      optional: {"AlarmName":true,"AlarmArn":true,"AlarmDescription":true,"StateReason":true,"StateReasonData":true,"MetricName":true,"Namespace":true,"ExtendedStatistic":true,"TreatMissingData":true,"EvaluateLowSampleCountPercentile":true,"ThresholdMetricId":true},
    }),
    AlarmConfigurationUpdatedTimestamp: node.first("AlarmConfigurationUpdatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    ActionsEnabled: node.first("ActionsEnabled", false, x => x.content === 'true'),
    OKActions: node.getList("OKActions", "member").map(x => x.content ?? ''),
    AlarmActions: node.getList("AlarmActions", "member").map(x => x.content ?? ''),
    InsufficientDataActions: node.getList("InsufficientDataActions", "member").map(x => x.content ?? ''),
    StateValue: node.first("StateValue", false, x => (x.content ?? '') as StateValue),
    StateUpdatedTimestamp: node.first("StateUpdatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    Statistic: node.first("Statistic", false, x => (x.content ?? '') as Statistic),
    Dimensions: node.getList("Dimensions", "member").map(Dimension_Parse),
    Period: node.first("Period", false, x => parseInt(x.content ?? '0')),
    Unit: node.first("Unit", false, x => (x.content ?? '') as StandardUnit),
    EvaluationPeriods: node.first("EvaluationPeriods", false, x => parseInt(x.content ?? '0')),
    DatapointsToAlarm: node.first("DatapointsToAlarm", false, x => parseInt(x.content ?? '0')),
    Threshold: node.first("Threshold", false, x => parseFloat(x.content ?? '0')),
    ComparisonOperator: node.first("ComparisonOperator", false, x => (x.content ?? '') as ComparisonOperator),
    Metrics: node.getList("Metrics", "member").map(MetricDataQuery_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface AnomalyDetector {
  Namespace?: string | null;
  MetricName?: string | null;
  Dimensions: Dimension[];
  Stat?: string | null;
  Configuration?: AnomalyDetectorConfiguration | null;
  StateValue?: AnomalyDetectorStateValue | null;
}
function AnomalyDetector_Parse(node: xmlP.XmlNode): AnomalyDetector {
  return {
    ...node.strings({
      optional: {"Namespace":true,"MetricName":true,"Stat":true},
    }),
    Dimensions: node.getList("Dimensions", "member").map(Dimension_Parse),
    Configuration: node.first("Configuration", false, AnomalyDetectorConfiguration_Parse),
    StateValue: node.first("StateValue", false, x => (x.content ?? '') as AnomalyDetectorStateValue),
  };
}

// refs: 1 - tags: output, named, enum
export type AnomalyDetectorStateValue =
| "PENDING_TRAINING"
| "TRAINED_INSUFFICIENT_DATA"
| "TRAINED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface InsightRule {
  Name: string;
  State: string;
  Schema: string;
  Definition: string;
}
function InsightRule_Parse(node: xmlP.XmlNode): InsightRule {
  return node.strings({
    required: {"Name":true,"State":true,"Schema":true,"Definition":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface InsightRuleContributor {
  Keys: string[];
  ApproximateAggregateValue: number;
  Datapoints: InsightRuleContributorDatapoint[];
}
function InsightRuleContributor_Parse(node: xmlP.XmlNode): InsightRuleContributor {
  return {
    Keys: node.getList("Keys", "member").map(x => x.content ?? ''),
    ApproximateAggregateValue: node.first("ApproximateAggregateValue", true, x => parseFloat(x.content ?? '0')),
    Datapoints: node.getList("Datapoints", "member").map(InsightRuleContributorDatapoint_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface InsightRuleContributorDatapoint {
  Timestamp: Date | number;
  ApproximateValue: number;
}
function InsightRuleContributorDatapoint_Parse(node: xmlP.XmlNode): InsightRuleContributorDatapoint {
  return {
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    ApproximateValue: node.first("ApproximateValue", true, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface InsightRuleMetricDatapoint {
  Timestamp: Date | number;
  UniqueContributors?: number | null;
  MaxContributorValue?: number | null;
  SampleCount?: number | null;
  Average?: number | null;
  Sum?: number | null;
  Minimum?: number | null;
  Maximum?: number | null;
}
function InsightRuleMetricDatapoint_Parse(node: xmlP.XmlNode): InsightRuleMetricDatapoint {
  return {
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    UniqueContributors: node.first("UniqueContributors", false, x => parseFloat(x.content ?? '0')),
    MaxContributorValue: node.first("MaxContributorValue", false, x => parseFloat(x.content ?? '0')),
    SampleCount: node.first("SampleCount", false, x => parseFloat(x.content ?? '0')),
    Average: node.first("Average", false, x => parseFloat(x.content ?? '0')),
    Sum: node.first("Sum", false, x => parseFloat(x.content ?? '0')),
    Minimum: node.first("Minimum", false, x => parseFloat(x.content ?? '0')),
    Maximum: node.first("Maximum", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface MetricDataResult {
  Id?: string | null;
  Label?: string | null;
  Timestamps: (Date | number)[];
  Values: number[];
  StatusCode?: StatusCode | null;
  Messages: MessageData[];
}
function MetricDataResult_Parse(node: xmlP.XmlNode): MetricDataResult {
  return {
    ...node.strings({
      optional: {"Id":true,"Label":true},
    }),
    Timestamps: node.getList("Timestamps", "member").map(x => xmlP.parseTimestamp(x.content)),
    Values: node.getList("Values", "member").map(x => parseFloat(x.content ?? '0')),
    StatusCode: node.first("StatusCode", false, x => (x.content ?? '') as StatusCode),
    Messages: node.getList("Messages", "member").map(MessageData_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type StatusCode =
| "Complete"
| "InternalError"
| "PartialData"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface MessageData {
  Code?: string | null;
  Value?: string | null;
}
function MessageData_Parse(node: xmlP.XmlNode): MessageData {
  return node.strings({
    optional: {"Code":true,"Value":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface Datapoint {
  Timestamp?: Date | number | null;
  SampleCount?: number | null;
  Average?: number | null;
  Sum?: number | null;
  Minimum?: number | null;
  Maximum?: number | null;
  Unit?: StandardUnit | null;
  ExtendedStatistics: { [key: string]: number | null | undefined };
}
function Datapoint_Parse(node: xmlP.XmlNode): Datapoint {
  return {
    Timestamp: node.first("Timestamp", false, x => xmlP.parseTimestamp(x.content)),
    SampleCount: node.first("SampleCount", false, x => parseFloat(x.content ?? '0')),
    Average: node.first("Average", false, x => parseFloat(x.content ?? '0')),
    Sum: node.first("Sum", false, x => parseFloat(x.content ?? '0')),
    Minimum: node.first("Minimum", false, x => parseFloat(x.content ?? '0')),
    Maximum: node.first("Maximum", false, x => parseFloat(x.content ?? '0')),
    Unit: node.first("Unit", false, x => (x.content ?? '') as StandardUnit),
    ExtendedStatistics: xmlP.readXmlMap(node.getList("ExtendedStatistics", "entry"), x => parseFloat(x.content ?? '0'), {}),
  };
}

// refs: 1 - tags: output, named, interface
export interface DashboardEntry {
  DashboardName?: string | null;
  DashboardArn?: string | null;
  LastModified?: Date | number | null;
  Size?: number | null;
}
function DashboardEntry_Parse(node: xmlP.XmlNode): DashboardEntry {
  return {
    ...node.strings({
      optional: {"DashboardName":true,"DashboardArn":true},
    }),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface DashboardValidationMessage {
  DataPath?: string | null;
  Message?: string | null;
}
function DashboardValidationMessage_Parse(node: xmlP.XmlNode): DashboardValidationMessage {
  return node.strings({
    optional: {"DataPath":true,"Message":true},
  });
}
