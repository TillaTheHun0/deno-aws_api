// Autogenerated API client for: Amazon Simple Email Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class SES {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SES.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2010-12-01",
    "endpointPrefix": "email",
    "protocol": "query",
    "serviceAbbreviation": "Amazon SES",
    "serviceFullName": "Amazon Simple Email Service",
    "serviceId": "SES",
    "signatureVersion": "v4",
    "signingName": "ses",
    "uid": "email-2010-12-01",
    "xmlNamespace": "http://ses.amazonaws.com/doc/2010-12-01/"
  };

  async cloneReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & s.CloneReceiptRuleSetRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    body.append(prefix+"OriginalRuleSetName", (params["OriginalRuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CloneReceiptRuleSet",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createConfigurationSet(
    {abortSignal, ...params}: RequestConfig & s.CreateConfigurationSetRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    ConfigurationSet_Serialize(body, prefix+"ConfigurationSet", params["ConfigurationSet"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConfigurationSet",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createConfigurationSetEventDestination(
    {abortSignal, ...params}: RequestConfig & s.CreateConfigurationSetEventDestinationRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    EventDestination_Serialize(body, prefix+"EventDestination", params["EventDestination"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConfigurationSetEventDestination",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createConfigurationSetTrackingOptions(
    {abortSignal, ...params}: RequestConfig & s.CreateConfigurationSetTrackingOptionsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    TrackingOptions_Serialize(body, prefix+"TrackingOptions", params["TrackingOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConfigurationSetTrackingOptions",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createCustomVerificationEmailTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateCustomVerificationEmailTemplateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    body.append(prefix+"FromEmailAddress", (params["FromEmailAddress"] ?? '').toString());
    body.append(prefix+"TemplateSubject", (params["TemplateSubject"] ?? '').toString());
    body.append(prefix+"TemplateContent", (params["TemplateContent"] ?? '').toString());
    body.append(prefix+"SuccessRedirectionURL", (params["SuccessRedirectionURL"] ?? '').toString());
    body.append(prefix+"FailureRedirectionURL", (params["FailureRedirectionURL"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomVerificationEmailTemplate",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createReceiptFilter(
    {abortSignal, ...params}: RequestConfig & s.CreateReceiptFilterRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    ReceiptFilter_Serialize(body, prefix+"Filter", params["Filter"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReceiptFilter",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createReceiptRule(
    {abortSignal, ...params}: RequestConfig & s.CreateReceiptRuleRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    if ("After" in params) body.append(prefix+"After", (params["After"] ?? '').toString());
    ReceiptRule_Serialize(body, prefix+"Rule", params["Rule"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReceiptRule",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & s.CreateReceiptRuleSetRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReceiptRuleSet",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateTemplateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    Template_Serialize(body, prefix+"Template", params["Template"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTemplate",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteConfigurationSet(
    {abortSignal, ...params}: RequestConfig & s.DeleteConfigurationSetRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConfigurationSet",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteConfigurationSetEventDestination(
    {abortSignal, ...params}: RequestConfig & s.DeleteConfigurationSetEventDestinationRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    body.append(prefix+"EventDestinationName", (params["EventDestinationName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConfigurationSetEventDestination",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteConfigurationSetTrackingOptions(
    {abortSignal, ...params}: RequestConfig & s.DeleteConfigurationSetTrackingOptionsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConfigurationSetTrackingOptions",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteCustomVerificationEmailTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteCustomVerificationEmailTemplateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCustomVerificationEmailTemplate",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteIdentity(
    {abortSignal, ...params}: RequestConfig & s.DeleteIdentityRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIdentity",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteIdentityPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteIdentityPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIdentityPolicy",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteReceiptFilter(
    {abortSignal, ...params}: RequestConfig & s.DeleteReceiptFilterRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"FilterName", (params["FilterName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReceiptFilter",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteReceiptRule(
    {abortSignal, ...params}: RequestConfig & s.DeleteReceiptRuleRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReceiptRule",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & s.DeleteReceiptRuleSetRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReceiptRuleSet",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteTemplateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTemplate",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteVerifiedEmailAddress(
    {abortSignal, ...params}: RequestConfig & s.DeleteVerifiedEmailAddressRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EmailAddress", (params["EmailAddress"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVerifiedEmailAddress",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async describeActiveReceiptRuleSet(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeActiveReceiptRuleSetResponse> {
    const body = new URLSearchParams;
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeActiveReceiptRuleSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeActiveReceiptRuleSetResult");
    return {
      Metadata: xml.first("Metadata", false, ReceiptRuleSetMetadata_Parse),
      Rules: xml.getList("Rules", "member").map(ReceiptRule_Parse),
    };
  }

  async describeConfigurationSet(
    {abortSignal, ...params}: RequestConfig & s.DescribeConfigurationSetRequest,
  ): Promise<s.DescribeConfigurationSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    if (params["ConfigurationSetAttributeNames"]) qsP.appendList(body, prefix+"ConfigurationSetAttributeNames", params["ConfigurationSetAttributeNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConfigurationSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeConfigurationSetResult");
    return {
      ConfigurationSet: xml.first("ConfigurationSet", false, ConfigurationSet_Parse),
      EventDestinations: xml.getList("EventDestinations", "member").map(EventDestination_Parse),
      TrackingOptions: xml.first("TrackingOptions", false, TrackingOptions_Parse),
      DeliveryOptions: xml.first("DeliveryOptions", false, DeliveryOptions_Parse),
      ReputationOptions: xml.first("ReputationOptions", false, ReputationOptions_Parse),
    };
  }

  async describeReceiptRule(
    {abortSignal, ...params}: RequestConfig & s.DescribeReceiptRuleRequest,
  ): Promise<s.DescribeReceiptRuleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReceiptRule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReceiptRuleResult");
    return {
      Rule: xml.first("Rule", false, ReceiptRule_Parse),
    };
  }

  async describeReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & s.DescribeReceiptRuleSetRequest,
  ): Promise<s.DescribeReceiptRuleSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReceiptRuleSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReceiptRuleSetResult");
    return {
      Metadata: xml.first("Metadata", false, ReceiptRuleSetMetadata_Parse),
      Rules: xml.getList("Rules", "member").map(ReceiptRule_Parse),
    };
  }

  async getAccountSendingEnabled(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetAccountSendingEnabledResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccountSendingEnabled",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetAccountSendingEnabledResult");
    return {
      Enabled: xml.first("Enabled", false, x => x.content === 'true'),
    };
  }

  async getCustomVerificationEmailTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetCustomVerificationEmailTemplateRequest,
  ): Promise<s.GetCustomVerificationEmailTemplateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCustomVerificationEmailTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetCustomVerificationEmailTemplateResult");
    return xml.strings({
      optional: {"TemplateName":true,"FromEmailAddress":true,"TemplateSubject":true,"TemplateContent":true,"SuccessRedirectionURL":true,"FailureRedirectionURL":true},
    });
  }

  async getIdentityDkimAttributes(
    {abortSignal, ...params}: RequestConfig & s.GetIdentityDkimAttributesRequest,
  ): Promise<s.GetIdentityDkimAttributesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identities"]) qsP.appendList(body, prefix+"Identities", params["Identities"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityDkimAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetIdentityDkimAttributesResult");
    return {
      DkimAttributes: xmlP.readXmlMap(xml.getList("DkimAttributes", "entry"), IdentityDkimAttributes_Parse, {}),
    };
  }

  async getIdentityMailFromDomainAttributes(
    {abortSignal, ...params}: RequestConfig & s.GetIdentityMailFromDomainAttributesRequest,
  ): Promise<s.GetIdentityMailFromDomainAttributesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identities"]) qsP.appendList(body, prefix+"Identities", params["Identities"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityMailFromDomainAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetIdentityMailFromDomainAttributesResult");
    return {
      MailFromDomainAttributes: xmlP.readXmlMap(xml.getList("MailFromDomainAttributes", "entry"), IdentityMailFromDomainAttributes_Parse, {}),
    };
  }

  async getIdentityNotificationAttributes(
    {abortSignal, ...params}: RequestConfig & s.GetIdentityNotificationAttributesRequest,
  ): Promise<s.GetIdentityNotificationAttributesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identities"]) qsP.appendList(body, prefix+"Identities", params["Identities"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityNotificationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetIdentityNotificationAttributesResult");
    return {
      NotificationAttributes: xmlP.readXmlMap(xml.getList("NotificationAttributes", "entry"), IdentityNotificationAttributes_Parse, {}),
    };
  }

  async getIdentityPolicies(
    {abortSignal, ...params}: RequestConfig & s.GetIdentityPoliciesRequest,
  ): Promise<s.GetIdentityPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    if (params["PolicyNames"]) qsP.appendList(body, prefix+"PolicyNames", params["PolicyNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetIdentityPoliciesResult");
    return {
      Policies: xmlP.readXmlMap(xml.getList("Policies", "entry"), x => x.content ?? '', {}),
    };
  }

  async getIdentityVerificationAttributes(
    {abortSignal, ...params}: RequestConfig & s.GetIdentityVerificationAttributesRequest,
  ): Promise<s.GetIdentityVerificationAttributesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identities"]) qsP.appendList(body, prefix+"Identities", params["Identities"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityVerificationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetIdentityVerificationAttributesResult");
    return {
      VerificationAttributes: xmlP.readXmlMap(xml.getList("VerificationAttributes", "entry"), IdentityVerificationAttributes_Parse, {}),
    };
  }

  async getSendQuota(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetSendQuotaResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSendQuota",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetSendQuotaResult");
    return {
      Max24HourSend: xml.first("Max24HourSend", false, x => parseFloat(x.content ?? '0')),
      MaxSendRate: xml.first("MaxSendRate", false, x => parseFloat(x.content ?? '0')),
      SentLast24Hours: xml.first("SentLast24Hours", false, x => parseFloat(x.content ?? '0')),
    };
  }

  async getSendStatistics(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetSendStatisticsResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSendStatistics",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetSendStatisticsResult");
    return {
      SendDataPoints: xml.getList("SendDataPoints", "member").map(SendDataPoint_Parse),
    };
  }

  async getTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetTemplateRequest,
  ): Promise<s.GetTemplateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetTemplateResult");
    return {
      Template: xml.first("Template", false, Template_Parse),
    };
  }

  async listConfigurationSets(
    {abortSignal, ...params}: RequestConfig & s.ListConfigurationSetsRequest = {},
  ): Promise<s.ListConfigurationSetsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListConfigurationSets",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListConfigurationSetsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      ConfigurationSets: xml.getList("ConfigurationSets", "member").map(ConfigurationSet_Parse),
    };
  }

  async listCustomVerificationEmailTemplates(
    {abortSignal, ...params}: RequestConfig & s.ListCustomVerificationEmailTemplatesRequest = {},
  ): Promise<s.ListCustomVerificationEmailTemplatesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCustomVerificationEmailTemplates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListCustomVerificationEmailTemplatesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      CustomVerificationEmailTemplates: xml.getList("CustomVerificationEmailTemplates", "member").map(CustomVerificationEmailTemplate_Parse),
    };
  }

  async listIdentities(
    {abortSignal, ...params}: RequestConfig & s.ListIdentitiesRequest = {},
  ): Promise<s.ListIdentitiesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("IdentityType" in params) body.append(prefix+"IdentityType", (params["IdentityType"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListIdentities",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListIdentitiesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Identities: xml.getList("Identities", "member").map(x => x.content ?? ''),
    };
  }

  async listIdentityPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListIdentityPoliciesRequest,
  ): Promise<s.ListIdentityPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListIdentityPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListIdentityPoliciesResult");
    return {
      PolicyNames: xml.getList("PolicyNames", "member").map(x => x.content ?? ''),
    };
  }

  async listReceiptFilters(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.ListReceiptFiltersResponse> {
    const body = new URLSearchParams;
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReceiptFilters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListReceiptFiltersResult");
    return {
      Filters: xml.getList("Filters", "member").map(ReceiptFilter_Parse),
    };
  }

  async listReceiptRuleSets(
    {abortSignal, ...params}: RequestConfig & s.ListReceiptRuleSetsRequest = {},
  ): Promise<s.ListReceiptRuleSetsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReceiptRuleSets",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListReceiptRuleSetsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      RuleSets: xml.getList("RuleSets", "member").map(ReceiptRuleSetMetadata_Parse),
    };
  }

  async listTemplates(
    {abortSignal, ...params}: RequestConfig & s.ListTemplatesRequest = {},
  ): Promise<s.ListTemplatesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTemplates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTemplatesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      TemplatesMetadata: xml.getList("TemplatesMetadata", "member").map(TemplateMetadata_Parse),
    };
  }

  async listVerifiedEmailAddresses(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.ListVerifiedEmailAddressesResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListVerifiedEmailAddresses",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListVerifiedEmailAddressesResult");
    return {
      VerifiedEmailAddresses: xml.getList("VerifiedEmailAddresses", "member").map(x => x.content ?? ''),
    };
  }

  async putConfigurationSetDeliveryOptions(
    {abortSignal, ...params}: RequestConfig & s.PutConfigurationSetDeliveryOptionsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    if (params["DeliveryOptions"] != null) DeliveryOptions_Serialize(body, prefix+"DeliveryOptions", params["DeliveryOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutConfigurationSetDeliveryOptions",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putIdentityPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutIdentityPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"Policy", (params["Policy"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutIdentityPolicy",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async reorderReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & s.ReorderReceiptRuleSetRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    if (params["RuleNames"]) qsP.appendList(body, prefix+"RuleNames", params["RuleNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReorderReceiptRuleSet",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async sendBounce(
    {abortSignal, ...params}: RequestConfig & s.SendBounceRequest,
  ): Promise<s.SendBounceResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OriginalMessageId", (params["OriginalMessageId"] ?? '').toString());
    body.append(prefix+"BounceSender", (params["BounceSender"] ?? '').toString());
    if ("Explanation" in params) body.append(prefix+"Explanation", (params["Explanation"] ?? '').toString());
    if (params["MessageDsn"] != null) MessageDsn_Serialize(body, prefix+"MessageDsn", params["MessageDsn"]);
    if (params["BouncedRecipientInfoList"]) qsP.appendList(body, prefix+"BouncedRecipientInfoList", params["BouncedRecipientInfoList"], {"appender":BouncedRecipientInfo_Serialize,"entryPrefix":".member."})
    if ("BounceSenderArn" in params) body.append(prefix+"BounceSenderArn", (params["BounceSenderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendBounce",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SendBounceResult");
    return xml.strings({
      optional: {"MessageId":true},
    });
  }

  async sendBulkTemplatedEmail(
    {abortSignal, ...params}: RequestConfig & s.SendBulkTemplatedEmailRequest,
  ): Promise<s.SendBulkTemplatedEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if ("SourceArn" in params) body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    if (params["ReplyToAddresses"]) qsP.appendList(body, prefix+"ReplyToAddresses", params["ReplyToAddresses"], {"entryPrefix":".member."})
    if ("ReturnPath" in params) body.append(prefix+"ReturnPath", (params["ReturnPath"] ?? '').toString());
    if ("ReturnPathArn" in params) body.append(prefix+"ReturnPathArn", (params["ReturnPathArn"] ?? '').toString());
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    if (params["DefaultTags"]) qsP.appendList(body, prefix+"DefaultTags", params["DefaultTags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
    body.append(prefix+"Template", (params["Template"] ?? '').toString());
    if ("TemplateArn" in params) body.append(prefix+"TemplateArn", (params["TemplateArn"] ?? '').toString());
    if ("DefaultTemplateData" in params) body.append(prefix+"DefaultTemplateData", (params["DefaultTemplateData"] ?? '').toString());
    if (params["Destinations"]) qsP.appendList(body, prefix+"Destinations", params["Destinations"], {"appender":BulkEmailDestination_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendBulkTemplatedEmail",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SendBulkTemplatedEmailResult");
    return {
      Status: xml.getList("Status", "member").map(BulkEmailDestinationStatus_Parse),
    };
  }

  async sendCustomVerificationEmail(
    {abortSignal, ...params}: RequestConfig & s.SendCustomVerificationEmailRequest,
  ): Promise<s.SendCustomVerificationEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EmailAddress", (params["EmailAddress"] ?? '').toString());
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendCustomVerificationEmail",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SendCustomVerificationEmailResult");
    return xml.strings({
      optional: {"MessageId":true},
    });
  }

  async sendEmail(
    {abortSignal, ...params}: RequestConfig & s.SendEmailRequest,
  ): Promise<s.SendEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Source", (params["Source"] ?? '').toString());
    Destination_Serialize(body, prefix+"Destination", params["Destination"]);
    Message_Serialize(body, prefix+"Message", params["Message"]);
    if (params["ReplyToAddresses"]) qsP.appendList(body, prefix+"ReplyToAddresses", params["ReplyToAddresses"], {"entryPrefix":".member."})
    if ("ReturnPath" in params) body.append(prefix+"ReturnPath", (params["ReturnPath"] ?? '').toString());
    if ("SourceArn" in params) body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    if ("ReturnPathArn" in params) body.append(prefix+"ReturnPathArn", (params["ReturnPathArn"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendEmail",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SendEmailResult");
    return xml.strings({
      required: {"MessageId":true},
    });
  }

  async sendRawEmail(
    {abortSignal, ...params}: RequestConfig & s.SendRawEmailRequest,
  ): Promise<s.SendRawEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if (params["Destinations"]) qsP.appendList(body, prefix+"Destinations", params["Destinations"], {"entryPrefix":".member."})
    RawMessage_Serialize(body, prefix+"RawMessage", params["RawMessage"]);
    if ("FromArn" in params) body.append(prefix+"FromArn", (params["FromArn"] ?? '').toString());
    if ("SourceArn" in params) body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    if ("ReturnPathArn" in params) body.append(prefix+"ReturnPathArn", (params["ReturnPathArn"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendRawEmail",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SendRawEmailResult");
    return xml.strings({
      required: {"MessageId":true},
    });
  }

  async sendTemplatedEmail(
    {abortSignal, ...params}: RequestConfig & s.SendTemplatedEmailRequest,
  ): Promise<s.SendTemplatedEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Source", (params["Source"] ?? '').toString());
    Destination_Serialize(body, prefix+"Destination", params["Destination"]);
    if (params["ReplyToAddresses"]) qsP.appendList(body, prefix+"ReplyToAddresses", params["ReplyToAddresses"], {"entryPrefix":".member."})
    if ("ReturnPath" in params) body.append(prefix+"ReturnPath", (params["ReturnPath"] ?? '').toString());
    if ("SourceArn" in params) body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    if ("ReturnPathArn" in params) body.append(prefix+"ReturnPathArn", (params["ReturnPathArn"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    body.append(prefix+"Template", (params["Template"] ?? '').toString());
    if ("TemplateArn" in params) body.append(prefix+"TemplateArn", (params["TemplateArn"] ?? '').toString());
    body.append(prefix+"TemplateData", (params["TemplateData"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendTemplatedEmail",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SendTemplatedEmailResult");
    return xml.strings({
      required: {"MessageId":true},
    });
  }

  async setActiveReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & s.SetActiveReceiptRuleSetRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("RuleSetName" in params) body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetActiveReceiptRuleSet",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async setIdentityDkimEnabled(
    {abortSignal, ...params}: RequestConfig & s.SetIdentityDkimEnabledRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"DkimEnabled", (params["DkimEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityDkimEnabled",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async setIdentityFeedbackForwardingEnabled(
    {abortSignal, ...params}: RequestConfig & s.SetIdentityFeedbackForwardingEnabledRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"ForwardingEnabled", (params["ForwardingEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityFeedbackForwardingEnabled",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async setIdentityHeadersInNotificationsEnabled(
    {abortSignal, ...params}: RequestConfig & s.SetIdentityHeadersInNotificationsEnabledRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"NotificationType", (params["NotificationType"] ?? '').toString());
    body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityHeadersInNotificationsEnabled",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async setIdentityMailFromDomain(
    {abortSignal, ...params}: RequestConfig & s.SetIdentityMailFromDomainRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    if ("MailFromDomain" in params) body.append(prefix+"MailFromDomain", (params["MailFromDomain"] ?? '').toString());
    if ("BehaviorOnMXFailure" in params) body.append(prefix+"BehaviorOnMXFailure", (params["BehaviorOnMXFailure"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityMailFromDomain",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async setIdentityNotificationTopic(
    {abortSignal, ...params}: RequestConfig & s.SetIdentityNotificationTopicRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"NotificationType", (params["NotificationType"] ?? '').toString());
    if ("SnsTopic" in params) body.append(prefix+"SnsTopic", (params["SnsTopic"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityNotificationTopic",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async setReceiptRulePosition(
    {abortSignal, ...params}: RequestConfig & s.SetReceiptRulePositionRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    if ("After" in params) body.append(prefix+"After", (params["After"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetReceiptRulePosition",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async testRenderTemplate(
    {abortSignal, ...params}: RequestConfig & s.TestRenderTemplateRequest,
  ): Promise<s.TestRenderTemplateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    body.append(prefix+"TemplateData", (params["TemplateData"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestRenderTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "TestRenderTemplateResult");
    return xml.strings({
      optional: {"RenderedTemplate":true},
    });
  }

  async updateAccountSendingEnabled(
    {abortSignal, ...params}: RequestConfig & s.UpdateAccountSendingEnabledRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccountSendingEnabled",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateConfigurationSetEventDestination(
    {abortSignal, ...params}: RequestConfig & s.UpdateConfigurationSetEventDestinationRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    EventDestination_Serialize(body, prefix+"EventDestination", params["EventDestination"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfigurationSetEventDestination",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateConfigurationSetReputationMetricsEnabled(
    {abortSignal, ...params}: RequestConfig & s.UpdateConfigurationSetReputationMetricsEnabledRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfigurationSetReputationMetricsEnabled",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateConfigurationSetSendingEnabled(
    {abortSignal, ...params}: RequestConfig & s.UpdateConfigurationSetSendingEnabledRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfigurationSetSendingEnabled",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateConfigurationSetTrackingOptions(
    {abortSignal, ...params}: RequestConfig & s.UpdateConfigurationSetTrackingOptionsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    TrackingOptions_Serialize(body, prefix+"TrackingOptions", params["TrackingOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfigurationSetTrackingOptions",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateCustomVerificationEmailTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateCustomVerificationEmailTemplateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("FromEmailAddress" in params) body.append(prefix+"FromEmailAddress", (params["FromEmailAddress"] ?? '').toString());
    if ("TemplateSubject" in params) body.append(prefix+"TemplateSubject", (params["TemplateSubject"] ?? '').toString());
    if ("TemplateContent" in params) body.append(prefix+"TemplateContent", (params["TemplateContent"] ?? '').toString());
    if ("SuccessRedirectionURL" in params) body.append(prefix+"SuccessRedirectionURL", (params["SuccessRedirectionURL"] ?? '').toString());
    if ("FailureRedirectionURL" in params) body.append(prefix+"FailureRedirectionURL", (params["FailureRedirectionURL"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCustomVerificationEmailTemplate",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateReceiptRule(
    {abortSignal, ...params}: RequestConfig & s.UpdateReceiptRuleRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    ReceiptRule_Serialize(body, prefix+"Rule", params["Rule"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateReceiptRule",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateTemplateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    Template_Serialize(body, prefix+"Template", params["Template"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTemplate",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async verifyDomainDkim(
    {abortSignal, ...params}: RequestConfig & s.VerifyDomainDkimRequest,
  ): Promise<s.VerifyDomainDkimResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyDomainDkim",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "VerifyDomainDkimResult");
    return {
      DkimTokens: xml.getList("DkimTokens", "member").map(x => x.content ?? ''),
    };
  }

  async verifyDomainIdentity(
    {abortSignal, ...params}: RequestConfig & s.VerifyDomainIdentityRequest,
  ): Promise<s.VerifyDomainIdentityResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyDomainIdentity",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "VerifyDomainIdentityResult");
    return xml.strings({
      required: {"VerificationToken":true},
    });
  }

  async verifyEmailAddress(
    {abortSignal, ...params}: RequestConfig & s.VerifyEmailAddressRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EmailAddress", (params["EmailAddress"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyEmailAddress",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async verifyEmailIdentity(
    {abortSignal, ...params}: RequestConfig & s.VerifyEmailIdentityRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EmailAddress", (params["EmailAddress"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyEmailIdentity",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 3 seconds apart (about 1 minutes max wait time). */
  async waitForIdentityExists(
    params: RequestConfig & s.GetIdentityVerificationAttributesRequest,
  ): Promise<s.GetIdentityVerificationAttributesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state IdentityExists';
    for (let i = 0; i < 20; i++) {
      const resp = await this.getIdentityVerificationAttributes(params);
      if (Object.values(resp?.VerificationAttributes).map(x => x?.VerificationStatus)?.every(x => x === "Success")) return resp;
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

}

function ConfigurationSet_Serialize(body: URLSearchParams, prefix: string, params: s.ConfigurationSet) {
  body.append(prefix+".Name", (params["Name"] ?? '').toString());
}
function ConfigurationSet_Parse(node: xmlP.XmlNode): s.ConfigurationSet {
  return node.strings({
    required: {"Name":true},
  });
}

function EventDestination_Serialize(body: URLSearchParams, prefix: string, params: s.EventDestination) {
  body.append(prefix+".Name", (params["Name"] ?? '').toString());
  if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
  if (params["MatchingEventTypes"]) qsP.appendList(body, prefix+".MatchingEventTypes", params["MatchingEventTypes"], {"entryPrefix":".member."})
  if (params["KinesisFirehoseDestination"] != null) KinesisFirehoseDestination_Serialize(body, prefix+".KinesisFirehoseDestination", params["KinesisFirehoseDestination"]);
  if (params["CloudWatchDestination"] != null) CloudWatchDestination_Serialize(body, prefix+".CloudWatchDestination", params["CloudWatchDestination"]);
  if (params["SNSDestination"] != null) SNSDestination_Serialize(body, prefix+".SNSDestination", params["SNSDestination"]);
}
function EventDestination_Parse(node: xmlP.XmlNode): s.EventDestination {
  return {
    ...node.strings({
      required: {"Name":true},
    }),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    MatchingEventTypes: node.getList("MatchingEventTypes", "member").map(x => (x.content ?? '') as s.EventType),
    KinesisFirehoseDestination: node.first("KinesisFirehoseDestination", false, KinesisFirehoseDestination_Parse),
    CloudWatchDestination: node.first("CloudWatchDestination", false, CloudWatchDestination_Parse),
    SNSDestination: node.first("SNSDestination", false, SNSDestination_Parse),
  };
}

function KinesisFirehoseDestination_Serialize(body: URLSearchParams, prefix: string, params: s.KinesisFirehoseDestination) {
  body.append(prefix+".IAMRoleARN", (params["IAMRoleARN"] ?? '').toString());
  body.append(prefix+".DeliveryStreamARN", (params["DeliveryStreamARN"] ?? '').toString());
}
function KinesisFirehoseDestination_Parse(node: xmlP.XmlNode): s.KinesisFirehoseDestination {
  return node.strings({
    required: {"IAMRoleARN":true,"DeliveryStreamARN":true},
  });
}

function CloudWatchDestination_Serialize(body: URLSearchParams, prefix: string, params: s.CloudWatchDestination) {
  if (params["DimensionConfigurations"]) qsP.appendList(body, prefix+".DimensionConfigurations", params["DimensionConfigurations"], {"appender":CloudWatchDimensionConfiguration_Serialize,"entryPrefix":".member."})
}
function CloudWatchDestination_Parse(node: xmlP.XmlNode): s.CloudWatchDestination {
  return {
    DimensionConfigurations: node.getList("DimensionConfigurations", "member").map(CloudWatchDimensionConfiguration_Parse),
  };
}

function CloudWatchDimensionConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.CloudWatchDimensionConfiguration) {
  body.append(prefix+".DimensionName", (params["DimensionName"] ?? '').toString());
  body.append(prefix+".DimensionValueSource", (params["DimensionValueSource"] ?? '').toString());
  body.append(prefix+".DefaultDimensionValue", (params["DefaultDimensionValue"] ?? '').toString());
}
function CloudWatchDimensionConfiguration_Parse(node: xmlP.XmlNode): s.CloudWatchDimensionConfiguration {
  return {
    ...node.strings({
      required: {"DimensionName":true,"DefaultDimensionValue":true},
    }),
    DimensionValueSource: node.first("DimensionValueSource", true, x => (x.content ?? '') as s.DimensionValueSource),
  };
}

function SNSDestination_Serialize(body: URLSearchParams, prefix: string, params: s.SNSDestination) {
  body.append(prefix+".TopicARN", (params["TopicARN"] ?? '').toString());
}
function SNSDestination_Parse(node: xmlP.XmlNode): s.SNSDestination {
  return node.strings({
    required: {"TopicARN":true},
  });
}

function TrackingOptions_Serialize(body: URLSearchParams, prefix: string, params: s.TrackingOptions) {
  if ("CustomRedirectDomain" in params) body.append(prefix+".CustomRedirectDomain", (params["CustomRedirectDomain"] ?? '').toString());
}
function TrackingOptions_Parse(node: xmlP.XmlNode): s.TrackingOptions {
  return node.strings({
    optional: {"CustomRedirectDomain":true},
  });
}

function ReceiptFilter_Serialize(body: URLSearchParams, prefix: string, params: s.ReceiptFilter) {
  body.append(prefix+".Name", (params["Name"] ?? '').toString());
  ReceiptIpFilter_Serialize(body, prefix+".IpFilter", params["IpFilter"]);
}
function ReceiptFilter_Parse(node: xmlP.XmlNode): s.ReceiptFilter {
  return {
    ...node.strings({
      required: {"Name":true},
    }),
    IpFilter: node.first("IpFilter", true, ReceiptIpFilter_Parse),
  };
}

function ReceiptIpFilter_Serialize(body: URLSearchParams, prefix: string, params: s.ReceiptIpFilter) {
  body.append(prefix+".Policy", (params["Policy"] ?? '').toString());
  body.append(prefix+".Cidr", (params["Cidr"] ?? '').toString());
}
function ReceiptIpFilter_Parse(node: xmlP.XmlNode): s.ReceiptIpFilter {
  return {
    ...node.strings({
      required: {"Cidr":true},
    }),
    Policy: node.first("Policy", true, x => (x.content ?? '') as s.ReceiptFilterPolicy),
  };
}

function ReceiptRule_Serialize(body: URLSearchParams, prefix: string, params: s.ReceiptRule) {
  body.append(prefix+".Name", (params["Name"] ?? '').toString());
  if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
  if ("TlsPolicy" in params) body.append(prefix+".TlsPolicy", (params["TlsPolicy"] ?? '').toString());
  if (params["Recipients"]) qsP.appendList(body, prefix+".Recipients", params["Recipients"], {"entryPrefix":".member."})
  if (params["Actions"]) qsP.appendList(body, prefix+".Actions", params["Actions"], {"appender":ReceiptAction_Serialize,"entryPrefix":".member."})
  if ("ScanEnabled" in params) body.append(prefix+".ScanEnabled", (params["ScanEnabled"] ?? '').toString());
}
function ReceiptRule_Parse(node: xmlP.XmlNode): s.ReceiptRule {
  return {
    ...node.strings({
      required: {"Name":true},
    }),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    TlsPolicy: node.first("TlsPolicy", false, x => (x.content ?? '') as s.TlsPolicy),
    Recipients: node.getList("Recipients", "member").map(x => x.content ?? ''),
    Actions: node.getList("Actions", "member").map(ReceiptAction_Parse),
    ScanEnabled: node.first("ScanEnabled", false, x => x.content === 'true'),
  };
}

function ReceiptAction_Serialize(body: URLSearchParams, prefix: string, params: s.ReceiptAction) {
  if (params["S3Action"] != null) S3Action_Serialize(body, prefix+".S3Action", params["S3Action"]);
  if (params["BounceAction"] != null) BounceAction_Serialize(body, prefix+".BounceAction", params["BounceAction"]);
  if (params["WorkmailAction"] != null) WorkmailAction_Serialize(body, prefix+".WorkmailAction", params["WorkmailAction"]);
  if (params["LambdaAction"] != null) LambdaAction_Serialize(body, prefix+".LambdaAction", params["LambdaAction"]);
  if (params["StopAction"] != null) StopAction_Serialize(body, prefix+".StopAction", params["StopAction"]);
  if (params["AddHeaderAction"] != null) AddHeaderAction_Serialize(body, prefix+".AddHeaderAction", params["AddHeaderAction"]);
  if (params["SNSAction"] != null) SNSAction_Serialize(body, prefix+".SNSAction", params["SNSAction"]);
}
function ReceiptAction_Parse(node: xmlP.XmlNode): s.ReceiptAction {
  return {
    S3Action: node.first("S3Action", false, S3Action_Parse),
    BounceAction: node.first("BounceAction", false, BounceAction_Parse),
    WorkmailAction: node.first("WorkmailAction", false, WorkmailAction_Parse),
    LambdaAction: node.first("LambdaAction", false, LambdaAction_Parse),
    StopAction: node.first("StopAction", false, StopAction_Parse),
    AddHeaderAction: node.first("AddHeaderAction", false, AddHeaderAction_Parse),
    SNSAction: node.first("SNSAction", false, SNSAction_Parse),
  };
}

function S3Action_Serialize(body: URLSearchParams, prefix: string, params: s.S3Action) {
  if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
  body.append(prefix+".BucketName", (params["BucketName"] ?? '').toString());
  if ("ObjectKeyPrefix" in params) body.append(prefix+".ObjectKeyPrefix", (params["ObjectKeyPrefix"] ?? '').toString());
  if ("KmsKeyArn" in params) body.append(prefix+".KmsKeyArn", (params["KmsKeyArn"] ?? '').toString());
}
function S3Action_Parse(node: xmlP.XmlNode): s.S3Action {
  return node.strings({
    required: {"BucketName":true},
    optional: {"TopicArn":true,"ObjectKeyPrefix":true,"KmsKeyArn":true},
  });
}

function BounceAction_Serialize(body: URLSearchParams, prefix: string, params: s.BounceAction) {
  if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
  body.append(prefix+".SmtpReplyCode", (params["SmtpReplyCode"] ?? '').toString());
  if ("StatusCode" in params) body.append(prefix+".StatusCode", (params["StatusCode"] ?? '').toString());
  body.append(prefix+".Message", (params["Message"] ?? '').toString());
  body.append(prefix+".Sender", (params["Sender"] ?? '').toString());
}
function BounceAction_Parse(node: xmlP.XmlNode): s.BounceAction {
  return node.strings({
    required: {"SmtpReplyCode":true,"Message":true,"Sender":true},
    optional: {"TopicArn":true,"StatusCode":true},
  });
}

function WorkmailAction_Serialize(body: URLSearchParams, prefix: string, params: s.WorkmailAction) {
  if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
  body.append(prefix+".OrganizationArn", (params["OrganizationArn"] ?? '').toString());
}
function WorkmailAction_Parse(node: xmlP.XmlNode): s.WorkmailAction {
  return node.strings({
    required: {"OrganizationArn":true},
    optional: {"TopicArn":true},
  });
}

function LambdaAction_Serialize(body: URLSearchParams, prefix: string, params: s.LambdaAction) {
  if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
  body.append(prefix+".FunctionArn", (params["FunctionArn"] ?? '').toString());
  if ("InvocationType" in params) body.append(prefix+".InvocationType", (params["InvocationType"] ?? '').toString());
}
function LambdaAction_Parse(node: xmlP.XmlNode): s.LambdaAction {
  return {
    ...node.strings({
      required: {"FunctionArn":true},
      optional: {"TopicArn":true},
    }),
    InvocationType: node.first("InvocationType", false, x => (x.content ?? '') as s.InvocationType),
  };
}

function StopAction_Serialize(body: URLSearchParams, prefix: string, params: s.StopAction) {
  body.append(prefix+".Scope", (params["Scope"] ?? '').toString());
  if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
}
function StopAction_Parse(node: xmlP.XmlNode): s.StopAction {
  return {
    ...node.strings({
      optional: {"TopicArn":true},
    }),
    Scope: node.first("Scope", true, x => (x.content ?? '') as s.StopScope),
  };
}

function AddHeaderAction_Serialize(body: URLSearchParams, prefix: string, params: s.AddHeaderAction) {
  body.append(prefix+".HeaderName", (params["HeaderName"] ?? '').toString());
  body.append(prefix+".HeaderValue", (params["HeaderValue"] ?? '').toString());
}
function AddHeaderAction_Parse(node: xmlP.XmlNode): s.AddHeaderAction {
  return node.strings({
    required: {"HeaderName":true,"HeaderValue":true},
  });
}

function SNSAction_Serialize(body: URLSearchParams, prefix: string, params: s.SNSAction) {
  body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
  if ("Encoding" in params) body.append(prefix+".Encoding", (params["Encoding"] ?? '').toString());
}
function SNSAction_Parse(node: xmlP.XmlNode): s.SNSAction {
  return {
    ...node.strings({
      required: {"TopicArn":true},
    }),
    Encoding: node.first("Encoding", false, x => (x.content ?? '') as s.SNSActionEncoding),
  };
}

function Template_Serialize(body: URLSearchParams, prefix: string, params: s.Template) {
  body.append(prefix+".TemplateName", (params["TemplateName"] ?? '').toString());
  if ("SubjectPart" in params) body.append(prefix+".SubjectPart", (params["SubjectPart"] ?? '').toString());
  if ("TextPart" in params) body.append(prefix+".TextPart", (params["TextPart"] ?? '').toString());
  if ("HtmlPart" in params) body.append(prefix+".HtmlPart", (params["HtmlPart"] ?? '').toString());
}
function Template_Parse(node: xmlP.XmlNode): s.Template {
  return node.strings({
    required: {"TemplateName":true},
    optional: {"SubjectPart":true,"TextPart":true,"HtmlPart":true},
  });
}

function DeliveryOptions_Serialize(body: URLSearchParams, prefix: string, params: s.DeliveryOptions) {
  if ("TlsPolicy" in params) body.append(prefix+".TlsPolicy", (params["TlsPolicy"] ?? '').toString());
}
function DeliveryOptions_Parse(node: xmlP.XmlNode): s.DeliveryOptions {
  return {
    TlsPolicy: node.first("TlsPolicy", false, x => (x.content ?? '') as s.TlsPolicy),
  };
}

function MessageDsn_Serialize(body: URLSearchParams, prefix: string, params: s.MessageDsn) {
  body.append(prefix+".ReportingMta", (params["ReportingMta"] ?? '').toString());
  if ("ArrivalDate" in params) body.append(prefix+".ArrivalDate", qsP.encodeDate_iso8601(params["ArrivalDate"]));
  if (params["ExtensionFields"]) qsP.appendList(body, prefix+".ExtensionFields", params["ExtensionFields"], {"appender":ExtensionField_Serialize,"entryPrefix":".member."})
}

function ExtensionField_Serialize(body: URLSearchParams, prefix: string, params: s.ExtensionField) {
  body.append(prefix+".Name", (params["Name"] ?? '').toString());
  body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function BouncedRecipientInfo_Serialize(body: URLSearchParams, prefix: string, params: s.BouncedRecipientInfo) {
  body.append(prefix+".Recipient", (params["Recipient"] ?? '').toString());
  if ("RecipientArn" in params) body.append(prefix+".RecipientArn", (params["RecipientArn"] ?? '').toString());
  if ("BounceType" in params) body.append(prefix+".BounceType", (params["BounceType"] ?? '').toString());
  if (params["RecipientDsnFields"] != null) RecipientDsnFields_Serialize(body, prefix+".RecipientDsnFields", params["RecipientDsnFields"]);
}

function RecipientDsnFields_Serialize(body: URLSearchParams, prefix: string, params: s.RecipientDsnFields) {
  if ("FinalRecipient" in params) body.append(prefix+".FinalRecipient", (params["FinalRecipient"] ?? '').toString());
  body.append(prefix+".Action", (params["Action"] ?? '').toString());
  if ("RemoteMta" in params) body.append(prefix+".RemoteMta", (params["RemoteMta"] ?? '').toString());
  body.append(prefix+".Status", (params["Status"] ?? '').toString());
  if ("DiagnosticCode" in params) body.append(prefix+".DiagnosticCode", (params["DiagnosticCode"] ?? '').toString());
  if ("LastAttemptDate" in params) body.append(prefix+".LastAttemptDate", qsP.encodeDate_iso8601(params["LastAttemptDate"]));
  if (params["ExtensionFields"]) qsP.appendList(body, prefix+".ExtensionFields", params["ExtensionFields"], {"appender":ExtensionField_Serialize,"entryPrefix":".member."})
}

function MessageTag_Serialize(body: URLSearchParams, prefix: string, params: s.MessageTag) {
  body.append(prefix+".Name", (params["Name"] ?? '').toString());
  body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function BulkEmailDestination_Serialize(body: URLSearchParams, prefix: string, params: s.BulkEmailDestination) {
  Destination_Serialize(body, prefix+".Destination", params["Destination"]);
  if (params["ReplacementTags"]) qsP.appendList(body, prefix+".ReplacementTags", params["ReplacementTags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
  if ("ReplacementTemplateData" in params) body.append(prefix+".ReplacementTemplateData", (params["ReplacementTemplateData"] ?? '').toString());
}

function Destination_Serialize(body: URLSearchParams, prefix: string, params: s.Destination) {
  if (params["ToAddresses"]) qsP.appendList(body, prefix+".ToAddresses", params["ToAddresses"], {"entryPrefix":".member."})
  if (params["CcAddresses"]) qsP.appendList(body, prefix+".CcAddresses", params["CcAddresses"], {"entryPrefix":".member."})
  if (params["BccAddresses"]) qsP.appendList(body, prefix+".BccAddresses", params["BccAddresses"], {"entryPrefix":".member."})
}

function Message_Serialize(body: URLSearchParams, prefix: string, params: s.Message) {
  Content_Serialize(body, prefix+".Subject", params["Subject"]);
  Body_Serialize(body, prefix+".Body", params["Body"]);
}

function Content_Serialize(body: URLSearchParams, prefix: string, params: s.Content) {
  body.append(prefix+".Data", (params["Data"] ?? '').toString());
  if ("Charset" in params) body.append(prefix+".Charset", (params["Charset"] ?? '').toString());
}

function Body_Serialize(body: URLSearchParams, prefix: string, params: s.Body) {
  if (params["Text"] != null) Content_Serialize(body, prefix+".Text", params["Text"]);
  if (params["Html"] != null) Content_Serialize(body, prefix+".Html", params["Html"]);
}

function RawMessage_Serialize(body: URLSearchParams, prefix: string, params: s.RawMessage) {
  body.append(prefix+".Data", serializeBlob(params["Data"]) ?? '');
}

function ReceiptRuleSetMetadata_Parse(node: xmlP.XmlNode): s.ReceiptRuleSetMetadata {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    CreatedTimestamp: node.first("CreatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ReputationOptions_Parse(node: xmlP.XmlNode): s.ReputationOptions {
  return {
    SendingEnabled: node.first("SendingEnabled", false, x => x.content === 'true'),
    ReputationMetricsEnabled: node.first("ReputationMetricsEnabled", false, x => x.content === 'true'),
    LastFreshStart: node.first("LastFreshStart", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function IdentityDkimAttributes_Parse(node: xmlP.XmlNode): s.IdentityDkimAttributes {
  return {
    DkimEnabled: node.first("DkimEnabled", true, x => x.content === 'true'),
    DkimVerificationStatus: node.first("DkimVerificationStatus", true, x => (x.content ?? '') as s.VerificationStatus),
    DkimTokens: node.getList("DkimTokens", "member").map(x => x.content ?? ''),
  };
}

function IdentityMailFromDomainAttributes_Parse(node: xmlP.XmlNode): s.IdentityMailFromDomainAttributes {
  return {
    ...node.strings({
      required: {"MailFromDomain":true},
    }),
    MailFromDomainStatus: node.first("MailFromDomainStatus", true, x => (x.content ?? '') as s.CustomMailFromStatus),
    BehaviorOnMXFailure: node.first("BehaviorOnMXFailure", true, x => (x.content ?? '') as s.BehaviorOnMXFailure),
  };
}

function IdentityNotificationAttributes_Parse(node: xmlP.XmlNode): s.IdentityNotificationAttributes {
  return {
    ...node.strings({
      required: {"BounceTopic":true,"ComplaintTopic":true,"DeliveryTopic":true},
    }),
    ForwardingEnabled: node.first("ForwardingEnabled", true, x => x.content === 'true'),
    HeadersInBounceNotificationsEnabled: node.first("HeadersInBounceNotificationsEnabled", false, x => x.content === 'true'),
    HeadersInComplaintNotificationsEnabled: node.first("HeadersInComplaintNotificationsEnabled", false, x => x.content === 'true'),
    HeadersInDeliveryNotificationsEnabled: node.first("HeadersInDeliveryNotificationsEnabled", false, x => x.content === 'true'),
  };
}

function IdentityVerificationAttributes_Parse(node: xmlP.XmlNode): s.IdentityVerificationAttributes {
  return {
    ...node.strings({
      optional: {"VerificationToken":true},
    }),
    VerificationStatus: node.first("VerificationStatus", true, x => (x.content ?? '') as s.VerificationStatus),
  };
}

function SendDataPoint_Parse(node: xmlP.XmlNode): s.SendDataPoint {
  return {
    Timestamp: node.first("Timestamp", false, x => xmlP.parseTimestamp(x.content)),
    DeliveryAttempts: node.first("DeliveryAttempts", false, x => parseInt(x.content ?? '0')),
    Bounces: node.first("Bounces", false, x => parseInt(x.content ?? '0')),
    Complaints: node.first("Complaints", false, x => parseInt(x.content ?? '0')),
    Rejects: node.first("Rejects", false, x => parseInt(x.content ?? '0')),
  };
}

function CustomVerificationEmailTemplate_Parse(node: xmlP.XmlNode): s.CustomVerificationEmailTemplate {
  return node.strings({
    optional: {"TemplateName":true,"FromEmailAddress":true,"TemplateSubject":true,"SuccessRedirectionURL":true,"FailureRedirectionURL":true},
  });
}

function TemplateMetadata_Parse(node: xmlP.XmlNode): s.TemplateMetadata {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    CreatedTimestamp: node.first("CreatedTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function BulkEmailDestinationStatus_Parse(node: xmlP.XmlNode): s.BulkEmailDestinationStatus {
  return {
    ...node.strings({
      optional: {"Error":true,"MessageId":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as s.BulkEmailStatus),
  };
}
