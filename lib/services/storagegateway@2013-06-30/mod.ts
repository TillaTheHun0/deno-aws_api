// Autogenerated API client for: AWS Storage Gateway

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class StorageGateway {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(StorageGateway.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2013-06-30",
    "endpointPrefix": "storagegateway",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Storage Gateway",
    "serviceId": "Storage Gateway",
    "signatureVersion": "v4",
    "targetPrefix": "StorageGateway_20130630",
    "uid": "storagegateway-2013-06-30"
  };

  async activateGateway(
    {abortSignal, ...params}: RequestConfig & s.ActivateGatewayInput,
  ): Promise<s.ActivateGatewayOutput> {
    const body: jsonP.JSONObject = {
      ActivationKey: params["ActivationKey"],
      GatewayName: params["GatewayName"],
      GatewayTimezone: params["GatewayTimezone"],
      GatewayRegion: params["GatewayRegion"],
      GatewayType: params["GatewayType"],
      TapeDriveType: params["TapeDriveType"],
      MediumChangerType: params["MediumChangerType"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ActivateGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async addCache(
    {abortSignal, ...params}: RequestConfig & s.AddCacheInput,
  ): Promise<s.AddCacheOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DiskIds: params["DiskIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & s.AddTagsToResourceInput,
  ): Promise<s.AddTagsToResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceARN": "s",
      },
    }, await resp.json());
  }

  async addUploadBuffer(
    {abortSignal, ...params}: RequestConfig & s.AddUploadBufferInput,
  ): Promise<s.AddUploadBufferOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DiskIds: params["DiskIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddUploadBuffer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async addWorkingStorage(
    {abortSignal, ...params}: RequestConfig & s.AddWorkingStorageInput,
  ): Promise<s.AddWorkingStorageOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DiskIds: params["DiskIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddWorkingStorage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async assignTapePool(
    {abortSignal, ...params}: RequestConfig & s.AssignTapePoolInput,
  ): Promise<s.AssignTapePoolOutput> {
    const body: jsonP.JSONObject = {
      TapeARN: params["TapeARN"],
      PoolId: params["PoolId"],
      BypassGovernanceRetention: params["BypassGovernanceRetention"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignTapePool",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async attachVolume(
    {abortSignal, ...params}: RequestConfig & s.AttachVolumeInput,
  ): Promise<s.AttachVolumeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TargetName: params["TargetName"],
      VolumeARN: params["VolumeARN"],
      NetworkInterfaceId: params["NetworkInterfaceId"],
      DiskId: params["DiskId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "TargetARN": "s",
      },
    }, await resp.json());
  }

  async cancelArchival(
    {abortSignal, ...params}: RequestConfig & s.CancelArchivalInput,
  ): Promise<s.CancelArchivalOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeARN: params["TapeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelArchival",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async cancelRetrieval(
    {abortSignal, ...params}: RequestConfig & s.CancelRetrievalInput,
  ): Promise<s.CancelRetrievalOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeARN: params["TapeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelRetrieval",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async createCachediSCSIVolume(
    {abortSignal, ...params}: RequestConfig & s.CreateCachediSCSIVolumeInput,
  ): Promise<s.CreateCachediSCSIVolumeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      VolumeSizeInBytes: params["VolumeSizeInBytes"],
      SnapshotId: params["SnapshotId"],
      TargetName: params["TargetName"],
      SourceVolumeARN: params["SourceVolumeARN"],
      NetworkInterfaceId: params["NetworkInterfaceId"],
      ClientToken: params["ClientToken"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCachediSCSIVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "TargetARN": "s",
      },
    }, await resp.json());
  }

  async createNFSFileShare(
    {abortSignal, ...params}: RequestConfig & s.CreateNFSFileShareInput,
  ): Promise<s.CreateNFSFileShareOutput> {
    const body: jsonP.JSONObject = {
      ClientToken: params["ClientToken"],
      NFSFileShareDefaults: fromNFSFileShareDefaults(params["NFSFileShareDefaults"]),
      GatewayARN: params["GatewayARN"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      Role: params["Role"],
      LocationARN: params["LocationARN"],
      DefaultStorageClass: params["DefaultStorageClass"],
      ObjectACL: params["ObjectACL"],
      ClientList: params["ClientList"],
      Squash: params["Squash"],
      ReadOnly: params["ReadOnly"],
      GuessMIMETypeEnabled: params["GuessMIMETypeEnabled"],
      RequesterPays: params["RequesterPays"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      FileShareName: params["FileShareName"],
      CacheAttributes: fromCacheAttributes(params["CacheAttributes"]),
      NotificationPolicy: params["NotificationPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNFSFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async createSMBFileShare(
    {abortSignal, ...params}: RequestConfig & s.CreateSMBFileShareInput,
  ): Promise<s.CreateSMBFileShareOutput> {
    const body: jsonP.JSONObject = {
      ClientToken: params["ClientToken"],
      GatewayARN: params["GatewayARN"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      Role: params["Role"],
      LocationARN: params["LocationARN"],
      DefaultStorageClass: params["DefaultStorageClass"],
      ObjectACL: params["ObjectACL"],
      ReadOnly: params["ReadOnly"],
      GuessMIMETypeEnabled: params["GuessMIMETypeEnabled"],
      RequesterPays: params["RequesterPays"],
      SMBACLEnabled: params["SMBACLEnabled"],
      AccessBasedEnumeration: params["AccessBasedEnumeration"],
      AdminUserList: params["AdminUserList"],
      ValidUserList: params["ValidUserList"],
      InvalidUserList: params["InvalidUserList"],
      AuditDestinationARN: params["AuditDestinationARN"],
      Authentication: params["Authentication"],
      CaseSensitivity: params["CaseSensitivity"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      FileShareName: params["FileShareName"],
      CacheAttributes: fromCacheAttributes(params["CacheAttributes"]),
      NotificationPolicy: params["NotificationPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSMBFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async createSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateSnapshotInput,
  ): Promise<s.CreateSnapshotOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
      SnapshotDescription: params["SnapshotDescription"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "SnapshotId": "s",
      },
    }, await resp.json());
  }

  async createSnapshotFromVolumeRecoveryPoint(
    {abortSignal, ...params}: RequestConfig & s.CreateSnapshotFromVolumeRecoveryPointInput,
  ): Promise<s.CreateSnapshotFromVolumeRecoveryPointOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
      SnapshotDescription: params["SnapshotDescription"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshotFromVolumeRecoveryPoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SnapshotId": "s",
        "VolumeARN": "s",
        "VolumeRecoveryPointTime": "s",
      },
    }, await resp.json());
  }

  async createStorediSCSIVolume(
    {abortSignal, ...params}: RequestConfig & s.CreateStorediSCSIVolumeInput,
  ): Promise<s.CreateStorediSCSIVolumeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DiskId: params["DiskId"],
      SnapshotId: params["SnapshotId"],
      PreserveExistingData: params["PreserveExistingData"],
      TargetName: params["TargetName"],
      NetworkInterfaceId: params["NetworkInterfaceId"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStorediSCSIVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "VolumeSizeInBytes": "n",
        "TargetARN": "s",
      },
    }, await resp.json());
  }

  async createTapePool(
    {abortSignal, ...params}: RequestConfig & s.CreateTapePoolInput,
  ): Promise<s.CreateTapePoolOutput> {
    const body: jsonP.JSONObject = {
      PoolName: params["PoolName"],
      StorageClass: params["StorageClass"],
      RetentionLockType: params["RetentionLockType"],
      RetentionLockTimeInDays: params["RetentionLockTimeInDays"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTapePool",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PoolARN": "s",
      },
    }, await resp.json());
  }

  async createTapeWithBarcode(
    {abortSignal, ...params}: RequestConfig & s.CreateTapeWithBarcodeInput,
  ): Promise<s.CreateTapeWithBarcodeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeSizeInBytes: params["TapeSizeInBytes"],
      TapeBarcode: params["TapeBarcode"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      PoolId: params["PoolId"],
      Worm: params["Worm"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTapeWithBarcode",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async createTapes(
    {abortSignal, ...params}: RequestConfig & s.CreateTapesInput,
  ): Promise<s.CreateTapesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeSizeInBytes: params["TapeSizeInBytes"],
      ClientToken: params["ClientToken"],
      NumTapesToCreate: params["NumTapesToCreate"],
      TapeBarcodePrefix: params["TapeBarcodePrefix"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      PoolId: params["PoolId"],
      Worm: params["Worm"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTapes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARNs": ["s"],
      },
    }, await resp.json());
  }

  async deleteAutomaticTapeCreationPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteAutomaticTapeCreationPolicyInput,
  ): Promise<s.DeleteAutomaticTapeCreationPolicyOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAutomaticTapeCreationPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async deleteBandwidthRateLimit(
    {abortSignal, ...params}: RequestConfig & s.DeleteBandwidthRateLimitInput,
  ): Promise<s.DeleteBandwidthRateLimitOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      BandwidthType: params["BandwidthType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBandwidthRateLimit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async deleteChapCredentials(
    {abortSignal, ...params}: RequestConfig & s.DeleteChapCredentialsInput,
  ): Promise<s.DeleteChapCredentialsOutput> {
    const body: jsonP.JSONObject = {
      TargetARN: params["TargetARN"],
      InitiatorName: params["InitiatorName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteChapCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TargetARN": "s",
        "InitiatorName": "s",
      },
    }, await resp.json());
  }

  async deleteFileShare(
    {abortSignal, ...params}: RequestConfig & s.DeleteFileShareInput,
  ): Promise<s.DeleteFileShareOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
      ForceDelete: params["ForceDelete"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async deleteGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteGatewayInput,
  ): Promise<s.DeleteGatewayOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async deleteSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & s.DeleteSnapshotScheduleInput,
  ): Promise<s.DeleteSnapshotScheduleOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshotSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
      },
    }, await resp.json());
  }

  async deleteTape(
    {abortSignal, ...params}: RequestConfig & s.DeleteTapeInput,
  ): Promise<s.DeleteTapeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeARN: params["TapeARN"],
      BypassGovernanceRetention: params["BypassGovernanceRetention"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTape",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async deleteTapeArchive(
    {abortSignal, ...params}: RequestConfig & s.DeleteTapeArchiveInput,
  ): Promise<s.DeleteTapeArchiveOutput> {
    const body: jsonP.JSONObject = {
      TapeARN: params["TapeARN"],
      BypassGovernanceRetention: params["BypassGovernanceRetention"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTapeArchive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async deleteTapePool(
    {abortSignal, ...params}: RequestConfig & s.DeleteTapePoolInput,
  ): Promise<s.DeleteTapePoolOutput> {
    const body: jsonP.JSONObject = {
      PoolARN: params["PoolARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTapePool",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PoolARN": "s",
      },
    }, await resp.json());
  }

  async deleteVolume(
    {abortSignal, ...params}: RequestConfig & s.DeleteVolumeInput,
  ): Promise<s.DeleteVolumeOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
      },
    }, await resp.json());
  }

  async describeAvailabilityMonitorTest(
    {abortSignal, ...params}: RequestConfig & s.DescribeAvailabilityMonitorTestInput,
  ): Promise<s.DescribeAvailabilityMonitorTestOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAvailabilityMonitorTest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvailabilityMonitorTestStatus>(x),
        "StartTime": "d",
      },
    }, await resp.json());
  }

  async describeBandwidthRateLimit(
    {abortSignal, ...params}: RequestConfig & s.DescribeBandwidthRateLimitInput,
  ): Promise<s.DescribeBandwidthRateLimitOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBandwidthRateLimit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "AverageUploadRateLimitInBitsPerSec": "n",
        "AverageDownloadRateLimitInBitsPerSec": "n",
      },
    }, await resp.json());
  }

  async describeBandwidthRateLimitSchedule(
    {abortSignal, ...params}: RequestConfig & s.DescribeBandwidthRateLimitScheduleInput,
  ): Promise<s.DescribeBandwidthRateLimitScheduleOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBandwidthRateLimitSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "BandwidthRateLimitIntervals": [toBandwidthRateLimitInterval],
      },
    }, await resp.json());
  }

  async describeCache(
    {abortSignal, ...params}: RequestConfig & s.DescribeCacheInput,
  ): Promise<s.DescribeCacheOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "DiskIds": ["s"],
        "CacheAllocatedInBytes": "n",
        "CacheUsedPercentage": "n",
        "CacheDirtyPercentage": "n",
        "CacheHitPercentage": "n",
        "CacheMissPercentage": "n",
      },
    }, await resp.json());
  }

  async describeCachediSCSIVolumes(
    {abortSignal, ...params}: RequestConfig & s.DescribeCachediSCSIVolumesInput,
  ): Promise<s.DescribeCachediSCSIVolumesOutput> {
    const body: jsonP.JSONObject = {
      VolumeARNs: params["VolumeARNs"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCachediSCSIVolumes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CachediSCSIVolumes": [toCachediSCSIVolume],
      },
    }, await resp.json());
  }

  async describeChapCredentials(
    {abortSignal, ...params}: RequestConfig & s.DescribeChapCredentialsInput,
  ): Promise<s.DescribeChapCredentialsOutput> {
    const body: jsonP.JSONObject = {
      TargetARN: params["TargetARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeChapCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChapCredentials": [toChapInfo],
      },
    }, await resp.json());
  }

  async describeGatewayInformation(
    {abortSignal, ...params}: RequestConfig & s.DescribeGatewayInformationInput,
  ): Promise<s.DescribeGatewayInformationOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGatewayInformation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "GatewayId": "s",
        "GatewayName": "s",
        "GatewayTimezone": "s",
        "GatewayState": "s",
        "GatewayNetworkInterfaces": [toNetworkInterface],
        "GatewayType": "s",
        "NextUpdateAvailabilityDate": "s",
        "LastSoftwareUpdate": "s",
        "Ec2InstanceId": "s",
        "Ec2InstanceRegion": "s",
        "Tags": [toTag],
        "VPCEndpoint": "s",
        "CloudWatchLogGroupARN": "s",
        "HostEnvironment": (x: jsonP.JSONValue) => cmnP.readEnum<s.HostEnvironment>(x),
        "EndpointType": "s",
        "SoftwareUpdatesEndDate": "s",
        "DeprecationDate": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceStartTime(
    {abortSignal, ...params}: RequestConfig & s.DescribeMaintenanceStartTimeInput,
  ): Promise<s.DescribeMaintenanceStartTimeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceStartTime",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "HourOfDay": "n",
        "MinuteOfHour": "n",
        "DayOfWeek": "n",
        "DayOfMonth": "n",
        "Timezone": "s",
      },
    }, await resp.json());
  }

  async describeNFSFileShares(
    {abortSignal, ...params}: RequestConfig & s.DescribeNFSFileSharesInput,
  ): Promise<s.DescribeNFSFileSharesOutput> {
    const body: jsonP.JSONObject = {
      FileShareARNList: params["FileShareARNList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNFSFileShares",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NFSFileShareInfoList": [toNFSFileShareInfo],
      },
    }, await resp.json());
  }

  async describeSMBFileShares(
    {abortSignal, ...params}: RequestConfig & s.DescribeSMBFileSharesInput,
  ): Promise<s.DescribeSMBFileSharesOutput> {
    const body: jsonP.JSONObject = {
      FileShareARNList: params["FileShareARNList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSMBFileShares",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SMBFileShareInfoList": [toSMBFileShareInfo],
      },
    }, await resp.json());
  }

  async describeSMBSettings(
    {abortSignal, ...params}: RequestConfig & s.DescribeSMBSettingsInput,
  ): Promise<s.DescribeSMBSettingsOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSMBSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "DomainName": "s",
        "ActiveDirectoryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActiveDirectoryStatus>(x),
        "SMBGuestPasswordSet": "b",
        "SMBSecurityStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SMBSecurityStrategy>(x),
        "FileSharesVisible": "b",
      },
    }, await resp.json());
  }

  async describeSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & s.DescribeSnapshotScheduleInput,
  ): Promise<s.DescribeSnapshotScheduleOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshotSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "StartAt": "n",
        "RecurrenceInHours": "n",
        "Description": "s",
        "Timezone": "s",
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async describeStorediSCSIVolumes(
    {abortSignal, ...params}: RequestConfig & s.DescribeStorediSCSIVolumesInput,
  ): Promise<s.DescribeStorediSCSIVolumesOutput> {
    const body: jsonP.JSONObject = {
      VolumeARNs: params["VolumeARNs"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStorediSCSIVolumes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StorediSCSIVolumes": [toStorediSCSIVolume],
      },
    }, await resp.json());
  }

  async describeTapeArchives(
    {abortSignal, ...params}: RequestConfig & s.DescribeTapeArchivesInput = {},
  ): Promise<s.DescribeTapeArchivesOutput> {
    const body: jsonP.JSONObject = {
      TapeARNs: params["TapeARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTapeArchives",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeArchives": [toTapeArchive],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeTapeRecoveryPoints(
    {abortSignal, ...params}: RequestConfig & s.DescribeTapeRecoveryPointsInput,
  ): Promise<s.DescribeTapeRecoveryPointsOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTapeRecoveryPoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "TapeRecoveryPointInfos": [toTapeRecoveryPointInfo],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeTapes(
    {abortSignal, ...params}: RequestConfig & s.DescribeTapesInput,
  ): Promise<s.DescribeTapesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeARNs: params["TapeARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTapes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tapes": [toTape],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeUploadBuffer(
    {abortSignal, ...params}: RequestConfig & s.DescribeUploadBufferInput,
  ): Promise<s.DescribeUploadBufferOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUploadBuffer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "DiskIds": ["s"],
        "UploadBufferUsedInBytes": "n",
        "UploadBufferAllocatedInBytes": "n",
      },
    }, await resp.json());
  }

  async describeVTLDevices(
    {abortSignal, ...params}: RequestConfig & s.DescribeVTLDevicesInput,
  ): Promise<s.DescribeVTLDevicesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      VTLDeviceARNs: params["VTLDeviceARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVTLDevices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "VTLDevices": [toVTLDevice],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeWorkingStorage(
    {abortSignal, ...params}: RequestConfig & s.DescribeWorkingStorageInput,
  ): Promise<s.DescribeWorkingStorageOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorkingStorage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "DiskIds": ["s"],
        "WorkingStorageUsedInBytes": "n",
        "WorkingStorageAllocatedInBytes": "n",
      },
    }, await resp.json());
  }

  async detachVolume(
    {abortSignal, ...params}: RequestConfig & s.DetachVolumeInput,
  ): Promise<s.DetachVolumeOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
      ForceDetach: params["ForceDetach"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
      },
    }, await resp.json());
  }

  async disableGateway(
    {abortSignal, ...params}: RequestConfig & s.DisableGatewayInput,
  ): Promise<s.DisableGatewayOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async joinDomain(
    {abortSignal, ...params}: RequestConfig & s.JoinDomainInput,
  ): Promise<s.JoinDomainOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DomainName: params["DomainName"],
      OrganizationalUnit: params["OrganizationalUnit"],
      DomainControllers: params["DomainControllers"],
      TimeoutInSeconds: params["TimeoutInSeconds"],
      UserName: params["UserName"],
      Password: params["Password"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "JoinDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "ActiveDirectoryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActiveDirectoryStatus>(x),
      },
    }, await resp.json());
  }

  async listAutomaticTapeCreationPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListAutomaticTapeCreationPoliciesInput = {},
  ): Promise<s.ListAutomaticTapeCreationPoliciesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAutomaticTapeCreationPolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutomaticTapeCreationPolicyInfos": [toAutomaticTapeCreationPolicyInfo],
      },
    }, await resp.json());
  }

  async listFileShares(
    {abortSignal, ...params}: RequestConfig & s.ListFileSharesInput = {},
  ): Promise<s.ListFileSharesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFileShares",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "NextMarker": "s",
        "FileShareInfoList": [toFileShareInfo],
      },
    }, await resp.json());
  }

  async listGateways(
    {abortSignal, ...params}: RequestConfig & s.ListGatewaysInput = {},
  ): Promise<s.ListGatewaysOutput> {
    const body: jsonP.JSONObject = {
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGateways",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Gateways": [toGatewayInfo],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listLocalDisks(
    {abortSignal, ...params}: RequestConfig & s.ListLocalDisksInput,
  ): Promise<s.ListLocalDisksOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLocalDisks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "Disks": [toDisk],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceInput,
  ): Promise<s.ListTagsForResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceARN": "s",
        "Marker": "s",
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async listTapePools(
    {abortSignal, ...params}: RequestConfig & s.ListTapePoolsInput = {},
  ): Promise<s.ListTapePoolsOutput> {
    const body: jsonP.JSONObject = {
      PoolARNs: params["PoolARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTapePools",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PoolInfos": [toPoolInfo],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listTapes(
    {abortSignal, ...params}: RequestConfig & s.ListTapesInput = {},
  ): Promise<s.ListTapesOutput> {
    const body: jsonP.JSONObject = {
      TapeARNs: params["TapeARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTapes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeInfos": [toTapeInfo],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listVolumeInitiators(
    {abortSignal, ...params}: RequestConfig & s.ListVolumeInitiatorsInput,
  ): Promise<s.ListVolumeInitiatorsOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVolumeInitiators",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Initiators": ["s"],
      },
    }, await resp.json());
  }

  async listVolumeRecoveryPoints(
    {abortSignal, ...params}: RequestConfig & s.ListVolumeRecoveryPointsInput,
  ): Promise<s.ListVolumeRecoveryPointsOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVolumeRecoveryPoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "VolumeRecoveryPointInfos": [toVolumeRecoveryPointInfo],
      },
    }, await resp.json());
  }

  async listVolumes(
    {abortSignal, ...params}: RequestConfig & s.ListVolumesInput = {},
  ): Promise<s.ListVolumesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVolumes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "Marker": "s",
        "VolumeInfos": [toVolumeInfo],
      },
    }, await resp.json());
  }

  async notifyWhenUploaded(
    {abortSignal, ...params}: RequestConfig & s.NotifyWhenUploadedInput,
  ): Promise<s.NotifyWhenUploadedOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "NotifyWhenUploaded",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
        "NotificationId": "s",
      },
    }, await resp.json());
  }

  async refreshCache(
    {abortSignal, ...params}: RequestConfig & s.RefreshCacheInput,
  ): Promise<s.RefreshCacheOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
      FolderList: params["FolderList"],
      Recursive: params["Recursive"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RefreshCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
        "NotificationId": "s",
      },
    }, await resp.json());
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsFromResourceInput,
  ): Promise<s.RemoveTagsFromResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceARN": "s",
      },
    }, await resp.json());
  }

  async resetCache(
    {abortSignal, ...params}: RequestConfig & s.ResetCacheInput,
  ): Promise<s.ResetCacheOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async retrieveTapeArchive(
    {abortSignal, ...params}: RequestConfig & s.RetrieveTapeArchiveInput,
  ): Promise<s.RetrieveTapeArchiveOutput> {
    const body: jsonP.JSONObject = {
      TapeARN: params["TapeARN"],
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetrieveTapeArchive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async retrieveTapeRecoveryPoint(
    {abortSignal, ...params}: RequestConfig & s.RetrieveTapeRecoveryPointInput,
  ): Promise<s.RetrieveTapeRecoveryPointOutput> {
    const body: jsonP.JSONObject = {
      TapeARN: params["TapeARN"],
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetrieveTapeRecoveryPoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async setLocalConsolePassword(
    {abortSignal, ...params}: RequestConfig & s.SetLocalConsolePasswordInput,
  ): Promise<s.SetLocalConsolePasswordOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      LocalConsolePassword: params["LocalConsolePassword"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetLocalConsolePassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async setSMBGuestPassword(
    {abortSignal, ...params}: RequestConfig & s.SetSMBGuestPasswordInput,
  ): Promise<s.SetSMBGuestPasswordOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      Password: params["Password"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetSMBGuestPassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async shutdownGateway(
    {abortSignal, ...params}: RequestConfig & s.ShutdownGatewayInput,
  ): Promise<s.ShutdownGatewayOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ShutdownGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async startAvailabilityMonitorTest(
    {abortSignal, ...params}: RequestConfig & s.StartAvailabilityMonitorTestInput,
  ): Promise<s.StartAvailabilityMonitorTestOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartAvailabilityMonitorTest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async startGateway(
    {abortSignal, ...params}: RequestConfig & s.StartGatewayInput,
  ): Promise<s.StartGatewayOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateAutomaticTapeCreationPolicy(
    {abortSignal, ...params}: RequestConfig & s.UpdateAutomaticTapeCreationPolicyInput,
  ): Promise<s.UpdateAutomaticTapeCreationPolicyOutput> {
    const body: jsonP.JSONObject = {
      AutomaticTapeCreationRules: params["AutomaticTapeCreationRules"]?.map(x => fromAutomaticTapeCreationRule(x)),
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAutomaticTapeCreationPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateBandwidthRateLimit(
    {abortSignal, ...params}: RequestConfig & s.UpdateBandwidthRateLimitInput,
  ): Promise<s.UpdateBandwidthRateLimitOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      AverageUploadRateLimitInBitsPerSec: params["AverageUploadRateLimitInBitsPerSec"],
      AverageDownloadRateLimitInBitsPerSec: params["AverageDownloadRateLimitInBitsPerSec"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBandwidthRateLimit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateBandwidthRateLimitSchedule(
    {abortSignal, ...params}: RequestConfig & s.UpdateBandwidthRateLimitScheduleInput,
  ): Promise<s.UpdateBandwidthRateLimitScheduleOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      BandwidthRateLimitIntervals: params["BandwidthRateLimitIntervals"]?.map(x => fromBandwidthRateLimitInterval(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBandwidthRateLimitSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateChapCredentials(
    {abortSignal, ...params}: RequestConfig & s.UpdateChapCredentialsInput,
  ): Promise<s.UpdateChapCredentialsOutput> {
    const body: jsonP.JSONObject = {
      TargetARN: params["TargetARN"],
      SecretToAuthenticateInitiator: params["SecretToAuthenticateInitiator"],
      InitiatorName: params["InitiatorName"],
      SecretToAuthenticateTarget: params["SecretToAuthenticateTarget"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChapCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TargetARN": "s",
        "InitiatorName": "s",
      },
    }, await resp.json());
  }

  async updateGatewayInformation(
    {abortSignal, ...params}: RequestConfig & s.UpdateGatewayInformationInput,
  ): Promise<s.UpdateGatewayInformationOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      GatewayName: params["GatewayName"],
      GatewayTimezone: params["GatewayTimezone"],
      CloudWatchLogGroupARN: params["CloudWatchLogGroupARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGatewayInformation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "GatewayName": "s",
      },
    }, await resp.json());
  }

  async updateGatewaySoftwareNow(
    {abortSignal, ...params}: RequestConfig & s.UpdateGatewaySoftwareNowInput,
  ): Promise<s.UpdateGatewaySoftwareNowOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGatewaySoftwareNow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateMaintenanceStartTime(
    {abortSignal, ...params}: RequestConfig & s.UpdateMaintenanceStartTimeInput,
  ): Promise<s.UpdateMaintenanceStartTimeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      HourOfDay: params["HourOfDay"],
      MinuteOfHour: params["MinuteOfHour"],
      DayOfWeek: params["DayOfWeek"],
      DayOfMonth: params["DayOfMonth"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMaintenanceStartTime",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateNFSFileShare(
    {abortSignal, ...params}: RequestConfig & s.UpdateNFSFileShareInput,
  ): Promise<s.UpdateNFSFileShareOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      NFSFileShareDefaults: fromNFSFileShareDefaults(params["NFSFileShareDefaults"]),
      DefaultStorageClass: params["DefaultStorageClass"],
      ObjectACL: params["ObjectACL"],
      ClientList: params["ClientList"],
      Squash: params["Squash"],
      ReadOnly: params["ReadOnly"],
      GuessMIMETypeEnabled: params["GuessMIMETypeEnabled"],
      RequesterPays: params["RequesterPays"],
      FileShareName: params["FileShareName"],
      CacheAttributes: fromCacheAttributes(params["CacheAttributes"]),
      NotificationPolicy: params["NotificationPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNFSFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async updateSMBFileShare(
    {abortSignal, ...params}: RequestConfig & s.UpdateSMBFileShareInput,
  ): Promise<s.UpdateSMBFileShareOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      DefaultStorageClass: params["DefaultStorageClass"],
      ObjectACL: params["ObjectACL"],
      ReadOnly: params["ReadOnly"],
      GuessMIMETypeEnabled: params["GuessMIMETypeEnabled"],
      RequesterPays: params["RequesterPays"],
      SMBACLEnabled: params["SMBACLEnabled"],
      AccessBasedEnumeration: params["AccessBasedEnumeration"],
      AdminUserList: params["AdminUserList"],
      ValidUserList: params["ValidUserList"],
      InvalidUserList: params["InvalidUserList"],
      AuditDestinationARN: params["AuditDestinationARN"],
      CaseSensitivity: params["CaseSensitivity"],
      FileShareName: params["FileShareName"],
      CacheAttributes: fromCacheAttributes(params["CacheAttributes"]),
      NotificationPolicy: params["NotificationPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSMBFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async updateSMBFileShareVisibility(
    {abortSignal, ...params}: RequestConfig & s.UpdateSMBFileShareVisibilityInput,
  ): Promise<s.UpdateSMBFileShareVisibilityOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      FileSharesVisible: params["FileSharesVisible"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSMBFileShareVisibility",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateSMBSecurityStrategy(
    {abortSignal, ...params}: RequestConfig & s.UpdateSMBSecurityStrategyInput,
  ): Promise<s.UpdateSMBSecurityStrategyOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      SMBSecurityStrategy: params["SMBSecurityStrategy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSMBSecurityStrategy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & s.UpdateSnapshotScheduleInput,
  ): Promise<s.UpdateSnapshotScheduleOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
      StartAt: params["StartAt"],
      RecurrenceInHours: params["RecurrenceInHours"],
      Description: params["Description"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSnapshotSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
      },
    }, await resp.json());
  }

  async updateVTLDeviceType(
    {abortSignal, ...params}: RequestConfig & s.UpdateVTLDeviceTypeInput,
  ): Promise<s.UpdateVTLDeviceTypeOutput> {
    const body: jsonP.JSONObject = {
      VTLDeviceARN: params["VTLDeviceARN"],
      DeviceType: params["DeviceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVTLDeviceType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VTLDeviceARN": "s",
      },
    }, await resp.json());
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromNFSFileShareDefaults(input?: s.NFSFileShareDefaults | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FileMode: input["FileMode"],
    DirectoryMode: input["DirectoryMode"],
    GroupId: input["GroupId"],
    OwnerId: input["OwnerId"],
  }
}
function toNFSFileShareDefaults(root: jsonP.JSONValue): s.NFSFileShareDefaults {
  return jsonP.readObj({
    required: {},
    optional: {
      "FileMode": "s",
      "DirectoryMode": "s",
      "GroupId": "n",
      "OwnerId": "n",
    },
  }, root);
}

function fromCacheAttributes(input?: s.CacheAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CacheStaleTimeoutInSeconds: input["CacheStaleTimeoutInSeconds"],
  }
}
function toCacheAttributes(root: jsonP.JSONValue): s.CacheAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "CacheStaleTimeoutInSeconds": "n",
    },
  }, root);
}

function fromAutomaticTapeCreationRule(input?: s.AutomaticTapeCreationRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TapeBarcodePrefix: input["TapeBarcodePrefix"],
    PoolId: input["PoolId"],
    TapeSizeInBytes: input["TapeSizeInBytes"],
    MinimumNumTapes: input["MinimumNumTapes"],
    Worm: input["Worm"],
  }
}
function toAutomaticTapeCreationRule(root: jsonP.JSONValue): s.AutomaticTapeCreationRule {
  return jsonP.readObj({
    required: {
      "TapeBarcodePrefix": "s",
      "PoolId": "s",
      "TapeSizeInBytes": "n",
      "MinimumNumTapes": "n",
    },
    optional: {
      "Worm": "b",
    },
  }, root);
}

function fromBandwidthRateLimitInterval(input?: s.BandwidthRateLimitInterval | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartHourOfDay: input["StartHourOfDay"],
    StartMinuteOfHour: input["StartMinuteOfHour"],
    EndHourOfDay: input["EndHourOfDay"],
    EndMinuteOfHour: input["EndMinuteOfHour"],
    DaysOfWeek: input["DaysOfWeek"],
    AverageUploadRateLimitInBitsPerSec: input["AverageUploadRateLimitInBitsPerSec"],
    AverageDownloadRateLimitInBitsPerSec: input["AverageDownloadRateLimitInBitsPerSec"],
  }
}
function toBandwidthRateLimitInterval(root: jsonP.JSONValue): s.BandwidthRateLimitInterval {
  return jsonP.readObj({
    required: {
      "StartHourOfDay": "n",
      "StartMinuteOfHour": "n",
      "EndHourOfDay": "n",
      "EndMinuteOfHour": "n",
      "DaysOfWeek": ["n"],
    },
    optional: {
      "AverageUploadRateLimitInBitsPerSec": "n",
      "AverageDownloadRateLimitInBitsPerSec": "n",
    },
  }, root);
}

function toCachediSCSIVolume(root: jsonP.JSONValue): s.CachediSCSIVolume {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeARN": "s",
      "VolumeId": "s",
      "VolumeType": "s",
      "VolumeStatus": "s",
      "VolumeAttachmentStatus": "s",
      "VolumeSizeInBytes": "n",
      "VolumeProgress": "n",
      "SourceSnapshotId": "s",
      "VolumeiSCSIAttributes": toVolumeiSCSIAttributes,
      "CreatedDate": "d",
      "VolumeUsedInBytes": "n",
      "KMSKey": "s",
      "TargetName": "s",
    },
  }, root);
}

function toVolumeiSCSIAttributes(root: jsonP.JSONValue): s.VolumeiSCSIAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetARN": "s",
      "NetworkInterfaceId": "s",
      "NetworkInterfacePort": "n",
      "LunNumber": "n",
      "ChapEnabled": "b",
    },
  }, root);
}

function toChapInfo(root: jsonP.JSONValue): s.ChapInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetARN": "s",
      "SecretToAuthenticateInitiator": "s",
      "InitiatorName": "s",
      "SecretToAuthenticateTarget": "s",
    },
  }, root);
}

function toNetworkInterface(root: jsonP.JSONValue): s.NetworkInterface {
  return jsonP.readObj({
    required: {},
    optional: {
      "Ipv4Address": "s",
      "MacAddress": "s",
      "Ipv6Address": "s",
    },
  }, root);
}

function toNFSFileShareInfo(root: jsonP.JSONValue): s.NFSFileShareInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "NFSFileShareDefaults": toNFSFileShareDefaults,
      "FileShareARN": "s",
      "FileShareId": "s",
      "FileShareStatus": "s",
      "GatewayARN": "s",
      "KMSEncrypted": "b",
      "KMSKey": "s",
      "Path": "s",
      "Role": "s",
      "LocationARN": "s",
      "DefaultStorageClass": "s",
      "ObjectACL": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObjectACL>(x),
      "ClientList": ["s"],
      "Squash": "s",
      "ReadOnly": "b",
      "GuessMIMETypeEnabled": "b",
      "RequesterPays": "b",
      "Tags": [toTag],
      "FileShareName": "s",
      "CacheAttributes": toCacheAttributes,
      "NotificationPolicy": "s",
    },
  }, root);
}

function toSMBFileShareInfo(root: jsonP.JSONValue): s.SMBFileShareInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "FileShareARN": "s",
      "FileShareId": "s",
      "FileShareStatus": "s",
      "GatewayARN": "s",
      "KMSEncrypted": "b",
      "KMSKey": "s",
      "Path": "s",
      "Role": "s",
      "LocationARN": "s",
      "DefaultStorageClass": "s",
      "ObjectACL": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObjectACL>(x),
      "ReadOnly": "b",
      "GuessMIMETypeEnabled": "b",
      "RequesterPays": "b",
      "SMBACLEnabled": "b",
      "AccessBasedEnumeration": "b",
      "AdminUserList": ["s"],
      "ValidUserList": ["s"],
      "InvalidUserList": ["s"],
      "AuditDestinationARN": "s",
      "Authentication": "s",
      "CaseSensitivity": (x: jsonP.JSONValue) => cmnP.readEnum<s.CaseSensitivity>(x),
      "Tags": [toTag],
      "FileShareName": "s",
      "CacheAttributes": toCacheAttributes,
      "NotificationPolicy": "s",
    },
  }, root);
}

function toStorediSCSIVolume(root: jsonP.JSONValue): s.StorediSCSIVolume {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeARN": "s",
      "VolumeId": "s",
      "VolumeType": "s",
      "VolumeStatus": "s",
      "VolumeAttachmentStatus": "s",
      "VolumeSizeInBytes": "n",
      "VolumeProgress": "n",
      "VolumeDiskId": "s",
      "SourceSnapshotId": "s",
      "PreservedExistingData": "b",
      "VolumeiSCSIAttributes": toVolumeiSCSIAttributes,
      "CreatedDate": "d",
      "VolumeUsedInBytes": "n",
      "KMSKey": "s",
      "TargetName": "s",
    },
  }, root);
}

function toTapeArchive(root: jsonP.JSONValue): s.TapeArchive {
  return jsonP.readObj({
    required: {},
    optional: {
      "TapeARN": "s",
      "TapeBarcode": "s",
      "TapeCreatedDate": "d",
      "TapeSizeInBytes": "n",
      "CompletionTime": "d",
      "RetrievedTo": "s",
      "TapeStatus": "s",
      "TapeUsedInBytes": "n",
      "KMSKey": "s",
      "PoolId": "s",
      "Worm": "b",
      "RetentionStartDate": "d",
      "PoolEntryDate": "d",
    },
  }, root);
}

function toTapeRecoveryPointInfo(root: jsonP.JSONValue): s.TapeRecoveryPointInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "TapeARN": "s",
      "TapeRecoveryPointTime": "d",
      "TapeSizeInBytes": "n",
      "TapeStatus": "s",
    },
  }, root);
}

function toTape(root: jsonP.JSONValue): s.Tape {
  return jsonP.readObj({
    required: {},
    optional: {
      "TapeARN": "s",
      "TapeBarcode": "s",
      "TapeCreatedDate": "d",
      "TapeSizeInBytes": "n",
      "TapeStatus": "s",
      "VTLDevice": "s",
      "Progress": "n",
      "TapeUsedInBytes": "n",
      "KMSKey": "s",
      "PoolId": "s",
      "Worm": "b",
      "RetentionStartDate": "d",
      "PoolEntryDate": "d",
    },
  }, root);
}

function toVTLDevice(root: jsonP.JSONValue): s.VTLDevice {
  return jsonP.readObj({
    required: {},
    optional: {
      "VTLDeviceARN": "s",
      "VTLDeviceType": "s",
      "VTLDeviceVendor": "s",
      "VTLDeviceProductIdentifier": "s",
      "DeviceiSCSIAttributes": toDeviceiSCSIAttributes,
    },
  }, root);
}

function toDeviceiSCSIAttributes(root: jsonP.JSONValue): s.DeviceiSCSIAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetARN": "s",
      "NetworkInterfaceId": "s",
      "NetworkInterfacePort": "n",
      "ChapEnabled": "b",
    },
  }, root);
}

function toAutomaticTapeCreationPolicyInfo(root: jsonP.JSONValue): s.AutomaticTapeCreationPolicyInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomaticTapeCreationRules": [toAutomaticTapeCreationRule],
      "GatewayARN": "s",
    },
  }, root);
}

function toFileShareInfo(root: jsonP.JSONValue): s.FileShareInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "FileShareType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileShareType>(x),
      "FileShareARN": "s",
      "FileShareId": "s",
      "FileShareStatus": "s",
      "GatewayARN": "s",
    },
  }, root);
}

function toGatewayInfo(root: jsonP.JSONValue): s.GatewayInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "GatewayId": "s",
      "GatewayARN": "s",
      "GatewayType": "s",
      "GatewayOperationalState": "s",
      "GatewayName": "s",
      "Ec2InstanceId": "s",
      "Ec2InstanceRegion": "s",
    },
  }, root);
}

function toDisk(root: jsonP.JSONValue): s.Disk {
  return jsonP.readObj({
    required: {},
    optional: {
      "DiskId": "s",
      "DiskPath": "s",
      "DiskNode": "s",
      "DiskStatus": "s",
      "DiskSizeInBytes": "n",
      "DiskAllocationType": "s",
      "DiskAllocationResource": "s",
      "DiskAttributeList": ["s"],
    },
  }, root);
}

function toPoolInfo(root: jsonP.JSONValue): s.PoolInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "PoolARN": "s",
      "PoolName": "s",
      "StorageClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.TapeStorageClass>(x),
      "RetentionLockType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RetentionLockType>(x),
      "RetentionLockTimeInDays": "n",
      "PoolStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PoolStatus>(x),
    },
  }, root);
}

function toTapeInfo(root: jsonP.JSONValue): s.TapeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "TapeARN": "s",
      "TapeBarcode": "s",
      "TapeSizeInBytes": "n",
      "TapeStatus": "s",
      "GatewayARN": "s",
      "PoolId": "s",
      "RetentionStartDate": "d",
      "PoolEntryDate": "d",
    },
  }, root);
}

function toVolumeRecoveryPointInfo(root: jsonP.JSONValue): s.VolumeRecoveryPointInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeARN": "s",
      "VolumeSizeInBytes": "n",
      "VolumeUsageInBytes": "n",
      "VolumeRecoveryPointTime": "s",
    },
  }, root);
}

function toVolumeInfo(root: jsonP.JSONValue): s.VolumeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeARN": "s",
      "VolumeId": "s",
      "GatewayARN": "s",
      "GatewayId": "s",
      "VolumeType": "s",
      "VolumeSizeInBytes": "n",
      "VolumeAttachmentStatus": "s",
    },
  }, root);
}
