// Autogenerated API client for: AWS Storage Gateway

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class StorageGateway {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(StorageGateway.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2013-06-30",
    "endpointPrefix": "storagegateway",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Storage Gateway",
    "serviceId": "Storage Gateway",
    "signatureVersion": "v4",
    "targetPrefix": "StorageGateway_20130630",
    "uid": "storagegateway-2013-06-30"
  };

  async activateGateway(
    {abortSignal, ...params}: RequestConfig & ActivateGatewayInput,
  ): Promise<ActivateGatewayOutput> {
    const body: jsonP.JSONObject = {
      ActivationKey: params["ActivationKey"],
      GatewayName: params["GatewayName"],
      GatewayTimezone: params["GatewayTimezone"],
      GatewayRegion: params["GatewayRegion"],
      GatewayType: params["GatewayType"],
      TapeDriveType: params["TapeDriveType"],
      MediumChangerType: params["MediumChangerType"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ActivateGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async addCache(
    {abortSignal, ...params}: RequestConfig & AddCacheInput,
  ): Promise<AddCacheOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DiskIds: params["DiskIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & AddTagsToResourceInput,
  ): Promise<AddTagsToResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceARN": "s",
      },
    }, await resp.json());
  }

  async addUploadBuffer(
    {abortSignal, ...params}: RequestConfig & AddUploadBufferInput,
  ): Promise<AddUploadBufferOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DiskIds: params["DiskIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddUploadBuffer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async addWorkingStorage(
    {abortSignal, ...params}: RequestConfig & AddWorkingStorageInput,
  ): Promise<AddWorkingStorageOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DiskIds: params["DiskIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddWorkingStorage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async assignTapePool(
    {abortSignal, ...params}: RequestConfig & AssignTapePoolInput,
  ): Promise<AssignTapePoolOutput> {
    const body: jsonP.JSONObject = {
      TapeARN: params["TapeARN"],
      PoolId: params["PoolId"],
      BypassGovernanceRetention: params["BypassGovernanceRetention"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignTapePool",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async attachVolume(
    {abortSignal, ...params}: RequestConfig & AttachVolumeInput,
  ): Promise<AttachVolumeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TargetName: params["TargetName"],
      VolumeARN: params["VolumeARN"],
      NetworkInterfaceId: params["NetworkInterfaceId"],
      DiskId: params["DiskId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "TargetARN": "s",
      },
    }, await resp.json());
  }

  async cancelArchival(
    {abortSignal, ...params}: RequestConfig & CancelArchivalInput,
  ): Promise<CancelArchivalOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeARN: params["TapeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelArchival",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async cancelRetrieval(
    {abortSignal, ...params}: RequestConfig & CancelRetrievalInput,
  ): Promise<CancelRetrievalOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeARN: params["TapeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelRetrieval",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async createCachediSCSIVolume(
    {abortSignal, ...params}: RequestConfig & CreateCachediSCSIVolumeInput,
  ): Promise<CreateCachediSCSIVolumeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      VolumeSizeInBytes: params["VolumeSizeInBytes"],
      SnapshotId: params["SnapshotId"],
      TargetName: params["TargetName"],
      SourceVolumeARN: params["SourceVolumeARN"],
      NetworkInterfaceId: params["NetworkInterfaceId"],
      ClientToken: params["ClientToken"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCachediSCSIVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "TargetARN": "s",
      },
    }, await resp.json());
  }

  async createNFSFileShare(
    {abortSignal, ...params}: RequestConfig & CreateNFSFileShareInput,
  ): Promise<CreateNFSFileShareOutput> {
    const body: jsonP.JSONObject = {
      ClientToken: params["ClientToken"],
      NFSFileShareDefaults: fromNFSFileShareDefaults(params["NFSFileShareDefaults"]),
      GatewayARN: params["GatewayARN"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      Role: params["Role"],
      LocationARN: params["LocationARN"],
      DefaultStorageClass: params["DefaultStorageClass"],
      ObjectACL: params["ObjectACL"],
      ClientList: params["ClientList"],
      Squash: params["Squash"],
      ReadOnly: params["ReadOnly"],
      GuessMIMETypeEnabled: params["GuessMIMETypeEnabled"],
      RequesterPays: params["RequesterPays"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      FileShareName: params["FileShareName"],
      CacheAttributes: fromCacheAttributes(params["CacheAttributes"]),
      NotificationPolicy: params["NotificationPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNFSFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async createSMBFileShare(
    {abortSignal, ...params}: RequestConfig & CreateSMBFileShareInput,
  ): Promise<CreateSMBFileShareOutput> {
    const body: jsonP.JSONObject = {
      ClientToken: params["ClientToken"],
      GatewayARN: params["GatewayARN"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      Role: params["Role"],
      LocationARN: params["LocationARN"],
      DefaultStorageClass: params["DefaultStorageClass"],
      ObjectACL: params["ObjectACL"],
      ReadOnly: params["ReadOnly"],
      GuessMIMETypeEnabled: params["GuessMIMETypeEnabled"],
      RequesterPays: params["RequesterPays"],
      SMBACLEnabled: params["SMBACLEnabled"],
      AccessBasedEnumeration: params["AccessBasedEnumeration"],
      AdminUserList: params["AdminUserList"],
      ValidUserList: params["ValidUserList"],
      InvalidUserList: params["InvalidUserList"],
      AuditDestinationARN: params["AuditDestinationARN"],
      Authentication: params["Authentication"],
      CaseSensitivity: params["CaseSensitivity"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      FileShareName: params["FileShareName"],
      CacheAttributes: fromCacheAttributes(params["CacheAttributes"]),
      NotificationPolicy: params["NotificationPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSMBFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async createSnapshot(
    {abortSignal, ...params}: RequestConfig & CreateSnapshotInput,
  ): Promise<CreateSnapshotOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
      SnapshotDescription: params["SnapshotDescription"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "SnapshotId": "s",
      },
    }, await resp.json());
  }

  async createSnapshotFromVolumeRecoveryPoint(
    {abortSignal, ...params}: RequestConfig & CreateSnapshotFromVolumeRecoveryPointInput,
  ): Promise<CreateSnapshotFromVolumeRecoveryPointOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
      SnapshotDescription: params["SnapshotDescription"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshotFromVolumeRecoveryPoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SnapshotId": "s",
        "VolumeARN": "s",
        "VolumeRecoveryPointTime": "s",
      },
    }, await resp.json());
  }

  async createStorediSCSIVolume(
    {abortSignal, ...params}: RequestConfig & CreateStorediSCSIVolumeInput,
  ): Promise<CreateStorediSCSIVolumeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DiskId: params["DiskId"],
      SnapshotId: params["SnapshotId"],
      PreserveExistingData: params["PreserveExistingData"],
      TargetName: params["TargetName"],
      NetworkInterfaceId: params["NetworkInterfaceId"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStorediSCSIVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "VolumeSizeInBytes": "n",
        "TargetARN": "s",
      },
    }, await resp.json());
  }

  async createTapePool(
    {abortSignal, ...params}: RequestConfig & CreateTapePoolInput,
  ): Promise<CreateTapePoolOutput> {
    const body: jsonP.JSONObject = {
      PoolName: params["PoolName"],
      StorageClass: params["StorageClass"],
      RetentionLockType: params["RetentionLockType"],
      RetentionLockTimeInDays: params["RetentionLockTimeInDays"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTapePool",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PoolARN": "s",
      },
    }, await resp.json());
  }

  async createTapeWithBarcode(
    {abortSignal, ...params}: RequestConfig & CreateTapeWithBarcodeInput,
  ): Promise<CreateTapeWithBarcodeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeSizeInBytes: params["TapeSizeInBytes"],
      TapeBarcode: params["TapeBarcode"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      PoolId: params["PoolId"],
      Worm: params["Worm"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTapeWithBarcode",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async createTapes(
    {abortSignal, ...params}: RequestConfig & CreateTapesInput,
  ): Promise<CreateTapesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeSizeInBytes: params["TapeSizeInBytes"],
      ClientToken: params["ClientToken"],
      NumTapesToCreate: params["NumTapesToCreate"],
      TapeBarcodePrefix: params["TapeBarcodePrefix"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      PoolId: params["PoolId"],
      Worm: params["Worm"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTapes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARNs": ["s"],
      },
    }, await resp.json());
  }

  async deleteAutomaticTapeCreationPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteAutomaticTapeCreationPolicyInput,
  ): Promise<DeleteAutomaticTapeCreationPolicyOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAutomaticTapeCreationPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async deleteBandwidthRateLimit(
    {abortSignal, ...params}: RequestConfig & DeleteBandwidthRateLimitInput,
  ): Promise<DeleteBandwidthRateLimitOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      BandwidthType: params["BandwidthType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBandwidthRateLimit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async deleteChapCredentials(
    {abortSignal, ...params}: RequestConfig & DeleteChapCredentialsInput,
  ): Promise<DeleteChapCredentialsOutput> {
    const body: jsonP.JSONObject = {
      TargetARN: params["TargetARN"],
      InitiatorName: params["InitiatorName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteChapCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TargetARN": "s",
        "InitiatorName": "s",
      },
    }, await resp.json());
  }

  async deleteFileShare(
    {abortSignal, ...params}: RequestConfig & DeleteFileShareInput,
  ): Promise<DeleteFileShareOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
      ForceDelete: params["ForceDelete"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async deleteGateway(
    {abortSignal, ...params}: RequestConfig & DeleteGatewayInput,
  ): Promise<DeleteGatewayOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async deleteSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & DeleteSnapshotScheduleInput,
  ): Promise<DeleteSnapshotScheduleOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshotSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
      },
    }, await resp.json());
  }

  async deleteTape(
    {abortSignal, ...params}: RequestConfig & DeleteTapeInput,
  ): Promise<DeleteTapeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeARN: params["TapeARN"],
      BypassGovernanceRetention: params["BypassGovernanceRetention"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTape",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async deleteTapeArchive(
    {abortSignal, ...params}: RequestConfig & DeleteTapeArchiveInput,
  ): Promise<DeleteTapeArchiveOutput> {
    const body: jsonP.JSONObject = {
      TapeARN: params["TapeARN"],
      BypassGovernanceRetention: params["BypassGovernanceRetention"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTapeArchive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async deleteTapePool(
    {abortSignal, ...params}: RequestConfig & DeleteTapePoolInput,
  ): Promise<DeleteTapePoolOutput> {
    const body: jsonP.JSONObject = {
      PoolARN: params["PoolARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTapePool",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PoolARN": "s",
      },
    }, await resp.json());
  }

  async deleteVolume(
    {abortSignal, ...params}: RequestConfig & DeleteVolumeInput,
  ): Promise<DeleteVolumeOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
      },
    }, await resp.json());
  }

  async describeAvailabilityMonitorTest(
    {abortSignal, ...params}: RequestConfig & DescribeAvailabilityMonitorTestInput,
  ): Promise<DescribeAvailabilityMonitorTestOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAvailabilityMonitorTest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<AvailabilityMonitorTestStatus>(x),
        "StartTime": "d",
      },
    }, await resp.json());
  }

  async describeBandwidthRateLimit(
    {abortSignal, ...params}: RequestConfig & DescribeBandwidthRateLimitInput,
  ): Promise<DescribeBandwidthRateLimitOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBandwidthRateLimit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "AverageUploadRateLimitInBitsPerSec": "n",
        "AverageDownloadRateLimitInBitsPerSec": "n",
      },
    }, await resp.json());
  }

  async describeBandwidthRateLimitSchedule(
    {abortSignal, ...params}: RequestConfig & DescribeBandwidthRateLimitScheduleInput,
  ): Promise<DescribeBandwidthRateLimitScheduleOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBandwidthRateLimitSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "BandwidthRateLimitIntervals": [toBandwidthRateLimitInterval],
      },
    }, await resp.json());
  }

  async describeCache(
    {abortSignal, ...params}: RequestConfig & DescribeCacheInput,
  ): Promise<DescribeCacheOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "DiskIds": ["s"],
        "CacheAllocatedInBytes": "n",
        "CacheUsedPercentage": "n",
        "CacheDirtyPercentage": "n",
        "CacheHitPercentage": "n",
        "CacheMissPercentage": "n",
      },
    }, await resp.json());
  }

  async describeCachediSCSIVolumes(
    {abortSignal, ...params}: RequestConfig & DescribeCachediSCSIVolumesInput,
  ): Promise<DescribeCachediSCSIVolumesOutput> {
    const body: jsonP.JSONObject = {
      VolumeARNs: params["VolumeARNs"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCachediSCSIVolumes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CachediSCSIVolumes": [toCachediSCSIVolume],
      },
    }, await resp.json());
  }

  async describeChapCredentials(
    {abortSignal, ...params}: RequestConfig & DescribeChapCredentialsInput,
  ): Promise<DescribeChapCredentialsOutput> {
    const body: jsonP.JSONObject = {
      TargetARN: params["TargetARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeChapCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChapCredentials": [toChapInfo],
      },
    }, await resp.json());
  }

  async describeGatewayInformation(
    {abortSignal, ...params}: RequestConfig & DescribeGatewayInformationInput,
  ): Promise<DescribeGatewayInformationOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGatewayInformation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "GatewayId": "s",
        "GatewayName": "s",
        "GatewayTimezone": "s",
        "GatewayState": "s",
        "GatewayNetworkInterfaces": [toNetworkInterface],
        "GatewayType": "s",
        "NextUpdateAvailabilityDate": "s",
        "LastSoftwareUpdate": "s",
        "Ec2InstanceId": "s",
        "Ec2InstanceRegion": "s",
        "Tags": [toTag],
        "VPCEndpoint": "s",
        "CloudWatchLogGroupARN": "s",
        "HostEnvironment": (x: jsonP.JSONValue) => cmnP.readEnum<HostEnvironment>(x),
        "EndpointType": "s",
        "SoftwareUpdatesEndDate": "s",
        "DeprecationDate": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceStartTime(
    {abortSignal, ...params}: RequestConfig & DescribeMaintenanceStartTimeInput,
  ): Promise<DescribeMaintenanceStartTimeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceStartTime",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "HourOfDay": "n",
        "MinuteOfHour": "n",
        "DayOfWeek": "n",
        "DayOfMonth": "n",
        "Timezone": "s",
      },
    }, await resp.json());
  }

  async describeNFSFileShares(
    {abortSignal, ...params}: RequestConfig & DescribeNFSFileSharesInput,
  ): Promise<DescribeNFSFileSharesOutput> {
    const body: jsonP.JSONObject = {
      FileShareARNList: params["FileShareARNList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNFSFileShares",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NFSFileShareInfoList": [toNFSFileShareInfo],
      },
    }, await resp.json());
  }

  async describeSMBFileShares(
    {abortSignal, ...params}: RequestConfig & DescribeSMBFileSharesInput,
  ): Promise<DescribeSMBFileSharesOutput> {
    const body: jsonP.JSONObject = {
      FileShareARNList: params["FileShareARNList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSMBFileShares",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SMBFileShareInfoList": [toSMBFileShareInfo],
      },
    }, await resp.json());
  }

  async describeSMBSettings(
    {abortSignal, ...params}: RequestConfig & DescribeSMBSettingsInput,
  ): Promise<DescribeSMBSettingsOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSMBSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "DomainName": "s",
        "ActiveDirectoryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ActiveDirectoryStatus>(x),
        "SMBGuestPasswordSet": "b",
        "SMBSecurityStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<SMBSecurityStrategy>(x),
        "FileSharesVisible": "b",
      },
    }, await resp.json());
  }

  async describeSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & DescribeSnapshotScheduleInput,
  ): Promise<DescribeSnapshotScheduleOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshotSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
        "StartAt": "n",
        "RecurrenceInHours": "n",
        "Description": "s",
        "Timezone": "s",
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async describeStorediSCSIVolumes(
    {abortSignal, ...params}: RequestConfig & DescribeStorediSCSIVolumesInput,
  ): Promise<DescribeStorediSCSIVolumesOutput> {
    const body: jsonP.JSONObject = {
      VolumeARNs: params["VolumeARNs"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStorediSCSIVolumes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StorediSCSIVolumes": [toStorediSCSIVolume],
      },
    }, await resp.json());
  }

  async describeTapeArchives(
    {abortSignal, ...params}: RequestConfig & DescribeTapeArchivesInput = {},
  ): Promise<DescribeTapeArchivesOutput> {
    const body: jsonP.JSONObject = {
      TapeARNs: params["TapeARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTapeArchives",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeArchives": [toTapeArchive],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeTapeRecoveryPoints(
    {abortSignal, ...params}: RequestConfig & DescribeTapeRecoveryPointsInput,
  ): Promise<DescribeTapeRecoveryPointsOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTapeRecoveryPoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "TapeRecoveryPointInfos": [toTapeRecoveryPointInfo],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeTapes(
    {abortSignal, ...params}: RequestConfig & DescribeTapesInput,
  ): Promise<DescribeTapesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      TapeARNs: params["TapeARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTapes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tapes": [toTape],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeUploadBuffer(
    {abortSignal, ...params}: RequestConfig & DescribeUploadBufferInput,
  ): Promise<DescribeUploadBufferOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUploadBuffer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "DiskIds": ["s"],
        "UploadBufferUsedInBytes": "n",
        "UploadBufferAllocatedInBytes": "n",
      },
    }, await resp.json());
  }

  async describeVTLDevices(
    {abortSignal, ...params}: RequestConfig & DescribeVTLDevicesInput,
  ): Promise<DescribeVTLDevicesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      VTLDeviceARNs: params["VTLDeviceARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVTLDevices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "VTLDevices": [toVTLDevice],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeWorkingStorage(
    {abortSignal, ...params}: RequestConfig & DescribeWorkingStorageInput,
  ): Promise<DescribeWorkingStorageOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorkingStorage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "DiskIds": ["s"],
        "WorkingStorageUsedInBytes": "n",
        "WorkingStorageAllocatedInBytes": "n",
      },
    }, await resp.json());
  }

  async detachVolume(
    {abortSignal, ...params}: RequestConfig & DetachVolumeInput,
  ): Promise<DetachVolumeOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
      ForceDetach: params["ForceDetach"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachVolume",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
      },
    }, await resp.json());
  }

  async disableGateway(
    {abortSignal, ...params}: RequestConfig & DisableGatewayInput,
  ): Promise<DisableGatewayOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async joinDomain(
    {abortSignal, ...params}: RequestConfig & JoinDomainInput,
  ): Promise<JoinDomainOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      DomainName: params["DomainName"],
      OrganizationalUnit: params["OrganizationalUnit"],
      DomainControllers: params["DomainControllers"],
      TimeoutInSeconds: params["TimeoutInSeconds"],
      UserName: params["UserName"],
      Password: params["Password"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "JoinDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "ActiveDirectoryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ActiveDirectoryStatus>(x),
      },
    }, await resp.json());
  }

  async listAutomaticTapeCreationPolicies(
    {abortSignal, ...params}: RequestConfig & ListAutomaticTapeCreationPoliciesInput = {},
  ): Promise<ListAutomaticTapeCreationPoliciesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAutomaticTapeCreationPolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutomaticTapeCreationPolicyInfos": [toAutomaticTapeCreationPolicyInfo],
      },
    }, await resp.json());
  }

  async listFileShares(
    {abortSignal, ...params}: RequestConfig & ListFileSharesInput = {},
  ): Promise<ListFileSharesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFileShares",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "NextMarker": "s",
        "FileShareInfoList": [toFileShareInfo],
      },
    }, await resp.json());
  }

  async listGateways(
    {abortSignal, ...params}: RequestConfig & ListGatewaysInput = {},
  ): Promise<ListGatewaysOutput> {
    const body: jsonP.JSONObject = {
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGateways",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Gateways": [toGatewayInfo],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listLocalDisks(
    {abortSignal, ...params}: RequestConfig & ListLocalDisksInput,
  ): Promise<ListLocalDisksOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLocalDisks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "Disks": [toDisk],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceInput,
  ): Promise<ListTagsForResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceARN": "s",
        "Marker": "s",
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async listTapePools(
    {abortSignal, ...params}: RequestConfig & ListTapePoolsInput = {},
  ): Promise<ListTapePoolsOutput> {
    const body: jsonP.JSONObject = {
      PoolARNs: params["PoolARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTapePools",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PoolInfos": [toPoolInfo],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listTapes(
    {abortSignal, ...params}: RequestConfig & ListTapesInput = {},
  ): Promise<ListTapesOutput> {
    const body: jsonP.JSONObject = {
      TapeARNs: params["TapeARNs"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTapes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeInfos": [toTapeInfo],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listVolumeInitiators(
    {abortSignal, ...params}: RequestConfig & ListVolumeInitiatorsInput,
  ): Promise<ListVolumeInitiatorsOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVolumeInitiators",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Initiators": ["s"],
      },
    }, await resp.json());
  }

  async listVolumeRecoveryPoints(
    {abortSignal, ...params}: RequestConfig & ListVolumeRecoveryPointsInput,
  ): Promise<ListVolumeRecoveryPointsOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVolumeRecoveryPoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "VolumeRecoveryPointInfos": [toVolumeRecoveryPointInfo],
      },
    }, await resp.json());
  }

  async listVolumes(
    {abortSignal, ...params}: RequestConfig & ListVolumesInput = {},
  ): Promise<ListVolumesOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      Marker: params["Marker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVolumes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "Marker": "s",
        "VolumeInfos": [toVolumeInfo],
      },
    }, await resp.json());
  }

  async notifyWhenUploaded(
    {abortSignal, ...params}: RequestConfig & NotifyWhenUploadedInput,
  ): Promise<NotifyWhenUploadedOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "NotifyWhenUploaded",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
        "NotificationId": "s",
      },
    }, await resp.json());
  }

  async refreshCache(
    {abortSignal, ...params}: RequestConfig & RefreshCacheInput,
  ): Promise<RefreshCacheOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
      FolderList: params["FolderList"],
      Recursive: params["Recursive"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RefreshCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
        "NotificationId": "s",
      },
    }, await resp.json());
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & RemoveTagsFromResourceInput,
  ): Promise<RemoveTagsFromResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceARN": "s",
      },
    }, await resp.json());
  }

  async resetCache(
    {abortSignal, ...params}: RequestConfig & ResetCacheInput,
  ): Promise<ResetCacheOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async retrieveTapeArchive(
    {abortSignal, ...params}: RequestConfig & RetrieveTapeArchiveInput,
  ): Promise<RetrieveTapeArchiveOutput> {
    const body: jsonP.JSONObject = {
      TapeARN: params["TapeARN"],
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetrieveTapeArchive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async retrieveTapeRecoveryPoint(
    {abortSignal, ...params}: RequestConfig & RetrieveTapeRecoveryPointInput,
  ): Promise<RetrieveTapeRecoveryPointOutput> {
    const body: jsonP.JSONObject = {
      TapeARN: params["TapeARN"],
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetrieveTapeRecoveryPoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TapeARN": "s",
      },
    }, await resp.json());
  }

  async setLocalConsolePassword(
    {abortSignal, ...params}: RequestConfig & SetLocalConsolePasswordInput,
  ): Promise<SetLocalConsolePasswordOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      LocalConsolePassword: params["LocalConsolePassword"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetLocalConsolePassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async setSMBGuestPassword(
    {abortSignal, ...params}: RequestConfig & SetSMBGuestPasswordInput,
  ): Promise<SetSMBGuestPasswordOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      Password: params["Password"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetSMBGuestPassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async shutdownGateway(
    {abortSignal, ...params}: RequestConfig & ShutdownGatewayInput,
  ): Promise<ShutdownGatewayOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ShutdownGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async startAvailabilityMonitorTest(
    {abortSignal, ...params}: RequestConfig & StartAvailabilityMonitorTestInput,
  ): Promise<StartAvailabilityMonitorTestOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartAvailabilityMonitorTest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async startGateway(
    {abortSignal, ...params}: RequestConfig & StartGatewayInput,
  ): Promise<StartGatewayOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateAutomaticTapeCreationPolicy(
    {abortSignal, ...params}: RequestConfig & UpdateAutomaticTapeCreationPolicyInput,
  ): Promise<UpdateAutomaticTapeCreationPolicyOutput> {
    const body: jsonP.JSONObject = {
      AutomaticTapeCreationRules: params["AutomaticTapeCreationRules"]?.map(x => fromAutomaticTapeCreationRule(x)),
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAutomaticTapeCreationPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateBandwidthRateLimit(
    {abortSignal, ...params}: RequestConfig & UpdateBandwidthRateLimitInput,
  ): Promise<UpdateBandwidthRateLimitOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      AverageUploadRateLimitInBitsPerSec: params["AverageUploadRateLimitInBitsPerSec"],
      AverageDownloadRateLimitInBitsPerSec: params["AverageDownloadRateLimitInBitsPerSec"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBandwidthRateLimit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateBandwidthRateLimitSchedule(
    {abortSignal, ...params}: RequestConfig & UpdateBandwidthRateLimitScheduleInput,
  ): Promise<UpdateBandwidthRateLimitScheduleOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      BandwidthRateLimitIntervals: params["BandwidthRateLimitIntervals"]?.map(x => fromBandwidthRateLimitInterval(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBandwidthRateLimitSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateChapCredentials(
    {abortSignal, ...params}: RequestConfig & UpdateChapCredentialsInput,
  ): Promise<UpdateChapCredentialsOutput> {
    const body: jsonP.JSONObject = {
      TargetARN: params["TargetARN"],
      SecretToAuthenticateInitiator: params["SecretToAuthenticateInitiator"],
      InitiatorName: params["InitiatorName"],
      SecretToAuthenticateTarget: params["SecretToAuthenticateTarget"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChapCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TargetARN": "s",
        "InitiatorName": "s",
      },
    }, await resp.json());
  }

  async updateGatewayInformation(
    {abortSignal, ...params}: RequestConfig & UpdateGatewayInformationInput,
  ): Promise<UpdateGatewayInformationOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      GatewayName: params["GatewayName"],
      GatewayTimezone: params["GatewayTimezone"],
      CloudWatchLogGroupARN: params["CloudWatchLogGroupARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGatewayInformation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
        "GatewayName": "s",
      },
    }, await resp.json());
  }

  async updateGatewaySoftwareNow(
    {abortSignal, ...params}: RequestConfig & UpdateGatewaySoftwareNowInput,
  ): Promise<UpdateGatewaySoftwareNowOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGatewaySoftwareNow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateMaintenanceStartTime(
    {abortSignal, ...params}: RequestConfig & UpdateMaintenanceStartTimeInput,
  ): Promise<UpdateMaintenanceStartTimeOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      HourOfDay: params["HourOfDay"],
      MinuteOfHour: params["MinuteOfHour"],
      DayOfWeek: params["DayOfWeek"],
      DayOfMonth: params["DayOfMonth"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMaintenanceStartTime",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateNFSFileShare(
    {abortSignal, ...params}: RequestConfig & UpdateNFSFileShareInput,
  ): Promise<UpdateNFSFileShareOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      NFSFileShareDefaults: fromNFSFileShareDefaults(params["NFSFileShareDefaults"]),
      DefaultStorageClass: params["DefaultStorageClass"],
      ObjectACL: params["ObjectACL"],
      ClientList: params["ClientList"],
      Squash: params["Squash"],
      ReadOnly: params["ReadOnly"],
      GuessMIMETypeEnabled: params["GuessMIMETypeEnabled"],
      RequesterPays: params["RequesterPays"],
      FileShareName: params["FileShareName"],
      CacheAttributes: fromCacheAttributes(params["CacheAttributes"]),
      NotificationPolicy: params["NotificationPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNFSFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async updateSMBFileShare(
    {abortSignal, ...params}: RequestConfig & UpdateSMBFileShareInput,
  ): Promise<UpdateSMBFileShareOutput> {
    const body: jsonP.JSONObject = {
      FileShareARN: params["FileShareARN"],
      KMSEncrypted: params["KMSEncrypted"],
      KMSKey: params["KMSKey"],
      DefaultStorageClass: params["DefaultStorageClass"],
      ObjectACL: params["ObjectACL"],
      ReadOnly: params["ReadOnly"],
      GuessMIMETypeEnabled: params["GuessMIMETypeEnabled"],
      RequesterPays: params["RequesterPays"],
      SMBACLEnabled: params["SMBACLEnabled"],
      AccessBasedEnumeration: params["AccessBasedEnumeration"],
      AdminUserList: params["AdminUserList"],
      ValidUserList: params["ValidUserList"],
      InvalidUserList: params["InvalidUserList"],
      AuditDestinationARN: params["AuditDestinationARN"],
      CaseSensitivity: params["CaseSensitivity"],
      FileShareName: params["FileShareName"],
      CacheAttributes: fromCacheAttributes(params["CacheAttributes"]),
      NotificationPolicy: params["NotificationPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSMBFileShare",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileShareARN": "s",
      },
    }, await resp.json());
  }

  async updateSMBFileShareVisibility(
    {abortSignal, ...params}: RequestConfig & UpdateSMBFileShareVisibilityInput,
  ): Promise<UpdateSMBFileShareVisibilityOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      FileSharesVisible: params["FileSharesVisible"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSMBFileShareVisibility",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateSMBSecurityStrategy(
    {abortSignal, ...params}: RequestConfig & UpdateSMBSecurityStrategyInput,
  ): Promise<UpdateSMBSecurityStrategyOutput> {
    const body: jsonP.JSONObject = {
      GatewayARN: params["GatewayARN"],
      SMBSecurityStrategy: params["SMBSecurityStrategy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSMBSecurityStrategy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GatewayARN": "s",
      },
    }, await resp.json());
  }

  async updateSnapshotSchedule(
    {abortSignal, ...params}: RequestConfig & UpdateSnapshotScheduleInput,
  ): Promise<UpdateSnapshotScheduleOutput> {
    const body: jsonP.JSONObject = {
      VolumeARN: params["VolumeARN"],
      StartAt: params["StartAt"],
      RecurrenceInHours: params["RecurrenceInHours"],
      Description: params["Description"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSnapshotSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VolumeARN": "s",
      },
    }, await resp.json());
  }

  async updateVTLDeviceType(
    {abortSignal, ...params}: RequestConfig & UpdateVTLDeviceTypeInput,
  ): Promise<UpdateVTLDeviceTypeOutput> {
    const body: jsonP.JSONObject = {
      VTLDeviceARN: params["VTLDeviceARN"],
      DeviceType: params["DeviceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVTLDeviceType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VTLDeviceARN": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface ActivateGatewayInput {
  ActivationKey: string;
  GatewayName: string;
  GatewayTimezone: string;
  GatewayRegion: string;
  GatewayType?: string | null;
  TapeDriveType?: string | null;
  MediumChangerType?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface AddCacheInput {
  GatewayARN: string;
  DiskIds: string[];
}

// refs: 1 - tags: named, input
export interface AddTagsToResourceInput {
  ResourceARN: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface AddUploadBufferInput {
  GatewayARN: string;
  DiskIds: string[];
}

// refs: 1 - tags: named, input
export interface AddWorkingStorageInput {
  GatewayARN: string;
  DiskIds: string[];
}

// refs: 1 - tags: named, input
export interface AssignTapePoolInput {
  TapeARN: string;
  PoolId: string;
  BypassGovernanceRetention?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AttachVolumeInput {
  GatewayARN: string;
  TargetName?: string | null;
  VolumeARN: string;
  NetworkInterfaceId: string;
  DiskId?: string | null;
}

// refs: 1 - tags: named, input
export interface CancelArchivalInput {
  GatewayARN: string;
  TapeARN: string;
}

// refs: 1 - tags: named, input
export interface CancelRetrievalInput {
  GatewayARN: string;
  TapeARN: string;
}

// refs: 1 - tags: named, input
export interface CreateCachediSCSIVolumeInput {
  GatewayARN: string;
  VolumeSizeInBytes: number;
  SnapshotId?: string | null;
  TargetName: string;
  SourceVolumeARN?: string | null;
  NetworkInterfaceId: string;
  ClientToken: string;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateNFSFileShareInput {
  ClientToken: string;
  NFSFileShareDefaults?: NFSFileShareDefaults | null;
  GatewayARN: string;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  Role: string;
  LocationARN: string;
  DefaultStorageClass?: string | null;
  ObjectACL?: ObjectACL | null;
  ClientList?: string[] | null;
  Squash?: string | null;
  ReadOnly?: boolean | null;
  GuessMIMETypeEnabled?: boolean | null;
  RequesterPays?: boolean | null;
  Tags?: Tag[] | null;
  FileShareName?: string | null;
  CacheAttributes?: CacheAttributes | null;
  NotificationPolicy?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateSMBFileShareInput {
  ClientToken: string;
  GatewayARN: string;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  Role: string;
  LocationARN: string;
  DefaultStorageClass?: string | null;
  ObjectACL?: ObjectACL | null;
  ReadOnly?: boolean | null;
  GuessMIMETypeEnabled?: boolean | null;
  RequesterPays?: boolean | null;
  SMBACLEnabled?: boolean | null;
  AccessBasedEnumeration?: boolean | null;
  AdminUserList?: string[] | null;
  ValidUserList?: string[] | null;
  InvalidUserList?: string[] | null;
  AuditDestinationARN?: string | null;
  Authentication?: string | null;
  CaseSensitivity?: CaseSensitivity | null;
  Tags?: Tag[] | null;
  FileShareName?: string | null;
  CacheAttributes?: CacheAttributes | null;
  NotificationPolicy?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateSnapshotInput {
  VolumeARN: string;
  SnapshotDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateSnapshotFromVolumeRecoveryPointInput {
  VolumeARN: string;
  SnapshotDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateStorediSCSIVolumeInput {
  GatewayARN: string;
  DiskId: string;
  SnapshotId?: string | null;
  PreserveExistingData: boolean;
  TargetName: string;
  NetworkInterfaceId: string;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateTapePoolInput {
  PoolName: string;
  StorageClass: TapeStorageClass;
  RetentionLockType?: RetentionLockType | null;
  RetentionLockTimeInDays?: number | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateTapeWithBarcodeInput {
  GatewayARN: string;
  TapeSizeInBytes: number;
  TapeBarcode: string;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  PoolId?: string | null;
  Worm?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateTapesInput {
  GatewayARN: string;
  TapeSizeInBytes: number;
  ClientToken: string;
  NumTapesToCreate: number;
  TapeBarcodePrefix: string;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  PoolId?: string | null;
  Worm?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteAutomaticTapeCreationPolicyInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DeleteBandwidthRateLimitInput {
  GatewayARN: string;
  BandwidthType: string;
}

// refs: 1 - tags: named, input
export interface DeleteChapCredentialsInput {
  TargetARN: string;
  InitiatorName: string;
}

// refs: 1 - tags: named, input
export interface DeleteFileShareInput {
  FileShareARN: string;
  ForceDelete?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteGatewayInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DeleteSnapshotScheduleInput {
  VolumeARN: string;
}

// refs: 1 - tags: named, input
export interface DeleteTapeInput {
  GatewayARN: string;
  TapeARN: string;
  BypassGovernanceRetention?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTapeArchiveInput {
  TapeARN: string;
  BypassGovernanceRetention?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTapePoolInput {
  PoolARN: string;
}

// refs: 1 - tags: named, input
export interface DeleteVolumeInput {
  VolumeARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeAvailabilityMonitorTestInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeBandwidthRateLimitInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeBandwidthRateLimitScheduleInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeCacheInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeCachediSCSIVolumesInput {
  VolumeARNs: string[];
}

// refs: 1 - tags: named, input
export interface DescribeChapCredentialsInput {
  TargetARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeGatewayInformationInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeMaintenanceStartTimeInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeNFSFileSharesInput {
  FileShareARNList: string[];
}

// refs: 1 - tags: named, input
export interface DescribeSMBFileSharesInput {
  FileShareARNList: string[];
}

// refs: 1 - tags: named, input
export interface DescribeSMBSettingsInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeSnapshotScheduleInput {
  VolumeARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeStorediSCSIVolumesInput {
  VolumeARNs: string[];
}

// refs: 1 - tags: named, input
export interface DescribeTapeArchivesInput {
  TapeARNs?: string[] | null;
  Marker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTapeRecoveryPointsInput {
  GatewayARN: string;
  Marker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTapesInput {
  GatewayARN: string;
  TapeARNs?: string[] | null;
  Marker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeUploadBufferInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DescribeVTLDevicesInput {
  GatewayARN: string;
  VTLDeviceARNs?: string[] | null;
  Marker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeWorkingStorageInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface DetachVolumeInput {
  VolumeARN: string;
  ForceDetach?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisableGatewayInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface JoinDomainInput {
  GatewayARN: string;
  DomainName: string;
  OrganizationalUnit?: string | null;
  DomainControllers?: string[] | null;
  TimeoutInSeconds?: number | null;
  UserName: string;
  Password: string;
}

// refs: 1 - tags: named, input
export interface ListAutomaticTapeCreationPoliciesInput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, input
export interface ListFileSharesInput {
  GatewayARN?: string | null;
  Limit?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListGatewaysInput {
  Marker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListLocalDisksInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceInput {
  ResourceARN: string;
  Marker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTapePoolsInput {
  PoolARNs?: string[] | null;
  Marker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTapesInput {
  TapeARNs?: string[] | null;
  Marker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListVolumeInitiatorsInput {
  VolumeARN: string;
}

// refs: 1 - tags: named, input
export interface ListVolumeRecoveryPointsInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface ListVolumesInput {
  GatewayARN?: string | null;
  Marker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface NotifyWhenUploadedInput {
  FileShareARN: string;
}

// refs: 1 - tags: named, input
export interface RefreshCacheInput {
  FileShareARN: string;
  FolderList?: string[] | null;
  Recursive?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RemoveTagsFromResourceInput {
  ResourceARN: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface ResetCacheInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface RetrieveTapeArchiveInput {
  TapeARN: string;
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface RetrieveTapeRecoveryPointInput {
  TapeARN: string;
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface SetLocalConsolePasswordInput {
  GatewayARN: string;
  LocalConsolePassword: string;
}

// refs: 1 - tags: named, input
export interface SetSMBGuestPasswordInput {
  GatewayARN: string;
  Password: string;
}

// refs: 1 - tags: named, input
export interface ShutdownGatewayInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface StartAvailabilityMonitorTestInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface StartGatewayInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface UpdateAutomaticTapeCreationPolicyInput {
  AutomaticTapeCreationRules: AutomaticTapeCreationRule[];
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface UpdateBandwidthRateLimitInput {
  GatewayARN: string;
  AverageUploadRateLimitInBitsPerSec?: number | null;
  AverageDownloadRateLimitInBitsPerSec?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateBandwidthRateLimitScheduleInput {
  GatewayARN: string;
  BandwidthRateLimitIntervals: BandwidthRateLimitInterval[];
}

// refs: 1 - tags: named, input
export interface UpdateChapCredentialsInput {
  TargetARN: string;
  SecretToAuthenticateInitiator: string;
  InitiatorName: string;
  SecretToAuthenticateTarget?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateGatewayInformationInput {
  GatewayARN: string;
  GatewayName?: string | null;
  GatewayTimezone?: string | null;
  CloudWatchLogGroupARN?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateGatewaySoftwareNowInput {
  GatewayARN: string;
}

// refs: 1 - tags: named, input
export interface UpdateMaintenanceStartTimeInput {
  GatewayARN: string;
  HourOfDay: number;
  MinuteOfHour: number;
  DayOfWeek?: number | null;
  DayOfMonth?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateNFSFileShareInput {
  FileShareARN: string;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  NFSFileShareDefaults?: NFSFileShareDefaults | null;
  DefaultStorageClass?: string | null;
  ObjectACL?: ObjectACL | null;
  ClientList?: string[] | null;
  Squash?: string | null;
  ReadOnly?: boolean | null;
  GuessMIMETypeEnabled?: boolean | null;
  RequesterPays?: boolean | null;
  FileShareName?: string | null;
  CacheAttributes?: CacheAttributes | null;
  NotificationPolicy?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateSMBFileShareInput {
  FileShareARN: string;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  DefaultStorageClass?: string | null;
  ObjectACL?: ObjectACL | null;
  ReadOnly?: boolean | null;
  GuessMIMETypeEnabled?: boolean | null;
  RequesterPays?: boolean | null;
  SMBACLEnabled?: boolean | null;
  AccessBasedEnumeration?: boolean | null;
  AdminUserList?: string[] | null;
  ValidUserList?: string[] | null;
  InvalidUserList?: string[] | null;
  AuditDestinationARN?: string | null;
  CaseSensitivity?: CaseSensitivity | null;
  FileShareName?: string | null;
  CacheAttributes?: CacheAttributes | null;
  NotificationPolicy?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateSMBFileShareVisibilityInput {
  GatewayARN: string;
  FileSharesVisible: boolean;
}

// refs: 1 - tags: named, input
export interface UpdateSMBSecurityStrategyInput {
  GatewayARN: string;
  SMBSecurityStrategy: SMBSecurityStrategy;
}

// refs: 1 - tags: named, input
export interface UpdateSnapshotScheduleInput {
  VolumeARN: string;
  StartAt: number;
  RecurrenceInHours: number;
  Description?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateVTLDeviceTypeInput {
  VTLDeviceARN: string;
  DeviceType: string;
}

// refs: 1 - tags: named, output
export interface ActivateGatewayOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface AddCacheOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface AddTagsToResourceOutput {
  ResourceARN?: string | null;
}

// refs: 1 - tags: named, output
export interface AddUploadBufferOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface AddWorkingStorageOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface AssignTapePoolOutput {
  TapeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface AttachVolumeOutput {
  VolumeARN?: string | null;
  TargetARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CancelArchivalOutput {
  TapeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CancelRetrievalOutput {
  TapeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateCachediSCSIVolumeOutput {
  VolumeARN?: string | null;
  TargetARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateNFSFileShareOutput {
  FileShareARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSMBFileShareOutput {
  FileShareARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSnapshotOutput {
  VolumeARN?: string | null;
  SnapshotId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSnapshotFromVolumeRecoveryPointOutput {
  SnapshotId?: string | null;
  VolumeARN?: string | null;
  VolumeRecoveryPointTime?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateStorediSCSIVolumeOutput {
  VolumeARN?: string | null;
  VolumeSizeInBytes?: number | null;
  TargetARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateTapePoolOutput {
  PoolARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateTapeWithBarcodeOutput {
  TapeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateTapesOutput {
  TapeARNs?: string[] | null;
}

// refs: 1 - tags: named, output
export interface DeleteAutomaticTapeCreationPolicyOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteBandwidthRateLimitOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteChapCredentialsOutput {
  TargetARN?: string | null;
  InitiatorName?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteFileShareOutput {
  FileShareARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteGatewayOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteSnapshotScheduleOutput {
  VolumeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteTapeOutput {
  TapeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteTapeArchiveOutput {
  TapeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteTapePoolOutput {
  PoolARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteVolumeOutput {
  VolumeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeAvailabilityMonitorTestOutput {
  GatewayARN?: string | null;
  Status?: AvailabilityMonitorTestStatus | null;
  StartTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeBandwidthRateLimitOutput {
  GatewayARN?: string | null;
  AverageUploadRateLimitInBitsPerSec?: number | null;
  AverageDownloadRateLimitInBitsPerSec?: number | null;
}

// refs: 1 - tags: named, output
export interface DescribeBandwidthRateLimitScheduleOutput {
  GatewayARN?: string | null;
  BandwidthRateLimitIntervals?: BandwidthRateLimitInterval[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeCacheOutput {
  GatewayARN?: string | null;
  DiskIds?: string[] | null;
  CacheAllocatedInBytes?: number | null;
  CacheUsedPercentage?: number | null;
  CacheDirtyPercentage?: number | null;
  CacheHitPercentage?: number | null;
  CacheMissPercentage?: number | null;
}

// refs: 1 - tags: named, output
export interface DescribeCachediSCSIVolumesOutput {
  CachediSCSIVolumes?: CachediSCSIVolume[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeChapCredentialsOutput {
  ChapCredentials?: ChapInfo[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeGatewayInformationOutput {
  GatewayARN?: string | null;
  GatewayId?: string | null;
  GatewayName?: string | null;
  GatewayTimezone?: string | null;
  GatewayState?: string | null;
  GatewayNetworkInterfaces?: NetworkInterface[] | null;
  GatewayType?: string | null;
  NextUpdateAvailabilityDate?: string | null;
  LastSoftwareUpdate?: string | null;
  Ec2InstanceId?: string | null;
  Ec2InstanceRegion?: string | null;
  Tags?: Tag[] | null;
  VPCEndpoint?: string | null;
  CloudWatchLogGroupARN?: string | null;
  HostEnvironment?: HostEnvironment | null;
  EndpointType?: string | null;
  SoftwareUpdatesEndDate?: string | null;
  DeprecationDate?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeMaintenanceStartTimeOutput {
  GatewayARN?: string | null;
  HourOfDay?: number | null;
  MinuteOfHour?: number | null;
  DayOfWeek?: number | null;
  DayOfMonth?: number | null;
  Timezone?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeNFSFileSharesOutput {
  NFSFileShareInfoList?: NFSFileShareInfo[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeSMBFileSharesOutput {
  SMBFileShareInfoList?: SMBFileShareInfo[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeSMBSettingsOutput {
  GatewayARN?: string | null;
  DomainName?: string | null;
  ActiveDirectoryStatus?: ActiveDirectoryStatus | null;
  SMBGuestPasswordSet?: boolean | null;
  SMBSecurityStrategy?: SMBSecurityStrategy | null;
  FileSharesVisible?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DescribeSnapshotScheduleOutput {
  VolumeARN?: string | null;
  StartAt?: number | null;
  RecurrenceInHours?: number | null;
  Description?: string | null;
  Timezone?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeStorediSCSIVolumesOutput {
  StorediSCSIVolumes?: StorediSCSIVolume[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeTapeArchivesOutput {
  TapeArchives?: TapeArchive[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTapeRecoveryPointsOutput {
  GatewayARN?: string | null;
  TapeRecoveryPointInfos?: TapeRecoveryPointInfo[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTapesOutput {
  Tapes?: Tape[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeUploadBufferOutput {
  GatewayARN?: string | null;
  DiskIds?: string[] | null;
  UploadBufferUsedInBytes?: number | null;
  UploadBufferAllocatedInBytes?: number | null;
}

// refs: 1 - tags: named, output
export interface DescribeVTLDevicesOutput {
  GatewayARN?: string | null;
  VTLDevices?: VTLDevice[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeWorkingStorageOutput {
  GatewayARN?: string | null;
  DiskIds?: string[] | null;
  WorkingStorageUsedInBytes?: number | null;
  WorkingStorageAllocatedInBytes?: number | null;
}

// refs: 1 - tags: named, output
export interface DetachVolumeOutput {
  VolumeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DisableGatewayOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface JoinDomainOutput {
  GatewayARN?: string | null;
  ActiveDirectoryStatus?: ActiveDirectoryStatus | null;
}

// refs: 1 - tags: named, output
export interface ListAutomaticTapeCreationPoliciesOutput {
  AutomaticTapeCreationPolicyInfos?: AutomaticTapeCreationPolicyInfo[] | null;
}

// refs: 1 - tags: named, output
export interface ListFileSharesOutput {
  Marker?: string | null;
  NextMarker?: string | null;
  FileShareInfoList?: FileShareInfo[] | null;
}

// refs: 1 - tags: named, output
export interface ListGatewaysOutput {
  Gateways?: GatewayInfo[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListLocalDisksOutput {
  GatewayARN?: string | null;
  Disks?: Disk[] | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceOutput {
  ResourceARN?: string | null;
  Marker?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface ListTapePoolsOutput {
  PoolInfos?: PoolInfo[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTapesOutput {
  TapeInfos?: TapeInfo[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListVolumeInitiatorsOutput {
  Initiators?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListVolumeRecoveryPointsOutput {
  GatewayARN?: string | null;
  VolumeRecoveryPointInfos?: VolumeRecoveryPointInfo[] | null;
}

// refs: 1 - tags: named, output
export interface ListVolumesOutput {
  GatewayARN?: string | null;
  Marker?: string | null;
  VolumeInfos?: VolumeInfo[] | null;
}

// refs: 1 - tags: named, output
export interface NotifyWhenUploadedOutput {
  FileShareARN?: string | null;
  NotificationId?: string | null;
}

// refs: 1 - tags: named, output
export interface RefreshCacheOutput {
  FileShareARN?: string | null;
  NotificationId?: string | null;
}

// refs: 1 - tags: named, output
export interface RemoveTagsFromResourceOutput {
  ResourceARN?: string | null;
}

// refs: 1 - tags: named, output
export interface ResetCacheOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface RetrieveTapeArchiveOutput {
  TapeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface RetrieveTapeRecoveryPointOutput {
  TapeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface SetLocalConsolePasswordOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface SetSMBGuestPasswordOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface ShutdownGatewayOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface StartAvailabilityMonitorTestOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface StartGatewayOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateAutomaticTapeCreationPolicyOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateBandwidthRateLimitOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateBandwidthRateLimitScheduleOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateChapCredentialsOutput {
  TargetARN?: string | null;
  InitiatorName?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateGatewayInformationOutput {
  GatewayARN?: string | null;
  GatewayName?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateGatewaySoftwareNowOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateMaintenanceStartTimeOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateNFSFileShareOutput {
  FileShareARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateSMBFileShareOutput {
  FileShareARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateSMBFileShareVisibilityOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateSMBSecurityStrategyOutput {
  GatewayARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateSnapshotScheduleOutput {
  VolumeARN?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateVTLDeviceTypeOutput {
  VTLDeviceARN?: string | null;
}

// refs: 17 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface NFSFileShareDefaults {
  FileMode?: string | null;
  DirectoryMode?: string | null;
  GroupId?: number | null;
  OwnerId?: number | null;
}
function fromNFSFileShareDefaults(input?: NFSFileShareDefaults | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FileMode: input["FileMode"],
    DirectoryMode: input["DirectoryMode"],
    GroupId: input["GroupId"],
    OwnerId: input["OwnerId"],
  }
}
function toNFSFileShareDefaults(root: jsonP.JSONValue): NFSFileShareDefaults {
  return jsonP.readObj({
    required: {},
    optional: {
      "FileMode": "s",
      "DirectoryMode": "s",
      "GroupId": "n",
      "OwnerId": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ObjectACL =
| "private"
| "public-read"
| "public-read-write"
| "authenticated-read"
| "bucket-owner-read"
| "bucket-owner-full-control"
| "aws-exec-read"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface CacheAttributes {
  CacheStaleTimeoutInSeconds?: number | null;
}
function fromCacheAttributes(input?: CacheAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CacheStaleTimeoutInSeconds: input["CacheStaleTimeoutInSeconds"],
  }
}
function toCacheAttributes(root: jsonP.JSONValue): CacheAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "CacheStaleTimeoutInSeconds": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type CaseSensitivity =
| "ClientSpecified"
| "CaseSensitive"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type TapeStorageClass =
| "DEEP_ARCHIVE"
| "GLACIER"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type RetentionLockType =
| "COMPLIANCE"
| "GOVERNANCE"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface AutomaticTapeCreationRule {
  TapeBarcodePrefix: string;
  PoolId: string;
  TapeSizeInBytes: number;
  MinimumNumTapes: number;
  Worm?: boolean | null;
}
function fromAutomaticTapeCreationRule(input?: AutomaticTapeCreationRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TapeBarcodePrefix: input["TapeBarcodePrefix"],
    PoolId: input["PoolId"],
    TapeSizeInBytes: input["TapeSizeInBytes"],
    MinimumNumTapes: input["MinimumNumTapes"],
    Worm: input["Worm"],
  }
}
function toAutomaticTapeCreationRule(root: jsonP.JSONValue): AutomaticTapeCreationRule {
  return jsonP.readObj({
    required: {
      "TapeBarcodePrefix": "s",
      "PoolId": "s",
      "TapeSizeInBytes": "n",
      "MinimumNumTapes": "n",
    },
    optional: {
      "Worm": "b",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface BandwidthRateLimitInterval {
  StartHourOfDay: number;
  StartMinuteOfHour: number;
  EndHourOfDay: number;
  EndMinuteOfHour: number;
  DaysOfWeek: number[];
  AverageUploadRateLimitInBitsPerSec?: number | null;
  AverageDownloadRateLimitInBitsPerSec?: number | null;
}
function fromBandwidthRateLimitInterval(input?: BandwidthRateLimitInterval | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartHourOfDay: input["StartHourOfDay"],
    StartMinuteOfHour: input["StartMinuteOfHour"],
    EndHourOfDay: input["EndHourOfDay"],
    EndMinuteOfHour: input["EndMinuteOfHour"],
    DaysOfWeek: input["DaysOfWeek"],
    AverageUploadRateLimitInBitsPerSec: input["AverageUploadRateLimitInBitsPerSec"],
    AverageDownloadRateLimitInBitsPerSec: input["AverageDownloadRateLimitInBitsPerSec"],
  }
}
function toBandwidthRateLimitInterval(root: jsonP.JSONValue): BandwidthRateLimitInterval {
  return jsonP.readObj({
    required: {
      "StartHourOfDay": "n",
      "StartMinuteOfHour": "n",
      "EndHourOfDay": "n",
      "EndMinuteOfHour": "n",
      "DaysOfWeek": ["n"],
    },
    optional: {
      "AverageUploadRateLimitInBitsPerSec": "n",
      "AverageDownloadRateLimitInBitsPerSec": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type SMBSecurityStrategy =
| "ClientSpecified"
| "MandatorySigning"
| "MandatoryEncryption"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type AvailabilityMonitorTestStatus =
| "COMPLETE"
| "FAILED"
| "PENDING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CachediSCSIVolume {
  VolumeARN?: string | null;
  VolumeId?: string | null;
  VolumeType?: string | null;
  VolumeStatus?: string | null;
  VolumeAttachmentStatus?: string | null;
  VolumeSizeInBytes?: number | null;
  VolumeProgress?: number | null;
  SourceSnapshotId?: string | null;
  VolumeiSCSIAttributes?: VolumeiSCSIAttributes | null;
  CreatedDate?: Date | number | null;
  VolumeUsedInBytes?: number | null;
  KMSKey?: string | null;
  TargetName?: string | null;
}
function toCachediSCSIVolume(root: jsonP.JSONValue): CachediSCSIVolume {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeARN": "s",
      "VolumeId": "s",
      "VolumeType": "s",
      "VolumeStatus": "s",
      "VolumeAttachmentStatus": "s",
      "VolumeSizeInBytes": "n",
      "VolumeProgress": "n",
      "SourceSnapshotId": "s",
      "VolumeiSCSIAttributes": toVolumeiSCSIAttributes,
      "CreatedDate": "d",
      "VolumeUsedInBytes": "n",
      "KMSKey": "s",
      "TargetName": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface VolumeiSCSIAttributes {
  TargetARN?: string | null;
  NetworkInterfaceId?: string | null;
  NetworkInterfacePort?: number | null;
  LunNumber?: number | null;
  ChapEnabled?: boolean | null;
}
function toVolumeiSCSIAttributes(root: jsonP.JSONValue): VolumeiSCSIAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetARN": "s",
      "NetworkInterfaceId": "s",
      "NetworkInterfacePort": "n",
      "LunNumber": "n",
      "ChapEnabled": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ChapInfo {
  TargetARN?: string | null;
  SecretToAuthenticateInitiator?: string | null;
  InitiatorName?: string | null;
  SecretToAuthenticateTarget?: string | null;
}
function toChapInfo(root: jsonP.JSONValue): ChapInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetARN": "s",
      "SecretToAuthenticateInitiator": "s",
      "InitiatorName": "s",
      "SecretToAuthenticateTarget": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NetworkInterface {
  Ipv4Address?: string | null;
  MacAddress?: string | null;
  Ipv6Address?: string | null;
}
function toNetworkInterface(root: jsonP.JSONValue): NetworkInterface {
  return jsonP.readObj({
    required: {},
    optional: {
      "Ipv4Address": "s",
      "MacAddress": "s",
      "Ipv6Address": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type HostEnvironment =
| "VMWARE"
| "HYPER-V"
| "EC2"
| "KVM"
| "OTHER"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface NFSFileShareInfo {
  NFSFileShareDefaults?: NFSFileShareDefaults | null;
  FileShareARN?: string | null;
  FileShareId?: string | null;
  FileShareStatus?: string | null;
  GatewayARN?: string | null;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  Path?: string | null;
  Role?: string | null;
  LocationARN?: string | null;
  DefaultStorageClass?: string | null;
  ObjectACL?: ObjectACL | null;
  ClientList?: string[] | null;
  Squash?: string | null;
  ReadOnly?: boolean | null;
  GuessMIMETypeEnabled?: boolean | null;
  RequesterPays?: boolean | null;
  Tags?: Tag[] | null;
  FileShareName?: string | null;
  CacheAttributes?: CacheAttributes | null;
  NotificationPolicy?: string | null;
}
function toNFSFileShareInfo(root: jsonP.JSONValue): NFSFileShareInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "NFSFileShareDefaults": toNFSFileShareDefaults,
      "FileShareARN": "s",
      "FileShareId": "s",
      "FileShareStatus": "s",
      "GatewayARN": "s",
      "KMSEncrypted": "b",
      "KMSKey": "s",
      "Path": "s",
      "Role": "s",
      "LocationARN": "s",
      "DefaultStorageClass": "s",
      "ObjectACL": (x: jsonP.JSONValue) => cmnP.readEnum<ObjectACL>(x),
      "ClientList": ["s"],
      "Squash": "s",
      "ReadOnly": "b",
      "GuessMIMETypeEnabled": "b",
      "RequesterPays": "b",
      "Tags": [toTag],
      "FileShareName": "s",
      "CacheAttributes": toCacheAttributes,
      "NotificationPolicy": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SMBFileShareInfo {
  FileShareARN?: string | null;
  FileShareId?: string | null;
  FileShareStatus?: string | null;
  GatewayARN?: string | null;
  KMSEncrypted?: boolean | null;
  KMSKey?: string | null;
  Path?: string | null;
  Role?: string | null;
  LocationARN?: string | null;
  DefaultStorageClass?: string | null;
  ObjectACL?: ObjectACL | null;
  ReadOnly?: boolean | null;
  GuessMIMETypeEnabled?: boolean | null;
  RequesterPays?: boolean | null;
  SMBACLEnabled?: boolean | null;
  AccessBasedEnumeration?: boolean | null;
  AdminUserList?: string[] | null;
  ValidUserList?: string[] | null;
  InvalidUserList?: string[] | null;
  AuditDestinationARN?: string | null;
  Authentication?: string | null;
  CaseSensitivity?: CaseSensitivity | null;
  Tags?: Tag[] | null;
  FileShareName?: string | null;
  CacheAttributes?: CacheAttributes | null;
  NotificationPolicy?: string | null;
}
function toSMBFileShareInfo(root: jsonP.JSONValue): SMBFileShareInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "FileShareARN": "s",
      "FileShareId": "s",
      "FileShareStatus": "s",
      "GatewayARN": "s",
      "KMSEncrypted": "b",
      "KMSKey": "s",
      "Path": "s",
      "Role": "s",
      "LocationARN": "s",
      "DefaultStorageClass": "s",
      "ObjectACL": (x: jsonP.JSONValue) => cmnP.readEnum<ObjectACL>(x),
      "ReadOnly": "b",
      "GuessMIMETypeEnabled": "b",
      "RequesterPays": "b",
      "SMBACLEnabled": "b",
      "AccessBasedEnumeration": "b",
      "AdminUserList": ["s"],
      "ValidUserList": ["s"],
      "InvalidUserList": ["s"],
      "AuditDestinationARN": "s",
      "Authentication": "s",
      "CaseSensitivity": (x: jsonP.JSONValue) => cmnP.readEnum<CaseSensitivity>(x),
      "Tags": [toTag],
      "FileShareName": "s",
      "CacheAttributes": toCacheAttributes,
      "NotificationPolicy": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ActiveDirectoryStatus =
| "ACCESS_DENIED"
| "DETACHED"
| "JOINED"
| "JOINING"
| "NETWORK_ERROR"
| "TIMEOUT"
| "UNKNOWN_ERROR"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface StorediSCSIVolume {
  VolumeARN?: string | null;
  VolumeId?: string | null;
  VolumeType?: string | null;
  VolumeStatus?: string | null;
  VolumeAttachmentStatus?: string | null;
  VolumeSizeInBytes?: number | null;
  VolumeProgress?: number | null;
  VolumeDiskId?: string | null;
  SourceSnapshotId?: string | null;
  PreservedExistingData?: boolean | null;
  VolumeiSCSIAttributes?: VolumeiSCSIAttributes | null;
  CreatedDate?: Date | number | null;
  VolumeUsedInBytes?: number | null;
  KMSKey?: string | null;
  TargetName?: string | null;
}
function toStorediSCSIVolume(root: jsonP.JSONValue): StorediSCSIVolume {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeARN": "s",
      "VolumeId": "s",
      "VolumeType": "s",
      "VolumeStatus": "s",
      "VolumeAttachmentStatus": "s",
      "VolumeSizeInBytes": "n",
      "VolumeProgress": "n",
      "VolumeDiskId": "s",
      "SourceSnapshotId": "s",
      "PreservedExistingData": "b",
      "VolumeiSCSIAttributes": toVolumeiSCSIAttributes,
      "CreatedDate": "d",
      "VolumeUsedInBytes": "n",
      "KMSKey": "s",
      "TargetName": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TapeArchive {
  TapeARN?: string | null;
  TapeBarcode?: string | null;
  TapeCreatedDate?: Date | number | null;
  TapeSizeInBytes?: number | null;
  CompletionTime?: Date | number | null;
  RetrievedTo?: string | null;
  TapeStatus?: string | null;
  TapeUsedInBytes?: number | null;
  KMSKey?: string | null;
  PoolId?: string | null;
  Worm?: boolean | null;
  RetentionStartDate?: Date | number | null;
  PoolEntryDate?: Date | number | null;
}
function toTapeArchive(root: jsonP.JSONValue): TapeArchive {
  return jsonP.readObj({
    required: {},
    optional: {
      "TapeARN": "s",
      "TapeBarcode": "s",
      "TapeCreatedDate": "d",
      "TapeSizeInBytes": "n",
      "CompletionTime": "d",
      "RetrievedTo": "s",
      "TapeStatus": "s",
      "TapeUsedInBytes": "n",
      "KMSKey": "s",
      "PoolId": "s",
      "Worm": "b",
      "RetentionStartDate": "d",
      "PoolEntryDate": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TapeRecoveryPointInfo {
  TapeARN?: string | null;
  TapeRecoveryPointTime?: Date | number | null;
  TapeSizeInBytes?: number | null;
  TapeStatus?: string | null;
}
function toTapeRecoveryPointInfo(root: jsonP.JSONValue): TapeRecoveryPointInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "TapeARN": "s",
      "TapeRecoveryPointTime": "d",
      "TapeSizeInBytes": "n",
      "TapeStatus": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Tape {
  TapeARN?: string | null;
  TapeBarcode?: string | null;
  TapeCreatedDate?: Date | number | null;
  TapeSizeInBytes?: number | null;
  TapeStatus?: string | null;
  VTLDevice?: string | null;
  Progress?: number | null;
  TapeUsedInBytes?: number | null;
  KMSKey?: string | null;
  PoolId?: string | null;
  Worm?: boolean | null;
  RetentionStartDate?: Date | number | null;
  PoolEntryDate?: Date | number | null;
}
function toTape(root: jsonP.JSONValue): Tape {
  return jsonP.readObj({
    required: {},
    optional: {
      "TapeARN": "s",
      "TapeBarcode": "s",
      "TapeCreatedDate": "d",
      "TapeSizeInBytes": "n",
      "TapeStatus": "s",
      "VTLDevice": "s",
      "Progress": "n",
      "TapeUsedInBytes": "n",
      "KMSKey": "s",
      "PoolId": "s",
      "Worm": "b",
      "RetentionStartDate": "d",
      "PoolEntryDate": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VTLDevice {
  VTLDeviceARN?: string | null;
  VTLDeviceType?: string | null;
  VTLDeviceVendor?: string | null;
  VTLDeviceProductIdentifier?: string | null;
  DeviceiSCSIAttributes?: DeviceiSCSIAttributes | null;
}
function toVTLDevice(root: jsonP.JSONValue): VTLDevice {
  return jsonP.readObj({
    required: {},
    optional: {
      "VTLDeviceARN": "s",
      "VTLDeviceType": "s",
      "VTLDeviceVendor": "s",
      "VTLDeviceProductIdentifier": "s",
      "DeviceiSCSIAttributes": toDeviceiSCSIAttributes,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DeviceiSCSIAttributes {
  TargetARN?: string | null;
  NetworkInterfaceId?: string | null;
  NetworkInterfacePort?: number | null;
  ChapEnabled?: boolean | null;
}
function toDeviceiSCSIAttributes(root: jsonP.JSONValue): DeviceiSCSIAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetARN": "s",
      "NetworkInterfaceId": "s",
      "NetworkInterfacePort": "n",
      "ChapEnabled": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AutomaticTapeCreationPolicyInfo {
  AutomaticTapeCreationRules?: AutomaticTapeCreationRule[] | null;
  GatewayARN?: string | null;
}
function toAutomaticTapeCreationPolicyInfo(root: jsonP.JSONValue): AutomaticTapeCreationPolicyInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomaticTapeCreationRules": [toAutomaticTapeCreationRule],
      "GatewayARN": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FileShareInfo {
  FileShareType?: FileShareType | null;
  FileShareARN?: string | null;
  FileShareId?: string | null;
  FileShareStatus?: string | null;
  GatewayARN?: string | null;
}
function toFileShareInfo(root: jsonP.JSONValue): FileShareInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "FileShareType": (x: jsonP.JSONValue) => cmnP.readEnum<FileShareType>(x),
      "FileShareARN": "s",
      "FileShareId": "s",
      "FileShareStatus": "s",
      "GatewayARN": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type FileShareType =
| "NFS"
| "SMB"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface GatewayInfo {
  GatewayId?: string | null;
  GatewayARN?: string | null;
  GatewayType?: string | null;
  GatewayOperationalState?: string | null;
  GatewayName?: string | null;
  Ec2InstanceId?: string | null;
  Ec2InstanceRegion?: string | null;
}
function toGatewayInfo(root: jsonP.JSONValue): GatewayInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "GatewayId": "s",
      "GatewayARN": "s",
      "GatewayType": "s",
      "GatewayOperationalState": "s",
      "GatewayName": "s",
      "Ec2InstanceId": "s",
      "Ec2InstanceRegion": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Disk {
  DiskId?: string | null;
  DiskPath?: string | null;
  DiskNode?: string | null;
  DiskStatus?: string | null;
  DiskSizeInBytes?: number | null;
  DiskAllocationType?: string | null;
  DiskAllocationResource?: string | null;
  DiskAttributeList?: string[] | null;
}
function toDisk(root: jsonP.JSONValue): Disk {
  return jsonP.readObj({
    required: {},
    optional: {
      "DiskId": "s",
      "DiskPath": "s",
      "DiskNode": "s",
      "DiskStatus": "s",
      "DiskSizeInBytes": "n",
      "DiskAllocationType": "s",
      "DiskAllocationResource": "s",
      "DiskAttributeList": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PoolInfo {
  PoolARN?: string | null;
  PoolName?: string | null;
  StorageClass?: TapeStorageClass | null;
  RetentionLockType?: RetentionLockType | null;
  RetentionLockTimeInDays?: number | null;
  PoolStatus?: PoolStatus | null;
}
function toPoolInfo(root: jsonP.JSONValue): PoolInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "PoolARN": "s",
      "PoolName": "s",
      "StorageClass": (x: jsonP.JSONValue) => cmnP.readEnum<TapeStorageClass>(x),
      "RetentionLockType": (x: jsonP.JSONValue) => cmnP.readEnum<RetentionLockType>(x),
      "RetentionLockTimeInDays": "n",
      "PoolStatus": (x: jsonP.JSONValue) => cmnP.readEnum<PoolStatus>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type PoolStatus =
| "ACTIVE"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface TapeInfo {
  TapeARN?: string | null;
  TapeBarcode?: string | null;
  TapeSizeInBytes?: number | null;
  TapeStatus?: string | null;
  GatewayARN?: string | null;
  PoolId?: string | null;
  RetentionStartDate?: Date | number | null;
  PoolEntryDate?: Date | number | null;
}
function toTapeInfo(root: jsonP.JSONValue): TapeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "TapeARN": "s",
      "TapeBarcode": "s",
      "TapeSizeInBytes": "n",
      "TapeStatus": "s",
      "GatewayARN": "s",
      "PoolId": "s",
      "RetentionStartDate": "d",
      "PoolEntryDate": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VolumeRecoveryPointInfo {
  VolumeARN?: string | null;
  VolumeSizeInBytes?: number | null;
  VolumeUsageInBytes?: number | null;
  VolumeRecoveryPointTime?: string | null;
}
function toVolumeRecoveryPointInfo(root: jsonP.JSONValue): VolumeRecoveryPointInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeARN": "s",
      "VolumeSizeInBytes": "n",
      "VolumeUsageInBytes": "n",
      "VolumeRecoveryPointTime": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VolumeInfo {
  VolumeARN?: string | null;
  VolumeId?: string | null;
  GatewayARN?: string | null;
  GatewayId?: string | null;
  VolumeType?: string | null;
  VolumeSizeInBytes?: number | null;
  VolumeAttachmentStatus?: string | null;
}
function toVolumeInfo(root: jsonP.JSONValue): VolumeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeARN": "s",
      "VolumeId": "s",
      "GatewayARN": "s",
      "GatewayId": "s",
      "VolumeType": "s",
      "VolumeSizeInBytes": "n",
      "VolumeAttachmentStatus": "s",
    },
  }, root);
}
