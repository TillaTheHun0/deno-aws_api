// Autogenerated API client for: Amazon Kinesis

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { JSONObject, JSONValue } from '../../encoding/json.ts';
import * as prt from "../../encoding/json.ts";

export default class Kinesis {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Kinesis.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2013-12-02",
    "endpointPrefix": "kinesis",
    "jsonVersion": "1.1",
    "protocol": "json",
    "protocolSettings": {
      "h2": "eventstream"
    },
    "serviceAbbreviation": "Kinesis",
    "serviceFullName": "Amazon Kinesis",
    "serviceId": "Kinesis",
    "signatureVersion": "v4",
    "targetPrefix": "Kinesis_20131202",
    "uid": "kinesis-2013-12-02"
  };

  async addTagsToStream(
    {abortSignal, ...params}: RequestConfig & AddTagsToStreamInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToStream",
    });
  }

  async createStream(
    {abortSignal, ...params}: RequestConfig & CreateStreamInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStream",
    });
  }

  async decreaseStreamRetentionPeriod(
    {abortSignal, ...params}: RequestConfig & DecreaseStreamRetentionPeriodInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DecreaseStreamRetentionPeriod",
    });
  }

  async deleteStream(
    {abortSignal, ...params}: RequestConfig & DeleteStreamInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStream",
    });
  }

  async deregisterStreamConsumer(
    {abortSignal, ...params}: RequestConfig & DeregisterStreamConsumerInput = {},
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterStreamConsumer",
    });
  }

  async describeLimits(
    {abortSignal, ...params}: RequestConfig & DescribeLimitsInput = {},
  ): Promise<DescribeLimitsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLimits",
    });
    return prt.readObj({
      required: {
        "ShardLimit": "n",
        "OpenShardCount": "n",
      },
      optional: {},
    }, await resp.json());
  }

  async describeStream(
    {abortSignal, ...params}: RequestConfig & DescribeStreamInput,
  ): Promise<DescribeStreamOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStream",
    });
    return prt.readObj({
      required: {
        "StreamDescription": toStreamDescription,
      },
      optional: {},
    }, await resp.json());
  }

  async describeStreamConsumer(
    {abortSignal, ...params}: RequestConfig & DescribeStreamConsumerInput = {},
  ): Promise<DescribeStreamConsumerOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStreamConsumer",
    });
    return prt.readObj({
      required: {
        "ConsumerDescription": toConsumerDescription,
      },
      optional: {},
    }, await resp.json());
  }

  async describeStreamSummary(
    {abortSignal, ...params}: RequestConfig & DescribeStreamSummaryInput,
  ): Promise<DescribeStreamSummaryOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStreamSummary",
    });
    return prt.readObj({
      required: {
        "StreamDescriptionSummary": toStreamDescriptionSummary,
      },
      optional: {},
    }, await resp.json());
  }

  async disableEnhancedMonitoring(
    {abortSignal, ...params}: RequestConfig & DisableEnhancedMonitoringInput,
  ): Promise<EnhancedMonitoringOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableEnhancedMonitoring",
    });
    return prt.readObj({
      required: {},
      optional: {
        "StreamName": "s",
        "CurrentShardLevelMetrics": [toMetricsName],
        "DesiredShardLevelMetrics": [toMetricsName],
      },
    }, await resp.json());
  }

  async enableEnhancedMonitoring(
    {abortSignal, ...params}: RequestConfig & EnableEnhancedMonitoringInput,
  ): Promise<EnhancedMonitoringOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableEnhancedMonitoring",
    });
    return prt.readObj({
      required: {},
      optional: {
        "StreamName": "s",
        "CurrentShardLevelMetrics": [toMetricsName],
        "DesiredShardLevelMetrics": [toMetricsName],
      },
    }, await resp.json());
  }

  async getRecords(
    {abortSignal, ...params}: RequestConfig & GetRecordsInput,
  ): Promise<GetRecordsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRecords",
    });
    return prt.readObj({
      required: {
        "Records": [toRecord],
      },
      optional: {
        "NextShardIterator": "s",
        "MillisBehindLatest": "n",
        "ChildShards": [toChildShard],
      },
    }, await resp.json());
  }

  async getShardIterator(
    {abortSignal, ...params}: RequestConfig & GetShardIteratorInput,
  ): Promise<GetShardIteratorOutput> {
    const body: JSONObject = {...params,
    Timestamp: prt.serializeDate_unixTimestamp(params["Timestamp"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetShardIterator",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ShardIterator": "s",
      },
    }, await resp.json());
  }

  async increaseStreamRetentionPeriod(
    {abortSignal, ...params}: RequestConfig & IncreaseStreamRetentionPeriodInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IncreaseStreamRetentionPeriod",
    });
  }

  async listShards(
    {abortSignal, ...params}: RequestConfig & ListShardsInput = {},
  ): Promise<ListShardsOutput> {
    const body: JSONObject = {...params,
    StreamCreationTimestamp: prt.serializeDate_unixTimestamp(params["StreamCreationTimestamp"]),
    ShardFilter: fromShardFilter(params["ShardFilter"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListShards",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Shards": [toShard],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listStreamConsumers(
    {abortSignal, ...params}: RequestConfig & ListStreamConsumersInput,
  ): Promise<ListStreamConsumersOutput> {
    const body: JSONObject = {...params,
    StreamCreationTimestamp: prt.serializeDate_unixTimestamp(params["StreamCreationTimestamp"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStreamConsumers",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Consumers": [toConsumer],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listStreams(
    {abortSignal, ...params}: RequestConfig & ListStreamsInput = {},
  ): Promise<ListStreamsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStreams",
    });
    return prt.readObj({
      required: {
        "StreamNames": ["s"],
        "HasMoreStreams": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async listTagsForStream(
    {abortSignal, ...params}: RequestConfig & ListTagsForStreamInput,
  ): Promise<ListTagsForStreamOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForStream",
    });
    return prt.readObj({
      required: {
        "Tags": [toTag],
        "HasMoreTags": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async mergeShards(
    {abortSignal, ...params}: RequestConfig & MergeShardsInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergeShards",
    });
  }

  async putRecord(
    {abortSignal, ...params}: RequestConfig & PutRecordInput,
  ): Promise<PutRecordOutput> {
    const body: JSONObject = {...params,
    Data: prt.serializeBlob(params["Data"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRecord",
    });
    return prt.readObj({
      required: {
        "ShardId": "s",
        "SequenceNumber": "s",
      },
      optional: {
        "EncryptionType": toEncryptionType,
      },
    }, await resp.json());
  }

  async putRecords(
    {abortSignal, ...params}: RequestConfig & PutRecordsInput,
  ): Promise<PutRecordsOutput> {
    const body: JSONObject = {...params,
    Records: params["Records"]?.map(x => fromPutRecordsRequestEntry(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRecords",
    });
    return prt.readObj({
      required: {
        "Records": [toPutRecordsResultEntry],
      },
      optional: {
        "FailedRecordCount": "n",
        "EncryptionType": toEncryptionType,
      },
    }, await resp.json());
  }

  async registerStreamConsumer(
    {abortSignal, ...params}: RequestConfig & RegisterStreamConsumerInput,
  ): Promise<RegisterStreamConsumerOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterStreamConsumer",
    });
    return prt.readObj({
      required: {
        "Consumer": toConsumer,
      },
      optional: {},
    }, await resp.json());
  }

  async removeTagsFromStream(
    {abortSignal, ...params}: RequestConfig & RemoveTagsFromStreamInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromStream",
    });
  }

  async splitShard(
    {abortSignal, ...params}: RequestConfig & SplitShardInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SplitShard",
    });
  }

  async startStreamEncryption(
    {abortSignal, ...params}: RequestConfig & StartStreamEncryptionInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartStreamEncryption",
    });
  }

  async stopStreamEncryption(
    {abortSignal, ...params}: RequestConfig & StopStreamEncryptionInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopStreamEncryption",
    });
  }

  async updateShardCount(
    {abortSignal, ...params}: RequestConfig & UpdateShardCountInput,
  ): Promise<UpdateShardCountOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateShardCount",
    });
    return prt.readObj({
      required: {},
      optional: {
        "StreamName": "s",
        "CurrentShardCount": "n",
        "TargetShardCount": "n",
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 18 times, 10 seconds apart (about 3 minutes max wait time). */
  async waitForStreamExists(
    params: RequestConfig & DescribeStreamInput,
  ): Promise<DescribeStreamOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StreamExists';
    for (let i = 0; i < 18; i++) {
      const resp = await this.describeStream(params);
      if (resp["StreamDescription"]?.["StreamStatus"] === "ACTIVE") return resp;
      await new Promise(r => setTimeout(r, 10000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 18 times, 10 seconds apart (about 3 minutes max wait time). */
  async waitForStreamNotExists(
    params: RequestConfig & DescribeStreamInput,
  ): Promise<Error | DescribeStreamOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StreamNotExists';
    for (let i = 0; i < 18; i++) {
      try {
        const resp = await this.describeStream(params);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 10000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddTagsToStreamInput {
  StreamName: string;
  Tags: { [key: string]: string };
}

// refs: 1 - tags: named, input
export interface CreateStreamInput {
  StreamName: string;
  ShardCount: number;
}

// refs: 1 - tags: named, input
export interface DecreaseStreamRetentionPeriodInput {
  StreamName: string;
  RetentionPeriodHours: number;
}

// refs: 1 - tags: named, input
export interface DeleteStreamInput {
  StreamName: string;
  EnforceConsumerDeletion?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeregisterStreamConsumerInput {
  StreamARN?: string | null;
  ConsumerName?: string | null;
  ConsumerARN?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeLimitsInput {
}

// refs: 1 - tags: named, input
export interface DescribeStreamInput {
  StreamName: string;
  Limit?: number | null;
  ExclusiveStartShardId?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeStreamConsumerInput {
  StreamARN?: string | null;
  ConsumerName?: string | null;
  ConsumerARN?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeStreamSummaryInput {
  StreamName: string;
}

// refs: 1 - tags: named, input
export interface DisableEnhancedMonitoringInput {
  StreamName: string;
  ShardLevelMetrics: MetricsName[];
}

// refs: 1 - tags: named, input
export interface EnableEnhancedMonitoringInput {
  StreamName: string;
  ShardLevelMetrics: MetricsName[];
}

// refs: 1 - tags: named, input
export interface GetRecordsInput {
  ShardIterator: string;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetShardIteratorInput {
  StreamName: string;
  ShardId: string;
  ShardIteratorType: ShardIteratorType;
  StartingSequenceNumber?: string | null;
  Timestamp?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface IncreaseStreamRetentionPeriodInput {
  StreamName: string;
  RetentionPeriodHours: number;
}

// refs: 1 - tags: named, input
export interface ListShardsInput {
  StreamName?: string | null;
  NextToken?: string | null;
  ExclusiveStartShardId?: string | null;
  MaxResults?: number | null;
  StreamCreationTimestamp?: Date | number | null;
  ShardFilter?: ShardFilter | null;
}

// refs: 1 - tags: named, input
export interface ListStreamConsumersInput {
  StreamARN: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  StreamCreationTimestamp?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface ListStreamsInput {
  Limit?: number | null;
  ExclusiveStartStreamName?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForStreamInput {
  StreamName: string;
  ExclusiveStartTagKey?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface MergeShardsInput {
  StreamName: string;
  ShardToMerge: string;
  AdjacentShardToMerge: string;
}

// refs: 1 - tags: named, input
export interface PutRecordInput {
  StreamName: string;
  Data: Uint8Array | string;
  PartitionKey: string;
  ExplicitHashKey?: string | null;
  SequenceNumberForOrdering?: string | null;
}

// refs: 1 - tags: named, input
export interface PutRecordsInput {
  Records: PutRecordsRequestEntry[];
  StreamName: string;
}

// refs: 1 - tags: named, input
export interface RegisterStreamConsumerInput {
  StreamARN: string;
  ConsumerName: string;
}

// refs: 1 - tags: named, input
export interface RemoveTagsFromStreamInput {
  StreamName: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface SplitShardInput {
  StreamName: string;
  ShardToSplit: string;
  NewStartingHashKey: string;
}

// refs: 1 - tags: named, input
export interface StartStreamEncryptionInput {
  StreamName: string;
  EncryptionType: EncryptionType;
  KeyId: string;
}

// refs: 1 - tags: named, input
export interface StopStreamEncryptionInput {
  StreamName: string;
  EncryptionType: EncryptionType;
  KeyId: string;
}

// refs: 1 - tags: named, input
export interface UpdateShardCountInput {
  StreamName: string;
  TargetShardCount: number;
  ScalingType: ScalingType;
}

// refs: 1 - tags: named, output
export interface DescribeLimitsOutput {
  ShardLimit: number;
  OpenShardCount: number;
}

// refs: 1 - tags: named, output
export interface DescribeStreamOutput {
  StreamDescription: StreamDescription;
}

// refs: 1 - tags: named, output
export interface DescribeStreamConsumerOutput {
  ConsumerDescription: ConsumerDescription;
}

// refs: 1 - tags: named, output
export interface DescribeStreamSummaryOutput {
  StreamDescriptionSummary: StreamDescriptionSummary;
}

// refs: 1 - tags: named, output
export interface EnhancedMonitoringOutput {
  StreamName?: string | null;
  CurrentShardLevelMetrics?: MetricsName[] | null;
  DesiredShardLevelMetrics?: MetricsName[] | null;
}

// refs: 1 - tags: named, output
export interface GetRecordsOutput {
  Records: Record[];
  NextShardIterator?: string | null;
  MillisBehindLatest?: number | null;
  ChildShards?: ChildShard[] | null;
}

// refs: 1 - tags: named, output
export interface GetShardIteratorOutput {
  ShardIterator?: string | null;
}

// refs: 1 - tags: named, output
export interface ListShardsOutput {
  Shards?: Shard[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStreamConsumersOutput {
  Consumers?: Consumer[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStreamsOutput {
  StreamNames: string[];
  HasMoreStreams: boolean;
}

// refs: 1 - tags: named, output
export interface ListTagsForStreamOutput {
  Tags: Tag[];
  HasMoreTags: boolean;
}

// refs: 1 - tags: named, output
export interface PutRecordOutput {
  ShardId: string;
  SequenceNumber: string;
  EncryptionType?: EncryptionType | null;
}

// refs: 1 - tags: named, output
export interface PutRecordsOutput {
  FailedRecordCount?: number | null;
  Records: PutRecordsResultEntry[];
  EncryptionType?: EncryptionType | null;
}

// refs: 1 - tags: named, output
export interface RegisterStreamConsumerOutput {
  Consumer: Consumer;
}

// refs: 1 - tags: named, output
export interface UpdateShardCountOutput {
  StreamName?: string | null;
  CurrentShardCount?: number | null;
  TargetShardCount?: number | null;
}

// refs: 6 - tags: input, named, enum, output
export type MetricsName =
| "IncomingBytes"
| "IncomingRecords"
| "OutgoingBytes"
| "OutgoingRecords"
| "WriteProvisionedThroughputExceeded"
| "ReadProvisionedThroughputExceeded"
| "IteratorAgeMilliseconds"
| "ALL"
;

function toMetricsName(root: JSONValue): MetricsName | null {
  return ( false
    || root == "IncomingBytes"
    || root == "IncomingRecords"
    || root == "OutgoingBytes"
    || root == "OutgoingRecords"
    || root == "WriteProvisionedThroughputExceeded"
    || root == "ReadProvisionedThroughputExceeded"
    || root == "IteratorAgeMilliseconds"
    || root == "ALL"
  ) ? root : null;
}

// refs: 1 - tags: input, named, enum
export type ShardIteratorType =
| "AT_SEQUENCE_NUMBER"
| "AFTER_SEQUENCE_NUMBER"
| "TRIM_HORIZON"
| "LATEST"
| "AT_TIMESTAMP"
;


// refs: 1 - tags: input, named, interface
export interface ShardFilter {
  Type: ShardFilterType;
  ShardId?: string | null;
  Timestamp?: Date | number | null;
}
function fromShardFilter(input?: ShardFilter | null): JSONValue {
  if (!input) return input;
  return {...input,
    Timestamp: prt.serializeDate_unixTimestamp(input["Timestamp"]),
  }
}

// refs: 1 - tags: input, named, enum
export type ShardFilterType =
| "AFTER_SHARD_ID"
| "AT_TRIM_HORIZON"
| "FROM_TRIM_HORIZON"
| "AT_LATEST"
| "AT_TIMESTAMP"
| "FROM_TIMESTAMP"
;


// refs: 1 - tags: input, named, interface
export interface PutRecordsRequestEntry {
  Data: Uint8Array | string;
  ExplicitHashKey?: string | null;
  PartitionKey: string;
}
function fromPutRecordsRequestEntry(input?: PutRecordsRequestEntry | null): JSONValue {
  if (!input) return input;
  return {...input,
    Data: prt.serializeBlob(input["Data"]),
  }
}

// refs: 7 - tags: input, named, enum, output
export type EncryptionType =
| "NONE"
| "KMS"
;

function toEncryptionType(root: JSONValue): EncryptionType | null {
  return ( false
    || root == "NONE"
    || root == "KMS"
  ) ? root : null;
}

// refs: 1 - tags: input, named, enum
export type ScalingType =
| "UNIFORM_SCALING"
;


// refs: 1 - tags: output, named, interface
export interface StreamDescription {
  StreamName: string;
  StreamARN: string;
  StreamStatus: StreamStatus;
  Shards: Shard[];
  HasMoreShards: boolean;
  RetentionPeriodHours: number;
  StreamCreationTimestamp: Date | number;
  EnhancedMonitoring: EnhancedMetrics[];
  EncryptionType?: EncryptionType | null;
  KeyId?: string | null;
}
function toStreamDescription(root: JSONValue): StreamDescription {
  return prt.readObj({
    required: {
      "StreamName": "s",
      "StreamARN": "s",
      "StreamStatus": toStreamStatus,
      "Shards": [toShard],
      "HasMoreShards": "b",
      "RetentionPeriodHours": "n",
      "StreamCreationTimestamp": "d",
      "EnhancedMonitoring": [toEnhancedMetrics],
    },
    optional: {
      "EncryptionType": toEncryptionType,
      "KeyId": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type StreamStatus =
| "CREATING"
| "DELETING"
| "ACTIVE"
| "UPDATING"
;
function toStreamStatus(root: JSONValue): StreamStatus | null {
  return ( false
    || root == "CREATING"
    || root == "DELETING"
    || root == "ACTIVE"
    || root == "UPDATING"
  ) ? root : null;
}

// refs: 2 - tags: output, named, interface
export interface Shard {
  ShardId: string;
  ParentShardId?: string | null;
  AdjacentParentShardId?: string | null;
  HashKeyRange: HashKeyRange;
  SequenceNumberRange: SequenceNumberRange;
}
function toShard(root: JSONValue): Shard {
  return prt.readObj({
    required: {
      "ShardId": "s",
      "HashKeyRange": toHashKeyRange,
      "SequenceNumberRange": toSequenceNumberRange,
    },
    optional: {
      "ParentShardId": "s",
      "AdjacentParentShardId": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface HashKeyRange {
  StartingHashKey: string;
  EndingHashKey: string;
}
function toHashKeyRange(root: JSONValue): HashKeyRange {
  return prt.readObj({
    required: {
      "StartingHashKey": "s",
      "EndingHashKey": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SequenceNumberRange {
  StartingSequenceNumber: string;
  EndingSequenceNumber?: string | null;
}
function toSequenceNumberRange(root: JSONValue): SequenceNumberRange {
  return prt.readObj({
    required: {
      "StartingSequenceNumber": "s",
    },
    optional: {
      "EndingSequenceNumber": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EnhancedMetrics {
  ShardLevelMetrics?: MetricsName[] | null;
}
function toEnhancedMetrics(root: JSONValue): EnhancedMetrics {
  return prt.readObj({
    required: {},
    optional: {
      "ShardLevelMetrics": [toMetricsName],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ConsumerDescription {
  ConsumerName: string;
  ConsumerARN: string;
  ConsumerStatus: ConsumerStatus;
  ConsumerCreationTimestamp: Date | number;
  StreamARN: string;
}
function toConsumerDescription(root: JSONValue): ConsumerDescription {
  return prt.readObj({
    required: {
      "ConsumerName": "s",
      "ConsumerARN": "s",
      "ConsumerStatus": toConsumerStatus,
      "ConsumerCreationTimestamp": "d",
      "StreamARN": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: output, named, enum
export type ConsumerStatus =
| "CREATING"
| "DELETING"
| "ACTIVE"
;
function toConsumerStatus(root: JSONValue): ConsumerStatus | null {
  return ( false
    || root == "CREATING"
    || root == "DELETING"
    || root == "ACTIVE"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface StreamDescriptionSummary {
  StreamName: string;
  StreamARN: string;
  StreamStatus: StreamStatus;
  RetentionPeriodHours: number;
  StreamCreationTimestamp: Date | number;
  EnhancedMonitoring: EnhancedMetrics[];
  EncryptionType?: EncryptionType | null;
  KeyId?: string | null;
  OpenShardCount: number;
  ConsumerCount?: number | null;
}
function toStreamDescriptionSummary(root: JSONValue): StreamDescriptionSummary {
  return prt.readObj({
    required: {
      "StreamName": "s",
      "StreamARN": "s",
      "StreamStatus": toStreamStatus,
      "RetentionPeriodHours": "n",
      "StreamCreationTimestamp": "d",
      "EnhancedMonitoring": [toEnhancedMetrics],
      "OpenShardCount": "n",
    },
    optional: {
      "EncryptionType": toEncryptionType,
      "KeyId": "s",
      "ConsumerCount": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Record {
  SequenceNumber: string;
  ApproximateArrivalTimestamp?: Date | number | null;
  Data: Uint8Array | string;
  PartitionKey: string;
  EncryptionType?: EncryptionType | null;
}
function toRecord(root: JSONValue): Record {
  return prt.readObj({
    required: {
      "SequenceNumber": "s",
      "Data": "a",
      "PartitionKey": "s",
    },
    optional: {
      "ApproximateArrivalTimestamp": "d",
      "EncryptionType": toEncryptionType,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ChildShard {
  ShardId: string;
  ParentShards: string[];
  HashKeyRange: HashKeyRange;
}
function toChildShard(root: JSONValue): ChildShard {
  return prt.readObj({
    required: {
      "ShardId": "s",
      "ParentShards": ["s"],
      "HashKeyRange": toHashKeyRange,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Consumer {
  ConsumerName: string;
  ConsumerARN: string;
  ConsumerStatus: ConsumerStatus;
  ConsumerCreationTimestamp: Date | number;
}
function toConsumer(root: JSONValue): Consumer {
  return prt.readObj({
    required: {
      "ConsumerName": "s",
      "ConsumerARN": "s",
      "ConsumerStatus": toConsumerStatus,
      "ConsumerCreationTimestamp": "d",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Tag {
  Key: string;
  Value?: string | null;
}
function toTag(root: JSONValue): Tag {
  return prt.readObj({
    required: {
      "Key": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PutRecordsResultEntry {
  SequenceNumber?: string | null;
  ShardId?: string | null;
  ErrorCode?: string | null;
  ErrorMessage?: string | null;
}
function toPutRecordsResultEntry(root: JSONValue): PutRecordsResultEntry {
  return prt.readObj({
    required: {},
    optional: {
      "SequenceNumber": "s",
      "ShardId": "s",
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}
