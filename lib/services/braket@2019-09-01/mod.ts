// Autogenerated API client for: Braket

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class Braket {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Braket.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2019-09-01",
    "endpointPrefix": "braket",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Braket",
    "serviceId": "Braket",
    "signatureVersion": "v4",
    "signingName": "braket",
    "uid": "braket-2019-09-01"
  };

  async cancelQuantumTask(
    {abortSignal, ...params}: RequestConfig & CancelQuantumTaskRequest,
  ): Promise<CancelQuantumTaskResponse> {
    const body: jsonP.JSONObject = params ? {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelQuantumTask",
      method: "PUT",
      requestUri: cmnP.encodePath`/quantum-task/${params["quantumTaskArn"]}/cancel`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "cancellationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CancellationStatus>(x),
          "quantumTaskArn": "s",
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async createQuantumTask(
    {abortSignal, ...params}: RequestConfig & CreateQuantumTaskRequest,
  ): Promise<CreateQuantumTaskResponse> {
    const body: jsonP.JSONObject = params ? {
      action: jsonP.serializeJsonValue(params["action"]),
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      deviceArn: params["deviceArn"],
      deviceParameters: jsonP.serializeJsonValue(params["deviceParameters"]),
      outputS3Bucket: params["outputS3Bucket"],
      outputS3KeyPrefix: params["outputS3KeyPrefix"],
      shots: params["shots"],
      tags: params["tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateQuantumTask",
      requestUri: "/quantum-task",
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {
          "quantumTaskArn": "s",
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async getDevice(
    {abortSignal, ...params}: RequestConfig & GetDeviceRequest,
  ): Promise<GetDeviceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDevice",
      method: "GET",
      requestUri: cmnP.encodePath`/device/${params["deviceArn"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "deviceArn": "s",
          "deviceCapabilities": jsonP.readJsonValue,
          "deviceName": "s",
          "deviceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceStatus>(x),
          "deviceType": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceType>(x),
          "providerName": "s",
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async getQuantumTask(
    {abortSignal, ...params}: RequestConfig & GetQuantumTaskRequest,
  ): Promise<GetQuantumTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetQuantumTask",
      method: "GET",
      requestUri: cmnP.encodePath`/quantum-task/${params["quantumTaskArn"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "createdAt": "d",
          "deviceArn": "s",
          "deviceParameters": jsonP.readJsonValue,
          "outputS3Bucket": "s",
          "outputS3Directory": "s",
          "quantumTaskArn": "s",
          "shots": "n",
          "status": (x: jsonP.JSONValue) => cmnP.readEnum<QuantumTaskStatus>(x),
        },
        optional: {
          "endedAt": "d",
          "failureReason": "s",
          "tags": x => jsonP.readMap(String, String, x),
        },
      }, await resp.json()),
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "tags": x => jsonP.readMap(String, String, x),
        },
      }, await resp.json()),
  };
  }

  async searchDevices(
    {abortSignal, ...params}: RequestConfig & SearchDevicesRequest,
  ): Promise<SearchDevicesResponse> {
    const body: jsonP.JSONObject = params ? {
      filters: params["filters"]?.map(x => fromSearchDevicesFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchDevices",
      requestUri: "/devices",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "devices": [toDeviceSummary],
        },
        optional: {
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async searchQuantumTasks(
    {abortSignal, ...params}: RequestConfig & SearchQuantumTasksRequest,
  ): Promise<SearchQuantumTasksResponse> {
    const body: jsonP.JSONObject = params ? {
      filters: params["filters"]?.map(x => fromSearchQuantumTasksFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchQuantumTasks",
      requestUri: "/quantum-tasks",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "quantumTasks": [toQuantumTaskSummary],
        },
        optional: {
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      tags: params["tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface CancelQuantumTaskRequest {
  clientToken: string;
  quantumTaskArn: string;
}

// refs: 1 - tags: named, input
export interface CreateQuantumTaskRequest {
  action: jsonP.JSONValue;
  clientToken: string;
  deviceArn: string;
  deviceParameters?: jsonP.JSONValue | null;
  outputS3Bucket: string;
  outputS3KeyPrefix: string;
  shots: number;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface GetDeviceRequest {
  deviceArn: string;
}

// refs: 1 - tags: named, input
export interface GetQuantumTaskRequest {
  quantumTaskArn: string;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface SearchDevicesRequest {
  filters: SearchDevicesFilter[];
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface SearchQuantumTasksRequest {
  filters: SearchQuantumTasksFilter[];
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, output
export interface CancelQuantumTaskResponse {
  cancellationStatus: CancellationStatus;
  quantumTaskArn: string;
}

// refs: 1 - tags: named, output
export interface CreateQuantumTaskResponse {
  quantumTaskArn: string;
}

// refs: 1 - tags: named, output
export interface GetDeviceResponse {
  deviceArn: string;
  deviceCapabilities: jsonP.JSONValue;
  deviceName: string;
  deviceStatus: DeviceStatus;
  deviceType: DeviceType;
  providerName: string;
}

// refs: 1 - tags: named, output
export interface GetQuantumTaskResponse {
  createdAt: Date | number;
  deviceArn: string;
  deviceParameters: jsonP.JSONValue;
  endedAt?: Date | number | null;
  failureReason?: string | null;
  outputS3Bucket: string;
  outputS3Directory: string;
  quantumTaskArn: string;
  shots: number;
  status: QuantumTaskStatus;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface SearchDevicesResponse {
  devices: DeviceSummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface SearchQuantumTasksResponse {
  nextToken?: string | null;
  quantumTasks: QuantumTaskSummary[];
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: input, named, interface
export interface SearchDevicesFilter {
  name: string;
  values: string[];
}
function fromSearchDevicesFilter(input?: SearchDevicesFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
  }
}

// refs: 1 - tags: input, named, interface
export interface SearchQuantumTasksFilter {
  name: string;
  operator: SearchQuantumTasksFilterOperator;
  values: string[];
}
function fromSearchQuantumTasksFilter(input?: SearchQuantumTasksFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    operator: input["operator"],
    values: input["values"],
  }
}

// refs: 1 - tags: input, named, enum
export type SearchQuantumTasksFilterOperator =
| "LT"
| "LTE"
| "EQUAL"
| "GT"
| "GTE"
| "BETWEEN"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type CancellationStatus =
| "CANCELLING"
| "CANCELLED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type DeviceStatus =
| "ONLINE"
| "OFFLINE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type DeviceType =
| "QPU"
| "SIMULATOR"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type QuantumTaskStatus =
| "CREATED"
| "QUEUED"
| "RUNNING"
| "COMPLETED"
| "FAILED"
| "CANCELLING"
| "CANCELLED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DeviceSummary {
  deviceArn: string;
  deviceName: string;
  deviceStatus: DeviceStatus;
  deviceType: DeviceType;
  providerName: string;
}
function toDeviceSummary(root: jsonP.JSONValue): DeviceSummary {
  return jsonP.readObj({
    required: {
      "deviceArn": "s",
      "deviceName": "s",
      "deviceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceStatus>(x),
      "deviceType": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceType>(x),
      "providerName": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface QuantumTaskSummary {
  createdAt: Date | number;
  deviceArn: string;
  endedAt?: Date | number | null;
  outputS3Bucket: string;
  outputS3Directory: string;
  quantumTaskArn: string;
  shots: number;
  status: QuantumTaskStatus;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toQuantumTaskSummary(root: jsonP.JSONValue): QuantumTaskSummary {
  return jsonP.readObj({
    required: {
      "createdAt": "d",
      "deviceArn": "s",
      "outputS3Bucket": "s",
      "outputS3Directory": "s",
      "quantumTaskArn": "s",
      "shots": "n",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<QuantumTaskStatus>(x),
    },
    optional: {
      "endedAt": "d",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
