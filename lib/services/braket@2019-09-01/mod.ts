// Autogenerated API client for: Braket

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class Braket {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Braket.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2019-09-01",
    "endpointPrefix": "braket",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Braket",
    "serviceId": "Braket",
    "signatureVersion": "v4",
    "signingName": "braket",
    "uid": "braket-2019-09-01"
  };

  async cancelQuantumTask(
    {abortSignal, ...params}: RequestConfig & s.CancelQuantumTaskRequest,
  ): Promise<s.CancelQuantumTaskResponse> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelQuantumTask",
      method: "PUT",
      requestUri: cmnP.encodePath`/quantum-task/${params["quantumTaskArn"]}/cancel`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "cancellationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CancellationStatus>(x),
        "quantumTaskArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createQuantumTask(
    {abortSignal, ...params}: RequestConfig & s.CreateQuantumTaskRequest,
  ): Promise<s.CreateQuantumTaskResponse> {
    const body: jsonP.JSONObject = {
      action: jsonP.serializeJsonValue(params["action"]),
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      deviceArn: params["deviceArn"],
      deviceParameters: jsonP.serializeJsonValue(params["deviceParameters"]),
      outputS3Bucket: params["outputS3Bucket"],
      outputS3KeyPrefix: params["outputS3KeyPrefix"],
      shots: params["shots"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateQuantumTask",
      requestUri: "/quantum-task",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {
        "quantumTaskArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getDevice(
    {abortSignal, ...params}: RequestConfig & s.GetDeviceRequest,
  ): Promise<s.GetDeviceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDevice",
      method: "GET",
      requestUri: cmnP.encodePath`/device/${params["deviceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "deviceArn": "s",
        "deviceCapabilities": jsonP.readJsonValue,
        "deviceName": "s",
        "deviceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceStatus>(x),
        "deviceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceType>(x),
        "providerName": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getQuantumTask(
    {abortSignal, ...params}: RequestConfig & s.GetQuantumTaskRequest,
  ): Promise<s.GetQuantumTaskResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetQuantumTask",
      method: "GET",
      requestUri: cmnP.encodePath`/quantum-task/${params["quantumTaskArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "createdAt": "d",
        "deviceArn": "s",
        "deviceParameters": jsonP.readJsonValue,
        "outputS3Bucket": "s",
        "outputS3Directory": "s",
        "quantumTaskArn": "s",
        "shots": "n",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.QuantumTaskStatus>(x),
      },
      optional: {
        "endedAt": "d",
        "failureReason": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async searchDevices(
    {abortSignal, ...params}: RequestConfig & s.SearchDevicesRequest,
  ): Promise<s.SearchDevicesResponse> {
    const body: jsonP.JSONObject = {
      filters: params["filters"]?.map(x => fromSearchDevicesFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchDevices",
      requestUri: "/devices",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "devices": [toDeviceSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async searchQuantumTasks(
    {abortSignal, ...params}: RequestConfig & s.SearchQuantumTasksRequest,
  ): Promise<s.SearchQuantumTasksResponse> {
    const body: jsonP.JSONObject = {
      filters: params["filters"]?.map(x => fromSearchQuantumTasksFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchQuantumTasks",
      requestUri: "/quantum-tasks",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "quantumTasks": [toQuantumTaskSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromSearchDevicesFilter(input?: s.SearchDevicesFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
  }
}

function fromSearchQuantumTasksFilter(input?: s.SearchQuantumTasksFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    operator: input["operator"],
    values: input["values"],
  }
}

function toDeviceSummary(root: jsonP.JSONValue): s.DeviceSummary {
  return jsonP.readObj({
    required: {
      "deviceArn": "s",
      "deviceName": "s",
      "deviceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceStatus>(x),
      "deviceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceType>(x),
      "providerName": "s",
    },
    optional: {},
  }, root);
}

function toQuantumTaskSummary(root: jsonP.JSONValue): s.QuantumTaskSummary {
  return jsonP.readObj({
    required: {
      "createdAt": "d",
      "deviceArn": "s",
      "outputS3Bucket": "s",
      "outputS3Directory": "s",
      "quantumTaskArn": "s",
      "shots": "n",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.QuantumTaskStatus>(x),
    },
    optional: {
      "endedAt": "d",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
