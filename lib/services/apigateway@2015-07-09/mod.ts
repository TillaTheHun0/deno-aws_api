// Autogenerated API client for: Amazon API Gateway

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class APIGateway {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(APIGateway.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-07-09",
    "endpointPrefix": "apigateway",
    "protocol": "rest-json",
    "serviceFullName": "Amazon API Gateway",
    "serviceId": "API Gateway",
    "signatureVersion": "v4",
    "uid": "apigateway-2015-07-09"
  };

  async createApiKey(
    {abortSignal, ...params}: RequestConfig & s.CreateApiKeyRequest = {},
  ): Promise<s.ApiKey> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      enabled: params["enabled"],
      generateDistinctId: params["generateDistinctId"],
      value: params["value"],
      stageKeys: params["stageKeys"]?.map(x => fromStageKey(x)),
      customerId: params["customerId"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApiKey",
      requestUri: "/apikeys",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "value": "s",
        "name": "s",
        "customerId": "s",
        "description": "s",
        "enabled": "b",
        "createdDate": "d",
        "lastUpdatedDate": "d",
        "stageKeys": ["s"],
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.CreateAuthorizerRequest,
  ): Promise<s.Authorizer> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      type: params["type"],
      providerARNs: params["providerARNs"],
      authType: params["authType"],
      authorizerUri: params["authorizerUri"],
      authorizerCredentials: params["authorizerCredentials"],
      identitySource: params["identitySource"],
      identityValidationExpression: params["identityValidationExpression"],
      authorizerResultTtlInSeconds: params["authorizerResultTtlInSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAuthorizer",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizerType>(x),
        "providerARNs": ["s"],
        "authType": "s",
        "authorizerUri": "s",
        "authorizerCredentials": "s",
        "identitySource": "s",
        "identityValidationExpression": "s",
        "authorizerResultTtlInSeconds": "n",
      },
    }, await resp.json());
  }

  async createBasePathMapping(
    {abortSignal, ...params}: RequestConfig & s.CreateBasePathMappingRequest,
  ): Promise<s.BasePathMapping> {
    const body: jsonP.JSONObject = {
      basePath: params["basePath"],
      restApiId: params["restApiId"],
      stage: params["stage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBasePathMapping",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "basePath": "s",
        "restApiId": "s",
        "stage": "s",
      },
    }, await resp.json());
  }

  async createDeployment(
    {abortSignal, ...params}: RequestConfig & s.CreateDeploymentRequest,
  ): Promise<s.Deployment> {
    const body: jsonP.JSONObject = {
      stageName: params["stageName"],
      stageDescription: params["stageDescription"],
      description: params["description"],
      cacheClusterEnabled: params["cacheClusterEnabled"],
      cacheClusterSize: params["cacheClusterSize"],
      variables: params["variables"],
      canarySettings: fromDeploymentCanarySettings(params["canarySettings"]),
      tracingEnabled: params["tracingEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeployment",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "description": "s",
        "createdDate": "d",
        "apiSummary": x => jsonP.readMap(String, y => jsonP.readMap(String, toMethodSnapshot, y)!, x),
      },
    }, await resp.json());
  }

  async createDocumentationPart(
    {abortSignal, ...params}: RequestConfig & s.CreateDocumentationPartRequest,
  ): Promise<s.DocumentationPart> {
    const body: jsonP.JSONObject = {
      location: fromDocumentationPartLocation(params["location"]),
      properties: params["properties"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDocumentationPart",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "location": toDocumentationPartLocation,
        "properties": "s",
      },
    }, await resp.json());
  }

  async createDocumentationVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateDocumentationVersionRequest,
  ): Promise<s.DocumentationVersion> {
    const body: jsonP.JSONObject = {
      documentationVersion: params["documentationVersion"],
      stageName: params["stageName"],
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDocumentationVersion",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "version": "s",
        "createdDate": "d",
        "description": "s",
      },
    }, await resp.json());
  }

  async createDomainName(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainNameRequest,
  ): Promise<s.DomainName> {
    const body: jsonP.JSONObject = {
      domainName: params["domainName"],
      certificateName: params["certificateName"],
      certificateBody: params["certificateBody"],
      certificatePrivateKey: params["certificatePrivateKey"],
      certificateChain: params["certificateChain"],
      certificateArn: params["certificateArn"],
      regionalCertificateName: params["regionalCertificateName"],
      regionalCertificateArn: params["regionalCertificateArn"],
      endpointConfiguration: fromEndpointConfiguration(params["endpointConfiguration"]),
      tags: params["tags"],
      securityPolicy: params["securityPolicy"],
      mutualTlsAuthentication: fromMutualTlsAuthenticationInput(params["mutualTlsAuthentication"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomainName",
      requestUri: "/domainnames",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainName": "s",
        "certificateName": "s",
        "certificateArn": "s",
        "certificateUploadDate": "d",
        "regionalDomainName": "s",
        "regionalHostedZoneId": "s",
        "regionalCertificateName": "s",
        "regionalCertificateArn": "s",
        "distributionDomainName": "s",
        "distributionHostedZoneId": "s",
        "endpointConfiguration": toEndpointConfiguration,
        "domainNameStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainNameStatus>(x),
        "domainNameStatusMessage": "s",
        "securityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SecurityPolicy>(x),
        "tags": x => jsonP.readMap(String, String, x),
        "mutualTlsAuthentication": toMutualTlsAuthentication,
      },
    }, await resp.json());
  }

  async createModel(
    {abortSignal, ...params}: RequestConfig & s.CreateModelRequest,
  ): Promise<s.Model> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      schema: params["schema"],
      contentType: params["contentType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModel",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "schema": "s",
        "contentType": "s",
      },
    }, await resp.json());
  }

  async createRequestValidator(
    {abortSignal, ...params}: RequestConfig & s.CreateRequestValidatorRequest,
  ): Promise<s.RequestValidator> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      validateRequestBody: params["validateRequestBody"],
      validateRequestParameters: params["validateRequestParameters"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRequestValidator",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "validateRequestBody": "b",
        "validateRequestParameters": "b",
      },
    }, await resp.json());
  }

  async createResource(
    {abortSignal, ...params}: RequestConfig & s.CreateResourceRequest,
  ): Promise<s.Resource> {
    const body: jsonP.JSONObject = {
      pathPart: params["pathPart"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateResource",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["parentId"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "parentId": "s",
        "pathPart": "s",
        "path": "s",
        "resourceMethods": x => jsonP.readMap(String, toMethod, x),
      },
    }, await resp.json());
  }

  async createRestApi(
    {abortSignal, ...params}: RequestConfig & s.CreateRestApiRequest,
  ): Promise<s.RestApi> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      version: params["version"],
      cloneFrom: params["cloneFrom"],
      binaryMediaTypes: params["binaryMediaTypes"],
      minimumCompressionSize: params["minimumCompressionSize"],
      apiKeySource: params["apiKeySource"],
      endpointConfiguration: fromEndpointConfiguration(params["endpointConfiguration"]),
      policy: params["policy"],
      tags: params["tags"],
      disableExecuteApiEndpoint: params["disableExecuteApiEndpoint"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRestApi",
      requestUri: "/restapis",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async createStage(
    {abortSignal, ...params}: RequestConfig & s.CreateStageRequest,
  ): Promise<s.Stage> {
    const body: jsonP.JSONObject = {
      stageName: params["stageName"],
      deploymentId: params["deploymentId"],
      description: params["description"],
      cacheClusterEnabled: params["cacheClusterEnabled"],
      cacheClusterSize: params["cacheClusterSize"],
      variables: params["variables"],
      documentationVersion: params["documentationVersion"],
      canarySettings: fromCanarySettings(params["canarySettings"]),
      tracingEnabled: params["tracingEnabled"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStage",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentId": "s",
        "clientCertificateId": "s",
        "stageName": "s",
        "description": "s",
        "cacheClusterEnabled": "b",
        "cacheClusterSize": (x: jsonP.JSONValue) => cmnP.readEnum<s.CacheClusterSize>(x),
        "cacheClusterStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CacheClusterStatus>(x),
        "methodSettings": x => jsonP.readMap(String, toMethodSetting, x),
        "variables": x => jsonP.readMap(String, String, x),
        "documentationVersion": "s",
        "accessLogSettings": toAccessLogSettings,
        "canarySettings": toCanarySettings,
        "tracingEnabled": "b",
        "webAclArn": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "createdDate": "d",
        "lastUpdatedDate": "d",
      },
    }, await resp.json());
  }

  async createUsagePlan(
    {abortSignal, ...params}: RequestConfig & s.CreateUsagePlanRequest,
  ): Promise<s.UsagePlan> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      apiStages: params["apiStages"]?.map(x => fromApiStage(x)),
      throttle: fromThrottleSettings(params["throttle"]),
      quota: fromQuotaSettings(params["quota"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUsagePlan",
      requestUri: "/usageplans",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "apiStages": [toApiStage],
        "throttle": toThrottleSettings,
        "quota": toQuotaSettings,
        "productCode": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createUsagePlanKey(
    {abortSignal, ...params}: RequestConfig & s.CreateUsagePlanKeyRequest,
  ): Promise<s.UsagePlanKey> {
    const body: jsonP.JSONObject = {
      keyId: params["keyId"],
      keyType: params["keyType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUsagePlanKey",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "type": "s",
        "value": "s",
        "name": "s",
      },
    }, await resp.json());
  }

  async createVpcLink(
    {abortSignal, ...params}: RequestConfig & s.CreateVpcLinkRequest,
  ): Promise<s.VpcLink> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      targetArns: params["targetArns"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcLink",
      requestUri: "/vpclinks",
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "targetArns": ["s"],
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkStatus>(x),
        "statusMessage": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async deleteApiKey(
    {abortSignal, ...params}: RequestConfig & s.DeleteApiKeyRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApiKey",
      method: "DELETE",
      requestUri: cmnP.encodePath`/apikeys/${params["apiKey"]}`,
      responseCode: 202,
    });
  }

  async deleteAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.DeleteAuthorizerRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAuthorizer",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers/${params["authorizerId"]}`,
      responseCode: 202,
    });
  }

  async deleteBasePathMapping(
    {abortSignal, ...params}: RequestConfig & s.DeleteBasePathMappingRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBasePathMapping",
      method: "DELETE",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings/${params["basePath"]}`,
      responseCode: 202,
    });
  }

  async deleteClientCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteClientCertificateRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteClientCertificate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clientcertificates/${params["clientCertificateId"]}`,
      responseCode: 202,
    });
  }

  async deleteDeployment(
    {abortSignal, ...params}: RequestConfig & s.DeleteDeploymentRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDeployment",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments/${params["deploymentId"]}`,
      responseCode: 202,
    });
  }

  async deleteDocumentationPart(
    {abortSignal, ...params}: RequestConfig & s.DeleteDocumentationPartRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDocumentationPart",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts/${params["documentationPartId"]}`,
      responseCode: 202,
    });
  }

  async deleteDocumentationVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteDocumentationVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDocumentationVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions/${params["documentationVersion"]}`,
      responseCode: 202,
    });
  }

  async deleteDomainName(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainNameRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDomainName",
      method: "DELETE",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}`,
      responseCode: 202,
    });
  }

  async deleteGatewayResponse(
    {abortSignal, ...params}: RequestConfig & s.DeleteGatewayResponseRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteGatewayResponse",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses/${params["responseType"]}`,
      responseCode: 202,
    });
  }

  async deleteIntegration(
    {abortSignal, ...params}: RequestConfig & s.DeleteIntegrationRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntegration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration`,
      responseCode: 204,
    });
  }

  async deleteIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & s.DeleteIntegrationResponseRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntegrationResponse",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration/responses/${params["statusCode"]}`,
      responseCode: 204,
    });
  }

  async deleteMethod(
    {abortSignal, ...params}: RequestConfig & s.DeleteMethodRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMethod",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
      responseCode: 204,
    });
  }

  async deleteMethodResponse(
    {abortSignal, ...params}: RequestConfig & s.DeleteMethodResponseRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMethodResponse",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/responses/${params["statusCode"]}`,
      responseCode: 204,
    });
  }

  async deleteModel(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteModel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models/${params["modelName"]}`,
      responseCode: 202,
    });
  }

  async deleteRequestValidator(
    {abortSignal, ...params}: RequestConfig & s.DeleteRequestValidatorRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRequestValidator",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators/${params["requestValidatorId"]}`,
      responseCode: 202,
    });
  }

  async deleteResource(
    {abortSignal, ...params}: RequestConfig & s.DeleteResourceRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}`,
      responseCode: 202,
    });
  }

  async deleteRestApi(
    {abortSignal, ...params}: RequestConfig & s.DeleteRestApiRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRestApi",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}`,
      responseCode: 202,
    });
  }

  async deleteStage(
    {abortSignal, ...params}: RequestConfig & s.DeleteStageRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteStage",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}`,
      responseCode: 202,
    });
  }

  async deleteUsagePlan(
    {abortSignal, ...params}: RequestConfig & s.DeleteUsagePlanRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteUsagePlan",
      method: "DELETE",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}`,
      responseCode: 202,
    });
  }

  async deleteUsagePlanKey(
    {abortSignal, ...params}: RequestConfig & s.DeleteUsagePlanKeyRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteUsagePlanKey",
      method: "DELETE",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys/${params["keyId"]}`,
      responseCode: 202,
    });
  }

  async deleteVpcLink(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpcLinkRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteVpcLink",
      method: "DELETE",
      requestUri: cmnP.encodePath`/vpclinks/${params["vpcLinkId"]}`,
      responseCode: 202,
    });
  }

  async flushStageAuthorizersCache(
    {abortSignal, ...params}: RequestConfig & s.FlushStageAuthorizersCacheRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "FlushStageAuthorizersCache",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}/cache/authorizers`,
      responseCode: 202,
    });
  }

  async flushStageCache(
    {abortSignal, ...params}: RequestConfig & s.FlushStageCacheRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "FlushStageCache",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}/cache/data`,
      responseCode: 202,
    });
  }

  async generateClientCertificate(
    {abortSignal, ...params}: RequestConfig & s.GenerateClientCertificateRequest = {},
  ): Promise<s.ClientCertificate> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateClientCertificate",
      requestUri: "/clientcertificates",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clientCertificateId": "s",
        "description": "s",
        "pemEncodedCertificate": "s",
        "createdDate": "d",
        "expirationDate": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getAccount(
    {abortSignal, ...params}: RequestConfig & s.GetAccountRequest = {},
  ): Promise<s.Account> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccount",
      method: "GET",
      requestUri: "/account",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cloudwatchRoleArn": "s",
        "throttleSettings": toThrottleSettings,
        "features": ["s"],
        "apiKeyVersion": "s",
      },
    }, await resp.json());
  }

  async getApiKey(
    {abortSignal, ...params}: RequestConfig & s.GetApiKeyRequest,
  ): Promise<s.ApiKey> {
    const query = new URLSearchParams;
    if (params["includeValue"] != null) query.set("includeValue", params["includeValue"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetApiKey",
      method: "GET",
      requestUri: cmnP.encodePath`/apikeys/${params["apiKey"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "value": "s",
        "name": "s",
        "customerId": "s",
        "description": "s",
        "enabled": "b",
        "createdDate": "d",
        "lastUpdatedDate": "d",
        "stageKeys": ["s"],
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getApiKeys(
    {abortSignal, ...params}: RequestConfig & s.GetApiKeysRequest = {},
  ): Promise<s.ApiKeys> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["nameQuery"] != null) query.set("name", params["nameQuery"]?.toString() ?? "");
    if (params["customerId"] != null) query.set("customerId", params["customerId"]?.toString() ?? "");
    if (params["includeValues"] != null) query.set("includeValues", params["includeValues"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetApiKeys",
      method: "GET",
      requestUri: "/apikeys",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "warnings": ["s"],
        "position": "s",
        "items": [toApiKey],
      },
    }, await resp.json());
  }

  async getAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.GetAuthorizerRequest,
  ): Promise<s.Authorizer> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAuthorizer",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers/${params["authorizerId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizerType>(x),
        "providerARNs": ["s"],
        "authType": "s",
        "authorizerUri": "s",
        "authorizerCredentials": "s",
        "identitySource": "s",
        "identityValidationExpression": "s",
        "authorizerResultTtlInSeconds": "n",
      },
    }, await resp.json());
  }

  async getAuthorizers(
    {abortSignal, ...params}: RequestConfig & s.GetAuthorizersRequest,
  ): Promise<s.Authorizers> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetAuthorizers",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toAuthorizer],
      },
    }, await resp.json());
  }

  async getBasePathMapping(
    {abortSignal, ...params}: RequestConfig & s.GetBasePathMappingRequest,
  ): Promise<s.BasePathMapping> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBasePathMapping",
      method: "GET",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings/${params["basePath"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "basePath": "s",
        "restApiId": "s",
        "stage": "s",
      },
    }, await resp.json());
  }

  async getBasePathMappings(
    {abortSignal, ...params}: RequestConfig & s.GetBasePathMappingsRequest,
  ): Promise<s.BasePathMappings> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBasePathMappings",
      method: "GET",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toBasePathMapping],
      },
    }, await resp.json());
  }

  async getClientCertificate(
    {abortSignal, ...params}: RequestConfig & s.GetClientCertificateRequest,
  ): Promise<s.ClientCertificate> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetClientCertificate",
      method: "GET",
      requestUri: cmnP.encodePath`/clientcertificates/${params["clientCertificateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clientCertificateId": "s",
        "description": "s",
        "pemEncodedCertificate": "s",
        "createdDate": "d",
        "expirationDate": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getClientCertificates(
    {abortSignal, ...params}: RequestConfig & s.GetClientCertificatesRequest = {},
  ): Promise<s.ClientCertificates> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetClientCertificates",
      method: "GET",
      requestUri: "/clientcertificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toClientCertificate],
      },
    }, await resp.json());
  }

  async getDeployment(
    {abortSignal, ...params}: RequestConfig & s.GetDeploymentRequest,
  ): Promise<s.Deployment> {
    const query = new URLSearchParams;
    for (const item of params["embed"] ?? []) {
      query.append("embed", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDeployment",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments/${params["deploymentId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "description": "s",
        "createdDate": "d",
        "apiSummary": x => jsonP.readMap(String, y => jsonP.readMap(String, toMethodSnapshot, y)!, x),
      },
    }, await resp.json());
  }

  async getDeployments(
    {abortSignal, ...params}: RequestConfig & s.GetDeploymentsRequest,
  ): Promise<s.Deployments> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDeployments",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toDeployment],
      },
    }, await resp.json());
  }

  async getDocumentationPart(
    {abortSignal, ...params}: RequestConfig & s.GetDocumentationPartRequest,
  ): Promise<s.DocumentationPart> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDocumentationPart",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts/${params["documentationPartId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "location": toDocumentationPartLocation,
        "properties": "s",
      },
    }, await resp.json());
  }

  async getDocumentationParts(
    {abortSignal, ...params}: RequestConfig & s.GetDocumentationPartsRequest,
  ): Promise<s.DocumentationParts> {
    const query = new URLSearchParams;
    if (params["type"] != null) query.set("type", params["type"]?.toString() ?? "");
    if (params["nameQuery"] != null) query.set("name", params["nameQuery"]?.toString() ?? "");
    if (params["path"] != null) query.set("path", params["path"]?.toString() ?? "");
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["locationStatus"] != null) query.set("locationStatus", params["locationStatus"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDocumentationParts",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toDocumentationPart],
      },
    }, await resp.json());
  }

  async getDocumentationVersion(
    {abortSignal, ...params}: RequestConfig & s.GetDocumentationVersionRequest,
  ): Promise<s.DocumentationVersion> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDocumentationVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions/${params["documentationVersion"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "version": "s",
        "createdDate": "d",
        "description": "s",
      },
    }, await resp.json());
  }

  async getDocumentationVersions(
    {abortSignal, ...params}: RequestConfig & s.GetDocumentationVersionsRequest,
  ): Promise<s.DocumentationVersions> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDocumentationVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toDocumentationVersion],
      },
    }, await resp.json());
  }

  async getDomainName(
    {abortSignal, ...params}: RequestConfig & s.GetDomainNameRequest,
  ): Promise<s.DomainName> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDomainName",
      method: "GET",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainName": "s",
        "certificateName": "s",
        "certificateArn": "s",
        "certificateUploadDate": "d",
        "regionalDomainName": "s",
        "regionalHostedZoneId": "s",
        "regionalCertificateName": "s",
        "regionalCertificateArn": "s",
        "distributionDomainName": "s",
        "distributionHostedZoneId": "s",
        "endpointConfiguration": toEndpointConfiguration,
        "domainNameStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainNameStatus>(x),
        "domainNameStatusMessage": "s",
        "securityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SecurityPolicy>(x),
        "tags": x => jsonP.readMap(String, String, x),
        "mutualTlsAuthentication": toMutualTlsAuthentication,
      },
    }, await resp.json());
  }

  async getDomainNames(
    {abortSignal, ...params}: RequestConfig & s.GetDomainNamesRequest = {},
  ): Promise<s.DomainNames> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDomainNames",
      method: "GET",
      requestUri: "/domainnames",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toDomainName],
      },
    }, await resp.json());
  }

  async getExport(
    {abortSignal, ...params}: RequestConfig & s.GetExportRequest,
  ): Promise<s.ExportResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    for (const [k,v] of Object.entries(params["parameters"] ?? {})) {
      query.append(k, v?.toString() ?? "");
    }
    if (params["accepts"] != null) headers.append("Accept", params["accepts"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetExport",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}/exports/${params["exportType"]}`,
      responseCode: 200,
    });
  return {
    contentType: resp.headers.get("Content-Type"),
    contentDisposition: resp.headers.get("Content-Disposition"),
    body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getGatewayResponse(
    {abortSignal, ...params}: RequestConfig & s.GetGatewayResponseRequest,
  ): Promise<s.GatewayResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetGatewayResponse",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses/${params["responseType"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "responseType": (x: jsonP.JSONValue) => cmnP.readEnum<s.GatewayResponseType>(x),
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "defaultResponse": "b",
      },
    }, await resp.json());
  }

  async getGatewayResponses(
    {abortSignal, ...params}: RequestConfig & s.GetGatewayResponsesRequest,
  ): Promise<s.GatewayResponses> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetGatewayResponses",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toGatewayResponse],
      },
    }, await resp.json());
  }

  async getIntegration(
    {abortSignal, ...params}: RequestConfig & s.GetIntegrationRequest,
  ): Promise<s.Integration> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetIntegration",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntegrationType>(x),
        "httpMethod": "s",
        "uri": "s",
        "connectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionType>(x),
        "connectionId": "s",
        "credentials": "s",
        "requestParameters": x => jsonP.readMap(String, String, x),
        "requestTemplates": x => jsonP.readMap(String, String, x),
        "passthroughBehavior": "s",
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
        "timeoutInMillis": "n",
        "cacheNamespace": "s",
        "cacheKeyParameters": ["s"],
        "integrationResponses": x => jsonP.readMap(String, toIntegrationResponse, x),
        "tlsConfig": toTlsConfig,
      },
    }, await resp.json());
  }

  async getIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & s.GetIntegrationResponseRequest,
  ): Promise<s.IntegrationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetIntegrationResponse",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration/responses/${params["statusCode"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "selectionPattern": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
      },
    }, await resp.json());
  }

  async getMethod(
    {abortSignal, ...params}: RequestConfig & s.GetMethodRequest,
  ): Promise<s.Method> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetMethod",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "httpMethod": "s",
        "authorizationType": "s",
        "authorizerId": "s",
        "apiKeyRequired": "b",
        "requestValidatorId": "s",
        "operationName": "s",
        "requestParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "requestModels": x => jsonP.readMap(String, String, x),
        "methodResponses": x => jsonP.readMap(String, toMethodResponse, x),
        "methodIntegration": toIntegration,
        "authorizationScopes": ["s"],
      },
    }, await resp.json());
  }

  async getMethodResponse(
    {abortSignal, ...params}: RequestConfig & s.GetMethodResponseRequest,
  ): Promise<s.MethodResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetMethodResponse",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/responses/${params["statusCode"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "responseModels": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getModel(
    {abortSignal, ...params}: RequestConfig & s.GetModelRequest,
  ): Promise<s.Model> {
    const query = new URLSearchParams;
    if (params["flatten"] != null) query.set("flatten", params["flatten"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetModel",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models/${params["modelName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "schema": "s",
        "contentType": "s",
      },
    }, await resp.json());
  }

  async getModelTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetModelTemplateRequest,
  ): Promise<s.Template> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetModelTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models/${params["modelName"]}/default_template`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "value": "s",
      },
    }, await resp.json());
  }

  async getModels(
    {abortSignal, ...params}: RequestConfig & s.GetModelsRequest,
  ): Promise<s.Models> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetModels",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toModel],
      },
    }, await resp.json());
  }

  async getRequestValidator(
    {abortSignal, ...params}: RequestConfig & s.GetRequestValidatorRequest,
  ): Promise<s.RequestValidator> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetRequestValidator",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators/${params["requestValidatorId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "validateRequestBody": "b",
        "validateRequestParameters": "b",
      },
    }, await resp.json());
  }

  async getRequestValidators(
    {abortSignal, ...params}: RequestConfig & s.GetRequestValidatorsRequest,
  ): Promise<s.RequestValidators> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRequestValidators",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toRequestValidator],
      },
    }, await resp.json());
  }

  async getResource(
    {abortSignal, ...params}: RequestConfig & s.GetResourceRequest,
  ): Promise<s.Resource> {
    const query = new URLSearchParams;
    for (const item of params["embed"] ?? []) {
      query.append("embed", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetResource",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "parentId": "s",
        "pathPart": "s",
        "path": "s",
        "resourceMethods": x => jsonP.readMap(String, toMethod, x),
      },
    }, await resp.json());
  }

  async getResources(
    {abortSignal, ...params}: RequestConfig & s.GetResourcesRequest,
  ): Promise<s.Resources> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    for (const item of params["embed"] ?? []) {
      query.append("embed", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetResources",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toResource],
      },
    }, await resp.json());
  }

  async getRestApi(
    {abortSignal, ...params}: RequestConfig & s.GetRestApiRequest,
  ): Promise<s.RestApi> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetRestApi",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async getRestApis(
    {abortSignal, ...params}: RequestConfig & s.GetRestApisRequest = {},
  ): Promise<s.RestApis> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRestApis",
      method: "GET",
      requestUri: "/restapis",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toRestApi],
      },
    }, await resp.json());
  }

  async getSdk(
    {abortSignal, ...params}: RequestConfig & s.GetSdkRequest,
  ): Promise<s.SdkResponse> {
    const query = new URLSearchParams;
    for (const [k,v] of Object.entries(params["parameters"] ?? {})) {
      query.append(k, v?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSdk",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}/sdks/${params["sdkType"]}`,
      responseCode: 200,
    });
  return {
    contentType: resp.headers.get("Content-Type"),
    contentDisposition: resp.headers.get("Content-Disposition"),
    body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getSdkType(
    {abortSignal, ...params}: RequestConfig & s.GetSdkTypeRequest,
  ): Promise<s.SdkType> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSdkType",
      method: "GET",
      requestUri: cmnP.encodePath`/sdktypes/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "friendlyName": "s",
        "description": "s",
        "configurationProperties": [toSdkConfigurationProperty],
      },
    }, await resp.json());
  }

  async getSdkTypes(
    {abortSignal, ...params}: RequestConfig & s.GetSdkTypesRequest = {},
  ): Promise<s.SdkTypes> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSdkTypes",
      method: "GET",
      requestUri: "/sdktypes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toSdkType],
      },
    }, await resp.json());
  }

  async getStage(
    {abortSignal, ...params}: RequestConfig & s.GetStageRequest,
  ): Promise<s.Stage> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStage",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentId": "s",
        "clientCertificateId": "s",
        "stageName": "s",
        "description": "s",
        "cacheClusterEnabled": "b",
        "cacheClusterSize": (x: jsonP.JSONValue) => cmnP.readEnum<s.CacheClusterSize>(x),
        "cacheClusterStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CacheClusterStatus>(x),
        "methodSettings": x => jsonP.readMap(String, toMethodSetting, x),
        "variables": x => jsonP.readMap(String, String, x),
        "documentationVersion": "s",
        "accessLogSettings": toAccessLogSettings,
        "canarySettings": toCanarySettings,
        "tracingEnabled": "b",
        "webAclArn": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "createdDate": "d",
        "lastUpdatedDate": "d",
      },
    }, await resp.json());
  }

  async getStages(
    {abortSignal, ...params}: RequestConfig & s.GetStagesRequest,
  ): Promise<s.Stages> {
    const query = new URLSearchParams;
    if (params["deploymentId"] != null) query.set("deploymentId", params["deploymentId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetStages",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "item": [toStage],
      },
    }, await resp.json());
  }

  async getTags(
    {abortSignal, ...params}: RequestConfig & s.GetTagsRequest,
  ): Promise<s.Tags> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetTags",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getUsage(
    {abortSignal, ...params}: RequestConfig & s.GetUsageRequest,
  ): Promise<s.Usage> {
    const query = new URLSearchParams;
    if (params["keyId"] != null) query.set("keyId", params["keyId"]?.toString() ?? "");
    query.set("startDate", params["startDate"]?.toString() ?? "");
    query.set("endDate", params["endDate"]?.toString() ?? "");
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUsage",
      method: "GET",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/usage`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "usagePlanId": "s",
        "startDate": "s",
        "endDate": "s",
        "position": "s",
        "items": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(y => jsonP.readList(jsonP.readNum, y)!) : [], x),
      },
    }, await resp.json());
  }

  async getUsagePlan(
    {abortSignal, ...params}: RequestConfig & s.GetUsagePlanRequest,
  ): Promise<s.UsagePlan> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetUsagePlan",
      method: "GET",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "apiStages": [toApiStage],
        "throttle": toThrottleSettings,
        "quota": toQuotaSettings,
        "productCode": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getUsagePlanKey(
    {abortSignal, ...params}: RequestConfig & s.GetUsagePlanKeyRequest,
  ): Promise<s.UsagePlanKey> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetUsagePlanKey",
      method: "GET",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys/${params["keyId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "type": "s",
        "value": "s",
        "name": "s",
      },
    }, await resp.json());
  }

  async getUsagePlanKeys(
    {abortSignal, ...params}: RequestConfig & s.GetUsagePlanKeysRequest,
  ): Promise<s.UsagePlanKeys> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["nameQuery"] != null) query.set("name", params["nameQuery"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUsagePlanKeys",
      method: "GET",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toUsagePlanKey],
      },
    }, await resp.json());
  }

  async getUsagePlans(
    {abortSignal, ...params}: RequestConfig & s.GetUsagePlansRequest = {},
  ): Promise<s.UsagePlans> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["keyId"] != null) query.set("keyId", params["keyId"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUsagePlans",
      method: "GET",
      requestUri: "/usageplans",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toUsagePlan],
      },
    }, await resp.json());
  }

  async getVpcLink(
    {abortSignal, ...params}: RequestConfig & s.GetVpcLinkRequest,
  ): Promise<s.VpcLink> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetVpcLink",
      method: "GET",
      requestUri: cmnP.encodePath`/vpclinks/${params["vpcLinkId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "targetArns": ["s"],
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkStatus>(x),
        "statusMessage": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getVpcLinks(
    {abortSignal, ...params}: RequestConfig & s.GetVpcLinksRequest = {},
  ): Promise<s.VpcLinks> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetVpcLinks",
      method: "GET",
      requestUri: "/vpclinks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toVpcLink],
      },
    }, await resp.json());
  }

  async importApiKeys(
    {abortSignal, ...params}: RequestConfig & s.ImportApiKeysRequest,
  ): Promise<s.ApiKeyIds> {
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const query = new URLSearchParams;
    query.set("format", params["format"]?.toString() ?? "");
    if (params["failOnWarnings"] != null) query.set("failonwarnings", params["failOnWarnings"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ImportApiKeys",
      requestUri: "/apikeys?mode=import",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "warnings": ["s"],
      },
    }, await resp.json());
  }

  async importDocumentationParts(
    {abortSignal, ...params}: RequestConfig & s.ImportDocumentationPartsRequest,
  ): Promise<s.DocumentationPartIds> {
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const query = new URLSearchParams;
    if (params["mode"] != null) query.set("mode", params["mode"]?.toString() ?? "");
    if (params["failOnWarnings"] != null) query.set("failonwarnings", params["failOnWarnings"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ImportDocumentationParts",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "warnings": ["s"],
      },
    }, await resp.json());
  }

  async importRestApi(
    {abortSignal, ...params}: RequestConfig & s.ImportRestApiRequest,
  ): Promise<s.RestApi> {
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const query = new URLSearchParams;
    if (params["failOnWarnings"] != null) query.set("failonwarnings", params["failOnWarnings"]?.toString() ?? "");
    for (const [k,v] of Object.entries(params["parameters"] ?? {})) {
      query.append(k, v?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ImportRestApi",
      requestUri: "/restapis?mode=import",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async putGatewayResponse(
    {abortSignal, ...params}: RequestConfig & s.PutGatewayResponseRequest,
  ): Promise<s.GatewayResponse> {
    const body: jsonP.JSONObject = {
      statusCode: params["statusCode"],
      responseParameters: params["responseParameters"],
      responseTemplates: params["responseTemplates"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutGatewayResponse",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses/${params["responseType"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "responseType": (x: jsonP.JSONValue) => cmnP.readEnum<s.GatewayResponseType>(x),
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "defaultResponse": "b",
      },
    }, await resp.json());
  }

  async putIntegration(
    {abortSignal, ...params}: RequestConfig & s.PutIntegrationRequest,
  ): Promise<s.Integration> {
    const body: jsonP.JSONObject = {
      type: params["type"],
      httpMethod: params["integrationHttpMethod"],
      uri: params["uri"],
      connectionType: params["connectionType"],
      connectionId: params["connectionId"],
      credentials: params["credentials"],
      requestParameters: params["requestParameters"],
      requestTemplates: params["requestTemplates"],
      passthroughBehavior: params["passthroughBehavior"],
      cacheNamespace: params["cacheNamespace"],
      cacheKeyParameters: params["cacheKeyParameters"],
      contentHandling: params["contentHandling"],
      timeoutInMillis: params["timeoutInMillis"],
      tlsConfig: fromTlsConfig(params["tlsConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutIntegration",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntegrationType>(x),
        "httpMethod": "s",
        "uri": "s",
        "connectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionType>(x),
        "connectionId": "s",
        "credentials": "s",
        "requestParameters": x => jsonP.readMap(String, String, x),
        "requestTemplates": x => jsonP.readMap(String, String, x),
        "passthroughBehavior": "s",
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
        "timeoutInMillis": "n",
        "cacheNamespace": "s",
        "cacheKeyParameters": ["s"],
        "integrationResponses": x => jsonP.readMap(String, toIntegrationResponse, x),
        "tlsConfig": toTlsConfig,
      },
    }, await resp.json());
  }

  async putIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & s.PutIntegrationResponseRequest,
  ): Promise<s.IntegrationResponse> {
    const body: jsonP.JSONObject = {
      selectionPattern: params["selectionPattern"],
      responseParameters: params["responseParameters"],
      responseTemplates: params["responseTemplates"],
      contentHandling: params["contentHandling"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutIntegrationResponse",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration/responses/${params["statusCode"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "selectionPattern": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
      },
    }, await resp.json());
  }

  async putMethod(
    {abortSignal, ...params}: RequestConfig & s.PutMethodRequest,
  ): Promise<s.Method> {
    const body: jsonP.JSONObject = {
      authorizationType: params["authorizationType"],
      authorizerId: params["authorizerId"],
      apiKeyRequired: params["apiKeyRequired"],
      operationName: params["operationName"],
      requestParameters: params["requestParameters"],
      requestModels: params["requestModels"],
      requestValidatorId: params["requestValidatorId"],
      authorizationScopes: params["authorizationScopes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMethod",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "httpMethod": "s",
        "authorizationType": "s",
        "authorizerId": "s",
        "apiKeyRequired": "b",
        "requestValidatorId": "s",
        "operationName": "s",
        "requestParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "requestModels": x => jsonP.readMap(String, String, x),
        "methodResponses": x => jsonP.readMap(String, toMethodResponse, x),
        "methodIntegration": toIntegration,
        "authorizationScopes": ["s"],
      },
    }, await resp.json());
  }

  async putMethodResponse(
    {abortSignal, ...params}: RequestConfig & s.PutMethodResponseRequest,
  ): Promise<s.MethodResponse> {
    const body: jsonP.JSONObject = {
      responseParameters: params["responseParameters"],
      responseModels: params["responseModels"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMethodResponse",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/responses/${params["statusCode"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "responseModels": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async putRestApi(
    {abortSignal, ...params}: RequestConfig & s.PutRestApiRequest,
  ): Promise<s.RestApi> {
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const query = new URLSearchParams;
    if (params["mode"] != null) query.set("mode", params["mode"]?.toString() ?? "");
    if (params["failOnWarnings"] != null) query.set("failonwarnings", params["failOnWarnings"]?.toString() ?? "");
    for (const [k,v] of Object.entries(params["parameters"] ?? {})) {
      query.append(k, v?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "PutRestApi",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      method: "PUT",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
  }

  async testInvokeAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.TestInvokeAuthorizerRequest,
  ): Promise<s.TestInvokeAuthorizerResponse> {
    const body: jsonP.JSONObject = {
      headers: params["headers"],
      multiValueHeaders: params["multiValueHeaders"],
      pathWithQueryString: params["pathWithQueryString"],
      body: params["body"],
      stageVariables: params["stageVariables"],
      additionalContext: params["additionalContext"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestInvokeAuthorizer",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers/${params["authorizerId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clientStatus": "n",
        "log": "s",
        "latency": "n",
        "principalId": "s",
        "policy": "s",
        "authorization": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
        "claims": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async testInvokeMethod(
    {abortSignal, ...params}: RequestConfig & s.TestInvokeMethodRequest,
  ): Promise<s.TestInvokeMethodResponse> {
    const body: jsonP.JSONObject = {
      pathWithQueryString: params["pathWithQueryString"],
      body: params["body"],
      headers: params["headers"],
      multiValueHeaders: params["multiValueHeaders"],
      clientCertificateId: params["clientCertificateId"],
      stageVariables: params["stageVariables"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestInvokeMethod",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": "n",
        "body": "s",
        "headers": x => jsonP.readMap(String, String, x),
        "multiValueHeaders": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
        "log": "s",
        "latency": "n",
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
  }

  async updateAccount(
    {abortSignal, ...params}: RequestConfig & s.UpdateAccountRequest = {},
  ): Promise<s.Account> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccount",
      method: "PATCH",
      requestUri: "/account",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cloudwatchRoleArn": "s",
        "throttleSettings": toThrottleSettings,
        "features": ["s"],
        "apiKeyVersion": "s",
      },
    }, await resp.json());
  }

  async updateApiKey(
    {abortSignal, ...params}: RequestConfig & s.UpdateApiKeyRequest,
  ): Promise<s.ApiKey> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApiKey",
      method: "PATCH",
      requestUri: cmnP.encodePath`/apikeys/${params["apiKey"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "value": "s",
        "name": "s",
        "customerId": "s",
        "description": "s",
        "enabled": "b",
        "createdDate": "d",
        "lastUpdatedDate": "d",
        "stageKeys": ["s"],
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.UpdateAuthorizerRequest,
  ): Promise<s.Authorizer> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAuthorizer",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers/${params["authorizerId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizerType>(x),
        "providerARNs": ["s"],
        "authType": "s",
        "authorizerUri": "s",
        "authorizerCredentials": "s",
        "identitySource": "s",
        "identityValidationExpression": "s",
        "authorizerResultTtlInSeconds": "n",
      },
    }, await resp.json());
  }

  async updateBasePathMapping(
    {abortSignal, ...params}: RequestConfig & s.UpdateBasePathMappingRequest,
  ): Promise<s.BasePathMapping> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBasePathMapping",
      method: "PATCH",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings/${params["basePath"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "basePath": "s",
        "restApiId": "s",
        "stage": "s",
      },
    }, await resp.json());
  }

  async updateClientCertificate(
    {abortSignal, ...params}: RequestConfig & s.UpdateClientCertificateRequest,
  ): Promise<s.ClientCertificate> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClientCertificate",
      method: "PATCH",
      requestUri: cmnP.encodePath`/clientcertificates/${params["clientCertificateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clientCertificateId": "s",
        "description": "s",
        "pemEncodedCertificate": "s",
        "createdDate": "d",
        "expirationDate": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateDeployment(
    {abortSignal, ...params}: RequestConfig & s.UpdateDeploymentRequest,
  ): Promise<s.Deployment> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDeployment",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments/${params["deploymentId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "description": "s",
        "createdDate": "d",
        "apiSummary": x => jsonP.readMap(String, y => jsonP.readMap(String, toMethodSnapshot, y)!, x),
      },
    }, await resp.json());
  }

  async updateDocumentationPart(
    {abortSignal, ...params}: RequestConfig & s.UpdateDocumentationPartRequest,
  ): Promise<s.DocumentationPart> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDocumentationPart",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts/${params["documentationPartId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "location": toDocumentationPartLocation,
        "properties": "s",
      },
    }, await resp.json());
  }

  async updateDocumentationVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateDocumentationVersionRequest,
  ): Promise<s.DocumentationVersion> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDocumentationVersion",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions/${params["documentationVersion"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "version": "s",
        "createdDate": "d",
        "description": "s",
      },
    }, await resp.json());
  }

  async updateDomainName(
    {abortSignal, ...params}: RequestConfig & s.UpdateDomainNameRequest,
  ): Promise<s.DomainName> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDomainName",
      method: "PATCH",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainName": "s",
        "certificateName": "s",
        "certificateArn": "s",
        "certificateUploadDate": "d",
        "regionalDomainName": "s",
        "regionalHostedZoneId": "s",
        "regionalCertificateName": "s",
        "regionalCertificateArn": "s",
        "distributionDomainName": "s",
        "distributionHostedZoneId": "s",
        "endpointConfiguration": toEndpointConfiguration,
        "domainNameStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainNameStatus>(x),
        "domainNameStatusMessage": "s",
        "securityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SecurityPolicy>(x),
        "tags": x => jsonP.readMap(String, String, x),
        "mutualTlsAuthentication": toMutualTlsAuthentication,
      },
    }, await resp.json());
  }

  async updateGatewayResponse(
    {abortSignal, ...params}: RequestConfig & s.UpdateGatewayResponseRequest,
  ): Promise<s.GatewayResponse> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGatewayResponse",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses/${params["responseType"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "responseType": (x: jsonP.JSONValue) => cmnP.readEnum<s.GatewayResponseType>(x),
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "defaultResponse": "b",
      },
    }, await resp.json());
  }

  async updateIntegration(
    {abortSignal, ...params}: RequestConfig & s.UpdateIntegrationRequest,
  ): Promise<s.Integration> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIntegration",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntegrationType>(x),
        "httpMethod": "s",
        "uri": "s",
        "connectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionType>(x),
        "connectionId": "s",
        "credentials": "s",
        "requestParameters": x => jsonP.readMap(String, String, x),
        "requestTemplates": x => jsonP.readMap(String, String, x),
        "passthroughBehavior": "s",
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
        "timeoutInMillis": "n",
        "cacheNamespace": "s",
        "cacheKeyParameters": ["s"],
        "integrationResponses": x => jsonP.readMap(String, toIntegrationResponse, x),
        "tlsConfig": toTlsConfig,
      },
    }, await resp.json());
  }

  async updateIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & s.UpdateIntegrationResponseRequest,
  ): Promise<s.IntegrationResponse> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIntegrationResponse",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration/responses/${params["statusCode"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "selectionPattern": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
      },
    }, await resp.json());
  }

  async updateMethod(
    {abortSignal, ...params}: RequestConfig & s.UpdateMethodRequest,
  ): Promise<s.Method> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMethod",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "httpMethod": "s",
        "authorizationType": "s",
        "authorizerId": "s",
        "apiKeyRequired": "b",
        "requestValidatorId": "s",
        "operationName": "s",
        "requestParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "requestModels": x => jsonP.readMap(String, String, x),
        "methodResponses": x => jsonP.readMap(String, toMethodResponse, x),
        "methodIntegration": toIntegration,
        "authorizationScopes": ["s"],
      },
    }, await resp.json());
  }

  async updateMethodResponse(
    {abortSignal, ...params}: RequestConfig & s.UpdateMethodResponseRequest,
  ): Promise<s.MethodResponse> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMethodResponse",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/responses/${params["statusCode"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "responseModels": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateModel(
    {abortSignal, ...params}: RequestConfig & s.UpdateModelRequest,
  ): Promise<s.Model> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateModel",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models/${params["modelName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "schema": "s",
        "contentType": "s",
      },
    }, await resp.json());
  }

  async updateRequestValidator(
    {abortSignal, ...params}: RequestConfig & s.UpdateRequestValidatorRequest,
  ): Promise<s.RequestValidator> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRequestValidator",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators/${params["requestValidatorId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "validateRequestBody": "b",
        "validateRequestParameters": "b",
      },
    }, await resp.json());
  }

  async updateResource(
    {abortSignal, ...params}: RequestConfig & s.UpdateResourceRequest,
  ): Promise<s.Resource> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateResource",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "parentId": "s",
        "pathPart": "s",
        "path": "s",
        "resourceMethods": x => jsonP.readMap(String, toMethod, x),
      },
    }, await resp.json());
  }

  async updateRestApi(
    {abortSignal, ...params}: RequestConfig & s.UpdateRestApiRequest,
  ): Promise<s.RestApi> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRestApi",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async updateStage(
    {abortSignal, ...params}: RequestConfig & s.UpdateStageRequest,
  ): Promise<s.Stage> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStage",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentId": "s",
        "clientCertificateId": "s",
        "stageName": "s",
        "description": "s",
        "cacheClusterEnabled": "b",
        "cacheClusterSize": (x: jsonP.JSONValue) => cmnP.readEnum<s.CacheClusterSize>(x),
        "cacheClusterStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CacheClusterStatus>(x),
        "methodSettings": x => jsonP.readMap(String, toMethodSetting, x),
        "variables": x => jsonP.readMap(String, String, x),
        "documentationVersion": "s",
        "accessLogSettings": toAccessLogSettings,
        "canarySettings": toCanarySettings,
        "tracingEnabled": "b",
        "webAclArn": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "createdDate": "d",
        "lastUpdatedDate": "d",
      },
    }, await resp.json());
  }

  async updateUsage(
    {abortSignal, ...params}: RequestConfig & s.UpdateUsageRequest,
  ): Promise<s.Usage> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUsage",
      method: "PATCH",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys/${params["keyId"]}/usage`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "usagePlanId": "s",
        "startDate": "s",
        "endDate": "s",
        "position": "s",
        "items": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(y => jsonP.readList(jsonP.readNum, y)!) : [], x),
      },
    }, await resp.json());
  }

  async updateUsagePlan(
    {abortSignal, ...params}: RequestConfig & s.UpdateUsagePlanRequest,
  ): Promise<s.UsagePlan> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUsagePlan",
      method: "PATCH",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "apiStages": [toApiStage],
        "throttle": toThrottleSettings,
        "quota": toQuotaSettings,
        "productCode": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateVpcLink(
    {abortSignal, ...params}: RequestConfig & s.UpdateVpcLinkRequest,
  ): Promise<s.VpcLink> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVpcLink",
      method: "PATCH",
      requestUri: cmnP.encodePath`/vpclinks/${params["vpcLinkId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "targetArns": ["s"],
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkStatus>(x),
        "statusMessage": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

}

function toApiKey(root: jsonP.JSONValue): s.ApiKey {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "value": "s",
      "name": "s",
      "customerId": "s",
      "description": "s",
      "enabled": "b",
      "createdDate": "d",
      "lastUpdatedDate": "d",
      "stageKeys": ["s"],
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toAuthorizer(root: jsonP.JSONValue): s.Authorizer {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizerType>(x),
      "providerARNs": ["s"],
      "authType": "s",
      "authorizerUri": "s",
      "authorizerCredentials": "s",
      "identitySource": "s",
      "identityValidationExpression": "s",
      "authorizerResultTtlInSeconds": "n",
    },
  }, root);
}

function toBasePathMapping(root: jsonP.JSONValue): s.BasePathMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "basePath": "s",
      "restApiId": "s",
      "stage": "s",
    },
  }, root);
}

function toDeployment(root: jsonP.JSONValue): s.Deployment {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "description": "s",
      "createdDate": "d",
      "apiSummary": x => jsonP.readMap(String, y => jsonP.readMap(String, toMethodSnapshot, y)!, x),
    },
  }, root);
}

function toDocumentationPart(root: jsonP.JSONValue): s.DocumentationPart {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "location": toDocumentationPartLocation,
      "properties": "s",
    },
  }, root);
}

function toDocumentationVersion(root: jsonP.JSONValue): s.DocumentationVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "version": "s",
      "createdDate": "d",
      "description": "s",
    },
  }, root);
}

function toDomainName(root: jsonP.JSONValue): s.DomainName {
  return jsonP.readObj({
    required: {},
    optional: {
      "domainName": "s",
      "certificateName": "s",
      "certificateArn": "s",
      "certificateUploadDate": "d",
      "regionalDomainName": "s",
      "regionalHostedZoneId": "s",
      "regionalCertificateName": "s",
      "regionalCertificateArn": "s",
      "distributionDomainName": "s",
      "distributionHostedZoneId": "s",
      "endpointConfiguration": toEndpointConfiguration,
      "domainNameStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainNameStatus>(x),
      "domainNameStatusMessage": "s",
      "securityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SecurityPolicy>(x),
      "tags": x => jsonP.readMap(String, String, x),
      "mutualTlsAuthentication": toMutualTlsAuthentication,
    },
  }, root);
}

function toModel(root: jsonP.JSONValue): s.Model {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "description": "s",
      "schema": "s",
      "contentType": "s",
    },
  }, root);
}

function toRequestValidator(root: jsonP.JSONValue): s.RequestValidator {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "validateRequestBody": "b",
      "validateRequestParameters": "b",
    },
  }, root);
}

function toResource(root: jsonP.JSONValue): s.Resource {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "parentId": "s",
      "pathPart": "s",
      "path": "s",
      "resourceMethods": x => jsonP.readMap(String, toMethod, x),
    },
  }, root);
}

function toRestApi(root: jsonP.JSONValue): s.RestApi {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "description": "s",
      "createdDate": "d",
      "version": "s",
      "warnings": ["s"],
      "binaryMediaTypes": ["s"],
      "minimumCompressionSize": "n",
      "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApiKeySourceType>(x),
      "endpointConfiguration": toEndpointConfiguration,
      "policy": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "disableExecuteApiEndpoint": "b",
    },
  }, root);
}

function toStage(root: jsonP.JSONValue): s.Stage {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "clientCertificateId": "s",
      "stageName": "s",
      "description": "s",
      "cacheClusterEnabled": "b",
      "cacheClusterSize": (x: jsonP.JSONValue) => cmnP.readEnum<s.CacheClusterSize>(x),
      "cacheClusterStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CacheClusterStatus>(x),
      "methodSettings": x => jsonP.readMap(String, toMethodSetting, x),
      "variables": x => jsonP.readMap(String, String, x),
      "documentationVersion": "s",
      "accessLogSettings": toAccessLogSettings,
      "canarySettings": toCanarySettings,
      "tracingEnabled": "b",
      "webAclArn": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "createdDate": "d",
      "lastUpdatedDate": "d",
    },
  }, root);
}

function toUsagePlan(root: jsonP.JSONValue): s.UsagePlan {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "description": "s",
      "apiStages": [toApiStage],
      "throttle": toThrottleSettings,
      "quota": toQuotaSettings,
      "productCode": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toUsagePlanKey(root: jsonP.JSONValue): s.UsagePlanKey {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "type": "s",
      "value": "s",
      "name": "s",
    },
  }, root);
}

function toVpcLink(root: jsonP.JSONValue): s.VpcLink {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "description": "s",
      "targetArns": ["s"],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkStatus>(x),
      "statusMessage": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toClientCertificate(root: jsonP.JSONValue): s.ClientCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "clientCertificateId": "s",
      "description": "s",
      "pemEncodedCertificate": "s",
      "createdDate": "d",
      "expirationDate": "d",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toGatewayResponse(root: jsonP.JSONValue): s.GatewayResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "responseType": (x: jsonP.JSONValue) => cmnP.readEnum<s.GatewayResponseType>(x),
      "statusCode": "s",
      "responseParameters": x => jsonP.readMap(String, String, x),
      "responseTemplates": x => jsonP.readMap(String, String, x),
      "defaultResponse": "b",
    },
  }, root);
}

function toIntegration(root: jsonP.JSONValue): s.Integration {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntegrationType>(x),
      "httpMethod": "s",
      "uri": "s",
      "connectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionType>(x),
      "connectionId": "s",
      "credentials": "s",
      "requestParameters": x => jsonP.readMap(String, String, x),
      "requestTemplates": x => jsonP.readMap(String, String, x),
      "passthroughBehavior": "s",
      "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
      "timeoutInMillis": "n",
      "cacheNamespace": "s",
      "cacheKeyParameters": ["s"],
      "integrationResponses": x => jsonP.readMap(String, toIntegrationResponse, x),
      "tlsConfig": toTlsConfig,
    },
  }, root);
}

function toIntegrationResponse(root: jsonP.JSONValue): s.IntegrationResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "statusCode": "s",
      "selectionPattern": "s",
      "responseParameters": x => jsonP.readMap(String, String, x),
      "responseTemplates": x => jsonP.readMap(String, String, x),
      "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
    },
  }, root);
}

function toMethod(root: jsonP.JSONValue): s.Method {
  return jsonP.readObj({
    required: {},
    optional: {
      "httpMethod": "s",
      "authorizationType": "s",
      "authorizerId": "s",
      "apiKeyRequired": "b",
      "requestValidatorId": "s",
      "operationName": "s",
      "requestParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
      "requestModels": x => jsonP.readMap(String, String, x),
      "methodResponses": x => jsonP.readMap(String, toMethodResponse, x),
      "methodIntegration": toIntegration,
      "authorizationScopes": ["s"],
    },
  }, root);
}

function toMethodResponse(root: jsonP.JSONValue): s.MethodResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "statusCode": "s",
      "responseParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
      "responseModels": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toSdkType(root: jsonP.JSONValue): s.SdkType {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "friendlyName": "s",
      "description": "s",
      "configurationProperties": [toSdkConfigurationProperty],
    },
  }, root);
}

function fromStageKey(input?: s.StageKey | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    restApiId: input["restApiId"],
    stageName: input["stageName"],
  }
}

function fromDeploymentCanarySettings(input?: s.DeploymentCanarySettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    percentTraffic: input["percentTraffic"],
    stageVariableOverrides: input["stageVariableOverrides"],
    useStageCache: input["useStageCache"],
  }
}

function fromDocumentationPartLocation(input?: s.DocumentationPartLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    path: input["path"],
    method: input["method"],
    statusCode: input["statusCode"],
    name: input["name"],
  }
}
function toDocumentationPartLocation(root: jsonP.JSONValue): s.DocumentationPartLocation {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentationPartType>(x),
    },
    optional: {
      "path": "s",
      "method": "s",
      "statusCode": "s",
      "name": "s",
    },
  }, root);
}

function fromEndpointConfiguration(input?: s.EndpointConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    types: input["types"],
    vpcEndpointIds: input["vpcEndpointIds"],
  }
}
function toEndpointConfiguration(root: jsonP.JSONValue): s.EndpointConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "types": [(x: jsonP.JSONValue) => cmnP.readEnum<s.EndpointType>(x)],
      "vpcEndpointIds": ["s"],
    },
  }, root);
}

function fromMutualTlsAuthenticationInput(input?: s.MutualTlsAuthenticationInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    truststoreUri: input["truststoreUri"],
    truststoreVersion: input["truststoreVersion"],
  }
}

function fromCanarySettings(input?: s.CanarySettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    percentTraffic: input["percentTraffic"],
    deploymentId: input["deploymentId"],
    stageVariableOverrides: input["stageVariableOverrides"],
    useStageCache: input["useStageCache"],
  }
}
function toCanarySettings(root: jsonP.JSONValue): s.CanarySettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "percentTraffic": "n",
      "deploymentId": "s",
      "stageVariableOverrides": x => jsonP.readMap(String, String, x),
      "useStageCache": "b",
    },
  }, root);
}

function fromApiStage(input?: s.ApiStage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    apiId: input["apiId"],
    stage: input["stage"],
    throttle: jsonP.serializeMap(input["throttle"], x => fromThrottleSettings(x)),
  }
}
function toApiStage(root: jsonP.JSONValue): s.ApiStage {
  return jsonP.readObj({
    required: {},
    optional: {
      "apiId": "s",
      "stage": "s",
      "throttle": x => jsonP.readMap(String, toThrottleSettings, x),
    },
  }, root);
}

function fromThrottleSettings(input?: s.ThrottleSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    burstLimit: input["burstLimit"],
    rateLimit: input["rateLimit"],
  }
}
function toThrottleSettings(root: jsonP.JSONValue): s.ThrottleSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "burstLimit": "n",
      "rateLimit": "n",
    },
  }, root);
}

function fromQuotaSettings(input?: s.QuotaSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    limit: input["limit"],
    offset: input["offset"],
    period: input["period"],
  }
}
function toQuotaSettings(root: jsonP.JSONValue): s.QuotaSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "limit": "n",
      "offset": "n",
      "period": (x: jsonP.JSONValue) => cmnP.readEnum<s.QuotaPeriodType>(x),
    },
  }, root);
}

function fromTlsConfig(input?: s.TlsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    insecureSkipVerification: input["insecureSkipVerification"],
  }
}
function toTlsConfig(root: jsonP.JSONValue): s.TlsConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "insecureSkipVerification": "b",
    },
  }, root);
}

function fromPatchOperation(input?: s.PatchOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    op: input["op"],
    path: input["path"],
    value: input["value"],
    from: input["from"],
  }
}

function toMethodSnapshot(root: jsonP.JSONValue): s.MethodSnapshot {
  return jsonP.readObj({
    required: {},
    optional: {
      "authorizationType": "s",
      "apiKeyRequired": "b",
    },
  }, root);
}

function toMutualTlsAuthentication(root: jsonP.JSONValue): s.MutualTlsAuthentication {
  return jsonP.readObj({
    required: {},
    optional: {
      "truststoreUri": "s",
      "truststoreVersion": "s",
      "truststoreWarnings": ["s"],
    },
  }, root);
}

function toMethodSetting(root: jsonP.JSONValue): s.MethodSetting {
  return jsonP.readObj({
    required: {},
    optional: {
      "metricsEnabled": "b",
      "loggingLevel": "s",
      "dataTraceEnabled": "b",
      "throttlingBurstLimit": "n",
      "throttlingRateLimit": "n",
      "cachingEnabled": "b",
      "cacheTtlInSeconds": "n",
      "cacheDataEncrypted": "b",
      "requireAuthorizationForCacheControl": "b",
      "unauthorizedCacheControlHeaderStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.UnauthorizedCacheControlHeaderStrategy>(x),
    },
  }, root);
}

function toAccessLogSettings(root: jsonP.JSONValue): s.AccessLogSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "format": "s",
      "destinationArn": "s",
    },
  }, root);
}

function toSdkConfigurationProperty(root: jsonP.JSONValue): s.SdkConfigurationProperty {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "friendlyName": "s",
      "description": "s",
      "required": "b",
      "defaultValue": "s",
    },
  }, root);
}
