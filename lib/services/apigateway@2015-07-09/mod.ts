// Autogenerated API client for: Amazon API Gateway

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class APIGateway {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(APIGateway.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2015-07-09",
    "endpointPrefix": "apigateway",
    "protocol": "rest-json",
    "serviceFullName": "Amazon API Gateway",
    "serviceId": "API Gateway",
    "signatureVersion": "v4",
    "uid": "apigateway-2015-07-09"
  };

  async createApiKey(
    {abortSignal, ...params}: RequestConfig & CreateApiKeyRequest = {},
  ): Promise<ApiKey> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      enabled: params["enabled"],
      generateDistinctId: params["generateDistinctId"],
      value: params["value"],
      stageKeys: params["stageKeys"]?.map(x => fromStageKey(x)),
      customerId: params["customerId"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApiKey",
      requestUri: "/apikeys",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "value": "s",
        "name": "s",
        "customerId": "s",
        "description": "s",
        "enabled": "b",
        "createdDate": "d",
        "lastUpdatedDate": "d",
        "stageKeys": ["s"],
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createAuthorizer(
    {abortSignal, ...params}: RequestConfig & CreateAuthorizerRequest,
  ): Promise<Authorizer> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      type: params["type"],
      providerARNs: params["providerARNs"],
      authType: params["authType"],
      authorizerUri: params["authorizerUri"],
      authorizerCredentials: params["authorizerCredentials"],
      identitySource: params["identitySource"],
      identityValidationExpression: params["identityValidationExpression"],
      authorizerResultTtlInSeconds: params["authorizerResultTtlInSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAuthorizer",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<AuthorizerType>(x),
        "providerARNs": ["s"],
        "authType": "s",
        "authorizerUri": "s",
        "authorizerCredentials": "s",
        "identitySource": "s",
        "identityValidationExpression": "s",
        "authorizerResultTtlInSeconds": "n",
      },
    }, await resp.json());
  }

  async createBasePathMapping(
    {abortSignal, ...params}: RequestConfig & CreateBasePathMappingRequest,
  ): Promise<BasePathMapping> {
    const body: jsonP.JSONObject = {
      basePath: params["basePath"],
      restApiId: params["restApiId"],
      stage: params["stage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBasePathMapping",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "basePath": "s",
        "restApiId": "s",
        "stage": "s",
      },
    }, await resp.json());
  }

  async createDeployment(
    {abortSignal, ...params}: RequestConfig & CreateDeploymentRequest,
  ): Promise<Deployment> {
    const body: jsonP.JSONObject = {
      stageName: params["stageName"],
      stageDescription: params["stageDescription"],
      description: params["description"],
      cacheClusterEnabled: params["cacheClusterEnabled"],
      cacheClusterSize: params["cacheClusterSize"],
      variables: params["variables"],
      canarySettings: fromDeploymentCanarySettings(params["canarySettings"]),
      tracingEnabled: params["tracingEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeployment",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "description": "s",
        "createdDate": "d",
        "apiSummary": x => jsonP.readMap(String, y => jsonP.readMap(String, toMethodSnapshot, y)!, x),
      },
    }, await resp.json());
  }

  async createDocumentationPart(
    {abortSignal, ...params}: RequestConfig & CreateDocumentationPartRequest,
  ): Promise<DocumentationPart> {
    const body: jsonP.JSONObject = {
      location: fromDocumentationPartLocation(params["location"]),
      properties: params["properties"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDocumentationPart",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "location": toDocumentationPartLocation,
        "properties": "s",
      },
    }, await resp.json());
  }

  async createDocumentationVersion(
    {abortSignal, ...params}: RequestConfig & CreateDocumentationVersionRequest,
  ): Promise<DocumentationVersion> {
    const body: jsonP.JSONObject = {
      documentationVersion: params["documentationVersion"],
      stageName: params["stageName"],
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDocumentationVersion",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "version": "s",
        "createdDate": "d",
        "description": "s",
      },
    }, await resp.json());
  }

  async createDomainName(
    {abortSignal, ...params}: RequestConfig & CreateDomainNameRequest,
  ): Promise<DomainName> {
    const body: jsonP.JSONObject = {
      domainName: params["domainName"],
      certificateName: params["certificateName"],
      certificateBody: params["certificateBody"],
      certificatePrivateKey: params["certificatePrivateKey"],
      certificateChain: params["certificateChain"],
      certificateArn: params["certificateArn"],
      regionalCertificateName: params["regionalCertificateName"],
      regionalCertificateArn: params["regionalCertificateArn"],
      endpointConfiguration: fromEndpointConfiguration(params["endpointConfiguration"]),
      tags: params["tags"],
      securityPolicy: params["securityPolicy"],
      mutualTlsAuthentication: fromMutualTlsAuthenticationInput(params["mutualTlsAuthentication"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomainName",
      requestUri: "/domainnames",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainName": "s",
        "certificateName": "s",
        "certificateArn": "s",
        "certificateUploadDate": "d",
        "regionalDomainName": "s",
        "regionalHostedZoneId": "s",
        "regionalCertificateName": "s",
        "regionalCertificateArn": "s",
        "distributionDomainName": "s",
        "distributionHostedZoneId": "s",
        "endpointConfiguration": toEndpointConfiguration,
        "domainNameStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DomainNameStatus>(x),
        "domainNameStatusMessage": "s",
        "securityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<SecurityPolicy>(x),
        "tags": x => jsonP.readMap(String, String, x),
        "mutualTlsAuthentication": toMutualTlsAuthentication,
      },
    }, await resp.json());
  }

  async createModel(
    {abortSignal, ...params}: RequestConfig & CreateModelRequest,
  ): Promise<Model> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      schema: params["schema"],
      contentType: params["contentType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModel",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "schema": "s",
        "contentType": "s",
      },
    }, await resp.json());
  }

  async createRequestValidator(
    {abortSignal, ...params}: RequestConfig & CreateRequestValidatorRequest,
  ): Promise<RequestValidator> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      validateRequestBody: params["validateRequestBody"],
      validateRequestParameters: params["validateRequestParameters"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRequestValidator",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "validateRequestBody": "b",
        "validateRequestParameters": "b",
      },
    }, await resp.json());
  }

  async createResource(
    {abortSignal, ...params}: RequestConfig & CreateResourceRequest,
  ): Promise<Resource> {
    const body: jsonP.JSONObject = {
      pathPart: params["pathPart"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateResource",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["parentId"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "parentId": "s",
        "pathPart": "s",
        "path": "s",
        "resourceMethods": x => jsonP.readMap(String, toMethod, x),
      },
    }, await resp.json());
  }

  async createRestApi(
    {abortSignal, ...params}: RequestConfig & CreateRestApiRequest,
  ): Promise<RestApi> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      version: params["version"],
      cloneFrom: params["cloneFrom"],
      binaryMediaTypes: params["binaryMediaTypes"],
      minimumCompressionSize: params["minimumCompressionSize"],
      apiKeySource: params["apiKeySource"],
      endpointConfiguration: fromEndpointConfiguration(params["endpointConfiguration"]),
      policy: params["policy"],
      tags: params["tags"],
      disableExecuteApiEndpoint: params["disableExecuteApiEndpoint"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRestApi",
      requestUri: "/restapis",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async createStage(
    {abortSignal, ...params}: RequestConfig & CreateStageRequest,
  ): Promise<Stage> {
    const body: jsonP.JSONObject = {
      stageName: params["stageName"],
      deploymentId: params["deploymentId"],
      description: params["description"],
      cacheClusterEnabled: params["cacheClusterEnabled"],
      cacheClusterSize: params["cacheClusterSize"],
      variables: params["variables"],
      documentationVersion: params["documentationVersion"],
      canarySettings: fromCanarySettings(params["canarySettings"]),
      tracingEnabled: params["tracingEnabled"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStage",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentId": "s",
        "clientCertificateId": "s",
        "stageName": "s",
        "description": "s",
        "cacheClusterEnabled": "b",
        "cacheClusterSize": (x: jsonP.JSONValue) => cmnP.readEnum<CacheClusterSize>(x),
        "cacheClusterStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CacheClusterStatus>(x),
        "methodSettings": x => jsonP.readMap(String, toMethodSetting, x),
        "variables": x => jsonP.readMap(String, String, x),
        "documentationVersion": "s",
        "accessLogSettings": toAccessLogSettings,
        "canarySettings": toCanarySettings,
        "tracingEnabled": "b",
        "webAclArn": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "createdDate": "d",
        "lastUpdatedDate": "d",
      },
    }, await resp.json());
  }

  async createUsagePlan(
    {abortSignal, ...params}: RequestConfig & CreateUsagePlanRequest,
  ): Promise<UsagePlan> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      apiStages: params["apiStages"]?.map(x => fromApiStage(x)),
      throttle: fromThrottleSettings(params["throttle"]),
      quota: fromQuotaSettings(params["quota"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUsagePlan",
      requestUri: "/usageplans",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "apiStages": [toApiStage],
        "throttle": toThrottleSettings,
        "quota": toQuotaSettings,
        "productCode": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createUsagePlanKey(
    {abortSignal, ...params}: RequestConfig & CreateUsagePlanKeyRequest,
  ): Promise<UsagePlanKey> {
    const body: jsonP.JSONObject = {
      keyId: params["keyId"],
      keyType: params["keyType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUsagePlanKey",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "type": "s",
        "value": "s",
        "name": "s",
      },
    }, await resp.json());
  }

  async createVpcLink(
    {abortSignal, ...params}: RequestConfig & CreateVpcLinkRequest,
  ): Promise<VpcLink> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      targetArns: params["targetArns"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcLink",
      requestUri: "/vpclinks",
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "targetArns": ["s"],
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<VpcLinkStatus>(x),
        "statusMessage": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async deleteApiKey(
    {abortSignal, ...params}: RequestConfig & DeleteApiKeyRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApiKey",
      method: "DELETE",
      requestUri: cmnP.encodePath`/apikeys/${params["apiKey"]}`,
      responseCode: 202,
    });
  }

  async deleteAuthorizer(
    {abortSignal, ...params}: RequestConfig & DeleteAuthorizerRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAuthorizer",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers/${params["authorizerId"]}`,
      responseCode: 202,
    });
  }

  async deleteBasePathMapping(
    {abortSignal, ...params}: RequestConfig & DeleteBasePathMappingRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBasePathMapping",
      method: "DELETE",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings/${params["basePath"]}`,
      responseCode: 202,
    });
  }

  async deleteClientCertificate(
    {abortSignal, ...params}: RequestConfig & DeleteClientCertificateRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteClientCertificate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clientcertificates/${params["clientCertificateId"]}`,
      responseCode: 202,
    });
  }

  async deleteDeployment(
    {abortSignal, ...params}: RequestConfig & DeleteDeploymentRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDeployment",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments/${params["deploymentId"]}`,
      responseCode: 202,
    });
  }

  async deleteDocumentationPart(
    {abortSignal, ...params}: RequestConfig & DeleteDocumentationPartRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDocumentationPart",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts/${params["documentationPartId"]}`,
      responseCode: 202,
    });
  }

  async deleteDocumentationVersion(
    {abortSignal, ...params}: RequestConfig & DeleteDocumentationVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDocumentationVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions/${params["documentationVersion"]}`,
      responseCode: 202,
    });
  }

  async deleteDomainName(
    {abortSignal, ...params}: RequestConfig & DeleteDomainNameRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDomainName",
      method: "DELETE",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}`,
      responseCode: 202,
    });
  }

  async deleteGatewayResponse(
    {abortSignal, ...params}: RequestConfig & DeleteGatewayResponseRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteGatewayResponse",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses/${params["responseType"]}`,
      responseCode: 202,
    });
  }

  async deleteIntegration(
    {abortSignal, ...params}: RequestConfig & DeleteIntegrationRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntegration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration`,
      responseCode: 204,
    });
  }

  async deleteIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & DeleteIntegrationResponseRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntegrationResponse",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration/responses/${params["statusCode"]}`,
      responseCode: 204,
    });
  }

  async deleteMethod(
    {abortSignal, ...params}: RequestConfig & DeleteMethodRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMethod",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
      responseCode: 204,
    });
  }

  async deleteMethodResponse(
    {abortSignal, ...params}: RequestConfig & DeleteMethodResponseRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMethodResponse",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/responses/${params["statusCode"]}`,
      responseCode: 204,
    });
  }

  async deleteModel(
    {abortSignal, ...params}: RequestConfig & DeleteModelRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteModel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models/${params["modelName"]}`,
      responseCode: 202,
    });
  }

  async deleteRequestValidator(
    {abortSignal, ...params}: RequestConfig & DeleteRequestValidatorRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRequestValidator",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators/${params["requestValidatorId"]}`,
      responseCode: 202,
    });
  }

  async deleteResource(
    {abortSignal, ...params}: RequestConfig & DeleteResourceRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}`,
      responseCode: 202,
    });
  }

  async deleteRestApi(
    {abortSignal, ...params}: RequestConfig & DeleteRestApiRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRestApi",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}`,
      responseCode: 202,
    });
  }

  async deleteStage(
    {abortSignal, ...params}: RequestConfig & DeleteStageRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteStage",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}`,
      responseCode: 202,
    });
  }

  async deleteUsagePlan(
    {abortSignal, ...params}: RequestConfig & DeleteUsagePlanRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteUsagePlan",
      method: "DELETE",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}`,
      responseCode: 202,
    });
  }

  async deleteUsagePlanKey(
    {abortSignal, ...params}: RequestConfig & DeleteUsagePlanKeyRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteUsagePlanKey",
      method: "DELETE",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys/${params["keyId"]}`,
      responseCode: 202,
    });
  }

  async deleteVpcLink(
    {abortSignal, ...params}: RequestConfig & DeleteVpcLinkRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteVpcLink",
      method: "DELETE",
      requestUri: cmnP.encodePath`/vpclinks/${params["vpcLinkId"]}`,
      responseCode: 202,
    });
  }

  async flushStageAuthorizersCache(
    {abortSignal, ...params}: RequestConfig & FlushStageAuthorizersCacheRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "FlushStageAuthorizersCache",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}/cache/authorizers`,
      responseCode: 202,
    });
  }

  async flushStageCache(
    {abortSignal, ...params}: RequestConfig & FlushStageCacheRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "FlushStageCache",
      method: "DELETE",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}/cache/data`,
      responseCode: 202,
    });
  }

  async generateClientCertificate(
    {abortSignal, ...params}: RequestConfig & GenerateClientCertificateRequest = {},
  ): Promise<ClientCertificate> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateClientCertificate",
      requestUri: "/clientcertificates",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clientCertificateId": "s",
        "description": "s",
        "pemEncodedCertificate": "s",
        "createdDate": "d",
        "expirationDate": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getAccount(
    {abortSignal, ...params}: RequestConfig & GetAccountRequest = {},
  ): Promise<Account> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccount",
      method: "GET",
      requestUri: "/account",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cloudwatchRoleArn": "s",
        "throttleSettings": toThrottleSettings,
        "features": ["s"],
        "apiKeyVersion": "s",
      },
    }, await resp.json());
  }

  async getApiKey(
    {abortSignal, ...params}: RequestConfig & GetApiKeyRequest,
  ): Promise<ApiKey> {
    const query = new URLSearchParams;
    if (params["includeValue"] != null) query.set("includeValue", params["includeValue"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetApiKey",
      method: "GET",
      requestUri: cmnP.encodePath`/apikeys/${params["apiKey"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "value": "s",
        "name": "s",
        "customerId": "s",
        "description": "s",
        "enabled": "b",
        "createdDate": "d",
        "lastUpdatedDate": "d",
        "stageKeys": ["s"],
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getApiKeys(
    {abortSignal, ...params}: RequestConfig & GetApiKeysRequest = {},
  ): Promise<ApiKeys> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["nameQuery"] != null) query.set("name", params["nameQuery"]?.toString() ?? "");
    if (params["customerId"] != null) query.set("customerId", params["customerId"]?.toString() ?? "");
    if (params["includeValues"] != null) query.set("includeValues", params["includeValues"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetApiKeys",
      method: "GET",
      requestUri: "/apikeys",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "warnings": ["s"],
        "position": "s",
        "items": [toApiKey],
      },
    }, await resp.json());
  }

  async getAuthorizer(
    {abortSignal, ...params}: RequestConfig & GetAuthorizerRequest,
  ): Promise<Authorizer> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAuthorizer",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers/${params["authorizerId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<AuthorizerType>(x),
        "providerARNs": ["s"],
        "authType": "s",
        "authorizerUri": "s",
        "authorizerCredentials": "s",
        "identitySource": "s",
        "identityValidationExpression": "s",
        "authorizerResultTtlInSeconds": "n",
      },
    }, await resp.json());
  }

  async getAuthorizers(
    {abortSignal, ...params}: RequestConfig & GetAuthorizersRequest,
  ): Promise<Authorizers> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetAuthorizers",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toAuthorizer],
      },
    }, await resp.json());
  }

  async getBasePathMapping(
    {abortSignal, ...params}: RequestConfig & GetBasePathMappingRequest,
  ): Promise<BasePathMapping> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBasePathMapping",
      method: "GET",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings/${params["basePath"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "basePath": "s",
        "restApiId": "s",
        "stage": "s",
      },
    }, await resp.json());
  }

  async getBasePathMappings(
    {abortSignal, ...params}: RequestConfig & GetBasePathMappingsRequest,
  ): Promise<BasePathMappings> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBasePathMappings",
      method: "GET",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toBasePathMapping],
      },
    }, await resp.json());
  }

  async getClientCertificate(
    {abortSignal, ...params}: RequestConfig & GetClientCertificateRequest,
  ): Promise<ClientCertificate> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetClientCertificate",
      method: "GET",
      requestUri: cmnP.encodePath`/clientcertificates/${params["clientCertificateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clientCertificateId": "s",
        "description": "s",
        "pemEncodedCertificate": "s",
        "createdDate": "d",
        "expirationDate": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getClientCertificates(
    {abortSignal, ...params}: RequestConfig & GetClientCertificatesRequest = {},
  ): Promise<ClientCertificates> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetClientCertificates",
      method: "GET",
      requestUri: "/clientcertificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toClientCertificate],
      },
    }, await resp.json());
  }

  async getDeployment(
    {abortSignal, ...params}: RequestConfig & GetDeploymentRequest,
  ): Promise<Deployment> {
    const query = new URLSearchParams;
    for (const item of params["embed"] ?? []) {
      query.append("embed", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDeployment",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments/${params["deploymentId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "description": "s",
        "createdDate": "d",
        "apiSummary": x => jsonP.readMap(String, y => jsonP.readMap(String, toMethodSnapshot, y)!, x),
      },
    }, await resp.json());
  }

  async getDeployments(
    {abortSignal, ...params}: RequestConfig & GetDeploymentsRequest,
  ): Promise<Deployments> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDeployments",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toDeployment],
      },
    }, await resp.json());
  }

  async getDocumentationPart(
    {abortSignal, ...params}: RequestConfig & GetDocumentationPartRequest,
  ): Promise<DocumentationPart> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDocumentationPart",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts/${params["documentationPartId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "location": toDocumentationPartLocation,
        "properties": "s",
      },
    }, await resp.json());
  }

  async getDocumentationParts(
    {abortSignal, ...params}: RequestConfig & GetDocumentationPartsRequest,
  ): Promise<DocumentationParts> {
    const query = new URLSearchParams;
    if (params["type"] != null) query.set("type", params["type"]?.toString() ?? "");
    if (params["nameQuery"] != null) query.set("name", params["nameQuery"]?.toString() ?? "");
    if (params["path"] != null) query.set("path", params["path"]?.toString() ?? "");
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["locationStatus"] != null) query.set("locationStatus", params["locationStatus"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDocumentationParts",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toDocumentationPart],
      },
    }, await resp.json());
  }

  async getDocumentationVersion(
    {abortSignal, ...params}: RequestConfig & GetDocumentationVersionRequest,
  ): Promise<DocumentationVersion> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDocumentationVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions/${params["documentationVersion"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "version": "s",
        "createdDate": "d",
        "description": "s",
      },
    }, await resp.json());
  }

  async getDocumentationVersions(
    {abortSignal, ...params}: RequestConfig & GetDocumentationVersionsRequest,
  ): Promise<DocumentationVersions> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDocumentationVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toDocumentationVersion],
      },
    }, await resp.json());
  }

  async getDomainName(
    {abortSignal, ...params}: RequestConfig & GetDomainNameRequest,
  ): Promise<DomainName> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDomainName",
      method: "GET",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainName": "s",
        "certificateName": "s",
        "certificateArn": "s",
        "certificateUploadDate": "d",
        "regionalDomainName": "s",
        "regionalHostedZoneId": "s",
        "regionalCertificateName": "s",
        "regionalCertificateArn": "s",
        "distributionDomainName": "s",
        "distributionHostedZoneId": "s",
        "endpointConfiguration": toEndpointConfiguration,
        "domainNameStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DomainNameStatus>(x),
        "domainNameStatusMessage": "s",
        "securityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<SecurityPolicy>(x),
        "tags": x => jsonP.readMap(String, String, x),
        "mutualTlsAuthentication": toMutualTlsAuthentication,
      },
    }, await resp.json());
  }

  async getDomainNames(
    {abortSignal, ...params}: RequestConfig & GetDomainNamesRequest = {},
  ): Promise<DomainNames> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDomainNames",
      method: "GET",
      requestUri: "/domainnames",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toDomainName],
      },
    }, await resp.json());
  }

  async getExport(
    {abortSignal, ...params}: RequestConfig & GetExportRequest,
  ): Promise<ExportResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    for (const [k,v] of Object.entries(params["parameters"] ?? {})) {
      query.append(k, v?.toString() ?? "");
    }
    if (params["accepts"] != null) headers.append("Accept", params["accepts"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetExport",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}/exports/${params["exportType"]}`,
      responseCode: 200,
    });
  return {
    contentType: resp.headers.get("Content-Type"),
    contentDisposition: resp.headers.get("Content-Disposition"),
    body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getGatewayResponse(
    {abortSignal, ...params}: RequestConfig & GetGatewayResponseRequest,
  ): Promise<GatewayResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetGatewayResponse",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses/${params["responseType"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "responseType": (x: jsonP.JSONValue) => cmnP.readEnum<GatewayResponseType>(x),
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "defaultResponse": "b",
      },
    }, await resp.json());
  }

  async getGatewayResponses(
    {abortSignal, ...params}: RequestConfig & GetGatewayResponsesRequest,
  ): Promise<GatewayResponses> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetGatewayResponses",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toGatewayResponse],
      },
    }, await resp.json());
  }

  async getIntegration(
    {abortSignal, ...params}: RequestConfig & GetIntegrationRequest,
  ): Promise<Integration> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetIntegration",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<IntegrationType>(x),
        "httpMethod": "s",
        "uri": "s",
        "connectionType": (x: jsonP.JSONValue) => cmnP.readEnum<ConnectionType>(x),
        "connectionId": "s",
        "credentials": "s",
        "requestParameters": x => jsonP.readMap(String, String, x),
        "requestTemplates": x => jsonP.readMap(String, String, x),
        "passthroughBehavior": "s",
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<ContentHandlingStrategy>(x),
        "timeoutInMillis": "n",
        "cacheNamespace": "s",
        "cacheKeyParameters": ["s"],
        "integrationResponses": x => jsonP.readMap(String, toIntegrationResponse, x),
        "tlsConfig": toTlsConfig,
      },
    }, await resp.json());
  }

  async getIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & GetIntegrationResponseRequest,
  ): Promise<IntegrationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetIntegrationResponse",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration/responses/${params["statusCode"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "selectionPattern": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<ContentHandlingStrategy>(x),
      },
    }, await resp.json());
  }

  async getMethod(
    {abortSignal, ...params}: RequestConfig & GetMethodRequest,
  ): Promise<Method> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetMethod",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "httpMethod": "s",
        "authorizationType": "s",
        "authorizerId": "s",
        "apiKeyRequired": "b",
        "requestValidatorId": "s",
        "operationName": "s",
        "requestParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "requestModels": x => jsonP.readMap(String, String, x),
        "methodResponses": x => jsonP.readMap(String, toMethodResponse, x),
        "methodIntegration": toIntegration,
        "authorizationScopes": ["s"],
      },
    }, await resp.json());
  }

  async getMethodResponse(
    {abortSignal, ...params}: RequestConfig & GetMethodResponseRequest,
  ): Promise<MethodResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetMethodResponse",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/responses/${params["statusCode"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "responseModels": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getModel(
    {abortSignal, ...params}: RequestConfig & GetModelRequest,
  ): Promise<Model> {
    const query = new URLSearchParams;
    if (params["flatten"] != null) query.set("flatten", params["flatten"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetModel",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models/${params["modelName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "schema": "s",
        "contentType": "s",
      },
    }, await resp.json());
  }

  async getModelTemplate(
    {abortSignal, ...params}: RequestConfig & GetModelTemplateRequest,
  ): Promise<Template> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetModelTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models/${params["modelName"]}/default_template`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "value": "s",
      },
    }, await resp.json());
  }

  async getModels(
    {abortSignal, ...params}: RequestConfig & GetModelsRequest,
  ): Promise<Models> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetModels",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toModel],
      },
    }, await resp.json());
  }

  async getRequestValidator(
    {abortSignal, ...params}: RequestConfig & GetRequestValidatorRequest,
  ): Promise<RequestValidator> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetRequestValidator",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators/${params["requestValidatorId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "validateRequestBody": "b",
        "validateRequestParameters": "b",
      },
    }, await resp.json());
  }

  async getRequestValidators(
    {abortSignal, ...params}: RequestConfig & GetRequestValidatorsRequest,
  ): Promise<RequestValidators> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRequestValidators",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toRequestValidator],
      },
    }, await resp.json());
  }

  async getResource(
    {abortSignal, ...params}: RequestConfig & GetResourceRequest,
  ): Promise<Resource> {
    const query = new URLSearchParams;
    for (const item of params["embed"] ?? []) {
      query.append("embed", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetResource",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "parentId": "s",
        "pathPart": "s",
        "path": "s",
        "resourceMethods": x => jsonP.readMap(String, toMethod, x),
      },
    }, await resp.json());
  }

  async getResources(
    {abortSignal, ...params}: RequestConfig & GetResourcesRequest,
  ): Promise<Resources> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    for (const item of params["embed"] ?? []) {
      query.append("embed", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetResources",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toResource],
      },
    }, await resp.json());
  }

  async getRestApi(
    {abortSignal, ...params}: RequestConfig & GetRestApiRequest,
  ): Promise<RestApi> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetRestApi",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async getRestApis(
    {abortSignal, ...params}: RequestConfig & GetRestApisRequest = {},
  ): Promise<RestApis> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRestApis",
      method: "GET",
      requestUri: "/restapis",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toRestApi],
      },
    }, await resp.json());
  }

  async getSdk(
    {abortSignal, ...params}: RequestConfig & GetSdkRequest,
  ): Promise<SdkResponse> {
    const query = new URLSearchParams;
    for (const [k,v] of Object.entries(params["parameters"] ?? {})) {
      query.append(k, v?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSdk",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}/sdks/${params["sdkType"]}`,
      responseCode: 200,
    });
  return {
    contentType: resp.headers.get("Content-Type"),
    contentDisposition: resp.headers.get("Content-Disposition"),
    body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getSdkType(
    {abortSignal, ...params}: RequestConfig & GetSdkTypeRequest,
  ): Promise<SdkType> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSdkType",
      method: "GET",
      requestUri: cmnP.encodePath`/sdktypes/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "friendlyName": "s",
        "description": "s",
        "configurationProperties": [toSdkConfigurationProperty],
      },
    }, await resp.json());
  }

  async getSdkTypes(
    {abortSignal, ...params}: RequestConfig & GetSdkTypesRequest = {},
  ): Promise<SdkTypes> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSdkTypes",
      method: "GET",
      requestUri: "/sdktypes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toSdkType],
      },
    }, await resp.json());
  }

  async getStage(
    {abortSignal, ...params}: RequestConfig & GetStageRequest,
  ): Promise<Stage> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStage",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentId": "s",
        "clientCertificateId": "s",
        "stageName": "s",
        "description": "s",
        "cacheClusterEnabled": "b",
        "cacheClusterSize": (x: jsonP.JSONValue) => cmnP.readEnum<CacheClusterSize>(x),
        "cacheClusterStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CacheClusterStatus>(x),
        "methodSettings": x => jsonP.readMap(String, toMethodSetting, x),
        "variables": x => jsonP.readMap(String, String, x),
        "documentationVersion": "s",
        "accessLogSettings": toAccessLogSettings,
        "canarySettings": toCanarySettings,
        "tracingEnabled": "b",
        "webAclArn": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "createdDate": "d",
        "lastUpdatedDate": "d",
      },
    }, await resp.json());
  }

  async getStages(
    {abortSignal, ...params}: RequestConfig & GetStagesRequest,
  ): Promise<Stages> {
    const query = new URLSearchParams;
    if (params["deploymentId"] != null) query.set("deploymentId", params["deploymentId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetStages",
      method: "GET",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "item": [toStage],
      },
    }, await resp.json());
  }

  async getTags(
    {abortSignal, ...params}: RequestConfig & GetTagsRequest,
  ): Promise<Tags> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetTags",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getUsage(
    {abortSignal, ...params}: RequestConfig & GetUsageRequest,
  ): Promise<Usage> {
    const query = new URLSearchParams;
    if (params["keyId"] != null) query.set("keyId", params["keyId"]?.toString() ?? "");
    query.set("startDate", params["startDate"]?.toString() ?? "");
    query.set("endDate", params["endDate"]?.toString() ?? "");
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUsage",
      method: "GET",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/usage`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "usagePlanId": "s",
        "startDate": "s",
        "endDate": "s",
        "position": "s",
        "items": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(y => jsonP.readList(jsonP.readNum, y)!) : [], x),
      },
    }, await resp.json());
  }

  async getUsagePlan(
    {abortSignal, ...params}: RequestConfig & GetUsagePlanRequest,
  ): Promise<UsagePlan> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetUsagePlan",
      method: "GET",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "apiStages": [toApiStage],
        "throttle": toThrottleSettings,
        "quota": toQuotaSettings,
        "productCode": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getUsagePlanKey(
    {abortSignal, ...params}: RequestConfig & GetUsagePlanKeyRequest,
  ): Promise<UsagePlanKey> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetUsagePlanKey",
      method: "GET",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys/${params["keyId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "type": "s",
        "value": "s",
        "name": "s",
      },
    }, await resp.json());
  }

  async getUsagePlanKeys(
    {abortSignal, ...params}: RequestConfig & GetUsagePlanKeysRequest,
  ): Promise<UsagePlanKeys> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["nameQuery"] != null) query.set("name", params["nameQuery"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUsagePlanKeys",
      method: "GET",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toUsagePlanKey],
      },
    }, await resp.json());
  }

  async getUsagePlans(
    {abortSignal, ...params}: RequestConfig & GetUsagePlansRequest = {},
  ): Promise<UsagePlans> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["keyId"] != null) query.set("keyId", params["keyId"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUsagePlans",
      method: "GET",
      requestUri: "/usageplans",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toUsagePlan],
      },
    }, await resp.json());
  }

  async getVpcLink(
    {abortSignal, ...params}: RequestConfig & GetVpcLinkRequest,
  ): Promise<VpcLink> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetVpcLink",
      method: "GET",
      requestUri: cmnP.encodePath`/vpclinks/${params["vpcLinkId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "targetArns": ["s"],
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<VpcLinkStatus>(x),
        "statusMessage": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getVpcLinks(
    {abortSignal, ...params}: RequestConfig & GetVpcLinksRequest = {},
  ): Promise<VpcLinks> {
    const query = new URLSearchParams;
    if (params["position"] != null) query.set("position", params["position"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetVpcLinks",
      method: "GET",
      requestUri: "/vpclinks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "position": "s",
        "items": [toVpcLink],
      },
    }, await resp.json());
  }

  async importApiKeys(
    {abortSignal, ...params}: RequestConfig & ImportApiKeysRequest,
  ): Promise<ApiKeyIds> {
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const query = new URLSearchParams;
    query.set("format", params["format"]?.toString() ?? "");
    if (params["failOnWarnings"] != null) query.set("failonwarnings", params["failOnWarnings"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ImportApiKeys",
      requestUri: "/apikeys?mode=import",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "warnings": ["s"],
      },
    }, await resp.json());
  }

  async importDocumentationParts(
    {abortSignal, ...params}: RequestConfig & ImportDocumentationPartsRequest,
  ): Promise<DocumentationPartIds> {
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const query = new URLSearchParams;
    if (params["mode"] != null) query.set("mode", params["mode"]?.toString() ?? "");
    if (params["failOnWarnings"] != null) query.set("failonwarnings", params["failOnWarnings"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ImportDocumentationParts",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "warnings": ["s"],
      },
    }, await resp.json());
  }

  async importRestApi(
    {abortSignal, ...params}: RequestConfig & ImportRestApiRequest,
  ): Promise<RestApi> {
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const query = new URLSearchParams;
    if (params["failOnWarnings"] != null) query.set("failonwarnings", params["failOnWarnings"]?.toString() ?? "");
    for (const [k,v] of Object.entries(params["parameters"] ?? {})) {
      query.append(k, v?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ImportRestApi",
      requestUri: "/restapis?mode=import",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async putGatewayResponse(
    {abortSignal, ...params}: RequestConfig & PutGatewayResponseRequest,
  ): Promise<GatewayResponse> {
    const body: jsonP.JSONObject = {
      statusCode: params["statusCode"],
      responseParameters: params["responseParameters"],
      responseTemplates: params["responseTemplates"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutGatewayResponse",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses/${params["responseType"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "responseType": (x: jsonP.JSONValue) => cmnP.readEnum<GatewayResponseType>(x),
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "defaultResponse": "b",
      },
    }, await resp.json());
  }

  async putIntegration(
    {abortSignal, ...params}: RequestConfig & PutIntegrationRequest,
  ): Promise<Integration> {
    const body: jsonP.JSONObject = {
      type: params["type"],
      httpMethod: params["integrationHttpMethod"],
      uri: params["uri"],
      connectionType: params["connectionType"],
      connectionId: params["connectionId"],
      credentials: params["credentials"],
      requestParameters: params["requestParameters"],
      requestTemplates: params["requestTemplates"],
      passthroughBehavior: params["passthroughBehavior"],
      cacheNamespace: params["cacheNamespace"],
      cacheKeyParameters: params["cacheKeyParameters"],
      contentHandling: params["contentHandling"],
      timeoutInMillis: params["timeoutInMillis"],
      tlsConfig: fromTlsConfig(params["tlsConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutIntegration",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<IntegrationType>(x),
        "httpMethod": "s",
        "uri": "s",
        "connectionType": (x: jsonP.JSONValue) => cmnP.readEnum<ConnectionType>(x),
        "connectionId": "s",
        "credentials": "s",
        "requestParameters": x => jsonP.readMap(String, String, x),
        "requestTemplates": x => jsonP.readMap(String, String, x),
        "passthroughBehavior": "s",
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<ContentHandlingStrategy>(x),
        "timeoutInMillis": "n",
        "cacheNamespace": "s",
        "cacheKeyParameters": ["s"],
        "integrationResponses": x => jsonP.readMap(String, toIntegrationResponse, x),
        "tlsConfig": toTlsConfig,
      },
    }, await resp.json());
  }

  async putIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & PutIntegrationResponseRequest,
  ): Promise<IntegrationResponse> {
    const body: jsonP.JSONObject = {
      selectionPattern: params["selectionPattern"],
      responseParameters: params["responseParameters"],
      responseTemplates: params["responseTemplates"],
      contentHandling: params["contentHandling"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutIntegrationResponse",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration/responses/${params["statusCode"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "selectionPattern": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<ContentHandlingStrategy>(x),
      },
    }, await resp.json());
  }

  async putMethod(
    {abortSignal, ...params}: RequestConfig & PutMethodRequest,
  ): Promise<Method> {
    const body: jsonP.JSONObject = {
      authorizationType: params["authorizationType"],
      authorizerId: params["authorizerId"],
      apiKeyRequired: params["apiKeyRequired"],
      operationName: params["operationName"],
      requestParameters: params["requestParameters"],
      requestModels: params["requestModels"],
      requestValidatorId: params["requestValidatorId"],
      authorizationScopes: params["authorizationScopes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMethod",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "httpMethod": "s",
        "authorizationType": "s",
        "authorizerId": "s",
        "apiKeyRequired": "b",
        "requestValidatorId": "s",
        "operationName": "s",
        "requestParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "requestModels": x => jsonP.readMap(String, String, x),
        "methodResponses": x => jsonP.readMap(String, toMethodResponse, x),
        "methodIntegration": toIntegration,
        "authorizationScopes": ["s"],
      },
    }, await resp.json());
  }

  async putMethodResponse(
    {abortSignal, ...params}: RequestConfig & PutMethodResponseRequest,
  ): Promise<MethodResponse> {
    const body: jsonP.JSONObject = {
      responseParameters: params["responseParameters"],
      responseModels: params["responseModels"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMethodResponse",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/responses/${params["statusCode"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "responseModels": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async putRestApi(
    {abortSignal, ...params}: RequestConfig & PutRestApiRequest,
  ): Promise<RestApi> {
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const query = new URLSearchParams;
    if (params["mode"] != null) query.set("mode", params["mode"]?.toString() ?? "");
    if (params["failOnWarnings"] != null) query.set("failonwarnings", params["failOnWarnings"]?.toString() ?? "");
    for (const [k,v] of Object.entries(params["parameters"] ?? {})) {
      query.append(k, v?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "PutRestApi",
      method: "PUT",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      method: "PUT",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
  }

  async testInvokeAuthorizer(
    {abortSignal, ...params}: RequestConfig & TestInvokeAuthorizerRequest,
  ): Promise<TestInvokeAuthorizerResponse> {
    const body: jsonP.JSONObject = {
      headers: params["headers"],
      multiValueHeaders: params["multiValueHeaders"],
      pathWithQueryString: params["pathWithQueryString"],
      body: params["body"],
      stageVariables: params["stageVariables"],
      additionalContext: params["additionalContext"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestInvokeAuthorizer",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers/${params["authorizerId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clientStatus": "n",
        "log": "s",
        "latency": "n",
        "principalId": "s",
        "policy": "s",
        "authorization": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
        "claims": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async testInvokeMethod(
    {abortSignal, ...params}: RequestConfig & TestInvokeMethodRequest,
  ): Promise<TestInvokeMethodResponse> {
    const body: jsonP.JSONObject = {
      pathWithQueryString: params["pathWithQueryString"],
      body: params["body"],
      headers: params["headers"],
      multiValueHeaders: params["multiValueHeaders"],
      clientCertificateId: params["clientCertificateId"],
      stageVariables: params["stageVariables"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestInvokeMethod",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": "n",
        "body": "s",
        "headers": x => jsonP.readMap(String, String, x),
        "multiValueHeaders": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
        "log": "s",
        "latency": "n",
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
  }

  async updateAccount(
    {abortSignal, ...params}: RequestConfig & UpdateAccountRequest = {},
  ): Promise<Account> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccount",
      method: "PATCH",
      requestUri: "/account",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cloudwatchRoleArn": "s",
        "throttleSettings": toThrottleSettings,
        "features": ["s"],
        "apiKeyVersion": "s",
      },
    }, await resp.json());
  }

  async updateApiKey(
    {abortSignal, ...params}: RequestConfig & UpdateApiKeyRequest,
  ): Promise<ApiKey> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApiKey",
      method: "PATCH",
      requestUri: cmnP.encodePath`/apikeys/${params["apiKey"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "value": "s",
        "name": "s",
        "customerId": "s",
        "description": "s",
        "enabled": "b",
        "createdDate": "d",
        "lastUpdatedDate": "d",
        "stageKeys": ["s"],
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateAuthorizer(
    {abortSignal, ...params}: RequestConfig & UpdateAuthorizerRequest,
  ): Promise<Authorizer> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAuthorizer",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/authorizers/${params["authorizerId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<AuthorizerType>(x),
        "providerARNs": ["s"],
        "authType": "s",
        "authorizerUri": "s",
        "authorizerCredentials": "s",
        "identitySource": "s",
        "identityValidationExpression": "s",
        "authorizerResultTtlInSeconds": "n",
      },
    }, await resp.json());
  }

  async updateBasePathMapping(
    {abortSignal, ...params}: RequestConfig & UpdateBasePathMappingRequest,
  ): Promise<BasePathMapping> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBasePathMapping",
      method: "PATCH",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}/basepathmappings/${params["basePath"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "basePath": "s",
        "restApiId": "s",
        "stage": "s",
      },
    }, await resp.json());
  }

  async updateClientCertificate(
    {abortSignal, ...params}: RequestConfig & UpdateClientCertificateRequest,
  ): Promise<ClientCertificate> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClientCertificate",
      method: "PATCH",
      requestUri: cmnP.encodePath`/clientcertificates/${params["clientCertificateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clientCertificateId": "s",
        "description": "s",
        "pemEncodedCertificate": "s",
        "createdDate": "d",
        "expirationDate": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateDeployment(
    {abortSignal, ...params}: RequestConfig & UpdateDeploymentRequest,
  ): Promise<Deployment> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDeployment",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/deployments/${params["deploymentId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "description": "s",
        "createdDate": "d",
        "apiSummary": x => jsonP.readMap(String, y => jsonP.readMap(String, toMethodSnapshot, y)!, x),
      },
    }, await resp.json());
  }

  async updateDocumentationPart(
    {abortSignal, ...params}: RequestConfig & UpdateDocumentationPartRequest,
  ): Promise<DocumentationPart> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDocumentationPart",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/parts/${params["documentationPartId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "location": toDocumentationPartLocation,
        "properties": "s",
      },
    }, await resp.json());
  }

  async updateDocumentationVersion(
    {abortSignal, ...params}: RequestConfig & UpdateDocumentationVersionRequest,
  ): Promise<DocumentationVersion> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDocumentationVersion",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/documentation/versions/${params["documentationVersion"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "version": "s",
        "createdDate": "d",
        "description": "s",
      },
    }, await resp.json());
  }

  async updateDomainName(
    {abortSignal, ...params}: RequestConfig & UpdateDomainNameRequest,
  ): Promise<DomainName> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDomainName",
      method: "PATCH",
      requestUri: cmnP.encodePath`/domainnames/${params["domainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domainName": "s",
        "certificateName": "s",
        "certificateArn": "s",
        "certificateUploadDate": "d",
        "regionalDomainName": "s",
        "regionalHostedZoneId": "s",
        "regionalCertificateName": "s",
        "regionalCertificateArn": "s",
        "distributionDomainName": "s",
        "distributionHostedZoneId": "s",
        "endpointConfiguration": toEndpointConfiguration,
        "domainNameStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DomainNameStatus>(x),
        "domainNameStatusMessage": "s",
        "securityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<SecurityPolicy>(x),
        "tags": x => jsonP.readMap(String, String, x),
        "mutualTlsAuthentication": toMutualTlsAuthentication,
      },
    }, await resp.json());
  }

  async updateGatewayResponse(
    {abortSignal, ...params}: RequestConfig & UpdateGatewayResponseRequest,
  ): Promise<GatewayResponse> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGatewayResponse",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/gatewayresponses/${params["responseType"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "responseType": (x: jsonP.JSONValue) => cmnP.readEnum<GatewayResponseType>(x),
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "defaultResponse": "b",
      },
    }, await resp.json());
  }

  async updateIntegration(
    {abortSignal, ...params}: RequestConfig & UpdateIntegrationRequest,
  ): Promise<Integration> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIntegration",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<IntegrationType>(x),
        "httpMethod": "s",
        "uri": "s",
        "connectionType": (x: jsonP.JSONValue) => cmnP.readEnum<ConnectionType>(x),
        "connectionId": "s",
        "credentials": "s",
        "requestParameters": x => jsonP.readMap(String, String, x),
        "requestTemplates": x => jsonP.readMap(String, String, x),
        "passthroughBehavior": "s",
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<ContentHandlingStrategy>(x),
        "timeoutInMillis": "n",
        "cacheNamespace": "s",
        "cacheKeyParameters": ["s"],
        "integrationResponses": x => jsonP.readMap(String, toIntegrationResponse, x),
        "tlsConfig": toTlsConfig,
      },
    }, await resp.json());
  }

  async updateIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & UpdateIntegrationResponseRequest,
  ): Promise<IntegrationResponse> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIntegrationResponse",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/integration/responses/${params["statusCode"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "selectionPattern": "s",
        "responseParameters": x => jsonP.readMap(String, String, x),
        "responseTemplates": x => jsonP.readMap(String, String, x),
        "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<ContentHandlingStrategy>(x),
      },
    }, await resp.json());
  }

  async updateMethod(
    {abortSignal, ...params}: RequestConfig & UpdateMethodRequest,
  ): Promise<Method> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMethod",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "httpMethod": "s",
        "authorizationType": "s",
        "authorizerId": "s",
        "apiKeyRequired": "b",
        "requestValidatorId": "s",
        "operationName": "s",
        "requestParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "requestModels": x => jsonP.readMap(String, String, x),
        "methodResponses": x => jsonP.readMap(String, toMethodResponse, x),
        "methodIntegration": toIntegration,
        "authorizationScopes": ["s"],
      },
    }, await resp.json());
  }

  async updateMethodResponse(
    {abortSignal, ...params}: RequestConfig & UpdateMethodResponseRequest,
  ): Promise<MethodResponse> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMethodResponse",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}/methods/${params["httpMethod"]}/responses/${params["statusCode"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "responseParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
        "responseModels": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateModel(
    {abortSignal, ...params}: RequestConfig & UpdateModelRequest,
  ): Promise<Model> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateModel",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/models/${params["modelName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "schema": "s",
        "contentType": "s",
      },
    }, await resp.json());
  }

  async updateRequestValidator(
    {abortSignal, ...params}: RequestConfig & UpdateRequestValidatorRequest,
  ): Promise<RequestValidator> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRequestValidator",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/requestvalidators/${params["requestValidatorId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "validateRequestBody": "b",
        "validateRequestParameters": "b",
      },
    }, await resp.json());
  }

  async updateResource(
    {abortSignal, ...params}: RequestConfig & UpdateResourceRequest,
  ): Promise<Resource> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateResource",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/resources/${params["resourceId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "parentId": "s",
        "pathPart": "s",
        "path": "s",
        "resourceMethods": x => jsonP.readMap(String, toMethod, x),
      },
    }, await resp.json());
  }

  async updateRestApi(
    {abortSignal, ...params}: RequestConfig & UpdateRestApiRequest,
  ): Promise<RestApi> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRestApi",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "createdDate": "d",
        "version": "s",
        "warnings": ["s"],
        "binaryMediaTypes": ["s"],
        "minimumCompressionSize": "n",
        "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<ApiKeySourceType>(x),
        "endpointConfiguration": toEndpointConfiguration,
        "policy": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "disableExecuteApiEndpoint": "b",
      },
    }, await resp.json());
  }

  async updateStage(
    {abortSignal, ...params}: RequestConfig & UpdateStageRequest,
  ): Promise<Stage> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStage",
      method: "PATCH",
      requestUri: cmnP.encodePath`/restapis/${params["restApiId"]}/stages/${params["stageName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentId": "s",
        "clientCertificateId": "s",
        "stageName": "s",
        "description": "s",
        "cacheClusterEnabled": "b",
        "cacheClusterSize": (x: jsonP.JSONValue) => cmnP.readEnum<CacheClusterSize>(x),
        "cacheClusterStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CacheClusterStatus>(x),
        "methodSettings": x => jsonP.readMap(String, toMethodSetting, x),
        "variables": x => jsonP.readMap(String, String, x),
        "documentationVersion": "s",
        "accessLogSettings": toAccessLogSettings,
        "canarySettings": toCanarySettings,
        "tracingEnabled": "b",
        "webAclArn": "s",
        "tags": x => jsonP.readMap(String, String, x),
        "createdDate": "d",
        "lastUpdatedDate": "d",
      },
    }, await resp.json());
  }

  async updateUsage(
    {abortSignal, ...params}: RequestConfig & UpdateUsageRequest,
  ): Promise<Usage> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUsage",
      method: "PATCH",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}/keys/${params["keyId"]}/usage`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "usagePlanId": "s",
        "startDate": "s",
        "endDate": "s",
        "position": "s",
        "items": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(y => jsonP.readList(jsonP.readNum, y)!) : [], x),
      },
    }, await resp.json());
  }

  async updateUsagePlan(
    {abortSignal, ...params}: RequestConfig & UpdateUsagePlanRequest,
  ): Promise<UsagePlan> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUsagePlan",
      method: "PATCH",
      requestUri: cmnP.encodePath`/usageplans/${params["usagePlanId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "apiStages": [toApiStage],
        "throttle": toThrottleSettings,
        "quota": toQuotaSettings,
        "productCode": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateVpcLink(
    {abortSignal, ...params}: RequestConfig & UpdateVpcLinkRequest,
  ): Promise<VpcLink> {
    const body: jsonP.JSONObject = {
      patchOperations: params["patchOperations"]?.map(x => fromPatchOperation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVpcLink",
      method: "PATCH",
      requestUri: cmnP.encodePath`/vpclinks/${params["vpcLinkId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "description": "s",
        "targetArns": ["s"],
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<VpcLinkStatus>(x),
        "statusMessage": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CreateApiKeyRequest {
  name?: string | null;
  description?: string | null;
  enabled?: boolean | null;
  generateDistinctId?: boolean | null;
  value?: string | null;
  stageKeys?: StageKey[] | null;
  customerId?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateAuthorizerRequest {
  restApiId: string;
  name: string;
  type: AuthorizerType;
  providerARNs?: string[] | null;
  authType?: string | null;
  authorizerUri?: string | null;
  authorizerCredentials?: string | null;
  identitySource?: string | null;
  identityValidationExpression?: string | null;
  authorizerResultTtlInSeconds?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateBasePathMappingRequest {
  domainName: string;
  basePath?: string | null;
  restApiId: string;
  stage?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateDeploymentRequest {
  restApiId: string;
  stageName?: string | null;
  stageDescription?: string | null;
  description?: string | null;
  cacheClusterEnabled?: boolean | null;
  cacheClusterSize?: CacheClusterSize | null;
  variables?: { [key: string]: string | null | undefined } | null;
  canarySettings?: DeploymentCanarySettings | null;
  tracingEnabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateDocumentationPartRequest {
  restApiId: string;
  location: DocumentationPartLocation;
  properties: string;
}

// refs: 1 - tags: named, input
export interface CreateDocumentationVersionRequest {
  restApiId: string;
  documentationVersion: string;
  stageName?: string | null;
  description?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateDomainNameRequest {
  domainName: string;
  certificateName?: string | null;
  certificateBody?: string | null;
  certificatePrivateKey?: string | null;
  certificateChain?: string | null;
  certificateArn?: string | null;
  regionalCertificateName?: string | null;
  regionalCertificateArn?: string | null;
  endpointConfiguration?: EndpointConfiguration | null;
  tags?: { [key: string]: string | null | undefined } | null;
  securityPolicy?: SecurityPolicy | null;
  mutualTlsAuthentication?: MutualTlsAuthenticationInput | null;
}

// refs: 1 - tags: named, input
export interface CreateModelRequest {
  restApiId: string;
  name: string;
  description?: string | null;
  schema?: string | null;
  contentType: string;
}

// refs: 1 - tags: named, input
export interface CreateRequestValidatorRequest {
  restApiId: string;
  name?: string | null;
  validateRequestBody?: boolean | null;
  validateRequestParameters?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateResourceRequest {
  restApiId: string;
  parentId: string;
  pathPart: string;
}

// refs: 1 - tags: named, input
export interface CreateRestApiRequest {
  name: string;
  description?: string | null;
  version?: string | null;
  cloneFrom?: string | null;
  binaryMediaTypes?: string[] | null;
  minimumCompressionSize?: number | null;
  apiKeySource?: ApiKeySourceType | null;
  endpointConfiguration?: EndpointConfiguration | null;
  policy?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
  disableExecuteApiEndpoint?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateStageRequest {
  restApiId: string;
  stageName: string;
  deploymentId: string;
  description?: string | null;
  cacheClusterEnabled?: boolean | null;
  cacheClusterSize?: CacheClusterSize | null;
  variables?: { [key: string]: string | null | undefined } | null;
  documentationVersion?: string | null;
  canarySettings?: CanarySettings | null;
  tracingEnabled?: boolean | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateUsagePlanRequest {
  name: string;
  description?: string | null;
  apiStages?: ApiStage[] | null;
  throttle?: ThrottleSettings | null;
  quota?: QuotaSettings | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateUsagePlanKeyRequest {
  usagePlanId: string;
  keyId: string;
  keyType: string;
}

// refs: 1 - tags: named, input
export interface CreateVpcLinkRequest {
  name: string;
  description?: string | null;
  targetArns: string[];
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface DeleteApiKeyRequest {
  apiKey: string;
}

// refs: 1 - tags: named, input
export interface DeleteAuthorizerRequest {
  restApiId: string;
  authorizerId: string;
}

// refs: 1 - tags: named, input
export interface DeleteBasePathMappingRequest {
  domainName: string;
  basePath: string;
}

// refs: 1 - tags: named, input
export interface DeleteClientCertificateRequest {
  clientCertificateId: string;
}

// refs: 1 - tags: named, input
export interface DeleteDeploymentRequest {
  restApiId: string;
  deploymentId: string;
}

// refs: 1 - tags: named, input
export interface DeleteDocumentationPartRequest {
  restApiId: string;
  documentationPartId: string;
}

// refs: 1 - tags: named, input
export interface DeleteDocumentationVersionRequest {
  restApiId: string;
  documentationVersion: string;
}

// refs: 1 - tags: named, input
export interface DeleteDomainNameRequest {
  domainName: string;
}

// refs: 1 - tags: named, input
export interface DeleteGatewayResponseRequest {
  restApiId: string;
  responseType: GatewayResponseType;
}

// refs: 1 - tags: named, input
export interface DeleteIntegrationRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
}

// refs: 1 - tags: named, input
export interface DeleteIntegrationResponseRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  statusCode: string;
}

// refs: 1 - tags: named, input
export interface DeleteMethodRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
}

// refs: 1 - tags: named, input
export interface DeleteMethodResponseRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  statusCode: string;
}

// refs: 1 - tags: named, input
export interface DeleteModelRequest {
  restApiId: string;
  modelName: string;
}

// refs: 1 - tags: named, input
export interface DeleteRequestValidatorRequest {
  restApiId: string;
  requestValidatorId: string;
}

// refs: 1 - tags: named, input
export interface DeleteResourceRequest {
  restApiId: string;
  resourceId: string;
}

// refs: 1 - tags: named, input
export interface DeleteRestApiRequest {
  restApiId: string;
}

// refs: 1 - tags: named, input
export interface DeleteStageRequest {
  restApiId: string;
  stageName: string;
}

// refs: 1 - tags: named, input
export interface DeleteUsagePlanRequest {
  usagePlanId: string;
}

// refs: 1 - tags: named, input
export interface DeleteUsagePlanKeyRequest {
  usagePlanId: string;
  keyId: string;
}

// refs: 1 - tags: named, input
export interface DeleteVpcLinkRequest {
  vpcLinkId: string;
}

// refs: 1 - tags: named, input
export interface FlushStageAuthorizersCacheRequest {
  restApiId: string;
  stageName: string;
}

// refs: 1 - tags: named, input
export interface FlushStageCacheRequest {
  restApiId: string;
  stageName: string;
}

// refs: 1 - tags: named, input
export interface GenerateClientCertificateRequest {
  description?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface GetAccountRequest {
}

// refs: 1 - tags: named, input
export interface GetApiKeyRequest {
  apiKey: string;
  includeValue?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetApiKeysRequest {
  position?: string | null;
  limit?: number | null;
  nameQuery?: string | null;
  customerId?: string | null;
  includeValues?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetAuthorizerRequest {
  restApiId: string;
  authorizerId: string;
}

// refs: 1 - tags: named, input
export interface GetAuthorizersRequest {
  restApiId: string;
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetBasePathMappingRequest {
  domainName: string;
  basePath: string;
}

// refs: 1 - tags: named, input
export interface GetBasePathMappingsRequest {
  domainName: string;
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetClientCertificateRequest {
  clientCertificateId: string;
}

// refs: 1 - tags: named, input
export interface GetClientCertificatesRequest {
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetDeploymentRequest {
  restApiId: string;
  deploymentId: string;
  embed?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GetDeploymentsRequest {
  restApiId: string;
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetDocumentationPartRequest {
  restApiId: string;
  documentationPartId: string;
}

// refs: 1 - tags: named, input
export interface GetDocumentationPartsRequest {
  restApiId: string;
  type?: DocumentationPartType | null;
  nameQuery?: string | null;
  path?: string | null;
  position?: string | null;
  limit?: number | null;
  locationStatus?: LocationStatusType | null;
}

// refs: 1 - tags: named, input
export interface GetDocumentationVersionRequest {
  restApiId: string;
  documentationVersion: string;
}

// refs: 1 - tags: named, input
export interface GetDocumentationVersionsRequest {
  restApiId: string;
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetDomainNameRequest {
  domainName: string;
}

// refs: 1 - tags: named, input
export interface GetDomainNamesRequest {
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetExportRequest {
  restApiId: string;
  stageName: string;
  exportType: string;
  parameters?: { [key: string]: string | null | undefined } | null;
  accepts?: string | null;
}

// refs: 1 - tags: named, input
export interface GetGatewayResponseRequest {
  restApiId: string;
  responseType: GatewayResponseType;
}

// refs: 1 - tags: named, input
export interface GetGatewayResponsesRequest {
  restApiId: string;
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetIntegrationRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
}

// refs: 1 - tags: named, input
export interface GetIntegrationResponseRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  statusCode: string;
}

// refs: 1 - tags: named, input
export interface GetMethodRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
}

// refs: 1 - tags: named, input
export interface GetMethodResponseRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  statusCode: string;
}

// refs: 1 - tags: named, input
export interface GetModelRequest {
  restApiId: string;
  modelName: string;
  flatten?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetModelTemplateRequest {
  restApiId: string;
  modelName: string;
}

// refs: 1 - tags: named, input
export interface GetModelsRequest {
  restApiId: string;
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetRequestValidatorRequest {
  restApiId: string;
  requestValidatorId: string;
}

// refs: 1 - tags: named, input
export interface GetRequestValidatorsRequest {
  restApiId: string;
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetResourceRequest {
  restApiId: string;
  resourceId: string;
  embed?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GetResourcesRequest {
  restApiId: string;
  position?: string | null;
  limit?: number | null;
  embed?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GetRestApiRequest {
  restApiId: string;
}

// refs: 1 - tags: named, input
export interface GetRestApisRequest {
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetSdkRequest {
  restApiId: string;
  stageName: string;
  sdkType: string;
  parameters?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface GetSdkTypeRequest {
  id: string;
}

// refs: 1 - tags: named, input
export interface GetSdkTypesRequest {
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetStageRequest {
  restApiId: string;
  stageName: string;
}

// refs: 1 - tags: named, input
export interface GetStagesRequest {
  restApiId: string;
  deploymentId?: string | null;
}

// refs: 1 - tags: named, input
export interface GetTagsRequest {
  resourceArn: string;
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetUsageRequest {
  usagePlanId: string;
  keyId?: string | null;
  startDate: string;
  endDate: string;
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetUsagePlanRequest {
  usagePlanId: string;
}

// refs: 1 - tags: named, input
export interface GetUsagePlanKeyRequest {
  usagePlanId: string;
  keyId: string;
}

// refs: 1 - tags: named, input
export interface GetUsagePlanKeysRequest {
  usagePlanId: string;
  position?: string | null;
  limit?: number | null;
  nameQuery?: string | null;
}

// refs: 1 - tags: named, input
export interface GetUsagePlansRequest {
  position?: string | null;
  keyId?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface GetVpcLinkRequest {
  vpcLinkId: string;
}

// refs: 1 - tags: named, input
export interface GetVpcLinksRequest {
  position?: string | null;
  limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ImportApiKeysRequest {
  body: Uint8Array | string;
  format: ApiKeysFormat;
  failOnWarnings?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ImportDocumentationPartsRequest {
  restApiId: string;
  mode?: PutMode | null;
  failOnWarnings?: boolean | null;
  body: Uint8Array | string;
}

// refs: 1 - tags: named, input
export interface ImportRestApiRequest {
  failOnWarnings?: boolean | null;
  parameters?: { [key: string]: string | null | undefined } | null;
  body: Uint8Array | string;
}

// refs: 1 - tags: named, input
export interface PutGatewayResponseRequest {
  restApiId: string;
  responseType: GatewayResponseType;
  statusCode?: string | null;
  responseParameters?: { [key: string]: string | null | undefined } | null;
  responseTemplates?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface PutIntegrationRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  type: IntegrationType;
  integrationHttpMethod?: string | null;
  uri?: string | null;
  connectionType?: ConnectionType | null;
  connectionId?: string | null;
  credentials?: string | null;
  requestParameters?: { [key: string]: string | null | undefined } | null;
  requestTemplates?: { [key: string]: string | null | undefined } | null;
  passthroughBehavior?: string | null;
  cacheNamespace?: string | null;
  cacheKeyParameters?: string[] | null;
  contentHandling?: ContentHandlingStrategy | null;
  timeoutInMillis?: number | null;
  tlsConfig?: TlsConfig | null;
}

// refs: 1 - tags: named, input
export interface PutIntegrationResponseRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  statusCode: string;
  selectionPattern?: string | null;
  responseParameters?: { [key: string]: string | null | undefined } | null;
  responseTemplates?: { [key: string]: string | null | undefined } | null;
  contentHandling?: ContentHandlingStrategy | null;
}

// refs: 1 - tags: named, input
export interface PutMethodRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  authorizationType: string;
  authorizerId?: string | null;
  apiKeyRequired?: boolean | null;
  operationName?: string | null;
  requestParameters?: { [key: string]: boolean | null | undefined } | null;
  requestModels?: { [key: string]: string | null | undefined } | null;
  requestValidatorId?: string | null;
  authorizationScopes?: string[] | null;
}

// refs: 1 - tags: named, input
export interface PutMethodResponseRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  statusCode: string;
  responseParameters?: { [key: string]: boolean | null | undefined } | null;
  responseModels?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface PutRestApiRequest {
  restApiId: string;
  mode?: PutMode | null;
  failOnWarnings?: boolean | null;
  parameters?: { [key: string]: string | null | undefined } | null;
  body: Uint8Array | string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface TestInvokeAuthorizerRequest {
  restApiId: string;
  authorizerId: string;
  headers?: { [key: string]: string | null | undefined } | null;
  multiValueHeaders?: { [key: string]: string[] | null | undefined } | null;
  pathWithQueryString?: string | null;
  body?: string | null;
  stageVariables?: { [key: string]: string | null | undefined } | null;
  additionalContext?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface TestInvokeMethodRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  pathWithQueryString?: string | null;
  body?: string | null;
  headers?: { [key: string]: string | null | undefined } | null;
  multiValueHeaders?: { [key: string]: string[] | null | undefined } | null;
  clientCertificateId?: string | null;
  stageVariables?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateAccountRequest {
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateApiKeyRequest {
  apiKey: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateAuthorizerRequest {
  restApiId: string;
  authorizerId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateBasePathMappingRequest {
  domainName: string;
  basePath: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateClientCertificateRequest {
  clientCertificateId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateDeploymentRequest {
  restApiId: string;
  deploymentId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateDocumentationPartRequest {
  restApiId: string;
  documentationPartId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateDocumentationVersionRequest {
  restApiId: string;
  documentationVersion: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateDomainNameRequest {
  domainName: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateGatewayResponseRequest {
  restApiId: string;
  responseType: GatewayResponseType;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateIntegrationRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateIntegrationResponseRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  statusCode: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateMethodRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateMethodResponseRequest {
  restApiId: string;
  resourceId: string;
  httpMethod: string;
  statusCode: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateModelRequest {
  restApiId: string;
  modelName: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateRequestValidatorRequest {
  restApiId: string;
  requestValidatorId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateResourceRequest {
  restApiId: string;
  resourceId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateRestApiRequest {
  restApiId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateStageRequest {
  restApiId: string;
  stageName: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateUsageRequest {
  usagePlanId: string;
  keyId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateUsagePlanRequest {
  usagePlanId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateVpcLinkRequest {
  vpcLinkId: string;
  patchOperations?: PatchOperation[] | null;
}

// refs: 2 - tags: named, output, interface
export interface ApiKey {
  id?: string | null;
  value?: string | null;
  name?: string | null;
  customerId?: string | null;
  description?: string | null;
  enabled?: boolean | null;
  createdDate?: Date | number | null;
  lastUpdatedDate?: Date | number | null;
  stageKeys?: string[] | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toApiKey(root: jsonP.JSONValue): ApiKey {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "value": "s",
      "name": "s",
      "customerId": "s",
      "description": "s",
      "enabled": "b",
      "createdDate": "d",
      "lastUpdatedDate": "d",
      "stageKeys": ["s"],
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface Authorizer {
  id?: string | null;
  name?: string | null;
  type?: AuthorizerType | null;
  providerARNs?: string[] | null;
  authType?: string | null;
  authorizerUri?: string | null;
  authorizerCredentials?: string | null;
  identitySource?: string | null;
  identityValidationExpression?: string | null;
  authorizerResultTtlInSeconds?: number | null;
}
function toAuthorizer(root: jsonP.JSONValue): Authorizer {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<AuthorizerType>(x),
      "providerARNs": ["s"],
      "authType": "s",
      "authorizerUri": "s",
      "authorizerCredentials": "s",
      "identitySource": "s",
      "identityValidationExpression": "s",
      "authorizerResultTtlInSeconds": "n",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface BasePathMapping {
  basePath?: string | null;
  restApiId?: string | null;
  stage?: string | null;
}
function toBasePathMapping(root: jsonP.JSONValue): BasePathMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "basePath": "s",
      "restApiId": "s",
      "stage": "s",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface Deployment {
  id?: string | null;
  description?: string | null;
  createdDate?: Date | number | null;
  apiSummary?: { [key: string]: { [key: string]: MethodSnapshot | null | undefined } | null | undefined } | null;
}
function toDeployment(root: jsonP.JSONValue): Deployment {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "description": "s",
      "createdDate": "d",
      "apiSummary": x => jsonP.readMap(String, y => jsonP.readMap(String, toMethodSnapshot, y)!, x),
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface DocumentationPart {
  id?: string | null;
  location?: DocumentationPartLocation | null;
  properties?: string | null;
}
function toDocumentationPart(root: jsonP.JSONValue): DocumentationPart {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "location": toDocumentationPartLocation,
      "properties": "s",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface DocumentationVersion {
  version?: string | null;
  createdDate?: Date | number | null;
  description?: string | null;
}
function toDocumentationVersion(root: jsonP.JSONValue): DocumentationVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "version": "s",
      "createdDate": "d",
      "description": "s",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface DomainName {
  domainName?: string | null;
  certificateName?: string | null;
  certificateArn?: string | null;
  certificateUploadDate?: Date | number | null;
  regionalDomainName?: string | null;
  regionalHostedZoneId?: string | null;
  regionalCertificateName?: string | null;
  regionalCertificateArn?: string | null;
  distributionDomainName?: string | null;
  distributionHostedZoneId?: string | null;
  endpointConfiguration?: EndpointConfiguration | null;
  domainNameStatus?: DomainNameStatus | null;
  domainNameStatusMessage?: string | null;
  securityPolicy?: SecurityPolicy | null;
  tags?: { [key: string]: string | null | undefined } | null;
  mutualTlsAuthentication?: MutualTlsAuthentication | null;
}
function toDomainName(root: jsonP.JSONValue): DomainName {
  return jsonP.readObj({
    required: {},
    optional: {
      "domainName": "s",
      "certificateName": "s",
      "certificateArn": "s",
      "certificateUploadDate": "d",
      "regionalDomainName": "s",
      "regionalHostedZoneId": "s",
      "regionalCertificateName": "s",
      "regionalCertificateArn": "s",
      "distributionDomainName": "s",
      "distributionHostedZoneId": "s",
      "endpointConfiguration": toEndpointConfiguration,
      "domainNameStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DomainNameStatus>(x),
      "domainNameStatusMessage": "s",
      "securityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<SecurityPolicy>(x),
      "tags": x => jsonP.readMap(String, String, x),
      "mutualTlsAuthentication": toMutualTlsAuthentication,
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface Model {
  id?: string | null;
  name?: string | null;
  description?: string | null;
  schema?: string | null;
  contentType?: string | null;
}
function toModel(root: jsonP.JSONValue): Model {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "description": "s",
      "schema": "s",
      "contentType": "s",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface RequestValidator {
  id?: string | null;
  name?: string | null;
  validateRequestBody?: boolean | null;
  validateRequestParameters?: boolean | null;
}
function toRequestValidator(root: jsonP.JSONValue): RequestValidator {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "validateRequestBody": "b",
      "validateRequestParameters": "b",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface Resource {
  id?: string | null;
  parentId?: string | null;
  pathPart?: string | null;
  path?: string | null;
  resourceMethods?: { [key: string]: Method | null | undefined } | null;
}
function toResource(root: jsonP.JSONValue): Resource {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "parentId": "s",
      "pathPart": "s",
      "path": "s",
      "resourceMethods": x => jsonP.readMap(String, toMethod, x),
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface RestApi {
  id?: string | null;
  name?: string | null;
  description?: string | null;
  createdDate?: Date | number | null;
  version?: string | null;
  warnings?: string[] | null;
  binaryMediaTypes?: string[] | null;
  minimumCompressionSize?: number | null;
  apiKeySource?: ApiKeySourceType | null;
  endpointConfiguration?: EndpointConfiguration | null;
  policy?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
  disableExecuteApiEndpoint?: boolean | null;
}
function toRestApi(root: jsonP.JSONValue): RestApi {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "description": "s",
      "createdDate": "d",
      "version": "s",
      "warnings": ["s"],
      "binaryMediaTypes": ["s"],
      "minimumCompressionSize": "n",
      "apiKeySource": (x: jsonP.JSONValue) => cmnP.readEnum<ApiKeySourceType>(x),
      "endpointConfiguration": toEndpointConfiguration,
      "policy": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "disableExecuteApiEndpoint": "b",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface Stage {
  deploymentId?: string | null;
  clientCertificateId?: string | null;
  stageName?: string | null;
  description?: string | null;
  cacheClusterEnabled?: boolean | null;
  cacheClusterSize?: CacheClusterSize | null;
  cacheClusterStatus?: CacheClusterStatus | null;
  methodSettings?: { [key: string]: MethodSetting | null | undefined } | null;
  variables?: { [key: string]: string | null | undefined } | null;
  documentationVersion?: string | null;
  accessLogSettings?: AccessLogSettings | null;
  canarySettings?: CanarySettings | null;
  tracingEnabled?: boolean | null;
  webAclArn?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
  createdDate?: Date | number | null;
  lastUpdatedDate?: Date | number | null;
}
function toStage(root: jsonP.JSONValue): Stage {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "clientCertificateId": "s",
      "stageName": "s",
      "description": "s",
      "cacheClusterEnabled": "b",
      "cacheClusterSize": (x: jsonP.JSONValue) => cmnP.readEnum<CacheClusterSize>(x),
      "cacheClusterStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CacheClusterStatus>(x),
      "methodSettings": x => jsonP.readMap(String, toMethodSetting, x),
      "variables": x => jsonP.readMap(String, String, x),
      "documentationVersion": "s",
      "accessLogSettings": toAccessLogSettings,
      "canarySettings": toCanarySettings,
      "tracingEnabled": "b",
      "webAclArn": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "createdDate": "d",
      "lastUpdatedDate": "d",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface UsagePlan {
  id?: string | null;
  name?: string | null;
  description?: string | null;
  apiStages?: ApiStage[] | null;
  throttle?: ThrottleSettings | null;
  quota?: QuotaSettings | null;
  productCode?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toUsagePlan(root: jsonP.JSONValue): UsagePlan {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "description": "s",
      "apiStages": [toApiStage],
      "throttle": toThrottleSettings,
      "quota": toQuotaSettings,
      "productCode": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface UsagePlanKey {
  id?: string | null;
  type?: string | null;
  value?: string | null;
  name?: string | null;
}
function toUsagePlanKey(root: jsonP.JSONValue): UsagePlanKey {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "type": "s",
      "value": "s",
      "name": "s",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface VpcLink {
  id?: string | null;
  name?: string | null;
  description?: string | null;
  targetArns?: string[] | null;
  status?: VpcLinkStatus | null;
  statusMessage?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toVpcLink(root: jsonP.JSONValue): VpcLink {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "description": "s",
      "targetArns": ["s"],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<VpcLinkStatus>(x),
      "statusMessage": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface ClientCertificate {
  clientCertificateId?: string | null;
  description?: string | null;
  pemEncodedCertificate?: string | null;
  createdDate?: Date | number | null;
  expirationDate?: Date | number | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toClientCertificate(root: jsonP.JSONValue): ClientCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "clientCertificateId": "s",
      "description": "s",
      "pemEncodedCertificate": "s",
      "createdDate": "d",
      "expirationDate": "d",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: named, output
export interface Account {
  cloudwatchRoleArn?: string | null;
  throttleSettings?: ThrottleSettings | null;
  features?: string[] | null;
  apiKeyVersion?: string | null;
}

// refs: 1 - tags: named, output
export interface ApiKeys {
  warnings?: string[] | null;
  position?: string | null;
  items?: ApiKey[] | null;
}

// refs: 1 - tags: named, output
export interface Authorizers {
  position?: string | null;
  items?: Authorizer[] | null;
}

// refs: 1 - tags: named, output
export interface BasePathMappings {
  position?: string | null;
  items?: BasePathMapping[] | null;
}

// refs: 1 - tags: named, output
export interface ClientCertificates {
  position?: string | null;
  items?: ClientCertificate[] | null;
}

// refs: 1 - tags: named, output
export interface Deployments {
  position?: string | null;
  items?: Deployment[] | null;
}

// refs: 1 - tags: named, output
export interface DocumentationParts {
  position?: string | null;
  items?: DocumentationPart[] | null;
}

// refs: 1 - tags: named, output
export interface DocumentationVersions {
  position?: string | null;
  items?: DocumentationVersion[] | null;
}

// refs: 1 - tags: named, output
export interface DomainNames {
  position?: string | null;
  items?: DomainName[] | null;
}

// refs: 1 - tags: named, output
export interface ExportResponse {
  contentType?: string | null;
  contentDisposition?: string | null;
  body?: Uint8Array | string | null;
}

// refs: 2 - tags: named, output, interface
export interface GatewayResponse {
  responseType?: GatewayResponseType | null;
  statusCode?: string | null;
  responseParameters?: { [key: string]: string | null | undefined } | null;
  responseTemplates?: { [key: string]: string | null | undefined } | null;
  defaultResponse?: boolean | null;
}
function toGatewayResponse(root: jsonP.JSONValue): GatewayResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "responseType": (x: jsonP.JSONValue) => cmnP.readEnum<GatewayResponseType>(x),
      "statusCode": "s",
      "responseParameters": x => jsonP.readMap(String, String, x),
      "responseTemplates": x => jsonP.readMap(String, String, x),
      "defaultResponse": "b",
    },
  }, root);
}

// refs: 1 - tags: named, output
export interface GatewayResponses {
  position?: string | null;
  items?: GatewayResponse[] | null;
}

// refs: 4 - tags: output, named, interface
export interface Integration {
  type?: IntegrationType | null;
  httpMethod?: string | null;
  uri?: string | null;
  connectionType?: ConnectionType | null;
  connectionId?: string | null;
  credentials?: string | null;
  requestParameters?: { [key: string]: string | null | undefined } | null;
  requestTemplates?: { [key: string]: string | null | undefined } | null;
  passthroughBehavior?: string | null;
  contentHandling?: ContentHandlingStrategy | null;
  timeoutInMillis?: number | null;
  cacheNamespace?: string | null;
  cacheKeyParameters?: string[] | null;
  integrationResponses?: { [key: string]: IntegrationResponse | null | undefined } | null;
  tlsConfig?: TlsConfig | null;
}
function toIntegration(root: jsonP.JSONValue): Integration {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<IntegrationType>(x),
      "httpMethod": "s",
      "uri": "s",
      "connectionType": (x: jsonP.JSONValue) => cmnP.readEnum<ConnectionType>(x),
      "connectionId": "s",
      "credentials": "s",
      "requestParameters": x => jsonP.readMap(String, String, x),
      "requestTemplates": x => jsonP.readMap(String, String, x),
      "passthroughBehavior": "s",
      "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<ContentHandlingStrategy>(x),
      "timeoutInMillis": "n",
      "cacheNamespace": "s",
      "cacheKeyParameters": ["s"],
      "integrationResponses": x => jsonP.readMap(String, toIntegrationResponse, x),
      "tlsConfig": toTlsConfig,
    },
  }, root);
}

// refs: 5 - tags: output, named, interface
export interface IntegrationResponse {
  statusCode?: string | null;
  selectionPattern?: string | null;
  responseParameters?: { [key: string]: string | null | undefined } | null;
  responseTemplates?: { [key: string]: string | null | undefined } | null;
  contentHandling?: ContentHandlingStrategy | null;
}
function toIntegrationResponse(root: jsonP.JSONValue): IntegrationResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "statusCode": "s",
      "selectionPattern": "s",
      "responseParameters": x => jsonP.readMap(String, String, x),
      "responseTemplates": x => jsonP.readMap(String, String, x),
      "contentHandling": (x: jsonP.JSONValue) => cmnP.readEnum<ContentHandlingStrategy>(x),
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Method {
  httpMethod?: string | null;
  authorizationType?: string | null;
  authorizerId?: string | null;
  apiKeyRequired?: boolean | null;
  requestValidatorId?: string | null;
  operationName?: string | null;
  requestParameters?: { [key: string]: boolean | null | undefined } | null;
  requestModels?: { [key: string]: string | null | undefined } | null;
  methodResponses?: { [key: string]: MethodResponse | null | undefined } | null;
  methodIntegration?: Integration | null;
  authorizationScopes?: string[] | null;
}
function toMethod(root: jsonP.JSONValue): Method {
  return jsonP.readObj({
    required: {},
    optional: {
      "httpMethod": "s",
      "authorizationType": "s",
      "authorizerId": "s",
      "apiKeyRequired": "b",
      "requestValidatorId": "s",
      "operationName": "s",
      "requestParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
      "requestModels": x => jsonP.readMap(String, String, x),
      "methodResponses": x => jsonP.readMap(String, toMethodResponse, x),
      "methodIntegration": toIntegration,
      "authorizationScopes": ["s"],
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface MethodResponse {
  statusCode?: string | null;
  responseParameters?: { [key: string]: boolean | null | undefined } | null;
  responseModels?: { [key: string]: string | null | undefined } | null;
}
function toMethodResponse(root: jsonP.JSONValue): MethodResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "statusCode": "s",
      "responseParameters": x => jsonP.readMap(String, y => typeof y === "boolean" ? y : null, x),
      "responseModels": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: named, output
export interface Template {
  value?: string | null;
}

// refs: 1 - tags: named, output
export interface Models {
  position?: string | null;
  items?: Model[] | null;
}

// refs: 1 - tags: named, output
export interface RequestValidators {
  position?: string | null;
  items?: RequestValidator[] | null;
}

// refs: 1 - tags: named, output
export interface Resources {
  position?: string | null;
  items?: Resource[] | null;
}

// refs: 1 - tags: named, output
export interface RestApis {
  position?: string | null;
  items?: RestApi[] | null;
}

// refs: 1 - tags: named, output
export interface SdkResponse {
  contentType?: string | null;
  contentDisposition?: string | null;
  body?: Uint8Array | string | null;
}

// refs: 2 - tags: named, output, interface
export interface SdkType {
  id?: string | null;
  friendlyName?: string | null;
  description?: string | null;
  configurationProperties?: SdkConfigurationProperty[] | null;
}
function toSdkType(root: jsonP.JSONValue): SdkType {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "friendlyName": "s",
      "description": "s",
      "configurationProperties": [toSdkConfigurationProperty],
    },
  }, root);
}

// refs: 1 - tags: named, output
export interface SdkTypes {
  position?: string | null;
  items?: SdkType[] | null;
}

// refs: 1 - tags: named, output
export interface Stages {
  item?: Stage[] | null;
}

// refs: 1 - tags: named, output
export interface Tags {
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface Usage {
  usagePlanId?: string | null;
  startDate?: string | null;
  endDate?: string | null;
  position?: string | null;
  items?: { [key: string]: number[][] | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface UsagePlanKeys {
  position?: string | null;
  items?: UsagePlanKey[] | null;
}

// refs: 1 - tags: named, output
export interface UsagePlans {
  position?: string | null;
  items?: UsagePlan[] | null;
}

// refs: 1 - tags: named, output
export interface VpcLinks {
  position?: string | null;
  items?: VpcLink[] | null;
}

// refs: 1 - tags: named, output
export interface ApiKeyIds {
  ids?: string[] | null;
  warnings?: string[] | null;
}

// refs: 1 - tags: named, output
export interface DocumentationPartIds {
  ids?: string[] | null;
  warnings?: string[] | null;
}

// refs: 1 - tags: named, output
export interface TestInvokeAuthorizerResponse {
  clientStatus?: number | null;
  log?: string | null;
  latency?: number | null;
  principalId?: string | null;
  policy?: string | null;
  authorization?: { [key: string]: string[] | null | undefined } | null;
  claims?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface TestInvokeMethodResponse {
  status?: number | null;
  body?: string | null;
  headers?: { [key: string]: string | null | undefined } | null;
  multiValueHeaders?: { [key: string]: string[] | null | undefined } | null;
  log?: string | null;
  latency?: number | null;
}

// refs: 1 - tags: input, named, interface
export interface StageKey {
  restApiId?: string | null;
  stageName?: string | null;
}
function fromStageKey(input?: StageKey | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    restApiId: input["restApiId"],
    stageName: input["stageName"],
  }
}

// refs: 3 - tags: input, named, enum, output
export type AuthorizerType =
| "TOKEN"
| "REQUEST"
| "COGNITO_USER_POOLS"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type CacheClusterSize =
| "0.5"
| "1.6"
| "6.1"
| "13.5"
| "28.4"
| "58.2"
| "118"
| "237"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface DeploymentCanarySettings {
  percentTraffic?: number | null;
  stageVariableOverrides?: { [key: string]: string | null | undefined } | null;
  useStageCache?: boolean | null;
}
function fromDeploymentCanarySettings(input?: DeploymentCanarySettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    percentTraffic: input["percentTraffic"],
    stageVariableOverrides: input["stageVariableOverrides"],
    useStageCache: input["useStageCache"],
  }
}

// refs: 3 - tags: input, named, interface, output
export interface DocumentationPartLocation {
  type: DocumentationPartType;
  path?: string | null;
  method?: string | null;
  statusCode?: string | null;
  name?: string | null;
}
function fromDocumentationPartLocation(input?: DocumentationPartLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    path: input["path"],
    method: input["method"],
    statusCode: input["statusCode"],
    name: input["name"],
  }
}
function toDocumentationPartLocation(root: jsonP.JSONValue): DocumentationPartLocation {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<DocumentationPartType>(x),
    },
    optional: {
      "path": "s",
      "method": "s",
      "statusCode": "s",
      "name": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type DocumentationPartType =
| "API"
| "AUTHORIZER"
| "MODEL"
| "RESOURCE"
| "METHOD"
| "PATH_PARAMETER"
| "QUERY_PARAMETER"
| "REQUEST_HEADER"
| "REQUEST_BODY"
| "RESPONSE"
| "RESPONSE_HEADER"
| "RESPONSE_BODY"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface EndpointConfiguration {
  types?: EndpointType[] | null;
  vpcEndpointIds?: string[] | null;
}
function fromEndpointConfiguration(input?: EndpointConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    types: input["types"],
    vpcEndpointIds: input["vpcEndpointIds"],
  }
}
function toEndpointConfiguration(root: jsonP.JSONValue): EndpointConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "types": [(x: jsonP.JSONValue) => cmnP.readEnum<EndpointType>(x)],
      "vpcEndpointIds": ["s"],
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type EndpointType =
| "REGIONAL"
| "EDGE"
| "PRIVATE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type SecurityPolicy =
| "TLS_1_0"
| "TLS_1_2"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface MutualTlsAuthenticationInput {
  truststoreUri?: string | null;
  truststoreVersion?: string | null;
}
function fromMutualTlsAuthenticationInput(input?: MutualTlsAuthenticationInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    truststoreUri: input["truststoreUri"],
    truststoreVersion: input["truststoreVersion"],
  }
}

// refs: 3 - tags: input, named, enum, output
export type ApiKeySourceType =
| "HEADER"
| "AUTHORIZER"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface CanarySettings {
  percentTraffic?: number | null;
  deploymentId?: string | null;
  stageVariableOverrides?: { [key: string]: string | null | undefined } | null;
  useStageCache?: boolean | null;
}
function fromCanarySettings(input?: CanarySettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    percentTraffic: input["percentTraffic"],
    deploymentId: input["deploymentId"],
    stageVariableOverrides: input["stageVariableOverrides"],
    useStageCache: input["useStageCache"],
  }
}
function toCanarySettings(root: jsonP.JSONValue): CanarySettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "percentTraffic": "n",
      "deploymentId": "s",
      "stageVariableOverrides": x => jsonP.readMap(String, String, x),
      "useStageCache": "b",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ApiStage {
  apiId?: string | null;
  stage?: string | null;
  throttle?: { [key: string]: ThrottleSettings | null | undefined } | null;
}
function fromApiStage(input?: ApiStage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    apiId: input["apiId"],
    stage: input["stage"],
    throttle: jsonP.serializeMap(input["throttle"], x => fromThrottleSettings(x)),
  }
}
function toApiStage(root: jsonP.JSONValue): ApiStage {
  return jsonP.readObj({
    required: {},
    optional: {
      "apiId": "s",
      "stage": "s",
      "throttle": x => jsonP.readMap(String, toThrottleSettings, x),
    },
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface ThrottleSettings {
  burstLimit?: number | null;
  rateLimit?: number | null;
}
function fromThrottleSettings(input?: ThrottleSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    burstLimit: input["burstLimit"],
    rateLimit: input["rateLimit"],
  }
}
function toThrottleSettings(root: jsonP.JSONValue): ThrottleSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "burstLimit": "n",
      "rateLimit": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface QuotaSettings {
  limit?: number | null;
  offset?: number | null;
  period?: QuotaPeriodType | null;
}
function fromQuotaSettings(input?: QuotaSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    limit: input["limit"],
    offset: input["offset"],
    period: input["period"],
  }
}
function toQuotaSettings(root: jsonP.JSONValue): QuotaSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "limit": "n",
      "offset": "n",
      "period": (x: jsonP.JSONValue) => cmnP.readEnum<QuotaPeriodType>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type QuotaPeriodType =
| "DAY"
| "WEEK"
| "MONTH"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type GatewayResponseType =
| "DEFAULT_4XX"
| "DEFAULT_5XX"
| "RESOURCE_NOT_FOUND"
| "UNAUTHORIZED"
| "INVALID_API_KEY"
| "ACCESS_DENIED"
| "AUTHORIZER_FAILURE"
| "AUTHORIZER_CONFIGURATION_ERROR"
| "INVALID_SIGNATURE"
| "EXPIRED_TOKEN"
| "MISSING_AUTHENTICATION_TOKEN"
| "INTEGRATION_FAILURE"
| "INTEGRATION_TIMEOUT"
| "API_CONFIGURATION_ERROR"
| "UNSUPPORTED_MEDIA_TYPE"
| "BAD_REQUEST_PARAMETERS"
| "BAD_REQUEST_BODY"
| "REQUEST_TOO_LARGE"
| "THROTTLED"
| "QUOTA_EXCEEDED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type LocationStatusType =
| "DOCUMENTED"
| "UNDOCUMENTED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ApiKeysFormat =
| "csv"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type PutMode =
| "merge"
| "overwrite"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type IntegrationType =
| "HTTP"
| "AWS"
| "MOCK"
| "HTTP_PROXY"
| "AWS_PROXY"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type ConnectionType =
| "INTERNET"
| "VPC_LINK"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, enum, output
export type ContentHandlingStrategy =
| "CONVERT_TO_BINARY"
| "CONVERT_TO_TEXT"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface TlsConfig {
  insecureSkipVerification?: boolean | null;
}
function fromTlsConfig(input?: TlsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    insecureSkipVerification: input["insecureSkipVerification"],
  }
}
function toTlsConfig(root: jsonP.JSONValue): TlsConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "insecureSkipVerification": "b",
    },
  }, root);
}

// refs: 22 - tags: input, named, interface
export interface PatchOperation {
  op?: Op | null;
  path?: string | null;
  value?: string | null;
  from?: string | null;
}
function fromPatchOperation(input?: PatchOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    op: input["op"],
    path: input["path"],
    value: input["value"],
    from: input["from"],
  }
}

// refs: 22 - tags: input, named, enum
export type Op =
| "add"
| "remove"
| "replace"
| "move"
| "copy"
| "test"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface MethodSnapshot {
  authorizationType?: string | null;
  apiKeyRequired?: boolean | null;
}
function toMethodSnapshot(root: jsonP.JSONValue): MethodSnapshot {
  return jsonP.readObj({
    required: {},
    optional: {
      "authorizationType": "s",
      "apiKeyRequired": "b",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DomainNameStatus =
| "AVAILABLE"
| "UPDATING"
| "PENDING"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface MutualTlsAuthentication {
  truststoreUri?: string | null;
  truststoreVersion?: string | null;
  truststoreWarnings?: string[] | null;
}
function toMutualTlsAuthentication(root: jsonP.JSONValue): MutualTlsAuthentication {
  return jsonP.readObj({
    required: {},
    optional: {
      "truststoreUri": "s",
      "truststoreVersion": "s",
      "truststoreWarnings": ["s"],
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type CacheClusterStatus =
| "CREATE_IN_PROGRESS"
| "AVAILABLE"
| "DELETE_IN_PROGRESS"
| "NOT_AVAILABLE"
| "FLUSH_IN_PROGRESS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface MethodSetting {
  metricsEnabled?: boolean | null;
  loggingLevel?: string | null;
  dataTraceEnabled?: boolean | null;
  throttlingBurstLimit?: number | null;
  throttlingRateLimit?: number | null;
  cachingEnabled?: boolean | null;
  cacheTtlInSeconds?: number | null;
  cacheDataEncrypted?: boolean | null;
  requireAuthorizationForCacheControl?: boolean | null;
  unauthorizedCacheControlHeaderStrategy?: UnauthorizedCacheControlHeaderStrategy | null;
}
function toMethodSetting(root: jsonP.JSONValue): MethodSetting {
  return jsonP.readObj({
    required: {},
    optional: {
      "metricsEnabled": "b",
      "loggingLevel": "s",
      "dataTraceEnabled": "b",
      "throttlingBurstLimit": "n",
      "throttlingRateLimit": "n",
      "cachingEnabled": "b",
      "cacheTtlInSeconds": "n",
      "cacheDataEncrypted": "b",
      "requireAuthorizationForCacheControl": "b",
      "unauthorizedCacheControlHeaderStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<UnauthorizedCacheControlHeaderStrategy>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type UnauthorizedCacheControlHeaderStrategy =
| "FAIL_WITH_403"
| "SUCCEED_WITH_RESPONSE_HEADER"
| "SUCCEED_WITHOUT_RESPONSE_HEADER"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface AccessLogSettings {
  format?: string | null;
  destinationArn?: string | null;
}
function toAccessLogSettings(root: jsonP.JSONValue): AccessLogSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "format": "s",
      "destinationArn": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type VpcLinkStatus =
| "AVAILABLE"
| "PENDING"
| "DELETING"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface SdkConfigurationProperty {
  name?: string | null;
  friendlyName?: string | null;
  description?: string | null;
  required?: boolean | null;
  defaultValue?: string | null;
}
function toSdkConfigurationProperty(root: jsonP.JSONValue): SdkConfigurationProperty {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "friendlyName": "s",
      "description": "s",
      "required": "b",
      "defaultValue": "s",
    },
  }, root);
}
