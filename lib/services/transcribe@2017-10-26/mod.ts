// Autogenerated API client for: Amazon Transcribe Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class TranscribeService {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(TranscribeService.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-10-26",
    "endpointPrefix": "transcribe",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Transcribe Service",
    "serviceId": "Transcribe",
    "signatureVersion": "v4",
    "signingName": "transcribe",
    "targetPrefix": "Transcribe",
    "uid": "transcribe-2017-10-26"
  };

  async createLanguageModel(
    {abortSignal, ...params}: RequestConfig & CreateLanguageModelRequest,
  ): Promise<CreateLanguageModelResponse> {
    const body: jsonP.JSONObject = params ? {
      LanguageCode: params["LanguageCode"],
      BaseModelName: params["BaseModelName"],
      ModelName: params["ModelName"],
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLanguageModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<CLMLanguageCode>(x),
        "BaseModelName": (x: jsonP.JSONValue) => cmnP.readEnum<BaseModelName>(x),
        "ModelName": "s",
        "InputDataConfig": toInputDataConfig,
        "ModelStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ModelStatus>(x),
      },
    }, await resp.json());
  }

  async createMedicalVocabulary(
    {abortSignal, ...params}: RequestConfig & CreateMedicalVocabularyRequest,
  ): Promise<CreateMedicalVocabularyResponse> {
    const body: jsonP.JSONObject = params ? {
      VocabularyName: params["VocabularyName"],
      LanguageCode: params["LanguageCode"],
      VocabularyFileUri: params["VocabularyFileUri"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMedicalVocabulary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VocabularyName": "s",
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
        "VocabularyState": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyState>(x),
        "LastModifiedTime": "d",
        "FailureReason": "s",
      },
    }, await resp.json());
  }

  async createVocabulary(
    {abortSignal, ...params}: RequestConfig & CreateVocabularyRequest,
  ): Promise<CreateVocabularyResponse> {
    const body: jsonP.JSONObject = params ? {
      VocabularyName: params["VocabularyName"],
      LanguageCode: params["LanguageCode"],
      Phrases: params["Phrases"],
      VocabularyFileUri: params["VocabularyFileUri"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVocabulary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VocabularyName": "s",
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
        "VocabularyState": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyState>(x),
        "LastModifiedTime": "d",
        "FailureReason": "s",
      },
    }, await resp.json());
  }

  async createVocabularyFilter(
    {abortSignal, ...params}: RequestConfig & CreateVocabularyFilterRequest,
  ): Promise<CreateVocabularyFilterResponse> {
    const body: jsonP.JSONObject = params ? {
      VocabularyFilterName: params["VocabularyFilterName"],
      LanguageCode: params["LanguageCode"],
      Words: params["Words"],
      VocabularyFilterFileUri: params["VocabularyFilterFileUri"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVocabularyFilter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VocabularyFilterName": "s",
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
        "LastModifiedTime": "d",
      },
    }, await resp.json());
  }

  async deleteLanguageModel(
    {abortSignal, ...params}: RequestConfig & DeleteLanguageModelRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ModelName: params["ModelName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLanguageModel",
    });
  }

  async deleteMedicalTranscriptionJob(
    {abortSignal, ...params}: RequestConfig & DeleteMedicalTranscriptionJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      MedicalTranscriptionJobName: params["MedicalTranscriptionJobName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMedicalTranscriptionJob",
    });
  }

  async deleteMedicalVocabulary(
    {abortSignal, ...params}: RequestConfig & DeleteMedicalVocabularyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      VocabularyName: params["VocabularyName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMedicalVocabulary",
    });
  }

  async deleteTranscriptionJob(
    {abortSignal, ...params}: RequestConfig & DeleteTranscriptionJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      TranscriptionJobName: params["TranscriptionJobName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTranscriptionJob",
    });
  }

  async deleteVocabulary(
    {abortSignal, ...params}: RequestConfig & DeleteVocabularyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      VocabularyName: params["VocabularyName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVocabulary",
    });
  }

  async deleteVocabularyFilter(
    {abortSignal, ...params}: RequestConfig & DeleteVocabularyFilterRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      VocabularyFilterName: params["VocabularyFilterName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVocabularyFilter",
    });
  }

  async describeLanguageModel(
    {abortSignal, ...params}: RequestConfig & DescribeLanguageModelRequest,
  ): Promise<DescribeLanguageModelResponse> {
    const body: jsonP.JSONObject = params ? {
      ModelName: params["ModelName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLanguageModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LanguageModel": toLanguageModel,
      },
    }, await resp.json());
  }

  async getMedicalTranscriptionJob(
    {abortSignal, ...params}: RequestConfig & GetMedicalTranscriptionJobRequest,
  ): Promise<GetMedicalTranscriptionJobResponse> {
    const body: jsonP.JSONObject = params ? {
      MedicalTranscriptionJobName: params["MedicalTranscriptionJobName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMedicalTranscriptionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MedicalTranscriptionJob": toMedicalTranscriptionJob,
      },
    }, await resp.json());
  }

  async getMedicalVocabulary(
    {abortSignal, ...params}: RequestConfig & GetMedicalVocabularyRequest,
  ): Promise<GetMedicalVocabularyResponse> {
    const body: jsonP.JSONObject = params ? {
      VocabularyName: params["VocabularyName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMedicalVocabulary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VocabularyName": "s",
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
        "VocabularyState": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyState>(x),
        "LastModifiedTime": "d",
        "FailureReason": "s",
        "DownloadUri": "s",
      },
    }, await resp.json());
  }

  async getTranscriptionJob(
    {abortSignal, ...params}: RequestConfig & GetTranscriptionJobRequest,
  ): Promise<GetTranscriptionJobResponse> {
    const body: jsonP.JSONObject = params ? {
      TranscriptionJobName: params["TranscriptionJobName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTranscriptionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TranscriptionJob": toTranscriptionJob,
      },
    }, await resp.json());
  }

  async getVocabulary(
    {abortSignal, ...params}: RequestConfig & GetVocabularyRequest,
  ): Promise<GetVocabularyResponse> {
    const body: jsonP.JSONObject = params ? {
      VocabularyName: params["VocabularyName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetVocabulary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VocabularyName": "s",
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
        "VocabularyState": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyState>(x),
        "LastModifiedTime": "d",
        "FailureReason": "s",
        "DownloadUri": "s",
      },
    }, await resp.json());
  }

  async getVocabularyFilter(
    {abortSignal, ...params}: RequestConfig & GetVocabularyFilterRequest,
  ): Promise<GetVocabularyFilterResponse> {
    const body: jsonP.JSONObject = params ? {
      VocabularyFilterName: params["VocabularyFilterName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetVocabularyFilter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VocabularyFilterName": "s",
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
        "LastModifiedTime": "d",
        "DownloadUri": "s",
      },
    }, await resp.json());
  }

  async listLanguageModels(
    {abortSignal, ...params}: RequestConfig & ListLanguageModelsRequest = {},
  ): Promise<ListLanguageModelsResponse> {
    const body: jsonP.JSONObject = params ? {
      StatusEquals: params["StatusEquals"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLanguageModels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Models": [toLanguageModel],
      },
    }, await resp.json());
  }

  async listMedicalTranscriptionJobs(
    {abortSignal, ...params}: RequestConfig & ListMedicalTranscriptionJobsRequest = {},
  ): Promise<ListMedicalTranscriptionJobsResponse> {
    const body: jsonP.JSONObject = params ? {
      Status: params["Status"],
      JobNameContains: params["JobNameContains"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMedicalTranscriptionJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<TranscriptionJobStatus>(x),
        "NextToken": "s",
        "MedicalTranscriptionJobSummaries": [toMedicalTranscriptionJobSummary],
      },
    }, await resp.json());
  }

  async listMedicalVocabularies(
    {abortSignal, ...params}: RequestConfig & ListMedicalVocabulariesRequest = {},
  ): Promise<ListMedicalVocabulariesResponse> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      StateEquals: params["StateEquals"],
      NameContains: params["NameContains"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMedicalVocabularies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyState>(x),
        "NextToken": "s",
        "Vocabularies": [toVocabularyInfo],
      },
    }, await resp.json());
  }

  async listTranscriptionJobs(
    {abortSignal, ...params}: RequestConfig & ListTranscriptionJobsRequest = {},
  ): Promise<ListTranscriptionJobsResponse> {
    const body: jsonP.JSONObject = params ? {
      Status: params["Status"],
      JobNameContains: params["JobNameContains"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTranscriptionJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<TranscriptionJobStatus>(x),
        "NextToken": "s",
        "TranscriptionJobSummaries": [toTranscriptionJobSummary],
      },
    }, await resp.json());
  }

  async listVocabularies(
    {abortSignal, ...params}: RequestConfig & ListVocabulariesRequest = {},
  ): Promise<ListVocabulariesResponse> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      StateEquals: params["StateEquals"],
      NameContains: params["NameContains"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVocabularies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyState>(x),
        "NextToken": "s",
        "Vocabularies": [toVocabularyInfo],
      },
    }, await resp.json());
  }

  async listVocabularyFilters(
    {abortSignal, ...params}: RequestConfig & ListVocabularyFiltersRequest = {},
  ): Promise<ListVocabularyFiltersResponse> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVocabularyFilters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "VocabularyFilters": [toVocabularyFilterInfo],
      },
    }, await resp.json());
  }

  async startMedicalTranscriptionJob(
    {abortSignal, ...params}: RequestConfig & StartMedicalTranscriptionJobRequest,
  ): Promise<StartMedicalTranscriptionJobResponse> {
    const body: jsonP.JSONObject = params ? {
      MedicalTranscriptionJobName: params["MedicalTranscriptionJobName"],
      LanguageCode: params["LanguageCode"],
      MediaSampleRateHertz: params["MediaSampleRateHertz"],
      MediaFormat: params["MediaFormat"],
      Media: fromMedia(params["Media"]),
      OutputBucketName: params["OutputBucketName"],
      OutputKey: params["OutputKey"],
      OutputEncryptionKMSKeyId: params["OutputEncryptionKMSKeyId"],
      Settings: fromMedicalTranscriptionSetting(params["Settings"]),
      Specialty: params["Specialty"],
      Type: params["Type"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMedicalTranscriptionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MedicalTranscriptionJob": toMedicalTranscriptionJob,
      },
    }, await resp.json());
  }

  async startTranscriptionJob(
    {abortSignal, ...params}: RequestConfig & StartTranscriptionJobRequest,
  ): Promise<StartTranscriptionJobResponse> {
    const body: jsonP.JSONObject = params ? {
      TranscriptionJobName: params["TranscriptionJobName"],
      LanguageCode: params["LanguageCode"],
      MediaSampleRateHertz: params["MediaSampleRateHertz"],
      MediaFormat: params["MediaFormat"],
      Media: fromMedia(params["Media"]),
      OutputBucketName: params["OutputBucketName"],
      OutputKey: params["OutputKey"],
      OutputEncryptionKMSKeyId: params["OutputEncryptionKMSKeyId"],
      Settings: fromSettings(params["Settings"]),
      ModelSettings: fromModelSettings(params["ModelSettings"]),
      JobExecutionSettings: fromJobExecutionSettings(params["JobExecutionSettings"]),
      ContentRedaction: fromContentRedaction(params["ContentRedaction"]),
      IdentifyLanguage: params["IdentifyLanguage"],
      LanguageOptions: params["LanguageOptions"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTranscriptionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TranscriptionJob": toTranscriptionJob,
      },
    }, await resp.json());
  }

  async updateMedicalVocabulary(
    {abortSignal, ...params}: RequestConfig & UpdateMedicalVocabularyRequest,
  ): Promise<UpdateMedicalVocabularyResponse> {
    const body: jsonP.JSONObject = params ? {
      VocabularyName: params["VocabularyName"],
      LanguageCode: params["LanguageCode"],
      VocabularyFileUri: params["VocabularyFileUri"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMedicalVocabulary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VocabularyName": "s",
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
        "LastModifiedTime": "d",
        "VocabularyState": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyState>(x),
      },
    }, await resp.json());
  }

  async updateVocabulary(
    {abortSignal, ...params}: RequestConfig & UpdateVocabularyRequest,
  ): Promise<UpdateVocabularyResponse> {
    const body: jsonP.JSONObject = params ? {
      VocabularyName: params["VocabularyName"],
      LanguageCode: params["LanguageCode"],
      Phrases: params["Phrases"],
      VocabularyFileUri: params["VocabularyFileUri"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVocabulary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VocabularyName": "s",
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
        "LastModifiedTime": "d",
        "VocabularyState": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyState>(x),
      },
    }, await resp.json());
  }

  async updateVocabularyFilter(
    {abortSignal, ...params}: RequestConfig & UpdateVocabularyFilterRequest,
  ): Promise<UpdateVocabularyFilterResponse> {
    const body: jsonP.JSONObject = params ? {
      VocabularyFilterName: params["VocabularyFilterName"],
      Words: params["Words"],
      VocabularyFilterFileUri: params["VocabularyFilterFileUri"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVocabularyFilter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VocabularyFilterName": "s",
        "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
        "LastModifiedTime": "d",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CreateLanguageModelRequest {
  LanguageCode: CLMLanguageCode;
  BaseModelName: BaseModelName;
  ModelName: string;
  InputDataConfig: InputDataConfig;
}

// refs: 1 - tags: named, input
export interface CreateMedicalVocabularyRequest {
  VocabularyName: string;
  LanguageCode: LanguageCode;
  VocabularyFileUri: string;
}

// refs: 1 - tags: named, input
export interface CreateVocabularyRequest {
  VocabularyName: string;
  LanguageCode: LanguageCode;
  Phrases?: string[] | null;
  VocabularyFileUri?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateVocabularyFilterRequest {
  VocabularyFilterName: string;
  LanguageCode: LanguageCode;
  Words?: string[] | null;
  VocabularyFilterFileUri?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteLanguageModelRequest {
  ModelName: string;
}

// refs: 1 - tags: named, input
export interface DeleteMedicalTranscriptionJobRequest {
  MedicalTranscriptionJobName: string;
}

// refs: 1 - tags: named, input
export interface DeleteMedicalVocabularyRequest {
  VocabularyName: string;
}

// refs: 1 - tags: named, input
export interface DeleteTranscriptionJobRequest {
  TranscriptionJobName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVocabularyRequest {
  VocabularyName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVocabularyFilterRequest {
  VocabularyFilterName: string;
}

// refs: 1 - tags: named, input
export interface DescribeLanguageModelRequest {
  ModelName: string;
}

// refs: 1 - tags: named, input
export interface GetMedicalTranscriptionJobRequest {
  MedicalTranscriptionJobName: string;
}

// refs: 1 - tags: named, input
export interface GetMedicalVocabularyRequest {
  VocabularyName: string;
}

// refs: 1 - tags: named, input
export interface GetTranscriptionJobRequest {
  TranscriptionJobName: string;
}

// refs: 1 - tags: named, input
export interface GetVocabularyRequest {
  VocabularyName: string;
}

// refs: 1 - tags: named, input
export interface GetVocabularyFilterRequest {
  VocabularyFilterName: string;
}

// refs: 1 - tags: named, input
export interface ListLanguageModelsRequest {
  StatusEquals?: ModelStatus | null;
  NameContains?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListMedicalTranscriptionJobsRequest {
  Status?: TranscriptionJobStatus | null;
  JobNameContains?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListMedicalVocabulariesRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  StateEquals?: VocabularyState | null;
  NameContains?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTranscriptionJobsRequest {
  Status?: TranscriptionJobStatus | null;
  JobNameContains?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListVocabulariesRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  StateEquals?: VocabularyState | null;
  NameContains?: string | null;
}

// refs: 1 - tags: named, input
export interface ListVocabularyFiltersRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  NameContains?: string | null;
}

// refs: 1 - tags: named, input
export interface StartMedicalTranscriptionJobRequest {
  MedicalTranscriptionJobName: string;
  LanguageCode: LanguageCode;
  MediaSampleRateHertz?: number | null;
  MediaFormat?: MediaFormat | null;
  Media: Media;
  OutputBucketName: string;
  OutputKey?: string | null;
  OutputEncryptionKMSKeyId?: string | null;
  Settings?: MedicalTranscriptionSetting | null;
  Specialty: Specialty;
  Type: Type;
}

// refs: 1 - tags: named, input
export interface StartTranscriptionJobRequest {
  TranscriptionJobName: string;
  LanguageCode?: LanguageCode | null;
  MediaSampleRateHertz?: number | null;
  MediaFormat?: MediaFormat | null;
  Media: Media;
  OutputBucketName?: string | null;
  OutputKey?: string | null;
  OutputEncryptionKMSKeyId?: string | null;
  Settings?: Settings | null;
  ModelSettings?: ModelSettings | null;
  JobExecutionSettings?: JobExecutionSettings | null;
  ContentRedaction?: ContentRedaction | null;
  IdentifyLanguage?: boolean | null;
  LanguageOptions?: LanguageCode[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateMedicalVocabularyRequest {
  VocabularyName: string;
  LanguageCode: LanguageCode;
  VocabularyFileUri?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateVocabularyRequest {
  VocabularyName: string;
  LanguageCode: LanguageCode;
  Phrases?: string[] | null;
  VocabularyFileUri?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateVocabularyFilterRequest {
  VocabularyFilterName: string;
  Words?: string[] | null;
  VocabularyFilterFileUri?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateLanguageModelResponse {
  LanguageCode?: CLMLanguageCode | null;
  BaseModelName?: BaseModelName | null;
  ModelName?: string | null;
  InputDataConfig?: InputDataConfig | null;
  ModelStatus?: ModelStatus | null;
}

// refs: 1 - tags: named, output
export interface CreateMedicalVocabularyResponse {
  VocabularyName?: string | null;
  LanguageCode?: LanguageCode | null;
  VocabularyState?: VocabularyState | null;
  LastModifiedTime?: Date | number | null;
  FailureReason?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateVocabularyResponse {
  VocabularyName?: string | null;
  LanguageCode?: LanguageCode | null;
  VocabularyState?: VocabularyState | null;
  LastModifiedTime?: Date | number | null;
  FailureReason?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateVocabularyFilterResponse {
  VocabularyFilterName?: string | null;
  LanguageCode?: LanguageCode | null;
  LastModifiedTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeLanguageModelResponse {
  LanguageModel?: LanguageModel | null;
}

// refs: 1 - tags: named, output
export interface GetMedicalTranscriptionJobResponse {
  MedicalTranscriptionJob?: MedicalTranscriptionJob | null;
}

// refs: 1 - tags: named, output
export interface GetMedicalVocabularyResponse {
  VocabularyName?: string | null;
  LanguageCode?: LanguageCode | null;
  VocabularyState?: VocabularyState | null;
  LastModifiedTime?: Date | number | null;
  FailureReason?: string | null;
  DownloadUri?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTranscriptionJobResponse {
  TranscriptionJob?: TranscriptionJob | null;
}

// refs: 1 - tags: named, output
export interface GetVocabularyResponse {
  VocabularyName?: string | null;
  LanguageCode?: LanguageCode | null;
  VocabularyState?: VocabularyState | null;
  LastModifiedTime?: Date | number | null;
  FailureReason?: string | null;
  DownloadUri?: string | null;
}

// refs: 1 - tags: named, output
export interface GetVocabularyFilterResponse {
  VocabularyFilterName?: string | null;
  LanguageCode?: LanguageCode | null;
  LastModifiedTime?: Date | number | null;
  DownloadUri?: string | null;
}

// refs: 1 - tags: named, output
export interface ListLanguageModelsResponse {
  NextToken?: string | null;
  Models?: LanguageModel[] | null;
}

// refs: 1 - tags: named, output
export interface ListMedicalTranscriptionJobsResponse {
  Status?: TranscriptionJobStatus | null;
  NextToken?: string | null;
  MedicalTranscriptionJobSummaries?: MedicalTranscriptionJobSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListMedicalVocabulariesResponse {
  Status?: VocabularyState | null;
  NextToken?: string | null;
  Vocabularies?: VocabularyInfo[] | null;
}

// refs: 1 - tags: named, output
export interface ListTranscriptionJobsResponse {
  Status?: TranscriptionJobStatus | null;
  NextToken?: string | null;
  TranscriptionJobSummaries?: TranscriptionJobSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListVocabulariesResponse {
  Status?: VocabularyState | null;
  NextToken?: string | null;
  Vocabularies?: VocabularyInfo[] | null;
}

// refs: 1 - tags: named, output
export interface ListVocabularyFiltersResponse {
  NextToken?: string | null;
  VocabularyFilters?: VocabularyFilterInfo[] | null;
}

// refs: 1 - tags: named, output
export interface StartMedicalTranscriptionJobResponse {
  MedicalTranscriptionJob?: MedicalTranscriptionJob | null;
}

// refs: 1 - tags: named, output
export interface StartTranscriptionJobResponse {
  TranscriptionJob?: TranscriptionJob | null;
}

// refs: 1 - tags: named, output
export interface UpdateMedicalVocabularyResponse {
  VocabularyName?: string | null;
  LanguageCode?: LanguageCode | null;
  LastModifiedTime?: Date | number | null;
  VocabularyState?: VocabularyState | null;
}

// refs: 1 - tags: named, output
export interface UpdateVocabularyResponse {
  VocabularyName?: string | null;
  LanguageCode?: LanguageCode | null;
  LastModifiedTime?: Date | number | null;
  VocabularyState?: VocabularyState | null;
}

// refs: 1 - tags: named, output
export interface UpdateVocabularyFilterResponse {
  VocabularyFilterName?: string | null;
  LanguageCode?: LanguageCode | null;
  LastModifiedTime?: Date | number | null;
}

// refs: 4 - tags: input, named, enum, output
export type CLMLanguageCode =
| "en-US"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type BaseModelName =
| "NarrowBand"
| "WideBand"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface InputDataConfig {
  S3Uri: string;
  TuningDataS3Uri?: string | null;
  DataAccessRoleArn: string;
}
function fromInputDataConfig(input?: InputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    TuningDataS3Uri: input["TuningDataS3Uri"],
    DataAccessRoleArn: input["DataAccessRoleArn"],
  }
}
function toInputDataConfig(root: jsonP.JSONValue): InputDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "DataAccessRoleArn": "s",
    },
    optional: {
      "TuningDataS3Uri": "s",
    },
  }, root);
}

// refs: 28 - tags: input, named, enum, output
export type LanguageCode =
| "af-ZA"
| "ar-AE"
| "ar-SA"
| "cy-GB"
| "da-DK"
| "de-CH"
| "de-DE"
| "en-AB"
| "en-AU"
| "en-GB"
| "en-IE"
| "en-IN"
| "en-US"
| "en-WL"
| "es-ES"
| "es-US"
| "fa-IR"
| "fr-CA"
| "fr-FR"
| "ga-IE"
| "gd-GB"
| "he-IL"
| "hi-IN"
| "id-ID"
| "it-IT"
| "ja-JP"
| "ko-KR"
| "ms-MY"
| "nl-NL"
| "pt-BR"
| "pt-PT"
| "ru-RU"
| "ta-IN"
| "te-IN"
| "tr-TR"
| "zh-CN"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type ModelStatus =
| "IN_PROGRESS"
| "FAILED"
| "COMPLETED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type TranscriptionJobStatus =
| "QUEUED"
| "IN_PROGRESS"
| "FAILED"
| "COMPLETED"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, enum, output
export type VocabularyState =
| "PENDING"
| "READY"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type MediaFormat =
| "mp3"
| "mp4"
| "wav"
| "flac"
| "ogg"
| "amr"
| "webm"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface Media {
  MediaFileUri?: string | null;
}
function fromMedia(input?: Media | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MediaFileUri: input["MediaFileUri"],
  }
}
function toMedia(root: jsonP.JSONValue): Media {
  return jsonP.readObj({
    required: {},
    optional: {
      "MediaFileUri": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MedicalTranscriptionSetting {
  ShowSpeakerLabels?: boolean | null;
  MaxSpeakerLabels?: number | null;
  ChannelIdentification?: boolean | null;
  ShowAlternatives?: boolean | null;
  MaxAlternatives?: number | null;
  VocabularyName?: string | null;
}
function fromMedicalTranscriptionSetting(input?: MedicalTranscriptionSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ShowSpeakerLabels: input["ShowSpeakerLabels"],
    MaxSpeakerLabels: input["MaxSpeakerLabels"],
    ChannelIdentification: input["ChannelIdentification"],
    ShowAlternatives: input["ShowAlternatives"],
    MaxAlternatives: input["MaxAlternatives"],
    VocabularyName: input["VocabularyName"],
  }
}
function toMedicalTranscriptionSetting(root: jsonP.JSONValue): MedicalTranscriptionSetting {
  return jsonP.readObj({
    required: {},
    optional: {
      "ShowSpeakerLabels": "b",
      "MaxSpeakerLabels": "n",
      "ChannelIdentification": "b",
      "ShowAlternatives": "b",
      "MaxAlternatives": "n",
      "VocabularyName": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type Specialty =
| "PRIMARYCARE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type Type =
| "CONVERSATION"
| "DICTATION"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface Settings {
  VocabularyName?: string | null;
  ShowSpeakerLabels?: boolean | null;
  MaxSpeakerLabels?: number | null;
  ChannelIdentification?: boolean | null;
  ShowAlternatives?: boolean | null;
  MaxAlternatives?: number | null;
  VocabularyFilterName?: string | null;
  VocabularyFilterMethod?: VocabularyFilterMethod | null;
}
function fromSettings(input?: Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VocabularyName: input["VocabularyName"],
    ShowSpeakerLabels: input["ShowSpeakerLabels"],
    MaxSpeakerLabels: input["MaxSpeakerLabels"],
    ChannelIdentification: input["ChannelIdentification"],
    ShowAlternatives: input["ShowAlternatives"],
    MaxAlternatives: input["MaxAlternatives"],
    VocabularyFilterName: input["VocabularyFilterName"],
    VocabularyFilterMethod: input["VocabularyFilterMethod"],
  }
}
function toSettings(root: jsonP.JSONValue): Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "VocabularyName": "s",
      "ShowSpeakerLabels": "b",
      "MaxSpeakerLabels": "n",
      "ChannelIdentification": "b",
      "ShowAlternatives": "b",
      "MaxAlternatives": "n",
      "VocabularyFilterName": "s",
      "VocabularyFilterMethod": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyFilterMethod>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type VocabularyFilterMethod =
| "remove"
| "mask"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface ModelSettings {
  LanguageModelName?: string | null;
}
function fromModelSettings(input?: ModelSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LanguageModelName: input["LanguageModelName"],
  }
}
function toModelSettings(root: jsonP.JSONValue): ModelSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "LanguageModelName": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface JobExecutionSettings {
  AllowDeferredExecution?: boolean | null;
  DataAccessRoleArn?: string | null;
}
function fromJobExecutionSettings(input?: JobExecutionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllowDeferredExecution: input["AllowDeferredExecution"],
    DataAccessRoleArn: input["DataAccessRoleArn"],
  }
}
function toJobExecutionSettings(root: jsonP.JSONValue): JobExecutionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AllowDeferredExecution": "b",
      "DataAccessRoleArn": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ContentRedaction {
  RedactionType: RedactionType;
  RedactionOutput: RedactionOutput;
}
function fromContentRedaction(input?: ContentRedaction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RedactionType: input["RedactionType"],
    RedactionOutput: input["RedactionOutput"],
  }
}
function toContentRedaction(root: jsonP.JSONValue): ContentRedaction {
  return jsonP.readObj({
    required: {
      "RedactionType": (x: jsonP.JSONValue) => cmnP.readEnum<RedactionType>(x),
      "RedactionOutput": (x: jsonP.JSONValue) => cmnP.readEnum<RedactionOutput>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type RedactionType =
| "PII"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type RedactionOutput =
| "redacted"
| "redacted_and_unredacted"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface LanguageModel {
  ModelName?: string | null;
  CreateTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  LanguageCode?: CLMLanguageCode | null;
  BaseModelName?: BaseModelName | null;
  ModelStatus?: ModelStatus | null;
  UpgradeAvailability?: boolean | null;
  FailureReason?: string | null;
  InputDataConfig?: InputDataConfig | null;
}
function toLanguageModel(root: jsonP.JSONValue): LanguageModel {
  return jsonP.readObj({
    required: {},
    optional: {
      "ModelName": "s",
      "CreateTime": "d",
      "LastModifiedTime": "d",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<CLMLanguageCode>(x),
      "BaseModelName": (x: jsonP.JSONValue) => cmnP.readEnum<BaseModelName>(x),
      "ModelStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ModelStatus>(x),
      "UpgradeAvailability": "b",
      "FailureReason": "s",
      "InputDataConfig": toInputDataConfig,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface MedicalTranscriptionJob {
  MedicalTranscriptionJobName?: string | null;
  TranscriptionJobStatus?: TranscriptionJobStatus | null;
  LanguageCode?: LanguageCode | null;
  MediaSampleRateHertz?: number | null;
  MediaFormat?: MediaFormat | null;
  Media?: Media | null;
  Transcript?: MedicalTranscript | null;
  StartTime?: Date | number | null;
  CreationTime?: Date | number | null;
  CompletionTime?: Date | number | null;
  FailureReason?: string | null;
  Settings?: MedicalTranscriptionSetting | null;
  Specialty?: Specialty | null;
  Type?: Type | null;
}
function toMedicalTranscriptionJob(root: jsonP.JSONValue): MedicalTranscriptionJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "MedicalTranscriptionJobName": "s",
      "TranscriptionJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TranscriptionJobStatus>(x),
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "MediaSampleRateHertz": "n",
      "MediaFormat": (x: jsonP.JSONValue) => cmnP.readEnum<MediaFormat>(x),
      "Media": toMedia,
      "Transcript": toMedicalTranscript,
      "StartTime": "d",
      "CreationTime": "d",
      "CompletionTime": "d",
      "FailureReason": "s",
      "Settings": toMedicalTranscriptionSetting,
      "Specialty": (x: jsonP.JSONValue) => cmnP.readEnum<Specialty>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<Type>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface MedicalTranscript {
  TranscriptFileUri?: string | null;
}
function toMedicalTranscript(root: jsonP.JSONValue): MedicalTranscript {
  return jsonP.readObj({
    required: {},
    optional: {
      "TranscriptFileUri": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface TranscriptionJob {
  TranscriptionJobName?: string | null;
  TranscriptionJobStatus?: TranscriptionJobStatus | null;
  LanguageCode?: LanguageCode | null;
  MediaSampleRateHertz?: number | null;
  MediaFormat?: MediaFormat | null;
  Media?: Media | null;
  Transcript?: Transcript | null;
  StartTime?: Date | number | null;
  CreationTime?: Date | number | null;
  CompletionTime?: Date | number | null;
  FailureReason?: string | null;
  Settings?: Settings | null;
  ModelSettings?: ModelSettings | null;
  JobExecutionSettings?: JobExecutionSettings | null;
  ContentRedaction?: ContentRedaction | null;
  IdentifyLanguage?: boolean | null;
  LanguageOptions?: LanguageCode[] | null;
  IdentifiedLanguageScore?: number | null;
}
function toTranscriptionJob(root: jsonP.JSONValue): TranscriptionJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "TranscriptionJobName": "s",
      "TranscriptionJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TranscriptionJobStatus>(x),
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "MediaSampleRateHertz": "n",
      "MediaFormat": (x: jsonP.JSONValue) => cmnP.readEnum<MediaFormat>(x),
      "Media": toMedia,
      "Transcript": toTranscript,
      "StartTime": "d",
      "CreationTime": "d",
      "CompletionTime": "d",
      "FailureReason": "s",
      "Settings": toSettings,
      "ModelSettings": toModelSettings,
      "JobExecutionSettings": toJobExecutionSettings,
      "ContentRedaction": toContentRedaction,
      "IdentifyLanguage": "b",
      "LanguageOptions": [(x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x)],
      "IdentifiedLanguageScore": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Transcript {
  TranscriptFileUri?: string | null;
  RedactedTranscriptFileUri?: string | null;
}
function toTranscript(root: jsonP.JSONValue): Transcript {
  return jsonP.readObj({
    required: {},
    optional: {
      "TranscriptFileUri": "s",
      "RedactedTranscriptFileUri": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MedicalTranscriptionJobSummary {
  MedicalTranscriptionJobName?: string | null;
  CreationTime?: Date | number | null;
  StartTime?: Date | number | null;
  CompletionTime?: Date | number | null;
  LanguageCode?: LanguageCode | null;
  TranscriptionJobStatus?: TranscriptionJobStatus | null;
  FailureReason?: string | null;
  OutputLocationType?: OutputLocationType | null;
  Specialty?: Specialty | null;
  Type?: Type | null;
}
function toMedicalTranscriptionJobSummary(root: jsonP.JSONValue): MedicalTranscriptionJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "MedicalTranscriptionJobName": "s",
      "CreationTime": "d",
      "StartTime": "d",
      "CompletionTime": "d",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "TranscriptionJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TranscriptionJobStatus>(x),
      "FailureReason": "s",
      "OutputLocationType": (x: jsonP.JSONValue) => cmnP.readEnum<OutputLocationType>(x),
      "Specialty": (x: jsonP.JSONValue) => cmnP.readEnum<Specialty>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<Type>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type OutputLocationType =
| "CUSTOMER_BUCKET"
| "SERVICE_BUCKET"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface VocabularyInfo {
  VocabularyName?: string | null;
  LanguageCode?: LanguageCode | null;
  LastModifiedTime?: Date | number | null;
  VocabularyState?: VocabularyState | null;
}
function toVocabularyInfo(root: jsonP.JSONValue): VocabularyInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VocabularyName": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "LastModifiedTime": "d",
      "VocabularyState": (x: jsonP.JSONValue) => cmnP.readEnum<VocabularyState>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TranscriptionJobSummary {
  TranscriptionJobName?: string | null;
  CreationTime?: Date | number | null;
  StartTime?: Date | number | null;
  CompletionTime?: Date | number | null;
  LanguageCode?: LanguageCode | null;
  TranscriptionJobStatus?: TranscriptionJobStatus | null;
  FailureReason?: string | null;
  OutputLocationType?: OutputLocationType | null;
  ContentRedaction?: ContentRedaction | null;
  ModelSettings?: ModelSettings | null;
  IdentifyLanguage?: boolean | null;
  IdentifiedLanguageScore?: number | null;
}
function toTranscriptionJobSummary(root: jsonP.JSONValue): TranscriptionJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TranscriptionJobName": "s",
      "CreationTime": "d",
      "StartTime": "d",
      "CompletionTime": "d",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "TranscriptionJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TranscriptionJobStatus>(x),
      "FailureReason": "s",
      "OutputLocationType": (x: jsonP.JSONValue) => cmnP.readEnum<OutputLocationType>(x),
      "ContentRedaction": toContentRedaction,
      "ModelSettings": toModelSettings,
      "IdentifyLanguage": "b",
      "IdentifiedLanguageScore": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VocabularyFilterInfo {
  VocabularyFilterName?: string | null;
  LanguageCode?: LanguageCode | null;
  LastModifiedTime?: Date | number | null;
}
function toVocabularyFilterInfo(root: jsonP.JSONValue): VocabularyFilterInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VocabularyFilterName": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "LastModifiedTime": "d",
    },
  }, root);
}
