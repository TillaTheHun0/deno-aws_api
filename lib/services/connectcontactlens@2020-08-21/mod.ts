// Autogenerated API client for: Amazon Connect Contact Lens

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ConnectContactLens {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ConnectContactLens.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2020-08-21",
    "endpointPrefix": "contact-lens",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "Amazon Connect Contact Lens",
    "serviceFullName": "Amazon Connect Contact Lens",
    "serviceId": "Connect Contact Lens",
    "signatureVersion": "v4",
    "signingName": "connect",
    "uid": "connect-contact-lens-2020-08-21"
  };

  async listRealtimeContactAnalysisSegments(
    {abortSignal, ...params}: RequestConfig & s.ListRealtimeContactAnalysisSegmentsRequest,
  ): Promise<s.ListRealtimeContactAnalysisSegmentsResponse> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      ContactId: params["ContactId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRealtimeContactAnalysisSegments",
      requestUri: "/realtime-contact-analysis/analysis-segments",
    });
    return jsonP.readObj({
      required: {
        "Segments": [toRealtimeContactAnalysisSegment],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

}

function toRealtimeContactAnalysisSegment(root: jsonP.JSONValue): s.RealtimeContactAnalysisSegment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Transcript": toTranscript,
      "Categories": toCategories,
    },
  }, root);
}

function toTranscript(root: jsonP.JSONValue): s.Transcript {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "ParticipantId": "s",
      "ParticipantRole": "s",
      "Content": "s",
      "BeginOffsetMillis": "n",
      "EndOffsetMillis": "n",
      "Sentiment": (x: jsonP.JSONValue) => cmnP.readEnum<s.SentimentValue>(x),
    },
    optional: {
      "IssuesDetected": [toIssueDetected],
    },
  }, root);
}

function toIssueDetected(root: jsonP.JSONValue): s.IssueDetected {
  return jsonP.readObj({
    required: {
      "CharacterOffsets": toCharacterOffsets,
    },
    optional: {},
  }, root);
}

function toCharacterOffsets(root: jsonP.JSONValue): s.CharacterOffsets {
  return jsonP.readObj({
    required: {
      "BeginOffsetChar": "n",
      "EndOffsetChar": "n",
    },
    optional: {},
  }, root);
}

function toCategories(root: jsonP.JSONValue): s.Categories {
  return jsonP.readObj({
    required: {
      "MatchedCategories": ["s"],
      "MatchedDetails": x => jsonP.readMap(String, toCategoryDetails, x),
    },
    optional: {},
  }, root);
}

function toCategoryDetails(root: jsonP.JSONValue): s.CategoryDetails {
  return jsonP.readObj({
    required: {
      "PointsOfInterest": [toPointOfInterest],
    },
    optional: {},
  }, root);
}

function toPointOfInterest(root: jsonP.JSONValue): s.PointOfInterest {
  return jsonP.readObj({
    required: {
      "BeginOffsetMillis": "n",
      "EndOffsetMillis": "n",
    },
    optional: {},
  }, root);
}
