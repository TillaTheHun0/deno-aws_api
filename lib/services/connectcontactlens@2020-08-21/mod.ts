// Autogenerated API client for: Amazon Connect Contact Lens

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ConnectContactLens {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ConnectContactLens.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2020-08-21",
    "endpointPrefix": "contact-lens",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "Amazon Connect Contact Lens",
    "serviceFullName": "Amazon Connect Contact Lens",
    "serviceId": "Connect Contact Lens",
    "signatureVersion": "v4",
    "signingName": "connect",
    "uid": "connect-contact-lens-2020-08-21"
  };

  async listRealtimeContactAnalysisSegments(
    {abortSignal, ...params}: RequestConfig & ListRealtimeContactAnalysisSegmentsRequest,
  ): Promise<ListRealtimeContactAnalysisSegmentsResponse> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      ContactId: params["ContactId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRealtimeContactAnalysisSegments",
      requestUri: "/realtime-contact-analysis/analysis-segments",
    });
    return jsonP.readObj({
      required: {
        "Segments": [toRealtimeContactAnalysisSegment],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface ListRealtimeContactAnalysisSegmentsRequest {
  InstanceId: string;
  ContactId: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRealtimeContactAnalysisSegmentsResponse {
  Segments: RealtimeContactAnalysisSegment[];
  NextToken?: string | null;
}

// refs: 1 - tags: output, named, interface
export interface RealtimeContactAnalysisSegment {
  Transcript?: Transcript | null;
  Categories?: Categories | null;
}
function toRealtimeContactAnalysisSegment(root: jsonP.JSONValue): RealtimeContactAnalysisSegment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Transcript": toTranscript,
      "Categories": toCategories,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Transcript {
  Id: string;
  ParticipantId: string;
  ParticipantRole: string;
  Content: string;
  BeginOffsetMillis: number;
  EndOffsetMillis: number;
  Sentiment: SentimentValue;
  IssuesDetected?: IssueDetected[] | null;
}
function toTranscript(root: jsonP.JSONValue): Transcript {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "ParticipantId": "s",
      "ParticipantRole": "s",
      "Content": "s",
      "BeginOffsetMillis": "n",
      "EndOffsetMillis": "n",
      "Sentiment": (x: jsonP.JSONValue) => cmnP.readEnum<SentimentValue>(x),
    },
    optional: {
      "IssuesDetected": [toIssueDetected],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type SentimentValue =
| "POSITIVE"
| "NEUTRAL"
| "NEGATIVE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface IssueDetected {
  CharacterOffsets: CharacterOffsets;
}
function toIssueDetected(root: jsonP.JSONValue): IssueDetected {
  return jsonP.readObj({
    required: {
      "CharacterOffsets": toCharacterOffsets,
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CharacterOffsets {
  BeginOffsetChar: number;
  EndOffsetChar: number;
}
function toCharacterOffsets(root: jsonP.JSONValue): CharacterOffsets {
  return jsonP.readObj({
    required: {
      "BeginOffsetChar": "n",
      "EndOffsetChar": "n",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Categories {
  MatchedCategories: string[];
  MatchedDetails: { [key: string]: CategoryDetails | null | undefined };
}
function toCategories(root: jsonP.JSONValue): Categories {
  return jsonP.readObj({
    required: {
      "MatchedCategories": ["s"],
      "MatchedDetails": x => jsonP.readMap(String, toCategoryDetails, x),
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CategoryDetails {
  PointsOfInterest: PointOfInterest[];
}
function toCategoryDetails(root: jsonP.JSONValue): CategoryDetails {
  return jsonP.readObj({
    required: {
      "PointsOfInterest": [toPointOfInterest],
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PointOfInterest {
  BeginOffsetMillis: number;
  EndOffsetMillis: number;
}
function toPointOfInterest(root: jsonP.JSONValue): PointOfInterest {
  return jsonP.readObj({
    required: {
      "BeginOffsetMillis": "n",
      "EndOffsetMillis": "n",
    },
    optional: {},
  }, root);
}
