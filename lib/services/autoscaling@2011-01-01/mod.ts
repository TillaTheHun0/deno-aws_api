// Autogenerated API client for: Auto Scaling

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export default class AutoScaling {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AutoScaling.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2011-01-01",
    "endpointPrefix": "autoscaling",
    "protocol": "query",
    "serviceFullName": "Auto Scaling",
    "serviceId": "Auto Scaling",
    "signatureVersion": "v4",
    "uid": "autoscaling-2011-01-01",
    "xmlNamespace": "http://autoscaling.amazonaws.com/doc/2011-01-01/"
  };

  async attachInstances(
    {abortSignal, ...params}: RequestConfig & s.AttachInstancesQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachInstances",
    });
    await resp.text();
  }

  async attachLoadBalancerTargetGroups(
    {abortSignal, ...params}: RequestConfig & s.AttachLoadBalancerTargetGroupsType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["TargetGroupARNs"]) qsP.appendList(body, prefix+"TargetGroupARNs", params["TargetGroupARNs"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachLoadBalancerTargetGroups",
    });
    await resp.text();
  }

  async attachLoadBalancers(
    {abortSignal, ...params}: RequestConfig & s.AttachLoadBalancersType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["LoadBalancerNames"]) qsP.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachLoadBalancers",
    });
    await resp.text();
  }

  async batchDeleteScheduledAction(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteScheduledActionType,
  ): Promise<s.BatchDeleteScheduledActionAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScheduledActionNames"]) qsP.appendList(body, prefix+"ScheduledActionNames", params["ScheduledActionNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteScheduledAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchDeleteScheduledActionResult");
    return {
      FailedScheduledActions: xml.getList("FailedScheduledActions", "member").map(FailedScheduledUpdateGroupActionRequest_Parse),
    };
  }

  async batchPutScheduledUpdateGroupAction(
    {abortSignal, ...params}: RequestConfig & s.BatchPutScheduledUpdateGroupActionType,
  ): Promise<s.BatchPutScheduledUpdateGroupActionAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScheduledUpdateGroupActions"]) qsP.appendList(body, prefix+"ScheduledUpdateGroupActions", params["ScheduledUpdateGroupActions"], {"appender":ScheduledUpdateGroupActionRequest_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchPutScheduledUpdateGroupAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchPutScheduledUpdateGroupActionResult");
    return {
      FailedScheduledUpdateGroupActions: xml.getList("FailedScheduledUpdateGroupActions", "member").map(FailedScheduledUpdateGroupActionRequest_Parse),
    };
  }

  async cancelInstanceRefresh(
    {abortSignal, ...params}: RequestConfig & s.CancelInstanceRefreshType,
  ): Promise<s.CancelInstanceRefreshAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelInstanceRefresh",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CancelInstanceRefreshResult");
    return xml.strings({
      optional: {"InstanceRefreshId":true},
    });
  }

  async completeLifecycleAction(
    {abortSignal, ...params}: RequestConfig & s.CompleteLifecycleActionType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LifecycleActionToken" in params) body.append(prefix+"LifecycleActionToken", (params["LifecycleActionToken"] ?? '').toString());
    body.append(prefix+"LifecycleActionResult", (params["LifecycleActionResult"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CompleteLifecycleAction",
    });
    await resp.text();
  }

  async createAutoScalingGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateAutoScalingGroupType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LaunchConfigurationName" in params) body.append(prefix+"LaunchConfigurationName", (params["LaunchConfigurationName"] ?? '').toString());
    if (params["LaunchTemplate"] != null) LaunchTemplateSpecification_Serialize(body, prefix+"LaunchTemplate", params["LaunchTemplate"]);
    if (params["MixedInstancesPolicy"] != null) MixedInstancesPolicy_Serialize(body, prefix+"MixedInstancesPolicy", params["MixedInstancesPolicy"]);
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"MinSize", (params["MinSize"] ?? '').toString());
    body.append(prefix+"MaxSize", (params["MaxSize"] ?? '').toString());
    if ("DesiredCapacity" in params) body.append(prefix+"DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
    if ("DefaultCooldown" in params) body.append(prefix+"DefaultCooldown", (params["DefaultCooldown"] ?? '').toString());
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".member."})
    if (params["LoadBalancerNames"]) qsP.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    if (params["TargetGroupARNs"]) qsP.appendList(body, prefix+"TargetGroupARNs", params["TargetGroupARNs"], {"entryPrefix":".member."})
    if ("HealthCheckType" in params) body.append(prefix+"HealthCheckType", (params["HealthCheckType"] ?? '').toString());
    if ("HealthCheckGracePeriod" in params) body.append(prefix+"HealthCheckGracePeriod", (params["HealthCheckGracePeriod"] ?? '').toString());
    if ("PlacementGroup" in params) body.append(prefix+"PlacementGroup", (params["PlacementGroup"] ?? '').toString());
    if ("VPCZoneIdentifier" in params) body.append(prefix+"VPCZoneIdentifier", (params["VPCZoneIdentifier"] ?? '').toString());
    if (params["TerminationPolicies"]) qsP.appendList(body, prefix+"TerminationPolicies", params["TerminationPolicies"], {"entryPrefix":".member."})
    if ("NewInstancesProtectedFromScaleIn" in params) body.append(prefix+"NewInstancesProtectedFromScaleIn", (params["NewInstancesProtectedFromScaleIn"] ?? '').toString());
    if ("CapacityRebalance" in params) body.append(prefix+"CapacityRebalance", (params["CapacityRebalance"] ?? '').toString());
    if (params["LifecycleHookSpecificationList"]) qsP.appendList(body, prefix+"LifecycleHookSpecificationList", params["LifecycleHookSpecificationList"], {"appender":LifecycleHookSpecification_Serialize,"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("ServiceLinkedRoleARN" in params) body.append(prefix+"ServiceLinkedRoleARN", (params["ServiceLinkedRoleARN"] ?? '').toString());
    if ("MaxInstanceLifetime" in params) body.append(prefix+"MaxInstanceLifetime", (params["MaxInstanceLifetime"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAutoScalingGroup",
    });
    await resp.text();
  }

  async createLaunchConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateLaunchConfigurationType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LaunchConfigurationName", (params["LaunchConfigurationName"] ?? '').toString());
    if ("ImageId" in params) body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+"SecurityGroups", params["SecurityGroups"], {"entryPrefix":".member."})
    if ("ClassicLinkVPCId" in params) body.append(prefix+"ClassicLinkVPCId", (params["ClassicLinkVPCId"] ?? '').toString());
    if (params["ClassicLinkVPCSecurityGroups"]) qsP.appendList(body, prefix+"ClassicLinkVPCSecurityGroups", params["ClassicLinkVPCSecurityGroups"], {"entryPrefix":".member."})
    if ("UserData" in params) body.append(prefix+"UserData", (params["UserData"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+"KernelId", (params["KernelId"] ?? '').toString());
    if ("RamdiskId" in params) body.append(prefix+"RamdiskId", (params["RamdiskId"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"BlockDeviceMappings", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":".member."})
    if (params["InstanceMonitoring"] != null) InstanceMonitoring_Serialize(body, prefix+"InstanceMonitoring", params["InstanceMonitoring"]);
    if ("SpotPrice" in params) body.append(prefix+"SpotPrice", (params["SpotPrice"] ?? '').toString());
    if ("IamInstanceProfile" in params) body.append(prefix+"IamInstanceProfile", (params["IamInstanceProfile"] ?? '').toString());
    if ("EbsOptimized" in params) body.append(prefix+"EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if ("AssociatePublicIpAddress" in params) body.append(prefix+"AssociatePublicIpAddress", (params["AssociatePublicIpAddress"] ?? '').toString());
    if ("PlacementTenancy" in params) body.append(prefix+"PlacementTenancy", (params["PlacementTenancy"] ?? '').toString());
    if (params["MetadataOptions"] != null) InstanceMetadataOptions_Serialize(body, prefix+"MetadataOptions", params["MetadataOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLaunchConfiguration",
    });
    await resp.text();
  }

  async createOrUpdateTags(
    {abortSignal, ...params}: RequestConfig & s.CreateOrUpdateTagsType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOrUpdateTags",
    });
    await resp.text();
  }

  async deleteAutoScalingGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteAutoScalingGroupType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("ForceDelete" in params) body.append(prefix+"ForceDelete", (params["ForceDelete"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAutoScalingGroup",
    });
    await resp.text();
  }

  async deleteLaunchConfiguration(
    {abortSignal, ...params}: RequestConfig & s.LaunchConfigurationNameType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LaunchConfigurationName", (params["LaunchConfigurationName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLaunchConfiguration",
    });
    await resp.text();
  }

  async deleteLifecycleHook(
    {abortSignal, ...params}: RequestConfig & s.DeleteLifecycleHookType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLifecycleHook",
    });
    await resp.text();
  }

  async deleteNotificationConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteNotificationConfigurationType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"TopicARN", (params["TopicARN"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNotificationConfiguration",
    });
    await resp.text();
  }

  async deletePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeletePolicyType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePolicy",
    });
    await resp.text();
  }

  async deleteScheduledAction(
    {abortSignal, ...params}: RequestConfig & s.DeleteScheduledActionType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteScheduledAction",
    });
    await resp.text();
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & s.DeleteTagsType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
    await resp.text();
  }

  async describeAccountLimits(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeAccountLimitsAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAccountLimits",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAccountLimitsResult");
    return {
      MaxNumberOfAutoScalingGroups: xml.first("MaxNumberOfAutoScalingGroups", false, x => parseInt(x.content ?? '0')),
      MaxNumberOfLaunchConfigurations: xml.first("MaxNumberOfLaunchConfigurations", false, x => parseInt(x.content ?? '0')),
      NumberOfAutoScalingGroups: xml.first("NumberOfAutoScalingGroups", false, x => parseInt(x.content ?? '0')),
      NumberOfLaunchConfigurations: xml.first("NumberOfLaunchConfigurations", false, x => parseInt(x.content ?? '0')),
    };
  }

  async describeAdjustmentTypes(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeAdjustmentTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAdjustmentTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAdjustmentTypesResult");
    return {
      AdjustmentTypes: xml.getList("AdjustmentTypes", "member").map(AdjustmentType_Parse),
    };
  }

  async describeAutoScalingGroups(
    {abortSignal, ...params}: RequestConfig & s.AutoScalingGroupNamesType = {},
  ): Promise<s.AutoScalingGroupsType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AutoScalingGroupNames"]) qsP.appendList(body, prefix+"AutoScalingGroupNames", params["AutoScalingGroupNames"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAutoScalingGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAutoScalingGroupsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AutoScalingGroups: xml.getList("AutoScalingGroups", "member").map(AutoScalingGroup_Parse),
    };
  }

  async describeAutoScalingInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeAutoScalingInstancesType = {},
  ): Promise<s.AutoScalingInstancesType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAutoScalingInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAutoScalingInstancesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AutoScalingInstances: xml.getList("AutoScalingInstances", "member").map(AutoScalingInstanceDetails_Parse),
    };
  }

  async describeAutoScalingNotificationTypes(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeAutoScalingNotificationTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAutoScalingNotificationTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAutoScalingNotificationTypesResult");
    return {
      AutoScalingNotificationTypes: xml.getList("AutoScalingNotificationTypes", "member").map(x => x.content ?? ''),
    };
  }

  async describeInstanceRefreshes(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstanceRefreshesType,
  ): Promise<s.DescribeInstanceRefreshesAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["InstanceRefreshIds"]) qsP.appendList(body, prefix+"InstanceRefreshIds", params["InstanceRefreshIds"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceRefreshes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeInstanceRefreshesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      InstanceRefreshes: xml.getList("InstanceRefreshes", "member").map(InstanceRefresh_Parse),
    };
  }

  async describeLaunchConfigurations(
    {abortSignal, ...params}: RequestConfig & s.LaunchConfigurationNamesType = {},
  ): Promise<s.LaunchConfigurationsType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LaunchConfigurationNames"]) qsP.appendList(body, prefix+"LaunchConfigurationNames", params["LaunchConfigurationNames"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLaunchConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLaunchConfigurationsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      LaunchConfigurations: xml.getList("LaunchConfigurations", "member").map(LaunchConfiguration_Parse),
    };
  }

  async describeLifecycleHookTypes(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeLifecycleHookTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeLifecycleHookTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLifecycleHookTypesResult");
    return {
      LifecycleHookTypes: xml.getList("LifecycleHookTypes", "member").map(x => x.content ?? ''),
    };
  }

  async describeLifecycleHooks(
    {abortSignal, ...params}: RequestConfig & s.DescribeLifecycleHooksType,
  ): Promise<s.DescribeLifecycleHooksAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["LifecycleHookNames"]) qsP.appendList(body, prefix+"LifecycleHookNames", params["LifecycleHookNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLifecycleHooks",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLifecycleHooksResult");
    return {
      LifecycleHooks: xml.getList("LifecycleHooks", "member").map(LifecycleHook_Parse),
    };
  }

  async describeLoadBalancerTargetGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeLoadBalancerTargetGroupsRequest,
  ): Promise<s.DescribeLoadBalancerTargetGroupsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancerTargetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLoadBalancerTargetGroupsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      LoadBalancerTargetGroups: xml.getList("LoadBalancerTargetGroups", "member").map(LoadBalancerTargetGroupState_Parse),
    };
  }

  async describeLoadBalancers(
    {abortSignal, ...params}: RequestConfig & s.DescribeLoadBalancersRequest,
  ): Promise<s.DescribeLoadBalancersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancers",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLoadBalancersResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      LoadBalancers: xml.getList("LoadBalancers", "member").map(LoadBalancerState_Parse),
    };
  }

  async describeMetricCollectionTypes(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeMetricCollectionTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeMetricCollectionTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeMetricCollectionTypesResult");
    return {
      Metrics: xml.getList("Metrics", "member").map(MetricCollectionType_Parse),
      Granularities: xml.getList("Granularities", "member").map(MetricGranularityType_Parse),
    };
  }

  async describeNotificationConfigurations(
    {abortSignal, ...params}: RequestConfig & s.DescribeNotificationConfigurationsType = {},
  ): Promise<s.DescribeNotificationConfigurationsAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AutoScalingGroupNames"]) qsP.appendList(body, prefix+"AutoScalingGroupNames", params["AutoScalingGroupNames"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotificationConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeNotificationConfigurationsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      NotificationConfigurations: xml.getList("NotificationConfigurations", "member").map(NotificationConfiguration_Parse),
    };
  }

  async describePolicies(
    {abortSignal, ...params}: RequestConfig & s.DescribePoliciesType = {},
  ): Promise<s.PoliciesType> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["PolicyNames"]) qsP.appendList(body, prefix+"PolicyNames", params["PolicyNames"], {"entryPrefix":".member."})
    if (params["PolicyTypes"]) qsP.appendList(body, prefix+"PolicyTypes", params["PolicyTypes"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribePoliciesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      ScalingPolicies: xml.getList("ScalingPolicies", "member").map(ScalingPolicy_Parse),
    };
  }

  async describeScalingActivities(
    {abortSignal, ...params}: RequestConfig & s.DescribeScalingActivitiesType = {},
  ): Promise<s.ActivitiesType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ActivityIds"]) qsP.appendList(body, prefix+"ActivityIds", params["ActivityIds"], {"entryPrefix":".member."})
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("IncludeDeletedGroups" in params) body.append(prefix+"IncludeDeletedGroups", (params["IncludeDeletedGroups"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScalingActivities",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeScalingActivitiesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Activities: xml.getList("Activities", "member").map(Activity_Parse),
    };
  }

  async describeScalingProcessTypes(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.ProcessesType> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeScalingProcessTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeScalingProcessTypesResult");
    return {
      Processes: xml.getList("Processes", "member").map(ProcessType_Parse),
    };
  }

  async describeScheduledActions(
    {abortSignal, ...params}: RequestConfig & s.DescribeScheduledActionsType = {},
  ): Promise<s.ScheduledActionsType> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScheduledActionNames"]) qsP.appendList(body, prefix+"ScheduledActionNames", params["ScheduledActionNames"], {"entryPrefix":".member."})
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScheduledActions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeScheduledActionsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      ScheduledUpdateGroupActions: xml.getList("ScheduledUpdateGroupActions", "member").map(ScheduledUpdateGroupAction_Parse),
    };
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & s.DescribeTagsType = {},
  ): Promise<s.TagsType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTagsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Tags: xml.getList("Tags", "member").map(TagDescription_Parse),
    };
  }

  async describeTerminationPolicyTypes(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeTerminationPolicyTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeTerminationPolicyTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTerminationPolicyTypesResult");
    return {
      TerminationPolicyTypes: xml.getList("TerminationPolicyTypes", "member").map(x => x.content ?? ''),
    };
  }

  async detachInstances(
    {abortSignal, ...params}: RequestConfig & s.DetachInstancesQuery,
  ): Promise<s.DetachInstancesAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ShouldDecrementDesiredCapacity", (params["ShouldDecrementDesiredCapacity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetachInstancesResult");
    return {
      Activities: xml.getList("Activities", "member").map(Activity_Parse),
    };
  }

  async detachLoadBalancerTargetGroups(
    {abortSignal, ...params}: RequestConfig & s.DetachLoadBalancerTargetGroupsType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["TargetGroupARNs"]) qsP.appendList(body, prefix+"TargetGroupARNs", params["TargetGroupARNs"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachLoadBalancerTargetGroups",
    });
    await resp.text();
  }

  async detachLoadBalancers(
    {abortSignal, ...params}: RequestConfig & s.DetachLoadBalancersType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["LoadBalancerNames"]) qsP.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachLoadBalancers",
    });
    await resp.text();
  }

  async disableMetricsCollection(
    {abortSignal, ...params}: RequestConfig & s.DisableMetricsCollectionQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["Metrics"]) qsP.appendList(body, prefix+"Metrics", params["Metrics"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableMetricsCollection",
    });
    await resp.text();
  }

  async enableMetricsCollection(
    {abortSignal, ...params}: RequestConfig & s.EnableMetricsCollectionQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["Metrics"]) qsP.appendList(body, prefix+"Metrics", params["Metrics"], {"entryPrefix":".member."})
    body.append(prefix+"Granularity", (params["Granularity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableMetricsCollection",
    });
    await resp.text();
  }

  async enterStandby(
    {abortSignal, ...params}: RequestConfig & s.EnterStandbyQuery,
  ): Promise<s.EnterStandbyAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ShouldDecrementDesiredCapacity", (params["ShouldDecrementDesiredCapacity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnterStandby",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EnterStandbyResult");
    return {
      Activities: xml.getList("Activities", "member").map(Activity_Parse),
    };
  }

  async executePolicy(
    {abortSignal, ...params}: RequestConfig & s.ExecutePolicyType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    if ("HonorCooldown" in params) body.append(prefix+"HonorCooldown", (params["HonorCooldown"] ?? '').toString());
    if ("MetricValue" in params) body.append(prefix+"MetricValue", (params["MetricValue"] ?? '').toString());
    if ("BreachThreshold" in params) body.append(prefix+"BreachThreshold", (params["BreachThreshold"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExecutePolicy",
    });
    await resp.text();
  }

  async exitStandby(
    {abortSignal, ...params}: RequestConfig & s.ExitStandbyQuery,
  ): Promise<s.ExitStandbyAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExitStandby",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ExitStandbyResult");
    return {
      Activities: xml.getList("Activities", "member").map(Activity_Parse),
    };
  }

  async putLifecycleHook(
    {abortSignal, ...params}: RequestConfig & s.PutLifecycleHookType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LifecycleTransition" in params) body.append(prefix+"LifecycleTransition", (params["LifecycleTransition"] ?? '').toString());
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if ("NotificationTargetARN" in params) body.append(prefix+"NotificationTargetARN", (params["NotificationTargetARN"] ?? '').toString());
    if ("NotificationMetadata" in params) body.append(prefix+"NotificationMetadata", (params["NotificationMetadata"] ?? '').toString());
    if ("HeartbeatTimeout" in params) body.append(prefix+"HeartbeatTimeout", (params["HeartbeatTimeout"] ?? '').toString());
    if ("DefaultResult" in params) body.append(prefix+"DefaultResult", (params["DefaultResult"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLifecycleHook",
    });
    await resp.text();
  }

  async putNotificationConfiguration(
    {abortSignal, ...params}: RequestConfig & s.PutNotificationConfigurationType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"TopicARN", (params["TopicARN"] ?? '').toString());
    if (params["NotificationTypes"]) qsP.appendList(body, prefix+"NotificationTypes", params["NotificationTypes"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutNotificationConfiguration",
    });
    await resp.text();
  }

  async putScalingPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutScalingPolicyType,
  ): Promise<s.PolicyARNType> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    if ("PolicyType" in params) body.append(prefix+"PolicyType", (params["PolicyType"] ?? '').toString());
    if ("AdjustmentType" in params) body.append(prefix+"AdjustmentType", (params["AdjustmentType"] ?? '').toString());
    if ("MinAdjustmentStep" in params) body.append(prefix+"MinAdjustmentStep", (params["MinAdjustmentStep"] ?? '').toString());
    if ("MinAdjustmentMagnitude" in params) body.append(prefix+"MinAdjustmentMagnitude", (params["MinAdjustmentMagnitude"] ?? '').toString());
    if ("ScalingAdjustment" in params) body.append(prefix+"ScalingAdjustment", (params["ScalingAdjustment"] ?? '').toString());
    if ("Cooldown" in params) body.append(prefix+"Cooldown", (params["Cooldown"] ?? '').toString());
    if ("MetricAggregationType" in params) body.append(prefix+"MetricAggregationType", (params["MetricAggregationType"] ?? '').toString());
    if (params["StepAdjustments"]) qsP.appendList(body, prefix+"StepAdjustments", params["StepAdjustments"], {"appender":StepAdjustment_Serialize,"entryPrefix":".member."})
    if ("EstimatedInstanceWarmup" in params) body.append(prefix+"EstimatedInstanceWarmup", (params["EstimatedInstanceWarmup"] ?? '').toString());
    if (params["TargetTrackingConfiguration"] != null) TargetTrackingConfiguration_Serialize(body, prefix+"TargetTrackingConfiguration", params["TargetTrackingConfiguration"]);
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutScalingPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PutScalingPolicyResult");
    return {
      ...xml.strings({
        optional: {"PolicyARN":true},
      }),
      Alarms: xml.getList("Alarms", "member").map(Alarm_Parse),
    };
  }

  async putScheduledUpdateGroupAction(
    {abortSignal, ...params}: RequestConfig & s.PutScheduledUpdateGroupActionType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    if ("Time" in params) body.append(prefix+"Time", qsP.encodeDate_iso8601(params["Time"]));
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Recurrence" in params) body.append(prefix+"Recurrence", (params["Recurrence"] ?? '').toString());
    if ("MinSize" in params) body.append(prefix+"MinSize", (params["MinSize"] ?? '').toString());
    if ("MaxSize" in params) body.append(prefix+"MaxSize", (params["MaxSize"] ?? '').toString());
    if ("DesiredCapacity" in params) body.append(prefix+"DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
    if ("TimeZone" in params) body.append(prefix+"TimeZone", (params["TimeZone"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutScheduledUpdateGroupAction",
    });
    await resp.text();
  }

  async recordLifecycleActionHeartbeat(
    {abortSignal, ...params}: RequestConfig & s.RecordLifecycleActionHeartbeatType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LifecycleActionToken" in params) body.append(prefix+"LifecycleActionToken", (params["LifecycleActionToken"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RecordLifecycleActionHeartbeat",
    });
    await resp.text();
  }

  async resumeProcesses(
    {abortSignal, ...params}: RequestConfig & s.ScalingProcessQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScalingProcesses"]) qsP.appendList(body, prefix+"ScalingProcesses", params["ScalingProcesses"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResumeProcesses",
    });
    await resp.text();
  }

  async setDesiredCapacity(
    {abortSignal, ...params}: RequestConfig & s.SetDesiredCapacityType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
    if ("HonorCooldown" in params) body.append(prefix+"HonorCooldown", (params["HonorCooldown"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetDesiredCapacity",
    });
    await resp.text();
  }

  async setInstanceHealth(
    {abortSignal, ...params}: RequestConfig & s.SetInstanceHealthQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"HealthStatus", (params["HealthStatus"] ?? '').toString());
    if ("ShouldRespectGracePeriod" in params) body.append(prefix+"ShouldRespectGracePeriod", (params["ShouldRespectGracePeriod"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetInstanceHealth",
    });
    await resp.text();
  }

  async setInstanceProtection(
    {abortSignal, ...params}: RequestConfig & s.SetInstanceProtectionQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ProtectedFromScaleIn", (params["ProtectedFromScaleIn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetInstanceProtection",
    });
    await resp.text();
  }

  async startInstanceRefresh(
    {abortSignal, ...params}: RequestConfig & s.StartInstanceRefreshType,
  ): Promise<s.StartInstanceRefreshAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("Strategy" in params) body.append(prefix+"Strategy", (params["Strategy"] ?? '').toString());
    if (params["Preferences"] != null) RefreshPreferences_Serialize(body, prefix+"Preferences", params["Preferences"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartInstanceRefresh",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "StartInstanceRefreshResult");
    return xml.strings({
      optional: {"InstanceRefreshId":true},
    });
  }

  async suspendProcesses(
    {abortSignal, ...params}: RequestConfig & s.ScalingProcessQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScalingProcesses"]) qsP.appendList(body, prefix+"ScalingProcesses", params["ScalingProcesses"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SuspendProcesses",
    });
    await resp.text();
  }

  async terminateInstanceInAutoScalingGroup(
    {abortSignal, ...params}: RequestConfig & s.TerminateInstanceInAutoScalingGroupType,
  ): Promise<s.ActivityType> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"ShouldDecrementDesiredCapacity", (params["ShouldDecrementDesiredCapacity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateInstanceInAutoScalingGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "TerminateInstanceInAutoScalingGroupResult");
    return {
      Activity: xml.first("Activity", false, Activity_Parse),
    };
  }

  async updateAutoScalingGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateAutoScalingGroupType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LaunchConfigurationName" in params) body.append(prefix+"LaunchConfigurationName", (params["LaunchConfigurationName"] ?? '').toString());
    if (params["LaunchTemplate"] != null) LaunchTemplateSpecification_Serialize(body, prefix+"LaunchTemplate", params["LaunchTemplate"]);
    if (params["MixedInstancesPolicy"] != null) MixedInstancesPolicy_Serialize(body, prefix+"MixedInstancesPolicy", params["MixedInstancesPolicy"]);
    if ("MinSize" in params) body.append(prefix+"MinSize", (params["MinSize"] ?? '').toString());
    if ("MaxSize" in params) body.append(prefix+"MaxSize", (params["MaxSize"] ?? '').toString());
    if ("DesiredCapacity" in params) body.append(prefix+"DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
    if ("DefaultCooldown" in params) body.append(prefix+"DefaultCooldown", (params["DefaultCooldown"] ?? '').toString());
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".member."})
    if ("HealthCheckType" in params) body.append(prefix+"HealthCheckType", (params["HealthCheckType"] ?? '').toString());
    if ("HealthCheckGracePeriod" in params) body.append(prefix+"HealthCheckGracePeriod", (params["HealthCheckGracePeriod"] ?? '').toString());
    if ("PlacementGroup" in params) body.append(prefix+"PlacementGroup", (params["PlacementGroup"] ?? '').toString());
    if ("VPCZoneIdentifier" in params) body.append(prefix+"VPCZoneIdentifier", (params["VPCZoneIdentifier"] ?? '').toString());
    if (params["TerminationPolicies"]) qsP.appendList(body, prefix+"TerminationPolicies", params["TerminationPolicies"], {"entryPrefix":".member."})
    if ("NewInstancesProtectedFromScaleIn" in params) body.append(prefix+"NewInstancesProtectedFromScaleIn", (params["NewInstancesProtectedFromScaleIn"] ?? '').toString());
    if ("ServiceLinkedRoleARN" in params) body.append(prefix+"ServiceLinkedRoleARN", (params["ServiceLinkedRoleARN"] ?? '').toString());
    if ("MaxInstanceLifetime" in params) body.append(prefix+"MaxInstanceLifetime", (params["MaxInstanceLifetime"] ?? '').toString());
    if ("CapacityRebalance" in params) body.append(prefix+"CapacityRebalance", (params["CapacityRebalance"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAutoScalingGroup",
    });
    await resp.text();
  }

}

function ScheduledUpdateGroupActionRequest_Serialize(body: URLSearchParams, prefix: string, params: s.ScheduledUpdateGroupActionRequest) {
    body.append(prefix+".ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+".StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+".EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Recurrence" in params) body.append(prefix+".Recurrence", (params["Recurrence"] ?? '').toString());
    if ("MinSize" in params) body.append(prefix+".MinSize", (params["MinSize"] ?? '').toString());
    if ("MaxSize" in params) body.append(prefix+".MaxSize", (params["MaxSize"] ?? '').toString());
    if ("DesiredCapacity" in params) body.append(prefix+".DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
    if ("TimeZone" in params) body.append(prefix+".TimeZone", (params["TimeZone"] ?? '').toString());
}

function LaunchTemplateSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateSpecification) {
    if ("LaunchTemplateId" in params) body.append(prefix+".LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+".LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("Version" in params) body.append(prefix+".Version", (params["Version"] ?? '').toString());
}
function LaunchTemplateSpecification_Parse(node: xmlP.XmlNode): s.LaunchTemplateSpecification {
  return node.strings({
    optional: {"LaunchTemplateId":true,"LaunchTemplateName":true,"Version":true},
  });
}

function MixedInstancesPolicy_Serialize(body: URLSearchParams, prefix: string, params: s.MixedInstancesPolicy) {
    if (params["LaunchTemplate"] != null) LaunchTemplate_Serialize(body, prefix+".LaunchTemplate", params["LaunchTemplate"]);
    if (params["InstancesDistribution"] != null) InstancesDistribution_Serialize(body, prefix+".InstancesDistribution", params["InstancesDistribution"]);
}
function MixedInstancesPolicy_Parse(node: xmlP.XmlNode): s.MixedInstancesPolicy {
  return {
    LaunchTemplate: node.first("LaunchTemplate", false, LaunchTemplate_Parse),
    InstancesDistribution: node.first("InstancesDistribution", false, InstancesDistribution_Parse),
  };
}

function LaunchTemplate_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplate) {
    if (params["LaunchTemplateSpecification"] != null) LaunchTemplateSpecification_Serialize(body, prefix+".LaunchTemplateSpecification", params["LaunchTemplateSpecification"]);
    if (params["Overrides"]) qsP.appendList(body, prefix+".Overrides", params["Overrides"], {"appender":LaunchTemplateOverrides_Serialize,"entryPrefix":".member."})
}
function LaunchTemplate_Parse(node: xmlP.XmlNode): s.LaunchTemplate {
  return {
    LaunchTemplateSpecification: node.first("LaunchTemplateSpecification", false, LaunchTemplateSpecification_Parse),
    Overrides: node.getList("Overrides", "member").map(LaunchTemplateOverrides_Parse),
  };
}

function LaunchTemplateOverrides_Serialize(body: URLSearchParams, prefix: string, params: s.LaunchTemplateOverrides) {
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("WeightedCapacity" in params) body.append(prefix+".WeightedCapacity", (params["WeightedCapacity"] ?? '').toString());
    if (params["LaunchTemplateSpecification"] != null) LaunchTemplateSpecification_Serialize(body, prefix+".LaunchTemplateSpecification", params["LaunchTemplateSpecification"]);
}
function LaunchTemplateOverrides_Parse(node: xmlP.XmlNode): s.LaunchTemplateOverrides {
  return {
    ...node.strings({
      optional: {"InstanceType":true,"WeightedCapacity":true},
    }),
    LaunchTemplateSpecification: node.first("LaunchTemplateSpecification", false, LaunchTemplateSpecification_Parse),
  };
}

function InstancesDistribution_Serialize(body: URLSearchParams, prefix: string, params: s.InstancesDistribution) {
    if ("OnDemandAllocationStrategy" in params) body.append(prefix+".OnDemandAllocationStrategy", (params["OnDemandAllocationStrategy"] ?? '').toString());
    if ("OnDemandBaseCapacity" in params) body.append(prefix+".OnDemandBaseCapacity", (params["OnDemandBaseCapacity"] ?? '').toString());
    if ("OnDemandPercentageAboveBaseCapacity" in params) body.append(prefix+".OnDemandPercentageAboveBaseCapacity", (params["OnDemandPercentageAboveBaseCapacity"] ?? '').toString());
    if ("SpotAllocationStrategy" in params) body.append(prefix+".SpotAllocationStrategy", (params["SpotAllocationStrategy"] ?? '').toString());
    if ("SpotInstancePools" in params) body.append(prefix+".SpotInstancePools", (params["SpotInstancePools"] ?? '').toString());
    if ("SpotMaxPrice" in params) body.append(prefix+".SpotMaxPrice", (params["SpotMaxPrice"] ?? '').toString());
}
function InstancesDistribution_Parse(node: xmlP.XmlNode): s.InstancesDistribution {
  return {
    ...node.strings({
      optional: {"OnDemandAllocationStrategy":true,"SpotAllocationStrategy":true,"SpotMaxPrice":true},
    }),
    OnDemandBaseCapacity: node.first("OnDemandBaseCapacity", false, x => parseInt(x.content ?? '0')),
    OnDemandPercentageAboveBaseCapacity: node.first("OnDemandPercentageAboveBaseCapacity", false, x => parseInt(x.content ?? '0')),
    SpotInstancePools: node.first("SpotInstancePools", false, x => parseInt(x.content ?? '0')),
  };
}

function LifecycleHookSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.LifecycleHookSpecification) {
    body.append(prefix+".LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+".LifecycleTransition", (params["LifecycleTransition"] ?? '').toString());
    if ("NotificationMetadata" in params) body.append(prefix+".NotificationMetadata", (params["NotificationMetadata"] ?? '').toString());
    if ("HeartbeatTimeout" in params) body.append(prefix+".HeartbeatTimeout", (params["HeartbeatTimeout"] ?? '').toString());
    if ("DefaultResult" in params) body.append(prefix+".DefaultResult", (params["DefaultResult"] ?? '').toString());
    if ("NotificationTargetARN" in params) body.append(prefix+".NotificationTargetARN", (params["NotificationTargetARN"] ?? '').toString());
    if ("RoleARN" in params) body.append(prefix+".RoleARN", (params["RoleARN"] ?? '').toString());
}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    if ("ResourceId" in params) body.append(prefix+".ResourceId", (params["ResourceId"] ?? '').toString());
    if ("ResourceType" in params) body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if ("PropagateAtLaunch" in params) body.append(prefix+".PropagateAtLaunch", (params["PropagateAtLaunch"] ?? '').toString());
}

function BlockDeviceMapping_Serialize(body: URLSearchParams, prefix: string, params: s.BlockDeviceMapping) {
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
    body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if (params["Ebs"] != null) Ebs_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
}
function BlockDeviceMapping_Parse(node: xmlP.XmlNode): s.BlockDeviceMapping {
  return {
    ...node.strings({
      required: {"DeviceName":true},
      optional: {"VirtualName":true},
    }),
    Ebs: node.first("Ebs", false, Ebs_Parse),
    NoDevice: node.first("NoDevice", false, x => x.content === 'true'),
  };
}

function Ebs_Serialize(body: URLSearchParams, prefix: string, params: s.Ebs) {
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeSize" in params) body.append(prefix+".VolumeSize", (params["VolumeSize"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+".VolumeType", (params["VolumeType"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+".Iops", (params["Iops"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+".Encrypted", (params["Encrypted"] ?? '').toString());
}
function Ebs_Parse(node: xmlP.XmlNode): s.Ebs {
  return {
    ...node.strings({
      optional: {"SnapshotId":true,"VolumeType":true},
    }),
    VolumeSize: node.first("VolumeSize", false, x => parseInt(x.content ?? '0')),
    DeleteOnTermination: node.first("DeleteOnTermination", false, x => x.content === 'true'),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    Encrypted: node.first("Encrypted", false, x => x.content === 'true'),
  };
}

function InstanceMonitoring_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceMonitoring) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}
function InstanceMonitoring_Parse(node: xmlP.XmlNode): s.InstanceMonitoring {
  return {
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
  };
}

function InstanceMetadataOptions_Serialize(body: URLSearchParams, prefix: string, params: s.InstanceMetadataOptions) {
    if ("HttpTokens" in params) body.append(prefix+".HttpTokens", (params["HttpTokens"] ?? '').toString());
    if ("HttpPutResponseHopLimit" in params) body.append(prefix+".HttpPutResponseHopLimit", (params["HttpPutResponseHopLimit"] ?? '').toString());
    if ("HttpEndpoint" in params) body.append(prefix+".HttpEndpoint", (params["HttpEndpoint"] ?? '').toString());
}
function InstanceMetadataOptions_Parse(node: xmlP.XmlNode): s.InstanceMetadataOptions {
  return {
    HttpTokens: node.first("HttpTokens", false, x => (x.content ?? '') as s.InstanceMetadataHttpTokensState),
    HttpPutResponseHopLimit: node.first("HttpPutResponseHopLimit", false, x => parseInt(x.content ?? '0')),
    HttpEndpoint: node.first("HttpEndpoint", false, x => (x.content ?? '') as s.InstanceMetadataEndpointState),
  };
}

function Filter_Serialize(body: URLSearchParams, prefix: string, params: s.Filter) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}

function StepAdjustment_Serialize(body: URLSearchParams, prefix: string, params: s.StepAdjustment) {
    if ("MetricIntervalLowerBound" in params) body.append(prefix+".MetricIntervalLowerBound", (params["MetricIntervalLowerBound"] ?? '').toString());
    if ("MetricIntervalUpperBound" in params) body.append(prefix+".MetricIntervalUpperBound", (params["MetricIntervalUpperBound"] ?? '').toString());
    body.append(prefix+".ScalingAdjustment", (params["ScalingAdjustment"] ?? '').toString());
}
function StepAdjustment_Parse(node: xmlP.XmlNode): s.StepAdjustment {
  return {
    MetricIntervalLowerBound: node.first("MetricIntervalLowerBound", false, x => parseFloat(x.content ?? '0')),
    MetricIntervalUpperBound: node.first("MetricIntervalUpperBound", false, x => parseFloat(x.content ?? '0')),
    ScalingAdjustment: node.first("ScalingAdjustment", true, x => parseInt(x.content ?? '0')),
  };
}

function TargetTrackingConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.TargetTrackingConfiguration) {
    if (params["PredefinedMetricSpecification"] != null) PredefinedMetricSpecification_Serialize(body, prefix+".PredefinedMetricSpecification", params["PredefinedMetricSpecification"]);
    if (params["CustomizedMetricSpecification"] != null) CustomizedMetricSpecification_Serialize(body, prefix+".CustomizedMetricSpecification", params["CustomizedMetricSpecification"]);
    body.append(prefix+".TargetValue", (params["TargetValue"] ?? '').toString());
    if ("DisableScaleIn" in params) body.append(prefix+".DisableScaleIn", (params["DisableScaleIn"] ?? '').toString());
}
function TargetTrackingConfiguration_Parse(node: xmlP.XmlNode): s.TargetTrackingConfiguration {
  return {
    PredefinedMetricSpecification: node.first("PredefinedMetricSpecification", false, PredefinedMetricSpecification_Parse),
    CustomizedMetricSpecification: node.first("CustomizedMetricSpecification", false, CustomizedMetricSpecification_Parse),
    TargetValue: node.first("TargetValue", true, x => parseFloat(x.content ?? '0')),
    DisableScaleIn: node.first("DisableScaleIn", false, x => x.content === 'true'),
  };
}

function PredefinedMetricSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.PredefinedMetricSpecification) {
    body.append(prefix+".PredefinedMetricType", (params["PredefinedMetricType"] ?? '').toString());
    if ("ResourceLabel" in params) body.append(prefix+".ResourceLabel", (params["ResourceLabel"] ?? '').toString());
}
function PredefinedMetricSpecification_Parse(node: xmlP.XmlNode): s.PredefinedMetricSpecification {
  return {
    ...node.strings({
      optional: {"ResourceLabel":true},
    }),
    PredefinedMetricType: node.first("PredefinedMetricType", true, x => (x.content ?? '') as s.MetricType),
  };
}

function CustomizedMetricSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.CustomizedMetricSpecification) {
    body.append(prefix+".MetricName", (params["MetricName"] ?? '').toString());
    body.append(prefix+".Namespace", (params["Namespace"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+".Dimensions", params["Dimensions"], {"appender":MetricDimension_Serialize,"entryPrefix":".member."})
    body.append(prefix+".Statistic", (params["Statistic"] ?? '').toString());
    if ("Unit" in params) body.append(prefix+".Unit", (params["Unit"] ?? '').toString());
}
function CustomizedMetricSpecification_Parse(node: xmlP.XmlNode): s.CustomizedMetricSpecification {
  return {
    ...node.strings({
      required: {"MetricName":true,"Namespace":true},
      optional: {"Unit":true},
    }),
    Dimensions: node.getList("Dimensions", "member").map(MetricDimension_Parse),
    Statistic: node.first("Statistic", true, x => (x.content ?? '') as s.MetricStatistic),
  };
}

function MetricDimension_Serialize(body: URLSearchParams, prefix: string, params: s.MetricDimension) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function MetricDimension_Parse(node: xmlP.XmlNode): s.MetricDimension {
  return node.strings({
    required: {"Name":true,"Value":true},
  });
}

function RefreshPreferences_Serialize(body: URLSearchParams, prefix: string, params: s.RefreshPreferences) {
    if ("MinHealthyPercentage" in params) body.append(prefix+".MinHealthyPercentage", (params["MinHealthyPercentage"] ?? '').toString());
    if ("InstanceWarmup" in params) body.append(prefix+".InstanceWarmup", (params["InstanceWarmup"] ?? '').toString());
    if (params["CheckpointPercentages"]) qsP.appendList(body, prefix+".CheckpointPercentages", params["CheckpointPercentages"], {"entryPrefix":".member."})
    if ("CheckpointDelay" in params) body.append(prefix+".CheckpointDelay", (params["CheckpointDelay"] ?? '').toString());
}

function FailedScheduledUpdateGroupActionRequest_Parse(node: xmlP.XmlNode): s.FailedScheduledUpdateGroupActionRequest {
  return node.strings({
    required: {"ScheduledActionName":true},
    optional: {"ErrorCode":true,"ErrorMessage":true},
  });
}

function AdjustmentType_Parse(node: xmlP.XmlNode): s.AdjustmentType {
  return node.strings({
    optional: {"AdjustmentType":true},
  });
}

function AutoScalingGroup_Parse(node: xmlP.XmlNode): s.AutoScalingGroup {
  return {
    ...node.strings({
      required: {"AutoScalingGroupName":true,"HealthCheckType":true},
      optional: {"AutoScalingGroupARN":true,"LaunchConfigurationName":true,"PlacementGroup":true,"VPCZoneIdentifier":true,"Status":true,"ServiceLinkedRoleARN":true},
    }),
    LaunchTemplate: node.first("LaunchTemplate", false, LaunchTemplateSpecification_Parse),
    MixedInstancesPolicy: node.first("MixedInstancesPolicy", false, MixedInstancesPolicy_Parse),
    MinSize: node.first("MinSize", true, x => parseInt(x.content ?? '0')),
    MaxSize: node.first("MaxSize", true, x => parseInt(x.content ?? '0')),
    DesiredCapacity: node.first("DesiredCapacity", true, x => parseInt(x.content ?? '0')),
    DefaultCooldown: node.first("DefaultCooldown", true, x => parseInt(x.content ?? '0')),
    AvailabilityZones: node.getList("AvailabilityZones", "member").map(x => x.content ?? ''),
    LoadBalancerNames: node.getList("LoadBalancerNames", "member").map(x => x.content ?? ''),
    TargetGroupARNs: node.getList("TargetGroupARNs", "member").map(x => x.content ?? ''),
    HealthCheckGracePeriod: node.first("HealthCheckGracePeriod", false, x => parseInt(x.content ?? '0')),
    Instances: node.getList("Instances", "member").map(Instance_Parse),
    CreatedTime: node.first("CreatedTime", true, x => xmlP.parseTimestamp(x.content)),
    SuspendedProcesses: node.getList("SuspendedProcesses", "member").map(SuspendedProcess_Parse),
    EnabledMetrics: node.getList("EnabledMetrics", "member").map(EnabledMetric_Parse),
    Tags: node.getList("Tags", "member").map(TagDescription_Parse),
    TerminationPolicies: node.getList("TerminationPolicies", "member").map(x => x.content ?? ''),
    NewInstancesProtectedFromScaleIn: node.first("NewInstancesProtectedFromScaleIn", false, x => x.content === 'true'),
    MaxInstanceLifetime: node.first("MaxInstanceLifetime", false, x => parseInt(x.content ?? '0')),
    CapacityRebalance: node.first("CapacityRebalance", false, x => x.content === 'true'),
  };
}

function Instance_Parse(node: xmlP.XmlNode): s.Instance {
  return {
    ...node.strings({
      required: {"InstanceId":true,"AvailabilityZone":true,"HealthStatus":true},
      optional: {"InstanceType":true,"LaunchConfigurationName":true,"WeightedCapacity":true},
    }),
    LifecycleState: node.first("LifecycleState", true, x => (x.content ?? '') as s.LifecycleState),
    LaunchTemplate: node.first("LaunchTemplate", false, LaunchTemplateSpecification_Parse),
    ProtectedFromScaleIn: node.first("ProtectedFromScaleIn", true, x => x.content === 'true'),
  };
}

function SuspendedProcess_Parse(node: xmlP.XmlNode): s.SuspendedProcess {
  return node.strings({
    optional: {"ProcessName":true,"SuspensionReason":true},
  });
}

function EnabledMetric_Parse(node: xmlP.XmlNode): s.EnabledMetric {
  return node.strings({
    optional: {"Metric":true,"Granularity":true},
  });
}

function TagDescription_Parse(node: xmlP.XmlNode): s.TagDescription {
  return {
    ...node.strings({
      optional: {"ResourceId":true,"ResourceType":true,"Key":true,"Value":true},
    }),
    PropagateAtLaunch: node.first("PropagateAtLaunch", false, x => x.content === 'true'),
  };
}

function AutoScalingInstanceDetails_Parse(node: xmlP.XmlNode): s.AutoScalingInstanceDetails {
  return {
    ...node.strings({
      required: {"InstanceId":true,"AutoScalingGroupName":true,"AvailabilityZone":true,"LifecycleState":true,"HealthStatus":true},
      optional: {"InstanceType":true,"LaunchConfigurationName":true,"WeightedCapacity":true},
    }),
    LaunchTemplate: node.first("LaunchTemplate", false, LaunchTemplateSpecification_Parse),
    ProtectedFromScaleIn: node.first("ProtectedFromScaleIn", true, x => x.content === 'true'),
  };
}

function InstanceRefresh_Parse(node: xmlP.XmlNode): s.InstanceRefresh {
  return {
    ...node.strings({
      optional: {"InstanceRefreshId":true,"AutoScalingGroupName":true,"StatusReason":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as s.InstanceRefreshStatus),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", false, x => xmlP.parseTimestamp(x.content)),
    PercentageComplete: node.first("PercentageComplete", false, x => parseInt(x.content ?? '0')),
    InstancesToUpdate: node.first("InstancesToUpdate", false, x => parseInt(x.content ?? '0')),
  };
}

function LaunchConfiguration_Parse(node: xmlP.XmlNode): s.LaunchConfiguration {
  return {
    ...node.strings({
      required: {"LaunchConfigurationName":true,"ImageId":true,"InstanceType":true},
      optional: {"LaunchConfigurationARN":true,"KeyName":true,"ClassicLinkVPCId":true,"UserData":true,"KernelId":true,"RamdiskId":true,"SpotPrice":true,"IamInstanceProfile":true,"PlacementTenancy":true},
    }),
    SecurityGroups: node.getList("SecurityGroups", "member").map(x => x.content ?? ''),
    ClassicLinkVPCSecurityGroups: node.getList("ClassicLinkVPCSecurityGroups", "member").map(x => x.content ?? ''),
    BlockDeviceMappings: node.getList("BlockDeviceMappings", "member").map(BlockDeviceMapping_Parse),
    InstanceMonitoring: node.first("InstanceMonitoring", false, InstanceMonitoring_Parse),
    CreatedTime: node.first("CreatedTime", true, x => xmlP.parseTimestamp(x.content)),
    EbsOptimized: node.first("EbsOptimized", false, x => x.content === 'true'),
    AssociatePublicIpAddress: node.first("AssociatePublicIpAddress", false, x => x.content === 'true'),
    MetadataOptions: node.first("MetadataOptions", false, InstanceMetadataOptions_Parse),
  };
}

function LifecycleHook_Parse(node: xmlP.XmlNode): s.LifecycleHook {
  return {
    ...node.strings({
      optional: {"LifecycleHookName":true,"AutoScalingGroupName":true,"LifecycleTransition":true,"NotificationTargetARN":true,"RoleARN":true,"NotificationMetadata":true,"DefaultResult":true},
    }),
    HeartbeatTimeout: node.first("HeartbeatTimeout", false, x => parseInt(x.content ?? '0')),
    GlobalTimeout: node.first("GlobalTimeout", false, x => parseInt(x.content ?? '0')),
  };
}

function LoadBalancerTargetGroupState_Parse(node: xmlP.XmlNode): s.LoadBalancerTargetGroupState {
  return node.strings({
    optional: {"LoadBalancerTargetGroupARN":true,"State":true},
  });
}

function LoadBalancerState_Parse(node: xmlP.XmlNode): s.LoadBalancerState {
  return node.strings({
    optional: {"LoadBalancerName":true,"State":true},
  });
}

function MetricCollectionType_Parse(node: xmlP.XmlNode): s.MetricCollectionType {
  return node.strings({
    optional: {"Metric":true},
  });
}

function MetricGranularityType_Parse(node: xmlP.XmlNode): s.MetricGranularityType {
  return node.strings({
    optional: {"Granularity":true},
  });
}

function NotificationConfiguration_Parse(node: xmlP.XmlNode): s.NotificationConfiguration {
  return node.strings({
    optional: {"AutoScalingGroupName":true,"TopicARN":true,"NotificationType":true},
  });
}

function ScalingPolicy_Parse(node: xmlP.XmlNode): s.ScalingPolicy {
  return {
    ...node.strings({
      optional: {"AutoScalingGroupName":true,"PolicyName":true,"PolicyARN":true,"PolicyType":true,"AdjustmentType":true,"MetricAggregationType":true},
    }),
    MinAdjustmentStep: node.first("MinAdjustmentStep", false, x => parseInt(x.content ?? '0')),
    MinAdjustmentMagnitude: node.first("MinAdjustmentMagnitude", false, x => parseInt(x.content ?? '0')),
    ScalingAdjustment: node.first("ScalingAdjustment", false, x => parseInt(x.content ?? '0')),
    Cooldown: node.first("Cooldown", false, x => parseInt(x.content ?? '0')),
    StepAdjustments: node.getList("StepAdjustments", "member").map(StepAdjustment_Parse),
    EstimatedInstanceWarmup: node.first("EstimatedInstanceWarmup", false, x => parseInt(x.content ?? '0')),
    Alarms: node.getList("Alarms", "member").map(Alarm_Parse),
    TargetTrackingConfiguration: node.first("TargetTrackingConfiguration", false, TargetTrackingConfiguration_Parse),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
  };
}

function Alarm_Parse(node: xmlP.XmlNode): s.Alarm {
  return node.strings({
    optional: {"AlarmName":true,"AlarmARN":true},
  });
}

function Activity_Parse(node: xmlP.XmlNode): s.Activity {
  return {
    ...node.strings({
      required: {"ActivityId":true,"AutoScalingGroupName":true,"Cause":true},
      optional: {"Description":true,"StatusMessage":true,"Details":true,"AutoScalingGroupState":true,"AutoScalingGroupARN":true},
    }),
    StartTime: node.first("StartTime", true, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", false, x => xmlP.parseTimestamp(x.content)),
    StatusCode: node.first("StatusCode", true, x => (x.content ?? '') as s.ScalingActivityStatusCode),
    Progress: node.first("Progress", false, x => parseInt(x.content ?? '0')),
  };
}

function ProcessType_Parse(node: xmlP.XmlNode): s.ProcessType {
  return node.strings({
    required: {"ProcessName":true},
  });
}

function ScheduledUpdateGroupAction_Parse(node: xmlP.XmlNode): s.ScheduledUpdateGroupAction {
  return {
    ...node.strings({
      optional: {"AutoScalingGroupName":true,"ScheduledActionName":true,"ScheduledActionARN":true,"Recurrence":true,"TimeZone":true},
    }),
    Time: node.first("Time", false, x => xmlP.parseTimestamp(x.content)),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", false, x => xmlP.parseTimestamp(x.content)),
    MinSize: node.first("MinSize", false, x => parseInt(x.content ?? '0')),
    MaxSize: node.first("MaxSize", false, x => parseInt(x.content ?? '0')),
    DesiredCapacity: node.first("DesiredCapacity", false, x => parseInt(x.content ?? '0')),
  };
}
