// Autogenerated API client for: Auto Scaling

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";

export default class AutoScaling {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AutoScaling.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2011-01-01",
    "endpointPrefix": "autoscaling",
    "protocol": "query",
    "serviceFullName": "Auto Scaling",
    "serviceId": "Auto Scaling",
    "signatureVersion": "v4",
    "uid": "autoscaling-2011-01-01",
    "xmlNamespace": "http://autoscaling.amazonaws.com/doc/2011-01-01/"
  };

  async attachInstances(
    {abortSignal, ...params}: RequestConfig & AttachInstancesQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachInstances",
    });
  }

  async attachLoadBalancerTargetGroups(
    {abortSignal, ...params}: RequestConfig & AttachLoadBalancerTargetGroupsType,
  ): Promise<AttachLoadBalancerTargetGroupsResultType> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["TargetGroupARNs"]) qsP.appendList(body, prefix+"TargetGroupARNs", params["TargetGroupARNs"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachLoadBalancerTargetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AttachLoadBalancerTargetGroupsResult");
    return {};
  }

  async attachLoadBalancers(
    {abortSignal, ...params}: RequestConfig & AttachLoadBalancersType,
  ): Promise<AttachLoadBalancersResultType> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["LoadBalancerNames"]) qsP.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachLoadBalancers",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AttachLoadBalancersResult");
    return {};
  }

  async batchDeleteScheduledAction(
    {abortSignal, ...params}: RequestConfig & BatchDeleteScheduledActionType,
  ): Promise<BatchDeleteScheduledActionAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScheduledActionNames"]) qsP.appendList(body, prefix+"ScheduledActionNames", params["ScheduledActionNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteScheduledAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchDeleteScheduledActionResult");
    return {
      FailedScheduledActions: xml.getList("FailedScheduledActions", "member").map(FailedScheduledUpdateGroupActionRequest_Parse),
    };
  }

  async batchPutScheduledUpdateGroupAction(
    {abortSignal, ...params}: RequestConfig & BatchPutScheduledUpdateGroupActionType,
  ): Promise<BatchPutScheduledUpdateGroupActionAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScheduledUpdateGroupActions"]) qsP.appendList(body, prefix+"ScheduledUpdateGroupActions", params["ScheduledUpdateGroupActions"], {"appender":ScheduledUpdateGroupActionRequest_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchPutScheduledUpdateGroupAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchPutScheduledUpdateGroupActionResult");
    return {
      FailedScheduledUpdateGroupActions: xml.getList("FailedScheduledUpdateGroupActions", "member").map(FailedScheduledUpdateGroupActionRequest_Parse),
    };
  }

  async cancelInstanceRefresh(
    {abortSignal, ...params}: RequestConfig & CancelInstanceRefreshType,
  ): Promise<CancelInstanceRefreshAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelInstanceRefresh",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CancelInstanceRefreshResult");
    return xml.strings({
      optional: {"InstanceRefreshId":true},
    });
  }

  async completeLifecycleAction(
    {abortSignal, ...params}: RequestConfig & CompleteLifecycleActionType,
  ): Promise<CompleteLifecycleActionAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LifecycleActionToken" in params) body.append(prefix+"LifecycleActionToken", (params["LifecycleActionToken"] ?? '').toString());
    body.append(prefix+"LifecycleActionResult", (params["LifecycleActionResult"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CompleteLifecycleAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CompleteLifecycleActionResult");
    return {};
  }

  async createAutoScalingGroup(
    {abortSignal, ...params}: RequestConfig & CreateAutoScalingGroupType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LaunchConfigurationName" in params) body.append(prefix+"LaunchConfigurationName", (params["LaunchConfigurationName"] ?? '').toString());
    if (params["LaunchTemplate"] != null) LaunchTemplateSpecification_Serialize(body, prefix+"LaunchTemplate", params["LaunchTemplate"]);
    if (params["MixedInstancesPolicy"] != null) MixedInstancesPolicy_Serialize(body, prefix+"MixedInstancesPolicy", params["MixedInstancesPolicy"]);
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"MinSize", (params["MinSize"] ?? '').toString());
    body.append(prefix+"MaxSize", (params["MaxSize"] ?? '').toString());
    if ("DesiredCapacity" in params) body.append(prefix+"DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
    if ("DefaultCooldown" in params) body.append(prefix+"DefaultCooldown", (params["DefaultCooldown"] ?? '').toString());
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".member."})
    if (params["LoadBalancerNames"]) qsP.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    if (params["TargetGroupARNs"]) qsP.appendList(body, prefix+"TargetGroupARNs", params["TargetGroupARNs"], {"entryPrefix":".member."})
    if ("HealthCheckType" in params) body.append(prefix+"HealthCheckType", (params["HealthCheckType"] ?? '').toString());
    if ("HealthCheckGracePeriod" in params) body.append(prefix+"HealthCheckGracePeriod", (params["HealthCheckGracePeriod"] ?? '').toString());
    if ("PlacementGroup" in params) body.append(prefix+"PlacementGroup", (params["PlacementGroup"] ?? '').toString());
    if ("VPCZoneIdentifier" in params) body.append(prefix+"VPCZoneIdentifier", (params["VPCZoneIdentifier"] ?? '').toString());
    if (params["TerminationPolicies"]) qsP.appendList(body, prefix+"TerminationPolicies", params["TerminationPolicies"], {"entryPrefix":".member."})
    if ("NewInstancesProtectedFromScaleIn" in params) body.append(prefix+"NewInstancesProtectedFromScaleIn", (params["NewInstancesProtectedFromScaleIn"] ?? '').toString());
    if (params["LifecycleHookSpecificationList"]) qsP.appendList(body, prefix+"LifecycleHookSpecificationList", params["LifecycleHookSpecificationList"], {"appender":LifecycleHookSpecification_Serialize,"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("ServiceLinkedRoleARN" in params) body.append(prefix+"ServiceLinkedRoleARN", (params["ServiceLinkedRoleARN"] ?? '').toString());
    if ("MaxInstanceLifetime" in params) body.append(prefix+"MaxInstanceLifetime", (params["MaxInstanceLifetime"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAutoScalingGroup",
    });
  }

  async createLaunchConfiguration(
    {abortSignal, ...params}: RequestConfig & CreateLaunchConfigurationType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LaunchConfigurationName", (params["LaunchConfigurationName"] ?? '').toString());
    if ("ImageId" in params) body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+"SecurityGroups", params["SecurityGroups"], {"entryPrefix":".member."})
    if ("ClassicLinkVPCId" in params) body.append(prefix+"ClassicLinkVPCId", (params["ClassicLinkVPCId"] ?? '').toString());
    if (params["ClassicLinkVPCSecurityGroups"]) qsP.appendList(body, prefix+"ClassicLinkVPCSecurityGroups", params["ClassicLinkVPCSecurityGroups"], {"entryPrefix":".member."})
    if ("UserData" in params) body.append(prefix+"UserData", (params["UserData"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+"KernelId", (params["KernelId"] ?? '').toString());
    if ("RamdiskId" in params) body.append(prefix+"RamdiskId", (params["RamdiskId"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"BlockDeviceMappings", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":".member."})
    if (params["InstanceMonitoring"] != null) InstanceMonitoring_Serialize(body, prefix+"InstanceMonitoring", params["InstanceMonitoring"]);
    if ("SpotPrice" in params) body.append(prefix+"SpotPrice", (params["SpotPrice"] ?? '').toString());
    if ("IamInstanceProfile" in params) body.append(prefix+"IamInstanceProfile", (params["IamInstanceProfile"] ?? '').toString());
    if ("EbsOptimized" in params) body.append(prefix+"EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if ("AssociatePublicIpAddress" in params) body.append(prefix+"AssociatePublicIpAddress", (params["AssociatePublicIpAddress"] ?? '').toString());
    if ("PlacementTenancy" in params) body.append(prefix+"PlacementTenancy", (params["PlacementTenancy"] ?? '').toString());
    if (params["MetadataOptions"] != null) InstanceMetadataOptions_Serialize(body, prefix+"MetadataOptions", params["MetadataOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLaunchConfiguration",
    });
  }

  async createOrUpdateTags(
    {abortSignal, ...params}: RequestConfig & CreateOrUpdateTagsType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOrUpdateTags",
    });
  }

  async deleteAutoScalingGroup(
    {abortSignal, ...params}: RequestConfig & DeleteAutoScalingGroupType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("ForceDelete" in params) body.append(prefix+"ForceDelete", (params["ForceDelete"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAutoScalingGroup",
    });
  }

  async deleteLaunchConfiguration(
    {abortSignal, ...params}: RequestConfig & LaunchConfigurationNameType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LaunchConfigurationName", (params["LaunchConfigurationName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLaunchConfiguration",
    });
  }

  async deleteLifecycleHook(
    {abortSignal, ...params}: RequestConfig & DeleteLifecycleHookType,
  ): Promise<DeleteLifecycleHookAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLifecycleHook",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteLifecycleHookResult");
    return {};
  }

  async deleteNotificationConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteNotificationConfigurationType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"TopicARN", (params["TopicARN"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNotificationConfiguration",
    });
  }

  async deletePolicy(
    {abortSignal, ...params}: RequestConfig & DeletePolicyType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePolicy",
    });
  }

  async deleteScheduledAction(
    {abortSignal, ...params}: RequestConfig & DeleteScheduledActionType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteScheduledAction",
    });
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & DeleteTagsType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
  }

  async describeAccountLimits(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<DescribeAccountLimitsAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAccountLimits",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAccountLimitsResult");
    return {
      MaxNumberOfAutoScalingGroups: xml.first("MaxNumberOfAutoScalingGroups", false, x => parseInt(x.content ?? '0')),
      MaxNumberOfLaunchConfigurations: xml.first("MaxNumberOfLaunchConfigurations", false, x => parseInt(x.content ?? '0')),
      NumberOfAutoScalingGroups: xml.first("NumberOfAutoScalingGroups", false, x => parseInt(x.content ?? '0')),
      NumberOfLaunchConfigurations: xml.first("NumberOfLaunchConfigurations", false, x => parseInt(x.content ?? '0')),
    };
  }

  async describeAdjustmentTypes(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<DescribeAdjustmentTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAdjustmentTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAdjustmentTypesResult");
    return {
      AdjustmentTypes: xml.getList("AdjustmentTypes", "member").map(AdjustmentType_Parse),
    };
  }

  async describeAutoScalingGroups(
    {abortSignal, ...params}: RequestConfig & AutoScalingGroupNamesType = {},
  ): Promise<AutoScalingGroupsType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AutoScalingGroupNames"]) qsP.appendList(body, prefix+"AutoScalingGroupNames", params["AutoScalingGroupNames"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAutoScalingGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAutoScalingGroupsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AutoScalingGroups: xml.getList("AutoScalingGroups", "member").map(AutoScalingGroup_Parse),
    };
  }

  async describeAutoScalingInstances(
    {abortSignal, ...params}: RequestConfig & DescribeAutoScalingInstancesType = {},
  ): Promise<AutoScalingInstancesType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAutoScalingInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAutoScalingInstancesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AutoScalingInstances: xml.getList("AutoScalingInstances", "member").map(AutoScalingInstanceDetails_Parse),
    };
  }

  async describeAutoScalingNotificationTypes(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<DescribeAutoScalingNotificationTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAutoScalingNotificationTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAutoScalingNotificationTypesResult");
    return {
      AutoScalingNotificationTypes: xml.getList("AutoScalingNotificationTypes", "member").map(x => x.content ?? ''),
    };
  }

  async describeInstanceRefreshes(
    {abortSignal, ...params}: RequestConfig & DescribeInstanceRefreshesType,
  ): Promise<DescribeInstanceRefreshesAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["InstanceRefreshIds"]) qsP.appendList(body, prefix+"InstanceRefreshIds", params["InstanceRefreshIds"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceRefreshes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeInstanceRefreshesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      InstanceRefreshes: xml.getList("InstanceRefreshes", "member").map(InstanceRefresh_Parse),
    };
  }

  async describeLaunchConfigurations(
    {abortSignal, ...params}: RequestConfig & LaunchConfigurationNamesType = {},
  ): Promise<LaunchConfigurationsType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LaunchConfigurationNames"]) qsP.appendList(body, prefix+"LaunchConfigurationNames", params["LaunchConfigurationNames"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLaunchConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLaunchConfigurationsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      LaunchConfigurations: xml.getList("LaunchConfigurations", "member").map(LaunchConfiguration_Parse),
    };
  }

  async describeLifecycleHookTypes(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<DescribeLifecycleHookTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeLifecycleHookTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLifecycleHookTypesResult");
    return {
      LifecycleHookTypes: xml.getList("LifecycleHookTypes", "member").map(x => x.content ?? ''),
    };
  }

  async describeLifecycleHooks(
    {abortSignal, ...params}: RequestConfig & DescribeLifecycleHooksType,
  ): Promise<DescribeLifecycleHooksAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["LifecycleHookNames"]) qsP.appendList(body, prefix+"LifecycleHookNames", params["LifecycleHookNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLifecycleHooks",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLifecycleHooksResult");
    return {
      LifecycleHooks: xml.getList("LifecycleHooks", "member").map(LifecycleHook_Parse),
    };
  }

  async describeLoadBalancerTargetGroups(
    {abortSignal, ...params}: RequestConfig & DescribeLoadBalancerTargetGroupsRequest,
  ): Promise<DescribeLoadBalancerTargetGroupsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancerTargetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLoadBalancerTargetGroupsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      LoadBalancerTargetGroups: xml.getList("LoadBalancerTargetGroups", "member").map(LoadBalancerTargetGroupState_Parse),
    };
  }

  async describeLoadBalancers(
    {abortSignal, ...params}: RequestConfig & DescribeLoadBalancersRequest,
  ): Promise<DescribeLoadBalancersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancers",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLoadBalancersResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      LoadBalancers: xml.getList("LoadBalancers", "member").map(LoadBalancerState_Parse),
    };
  }

  async describeMetricCollectionTypes(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<DescribeMetricCollectionTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeMetricCollectionTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeMetricCollectionTypesResult");
    return {
      Metrics: xml.getList("Metrics", "member").map(MetricCollectionType_Parse),
      Granularities: xml.getList("Granularities", "member").map(MetricGranularityType_Parse),
    };
  }

  async describeNotificationConfigurations(
    {abortSignal, ...params}: RequestConfig & DescribeNotificationConfigurationsType = {},
  ): Promise<DescribeNotificationConfigurationsAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AutoScalingGroupNames"]) qsP.appendList(body, prefix+"AutoScalingGroupNames", params["AutoScalingGroupNames"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotificationConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeNotificationConfigurationsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      NotificationConfigurations: xml.getList("NotificationConfigurations", "member").map(NotificationConfiguration_Parse),
    };
  }

  async describePolicies(
    {abortSignal, ...params}: RequestConfig & DescribePoliciesType = {},
  ): Promise<PoliciesType> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["PolicyNames"]) qsP.appendList(body, prefix+"PolicyNames", params["PolicyNames"], {"entryPrefix":".member."})
    if (params["PolicyTypes"]) qsP.appendList(body, prefix+"PolicyTypes", params["PolicyTypes"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribePoliciesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      ScalingPolicies: xml.getList("ScalingPolicies", "member").map(ScalingPolicy_Parse),
    };
  }

  async describeScalingActivities(
    {abortSignal, ...params}: RequestConfig & DescribeScalingActivitiesType = {},
  ): Promise<ActivitiesType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ActivityIds"]) qsP.appendList(body, prefix+"ActivityIds", params["ActivityIds"], {"entryPrefix":".member."})
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScalingActivities",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeScalingActivitiesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Activities: xml.getList("Activities", "member").map(Activity_Parse),
    };
  }

  async describeScalingProcessTypes(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<ProcessesType> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeScalingProcessTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeScalingProcessTypesResult");
    return {
      Processes: xml.getList("Processes", "member").map(ProcessType_Parse),
    };
  }

  async describeScheduledActions(
    {abortSignal, ...params}: RequestConfig & DescribeScheduledActionsType = {},
  ): Promise<ScheduledActionsType> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScheduledActionNames"]) qsP.appendList(body, prefix+"ScheduledActionNames", params["ScheduledActionNames"], {"entryPrefix":".member."})
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScheduledActions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeScheduledActionsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      ScheduledUpdateGroupActions: xml.getList("ScheduledUpdateGroupActions", "member").map(ScheduledUpdateGroupAction_Parse),
    };
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & DescribeTagsType = {},
  ): Promise<TagsType> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTagsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Tags: xml.getList("Tags", "member").map(TagDescription_Parse),
    };
  }

  async describeTerminationPolicyTypes(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<DescribeTerminationPolicyTypesAnswer> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeTerminationPolicyTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTerminationPolicyTypesResult");
    return {
      TerminationPolicyTypes: xml.getList("TerminationPolicyTypes", "member").map(x => x.content ?? ''),
    };
  }

  async detachInstances(
    {abortSignal, ...params}: RequestConfig & DetachInstancesQuery,
  ): Promise<DetachInstancesAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ShouldDecrementDesiredCapacity", (params["ShouldDecrementDesiredCapacity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetachInstancesResult");
    return {
      Activities: xml.getList("Activities", "member").map(Activity_Parse),
    };
  }

  async detachLoadBalancerTargetGroups(
    {abortSignal, ...params}: RequestConfig & DetachLoadBalancerTargetGroupsType,
  ): Promise<DetachLoadBalancerTargetGroupsResultType> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["TargetGroupARNs"]) qsP.appendList(body, prefix+"TargetGroupARNs", params["TargetGroupARNs"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachLoadBalancerTargetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetachLoadBalancerTargetGroupsResult");
    return {};
  }

  async detachLoadBalancers(
    {abortSignal, ...params}: RequestConfig & DetachLoadBalancersType,
  ): Promise<DetachLoadBalancersResultType> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["LoadBalancerNames"]) qsP.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachLoadBalancers",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetachLoadBalancersResult");
    return {};
  }

  async disableMetricsCollection(
    {abortSignal, ...params}: RequestConfig & DisableMetricsCollectionQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["Metrics"]) qsP.appendList(body, prefix+"Metrics", params["Metrics"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableMetricsCollection",
    });
  }

  async enableMetricsCollection(
    {abortSignal, ...params}: RequestConfig & EnableMetricsCollectionQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["Metrics"]) qsP.appendList(body, prefix+"Metrics", params["Metrics"], {"entryPrefix":".member."})
    body.append(prefix+"Granularity", (params["Granularity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableMetricsCollection",
    });
  }

  async enterStandby(
    {abortSignal, ...params}: RequestConfig & EnterStandbyQuery,
  ): Promise<EnterStandbyAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ShouldDecrementDesiredCapacity", (params["ShouldDecrementDesiredCapacity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnterStandby",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EnterStandbyResult");
    return {
      Activities: xml.getList("Activities", "member").map(Activity_Parse),
    };
  }

  async executePolicy(
    {abortSignal, ...params}: RequestConfig & ExecutePolicyType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoScalingGroupName" in params) body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    if ("HonorCooldown" in params) body.append(prefix+"HonorCooldown", (params["HonorCooldown"] ?? '').toString());
    if ("MetricValue" in params) body.append(prefix+"MetricValue", (params["MetricValue"] ?? '').toString());
    if ("BreachThreshold" in params) body.append(prefix+"BreachThreshold", (params["BreachThreshold"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExecutePolicy",
    });
  }

  async exitStandby(
    {abortSignal, ...params}: RequestConfig & ExitStandbyQuery,
  ): Promise<ExitStandbyAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExitStandby",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ExitStandbyResult");
    return {
      Activities: xml.getList("Activities", "member").map(Activity_Parse),
    };
  }

  async putLifecycleHook(
    {abortSignal, ...params}: RequestConfig & PutLifecycleHookType,
  ): Promise<PutLifecycleHookAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LifecycleTransition" in params) body.append(prefix+"LifecycleTransition", (params["LifecycleTransition"] ?? '').toString());
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if ("NotificationTargetARN" in params) body.append(prefix+"NotificationTargetARN", (params["NotificationTargetARN"] ?? '').toString());
    if ("NotificationMetadata" in params) body.append(prefix+"NotificationMetadata", (params["NotificationMetadata"] ?? '').toString());
    if ("HeartbeatTimeout" in params) body.append(prefix+"HeartbeatTimeout", (params["HeartbeatTimeout"] ?? '').toString());
    if ("DefaultResult" in params) body.append(prefix+"DefaultResult", (params["DefaultResult"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLifecycleHook",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PutLifecycleHookResult");
    return {};
  }

  async putNotificationConfiguration(
    {abortSignal, ...params}: RequestConfig & PutNotificationConfigurationType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"TopicARN", (params["TopicARN"] ?? '').toString());
    if (params["NotificationTypes"]) qsP.appendList(body, prefix+"NotificationTypes", params["NotificationTypes"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutNotificationConfiguration",
    });
  }

  async putScalingPolicy(
    {abortSignal, ...params}: RequestConfig & PutScalingPolicyType,
  ): Promise<PolicyARNType> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    if ("PolicyType" in params) body.append(prefix+"PolicyType", (params["PolicyType"] ?? '').toString());
    if ("AdjustmentType" in params) body.append(prefix+"AdjustmentType", (params["AdjustmentType"] ?? '').toString());
    if ("MinAdjustmentStep" in params) body.append(prefix+"MinAdjustmentStep", (params["MinAdjustmentStep"] ?? '').toString());
    if ("MinAdjustmentMagnitude" in params) body.append(prefix+"MinAdjustmentMagnitude", (params["MinAdjustmentMagnitude"] ?? '').toString());
    if ("ScalingAdjustment" in params) body.append(prefix+"ScalingAdjustment", (params["ScalingAdjustment"] ?? '').toString());
    if ("Cooldown" in params) body.append(prefix+"Cooldown", (params["Cooldown"] ?? '').toString());
    if ("MetricAggregationType" in params) body.append(prefix+"MetricAggregationType", (params["MetricAggregationType"] ?? '').toString());
    if (params["StepAdjustments"]) qsP.appendList(body, prefix+"StepAdjustments", params["StepAdjustments"], {"appender":StepAdjustment_Serialize,"entryPrefix":".member."})
    if ("EstimatedInstanceWarmup" in params) body.append(prefix+"EstimatedInstanceWarmup", (params["EstimatedInstanceWarmup"] ?? '').toString());
    if (params["TargetTrackingConfiguration"] != null) TargetTrackingConfiguration_Serialize(body, prefix+"TargetTrackingConfiguration", params["TargetTrackingConfiguration"]);
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutScalingPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PutScalingPolicyResult");
    return {
      ...xml.strings({
        optional: {"PolicyARN":true},
      }),
      Alarms: xml.getList("Alarms", "member").map(Alarm_Parse),
    };
  }

  async putScheduledUpdateGroupAction(
    {abortSignal, ...params}: RequestConfig & PutScheduledUpdateGroupActionType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    if ("Time" in params) body.append(prefix+"Time", qsP.encodeDate_iso8601(params["Time"]));
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Recurrence" in params) body.append(prefix+"Recurrence", (params["Recurrence"] ?? '').toString());
    if ("MinSize" in params) body.append(prefix+"MinSize", (params["MinSize"] ?? '').toString());
    if ("MaxSize" in params) body.append(prefix+"MaxSize", (params["MaxSize"] ?? '').toString());
    if ("DesiredCapacity" in params) body.append(prefix+"DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutScheduledUpdateGroupAction",
    });
  }

  async recordLifecycleActionHeartbeat(
    {abortSignal, ...params}: RequestConfig & RecordLifecycleActionHeartbeatType,
  ): Promise<RecordLifecycleActionHeartbeatAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LifecycleActionToken" in params) body.append(prefix+"LifecycleActionToken", (params["LifecycleActionToken"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RecordLifecycleActionHeartbeat",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RecordLifecycleActionHeartbeatResult");
    return {};
  }

  async resumeProcesses(
    {abortSignal, ...params}: RequestConfig & ScalingProcessQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScalingProcesses"]) qsP.appendList(body, prefix+"ScalingProcesses", params["ScalingProcesses"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResumeProcesses",
    });
  }

  async setDesiredCapacity(
    {abortSignal, ...params}: RequestConfig & SetDesiredCapacityType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
    if ("HonorCooldown" in params) body.append(prefix+"HonorCooldown", (params["HonorCooldown"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetDesiredCapacity",
    });
  }

  async setInstanceHealth(
    {abortSignal, ...params}: RequestConfig & SetInstanceHealthQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"HealthStatus", (params["HealthStatus"] ?? '').toString());
    if ("ShouldRespectGracePeriod" in params) body.append(prefix+"ShouldRespectGracePeriod", (params["ShouldRespectGracePeriod"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetInstanceHealth",
    });
  }

  async setInstanceProtection(
    {abortSignal, ...params}: RequestConfig & SetInstanceProtectionQuery,
  ): Promise<SetInstanceProtectionAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceIds", params["InstanceIds"], {"entryPrefix":".member."})
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    body.append(prefix+"ProtectedFromScaleIn", (params["ProtectedFromScaleIn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetInstanceProtection",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SetInstanceProtectionResult");
    return {};
  }

  async startInstanceRefresh(
    {abortSignal, ...params}: RequestConfig & StartInstanceRefreshType,
  ): Promise<StartInstanceRefreshAnswer> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("Strategy" in params) body.append(prefix+"Strategy", (params["Strategy"] ?? '').toString());
    if (params["Preferences"] != null) RefreshPreferences_Serialize(body, prefix+"Preferences", params["Preferences"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartInstanceRefresh",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "StartInstanceRefreshResult");
    return xml.strings({
      optional: {"InstanceRefreshId":true},
    });
  }

  async suspendProcesses(
    {abortSignal, ...params}: RequestConfig & ScalingProcessQuery,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if (params["ScalingProcesses"]) qsP.appendList(body, prefix+"ScalingProcesses", params["ScalingProcesses"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SuspendProcesses",
    });
  }

  async terminateInstanceInAutoScalingGroup(
    {abortSignal, ...params}: RequestConfig & TerminateInstanceInAutoScalingGroupType,
  ): Promise<ActivityType> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"ShouldDecrementDesiredCapacity", (params["ShouldDecrementDesiredCapacity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateInstanceInAutoScalingGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "TerminateInstanceInAutoScalingGroupResult");
    return {
      Activity: xml.first("Activity", false, Activity_Parse),
    };
  }

  async updateAutoScalingGroup(
    {abortSignal, ...params}: RequestConfig & UpdateAutoScalingGroupType,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AutoScalingGroupName", (params["AutoScalingGroupName"] ?? '').toString());
    if ("LaunchConfigurationName" in params) body.append(prefix+"LaunchConfigurationName", (params["LaunchConfigurationName"] ?? '').toString());
    if (params["LaunchTemplate"] != null) LaunchTemplateSpecification_Serialize(body, prefix+"LaunchTemplate", params["LaunchTemplate"]);
    if (params["MixedInstancesPolicy"] != null) MixedInstancesPolicy_Serialize(body, prefix+"MixedInstancesPolicy", params["MixedInstancesPolicy"]);
    if ("MinSize" in params) body.append(prefix+"MinSize", (params["MinSize"] ?? '').toString());
    if ("MaxSize" in params) body.append(prefix+"MaxSize", (params["MaxSize"] ?? '').toString());
    if ("DesiredCapacity" in params) body.append(prefix+"DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
    if ("DefaultCooldown" in params) body.append(prefix+"DefaultCooldown", (params["DefaultCooldown"] ?? '').toString());
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".member."})
    if ("HealthCheckType" in params) body.append(prefix+"HealthCheckType", (params["HealthCheckType"] ?? '').toString());
    if ("HealthCheckGracePeriod" in params) body.append(prefix+"HealthCheckGracePeriod", (params["HealthCheckGracePeriod"] ?? '').toString());
    if ("PlacementGroup" in params) body.append(prefix+"PlacementGroup", (params["PlacementGroup"] ?? '').toString());
    if ("VPCZoneIdentifier" in params) body.append(prefix+"VPCZoneIdentifier", (params["VPCZoneIdentifier"] ?? '').toString());
    if (params["TerminationPolicies"]) qsP.appendList(body, prefix+"TerminationPolicies", params["TerminationPolicies"], {"entryPrefix":".member."})
    if ("NewInstancesProtectedFromScaleIn" in params) body.append(prefix+"NewInstancesProtectedFromScaleIn", (params["NewInstancesProtectedFromScaleIn"] ?? '').toString());
    if ("ServiceLinkedRoleARN" in params) body.append(prefix+"ServiceLinkedRoleARN", (params["ServiceLinkedRoleARN"] ?? '').toString());
    if ("MaxInstanceLifetime" in params) body.append(prefix+"MaxInstanceLifetime", (params["MaxInstanceLifetime"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAutoScalingGroup",
    });
  }

}

// refs: 1 - tags: named, input
export interface AttachInstancesQuery {
  InstanceIds?: string[] | null;
  AutoScalingGroupName: string;
}

// refs: 1 - tags: named, input
export interface AttachLoadBalancerTargetGroupsType {
  AutoScalingGroupName: string;
  TargetGroupARNs: string[];
}

// refs: 1 - tags: named, input
export interface AttachLoadBalancersType {
  AutoScalingGroupName: string;
  LoadBalancerNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchDeleteScheduledActionType {
  AutoScalingGroupName: string;
  ScheduledActionNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchPutScheduledUpdateGroupActionType {
  AutoScalingGroupName: string;
  ScheduledUpdateGroupActions: ScheduledUpdateGroupActionRequest[];
}

// refs: 1 - tags: named, input
export interface CancelInstanceRefreshType {
  AutoScalingGroupName: string;
}

// refs: 1 - tags: named, input
export interface CompleteLifecycleActionType {
  LifecycleHookName: string;
  AutoScalingGroupName: string;
  LifecycleActionToken?: string | null;
  LifecycleActionResult: string;
  InstanceId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateAutoScalingGroupType {
  AutoScalingGroupName: string;
  LaunchConfigurationName?: string | null;
  LaunchTemplate?: LaunchTemplateSpecification | null;
  MixedInstancesPolicy?: MixedInstancesPolicy | null;
  InstanceId?: string | null;
  MinSize: number;
  MaxSize: number;
  DesiredCapacity?: number | null;
  DefaultCooldown?: number | null;
  AvailabilityZones?: string[] | null;
  LoadBalancerNames?: string[] | null;
  TargetGroupARNs?: string[] | null;
  HealthCheckType?: string | null;
  HealthCheckGracePeriod?: number | null;
  PlacementGroup?: string | null;
  VPCZoneIdentifier?: string | null;
  TerminationPolicies?: string[] | null;
  NewInstancesProtectedFromScaleIn?: boolean | null;
  LifecycleHookSpecificationList?: LifecycleHookSpecification[] | null;
  Tags?: Tag[] | null;
  ServiceLinkedRoleARN?: string | null;
  MaxInstanceLifetime?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateLaunchConfigurationType {
  LaunchConfigurationName: string;
  ImageId?: string | null;
  KeyName?: string | null;
  SecurityGroups?: string[] | null;
  ClassicLinkVPCId?: string | null;
  ClassicLinkVPCSecurityGroups?: string[] | null;
  UserData?: string | null;
  InstanceId?: string | null;
  InstanceType?: string | null;
  KernelId?: string | null;
  RamdiskId?: string | null;
  BlockDeviceMappings?: BlockDeviceMapping[] | null;
  InstanceMonitoring?: InstanceMonitoring | null;
  SpotPrice?: string | null;
  IamInstanceProfile?: string | null;
  EbsOptimized?: boolean | null;
  AssociatePublicIpAddress?: boolean | null;
  PlacementTenancy?: string | null;
  MetadataOptions?: InstanceMetadataOptions | null;
}

// refs: 1 - tags: named, input
export interface CreateOrUpdateTagsType {
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface DeleteAutoScalingGroupType {
  AutoScalingGroupName: string;
  ForceDelete?: boolean | null;
}

// refs: 1 - tags: named, input
export interface LaunchConfigurationNameType {
  LaunchConfigurationName: string;
}

// refs: 1 - tags: named, input
export interface DeleteLifecycleHookType {
  LifecycleHookName: string;
  AutoScalingGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteNotificationConfigurationType {
  AutoScalingGroupName: string;
  TopicARN: string;
}

// refs: 1 - tags: named, input
export interface DeletePolicyType {
  AutoScalingGroupName?: string | null;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface DeleteScheduledActionType {
  AutoScalingGroupName: string;
  ScheduledActionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteTagsType {
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface AutoScalingGroupNamesType {
  AutoScalingGroupNames?: string[] | null;
  NextToken?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeAutoScalingInstancesType {
  InstanceIds?: string[] | null;
  MaxRecords?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstanceRefreshesType {
  AutoScalingGroupName: string;
  InstanceRefreshIds?: string[] | null;
  NextToken?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface LaunchConfigurationNamesType {
  LaunchConfigurationNames?: string[] | null;
  NextToken?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeLifecycleHooksType {
  AutoScalingGroupName: string;
  LifecycleHookNames?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeLoadBalancerTargetGroupsRequest {
  AutoScalingGroupName: string;
  NextToken?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeLoadBalancersRequest {
  AutoScalingGroupName: string;
  NextToken?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeNotificationConfigurationsType {
  AutoScalingGroupNames?: string[] | null;
  NextToken?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribePoliciesType {
  AutoScalingGroupName?: string | null;
  PolicyNames?: string[] | null;
  PolicyTypes?: string[] | null;
  NextToken?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeScalingActivitiesType {
  ActivityIds?: string[] | null;
  AutoScalingGroupName?: string | null;
  MaxRecords?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeScheduledActionsType {
  AutoScalingGroupName?: string | null;
  ScheduledActionNames?: string[] | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  NextToken?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTagsType {
  Filters?: Filter[] | null;
  NextToken?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DetachInstancesQuery {
  InstanceIds?: string[] | null;
  AutoScalingGroupName: string;
  ShouldDecrementDesiredCapacity: boolean;
}

// refs: 1 - tags: named, input
export interface DetachLoadBalancerTargetGroupsType {
  AutoScalingGroupName: string;
  TargetGroupARNs: string[];
}

// refs: 1 - tags: named, input
export interface DetachLoadBalancersType {
  AutoScalingGroupName: string;
  LoadBalancerNames: string[];
}

// refs: 1 - tags: named, input
export interface DisableMetricsCollectionQuery {
  AutoScalingGroupName: string;
  Metrics?: string[] | null;
}

// refs: 1 - tags: named, input
export interface EnableMetricsCollectionQuery {
  AutoScalingGroupName: string;
  Metrics?: string[] | null;
  Granularity: string;
}

// refs: 1 - tags: named, input
export interface EnterStandbyQuery {
  InstanceIds?: string[] | null;
  AutoScalingGroupName: string;
  ShouldDecrementDesiredCapacity: boolean;
}

// refs: 1 - tags: named, input
export interface ExecutePolicyType {
  AutoScalingGroupName?: string | null;
  PolicyName: string;
  HonorCooldown?: boolean | null;
  MetricValue?: number | null;
  BreachThreshold?: number | null;
}

// refs: 1 - tags: named, input
export interface ExitStandbyQuery {
  InstanceIds?: string[] | null;
  AutoScalingGroupName: string;
}

// refs: 1 - tags: named, input
export interface PutLifecycleHookType {
  LifecycleHookName: string;
  AutoScalingGroupName: string;
  LifecycleTransition?: string | null;
  RoleARN?: string | null;
  NotificationTargetARN?: string | null;
  NotificationMetadata?: string | null;
  HeartbeatTimeout?: number | null;
  DefaultResult?: string | null;
}

// refs: 1 - tags: named, input
export interface PutNotificationConfigurationType {
  AutoScalingGroupName: string;
  TopicARN: string;
  NotificationTypes: string[];
}

// refs: 1 - tags: named, input
export interface PutScalingPolicyType {
  AutoScalingGroupName: string;
  PolicyName: string;
  PolicyType?: string | null;
  AdjustmentType?: string | null;
  MinAdjustmentStep?: number | null;
  MinAdjustmentMagnitude?: number | null;
  ScalingAdjustment?: number | null;
  Cooldown?: number | null;
  MetricAggregationType?: string | null;
  StepAdjustments?: StepAdjustment[] | null;
  EstimatedInstanceWarmup?: number | null;
  TargetTrackingConfiguration?: TargetTrackingConfiguration | null;
  Enabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface PutScheduledUpdateGroupActionType {
  AutoScalingGroupName: string;
  ScheduledActionName: string;
  Time?: Date | number | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Recurrence?: string | null;
  MinSize?: number | null;
  MaxSize?: number | null;
  DesiredCapacity?: number | null;
}

// refs: 1 - tags: named, input
export interface RecordLifecycleActionHeartbeatType {
  LifecycleHookName: string;
  AutoScalingGroupName: string;
  LifecycleActionToken?: string | null;
  InstanceId?: string | null;
}

// refs: 1 - tags: named, input
export interface ScalingProcessQuery {
  AutoScalingGroupName: string;
  ScalingProcesses?: string[] | null;
}

// refs: 1 - tags: named, input
export interface SetDesiredCapacityType {
  AutoScalingGroupName: string;
  DesiredCapacity: number;
  HonorCooldown?: boolean | null;
}

// refs: 1 - tags: named, input
export interface SetInstanceHealthQuery {
  InstanceId: string;
  HealthStatus: string;
  ShouldRespectGracePeriod?: boolean | null;
}

// refs: 1 - tags: named, input
export interface SetInstanceProtectionQuery {
  InstanceIds: string[];
  AutoScalingGroupName: string;
  ProtectedFromScaleIn: boolean;
}

// refs: 1 - tags: named, input
export interface StartInstanceRefreshType {
  AutoScalingGroupName: string;
  Strategy?: RefreshStrategy | null;
  Preferences?: RefreshPreferences | null;
}

// refs: 1 - tags: named, input
export interface TerminateInstanceInAutoScalingGroupType {
  InstanceId: string;
  ShouldDecrementDesiredCapacity: boolean;
}

// refs: 1 - tags: named, input
export interface UpdateAutoScalingGroupType {
  AutoScalingGroupName: string;
  LaunchConfigurationName?: string | null;
  LaunchTemplate?: LaunchTemplateSpecification | null;
  MixedInstancesPolicy?: MixedInstancesPolicy | null;
  MinSize?: number | null;
  MaxSize?: number | null;
  DesiredCapacity?: number | null;
  DefaultCooldown?: number | null;
  AvailabilityZones?: string[] | null;
  HealthCheckType?: string | null;
  HealthCheckGracePeriod?: number | null;
  PlacementGroup?: string | null;
  VPCZoneIdentifier?: string | null;
  TerminationPolicies?: string[] | null;
  NewInstancesProtectedFromScaleIn?: boolean | null;
  ServiceLinkedRoleARN?: string | null;
  MaxInstanceLifetime?: number | null;
}

// refs: 1 - tags: named, output
export interface AttachLoadBalancerTargetGroupsResultType {
}

// refs: 1 - tags: named, output
export interface AttachLoadBalancersResultType {
}

// refs: 1 - tags: named, output
export interface BatchDeleteScheduledActionAnswer {
  FailedScheduledActions: FailedScheduledUpdateGroupActionRequest[];
}

// refs: 1 - tags: named, output
export interface BatchPutScheduledUpdateGroupActionAnswer {
  FailedScheduledUpdateGroupActions: FailedScheduledUpdateGroupActionRequest[];
}

// refs: 1 - tags: named, output
export interface CancelInstanceRefreshAnswer {
  InstanceRefreshId?: string | null;
}

// refs: 1 - tags: named, output
export interface CompleteLifecycleActionAnswer {
}

// refs: 1 - tags: named, output
export interface DeleteLifecycleHookAnswer {
}

// refs: 1 - tags: named, output
export interface DescribeAccountLimitsAnswer {
  MaxNumberOfAutoScalingGroups?: number | null;
  MaxNumberOfLaunchConfigurations?: number | null;
  NumberOfAutoScalingGroups?: number | null;
  NumberOfLaunchConfigurations?: number | null;
}

// refs: 1 - tags: named, output
export interface DescribeAdjustmentTypesAnswer {
  AdjustmentTypes: AdjustmentType[];
}

// refs: 1 - tags: named, output
export interface AutoScalingGroupsType {
  AutoScalingGroups: AutoScalingGroup[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface AutoScalingInstancesType {
  AutoScalingInstances: AutoScalingInstanceDetails[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeAutoScalingNotificationTypesAnswer {
  AutoScalingNotificationTypes: string[];
}

// refs: 1 - tags: named, output
export interface DescribeInstanceRefreshesAnswer {
  InstanceRefreshes: InstanceRefresh[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface LaunchConfigurationsType {
  LaunchConfigurations: LaunchConfiguration[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLifecycleHookTypesAnswer {
  LifecycleHookTypes: string[];
}

// refs: 1 - tags: named, output
export interface DescribeLifecycleHooksAnswer {
  LifecycleHooks: LifecycleHook[];
}

// refs: 1 - tags: named, output
export interface DescribeLoadBalancerTargetGroupsResponse {
  LoadBalancerTargetGroups: LoadBalancerTargetGroupState[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLoadBalancersResponse {
  LoadBalancers: LoadBalancerState[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeMetricCollectionTypesAnswer {
  Metrics: MetricCollectionType[];
  Granularities: MetricGranularityType[];
}

// refs: 1 - tags: named, output
export interface DescribeNotificationConfigurationsAnswer {
  NotificationConfigurations: NotificationConfiguration[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PoliciesType {
  ScalingPolicies: ScalingPolicy[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ActivitiesType {
  Activities: Activity[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ProcessesType {
  Processes: ProcessType[];
}

// refs: 1 - tags: named, output
export interface ScheduledActionsType {
  ScheduledUpdateGroupActions: ScheduledUpdateGroupAction[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface TagsType {
  Tags: TagDescription[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTerminationPolicyTypesAnswer {
  TerminationPolicyTypes: string[];
}

// refs: 1 - tags: named, output
export interface DetachInstancesAnswer {
  Activities: Activity[];
}

// refs: 1 - tags: named, output
export interface DetachLoadBalancerTargetGroupsResultType {
}

// refs: 1 - tags: named, output
export interface DetachLoadBalancersResultType {
}

// refs: 1 - tags: named, output
export interface EnterStandbyAnswer {
  Activities: Activity[];
}

// refs: 1 - tags: named, output
export interface ExitStandbyAnswer {
  Activities: Activity[];
}

// refs: 1 - tags: named, output
export interface PutLifecycleHookAnswer {
}

// refs: 1 - tags: named, output
export interface PolicyARNType {
  PolicyARN?: string | null;
  Alarms: Alarm[];
}

// refs: 1 - tags: named, output
export interface RecordLifecycleActionHeartbeatAnswer {
}

// refs: 1 - tags: named, output
export interface SetInstanceProtectionAnswer {
}

// refs: 1 - tags: named, output
export interface StartInstanceRefreshAnswer {
  InstanceRefreshId?: string | null;
}

// refs: 1 - tags: named, output
export interface ActivityType {
  Activity?: Activity | null;
}

// refs: 1 - tags: input, named, interface
export interface ScheduledUpdateGroupActionRequest {
  ScheduledActionName: string;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Recurrence?: string | null;
  MinSize?: number | null;
  MaxSize?: number | null;
  DesiredCapacity?: number | null;
}
function ScheduledUpdateGroupActionRequest_Serialize(body: URLSearchParams, prefix: string, params: ScheduledUpdateGroupActionRequest) {
    body.append(prefix+".ScheduledActionName", (params["ScheduledActionName"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+".StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+".EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Recurrence" in params) body.append(prefix+".Recurrence", (params["Recurrence"] ?? '').toString());
    if ("MinSize" in params) body.append(prefix+".MinSize", (params["MinSize"] ?? '').toString());
    if ("MaxSize" in params) body.append(prefix+".MaxSize", (params["MaxSize"] ?? '').toString());
    if ("DesiredCapacity" in params) body.append(prefix+".DesiredCapacity", (params["DesiredCapacity"] ?? '').toString());
}

// refs: 8 - tags: input, named, interface, output
export interface LaunchTemplateSpecification {
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  Version?: string | null;
}
function LaunchTemplateSpecification_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateSpecification) {
    if ("LaunchTemplateId" in params) body.append(prefix+".LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+".LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("Version" in params) body.append(prefix+".Version", (params["Version"] ?? '').toString());
}
function LaunchTemplateSpecification_Parse(node: xmlP.XmlNode): LaunchTemplateSpecification {
  return node.strings({
    optional: {"LaunchTemplateId":true,"LaunchTemplateName":true,"Version":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface MixedInstancesPolicy {
  LaunchTemplate?: LaunchTemplate | null;
  InstancesDistribution?: InstancesDistribution | null;
}
function MixedInstancesPolicy_Serialize(body: URLSearchParams, prefix: string, params: MixedInstancesPolicy) {
    if (params["LaunchTemplate"] != null) LaunchTemplate_Serialize(body, prefix+".LaunchTemplate", params["LaunchTemplate"]);
    if (params["InstancesDistribution"] != null) InstancesDistribution_Serialize(body, prefix+".InstancesDistribution", params["InstancesDistribution"]);
}
function MixedInstancesPolicy_Parse(node: xmlP.XmlNode): MixedInstancesPolicy {
  return {
    LaunchTemplate: node.first("LaunchTemplate", false, LaunchTemplate_Parse),
    InstancesDistribution: node.first("InstancesDistribution", false, InstancesDistribution_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface LaunchTemplate {
  LaunchTemplateSpecification?: LaunchTemplateSpecification | null;
  Overrides: LaunchTemplateOverrides[];
}
function LaunchTemplate_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplate) {
    if (params["LaunchTemplateSpecification"] != null) LaunchTemplateSpecification_Serialize(body, prefix+".LaunchTemplateSpecification", params["LaunchTemplateSpecification"]);
    if (params["Overrides"]) qsP.appendList(body, prefix+".Overrides", params["Overrides"], {"appender":LaunchTemplateOverrides_Serialize,"entryPrefix":".member."})
}
function LaunchTemplate_Parse(node: xmlP.XmlNode): LaunchTemplate {
  return {
    LaunchTemplateSpecification: node.first("LaunchTemplateSpecification", false, LaunchTemplateSpecification_Parse),
    Overrides: node.getList("Overrides", "member").map(LaunchTemplateOverrides_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface LaunchTemplateOverrides {
  InstanceType?: string | null;
  WeightedCapacity?: string | null;
}
function LaunchTemplateOverrides_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateOverrides) {
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("WeightedCapacity" in params) body.append(prefix+".WeightedCapacity", (params["WeightedCapacity"] ?? '').toString());
}
function LaunchTemplateOverrides_Parse(node: xmlP.XmlNode): LaunchTemplateOverrides {
  return node.strings({
    optional: {"InstanceType":true,"WeightedCapacity":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface InstancesDistribution {
  OnDemandAllocationStrategy?: string | null;
  OnDemandBaseCapacity?: number | null;
  OnDemandPercentageAboveBaseCapacity?: number | null;
  SpotAllocationStrategy?: string | null;
  SpotInstancePools?: number | null;
  SpotMaxPrice?: string | null;
}
function InstancesDistribution_Serialize(body: URLSearchParams, prefix: string, params: InstancesDistribution) {
    if ("OnDemandAllocationStrategy" in params) body.append(prefix+".OnDemandAllocationStrategy", (params["OnDemandAllocationStrategy"] ?? '').toString());
    if ("OnDemandBaseCapacity" in params) body.append(prefix+".OnDemandBaseCapacity", (params["OnDemandBaseCapacity"] ?? '').toString());
    if ("OnDemandPercentageAboveBaseCapacity" in params) body.append(prefix+".OnDemandPercentageAboveBaseCapacity", (params["OnDemandPercentageAboveBaseCapacity"] ?? '').toString());
    if ("SpotAllocationStrategy" in params) body.append(prefix+".SpotAllocationStrategy", (params["SpotAllocationStrategy"] ?? '').toString());
    if ("SpotInstancePools" in params) body.append(prefix+".SpotInstancePools", (params["SpotInstancePools"] ?? '').toString());
    if ("SpotMaxPrice" in params) body.append(prefix+".SpotMaxPrice", (params["SpotMaxPrice"] ?? '').toString());
}
function InstancesDistribution_Parse(node: xmlP.XmlNode): InstancesDistribution {
  return {
    ...node.strings({
      optional: {"OnDemandAllocationStrategy":true,"SpotAllocationStrategy":true,"SpotMaxPrice":true},
    }),
    OnDemandBaseCapacity: node.first("OnDemandBaseCapacity", false, x => parseInt(x.content ?? '0')),
    OnDemandPercentageAboveBaseCapacity: node.first("OnDemandPercentageAboveBaseCapacity", false, x => parseInt(x.content ?? '0')),
    SpotInstancePools: node.first("SpotInstancePools", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: input, named, interface
export interface LifecycleHookSpecification {
  LifecycleHookName: string;
  LifecycleTransition: string;
  NotificationMetadata?: string | null;
  HeartbeatTimeout?: number | null;
  DefaultResult?: string | null;
  NotificationTargetARN?: string | null;
  RoleARN?: string | null;
}
function LifecycleHookSpecification_Serialize(body: URLSearchParams, prefix: string, params: LifecycleHookSpecification) {
    body.append(prefix+".LifecycleHookName", (params["LifecycleHookName"] ?? '').toString());
    body.append(prefix+".LifecycleTransition", (params["LifecycleTransition"] ?? '').toString());
    if ("NotificationMetadata" in params) body.append(prefix+".NotificationMetadata", (params["NotificationMetadata"] ?? '').toString());
    if ("HeartbeatTimeout" in params) body.append(prefix+".HeartbeatTimeout", (params["HeartbeatTimeout"] ?? '').toString());
    if ("DefaultResult" in params) body.append(prefix+".DefaultResult", (params["DefaultResult"] ?? '').toString());
    if ("NotificationTargetARN" in params) body.append(prefix+".NotificationTargetARN", (params["NotificationTargetARN"] ?? '').toString());
    if ("RoleARN" in params) body.append(prefix+".RoleARN", (params["RoleARN"] ?? '').toString());
}

// refs: 3 - tags: input, named, interface
export interface Tag {
  ResourceId?: string | null;
  ResourceType?: string | null;
  Key: string;
  Value?: string | null;
  PropagateAtLaunch?: boolean | null;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    if ("ResourceId" in params) body.append(prefix+".ResourceId", (params["ResourceId"] ?? '').toString());
    if ("ResourceType" in params) body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if ("PropagateAtLaunch" in params) body.append(prefix+".PropagateAtLaunch", (params["PropagateAtLaunch"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface, output
export interface BlockDeviceMapping {
  VirtualName?: string | null;
  DeviceName: string;
  Ebs?: Ebs | null;
  NoDevice?: boolean | null;
}
function BlockDeviceMapping_Serialize(body: URLSearchParams, prefix: string, params: BlockDeviceMapping) {
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
    body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if (params["Ebs"] != null) Ebs_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
}
function BlockDeviceMapping_Parse(node: xmlP.XmlNode): BlockDeviceMapping {
  return {
    ...node.strings({
      required: {"DeviceName":true},
      optional: {"VirtualName":true},
    }),
    Ebs: node.first("Ebs", false, Ebs_Parse),
    NoDevice: node.first("NoDevice", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface Ebs {
  SnapshotId?: string | null;
  VolumeSize?: number | null;
  VolumeType?: string | null;
  DeleteOnTermination?: boolean | null;
  Iops?: number | null;
  Encrypted?: boolean | null;
}
function Ebs_Serialize(body: URLSearchParams, prefix: string, params: Ebs) {
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeSize" in params) body.append(prefix+".VolumeSize", (params["VolumeSize"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+".VolumeType", (params["VolumeType"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+".Iops", (params["Iops"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+".Encrypted", (params["Encrypted"] ?? '').toString());
}
function Ebs_Parse(node: xmlP.XmlNode): Ebs {
  return {
    ...node.strings({
      optional: {"SnapshotId":true,"VolumeType":true},
    }),
    VolumeSize: node.first("VolumeSize", false, x => parseInt(x.content ?? '0')),
    DeleteOnTermination: node.first("DeleteOnTermination", false, x => x.content === 'true'),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    Encrypted: node.first("Encrypted", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface InstanceMonitoring {
  Enabled?: boolean | null;
}
function InstanceMonitoring_Serialize(body: URLSearchParams, prefix: string, params: InstanceMonitoring) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}
function InstanceMonitoring_Parse(node: xmlP.XmlNode): InstanceMonitoring {
  return {
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface InstanceMetadataOptions {
  HttpTokens?: InstanceMetadataHttpTokensState | null;
  HttpPutResponseHopLimit?: number | null;
  HttpEndpoint?: InstanceMetadataEndpointState | null;
}
function InstanceMetadataOptions_Serialize(body: URLSearchParams, prefix: string, params: InstanceMetadataOptions) {
    if ("HttpTokens" in params) body.append(prefix+".HttpTokens", (params["HttpTokens"] ?? '').toString());
    if ("HttpPutResponseHopLimit" in params) body.append(prefix+".HttpPutResponseHopLimit", (params["HttpPutResponseHopLimit"] ?? '').toString());
    if ("HttpEndpoint" in params) body.append(prefix+".HttpEndpoint", (params["HttpEndpoint"] ?? '').toString());
}
function InstanceMetadataOptions_Parse(node: xmlP.XmlNode): InstanceMetadataOptions {
  return {
    HttpTokens: node.first("HttpTokens", false, x => (x.content ?? '') as InstanceMetadataHttpTokensState),
    HttpPutResponseHopLimit: node.first("HttpPutResponseHopLimit", false, x => parseInt(x.content ?? '0')),
    HttpEndpoint: node.first("HttpEndpoint", false, x => (x.content ?? '') as InstanceMetadataEndpointState),
  };
}

// refs: 2 - tags: input, named, enum, output
export type InstanceMetadataHttpTokensState =
| "optional"
| "required"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type InstanceMetadataEndpointState =
| "disabled"
| "enabled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface Filter {
  Name?: string | null;
  Values?: string[] | null;
}
function Filter_Serialize(body: URLSearchParams, prefix: string, params: Filter) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}

// refs: 2 - tags: input, named, interface, output
export interface StepAdjustment {
  MetricIntervalLowerBound?: number | null;
  MetricIntervalUpperBound?: number | null;
  ScalingAdjustment: number;
}
function StepAdjustment_Serialize(body: URLSearchParams, prefix: string, params: StepAdjustment) {
    if ("MetricIntervalLowerBound" in params) body.append(prefix+".MetricIntervalLowerBound", (params["MetricIntervalLowerBound"] ?? '').toString());
    if ("MetricIntervalUpperBound" in params) body.append(prefix+".MetricIntervalUpperBound", (params["MetricIntervalUpperBound"] ?? '').toString());
    body.append(prefix+".ScalingAdjustment", (params["ScalingAdjustment"] ?? '').toString());
}
function StepAdjustment_Parse(node: xmlP.XmlNode): StepAdjustment {
  return {
    MetricIntervalLowerBound: node.first("MetricIntervalLowerBound", false, x => parseFloat(x.content ?? '0')),
    MetricIntervalUpperBound: node.first("MetricIntervalUpperBound", false, x => parseFloat(x.content ?? '0')),
    ScalingAdjustment: node.first("ScalingAdjustment", true, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface TargetTrackingConfiguration {
  PredefinedMetricSpecification?: PredefinedMetricSpecification | null;
  CustomizedMetricSpecification?: CustomizedMetricSpecification | null;
  TargetValue: number;
  DisableScaleIn?: boolean | null;
}
function TargetTrackingConfiguration_Serialize(body: URLSearchParams, prefix: string, params: TargetTrackingConfiguration) {
    if (params["PredefinedMetricSpecification"] != null) PredefinedMetricSpecification_Serialize(body, prefix+".PredefinedMetricSpecification", params["PredefinedMetricSpecification"]);
    if (params["CustomizedMetricSpecification"] != null) CustomizedMetricSpecification_Serialize(body, prefix+".CustomizedMetricSpecification", params["CustomizedMetricSpecification"]);
    body.append(prefix+".TargetValue", (params["TargetValue"] ?? '').toString());
    if ("DisableScaleIn" in params) body.append(prefix+".DisableScaleIn", (params["DisableScaleIn"] ?? '').toString());
}
function TargetTrackingConfiguration_Parse(node: xmlP.XmlNode): TargetTrackingConfiguration {
  return {
    PredefinedMetricSpecification: node.first("PredefinedMetricSpecification", false, PredefinedMetricSpecification_Parse),
    CustomizedMetricSpecification: node.first("CustomizedMetricSpecification", false, CustomizedMetricSpecification_Parse),
    TargetValue: node.first("TargetValue", true, x => parseFloat(x.content ?? '0')),
    DisableScaleIn: node.first("DisableScaleIn", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface PredefinedMetricSpecification {
  PredefinedMetricType: MetricType;
  ResourceLabel?: string | null;
}
function PredefinedMetricSpecification_Serialize(body: URLSearchParams, prefix: string, params: PredefinedMetricSpecification) {
    body.append(prefix+".PredefinedMetricType", (params["PredefinedMetricType"] ?? '').toString());
    if ("ResourceLabel" in params) body.append(prefix+".ResourceLabel", (params["ResourceLabel"] ?? '').toString());
}
function PredefinedMetricSpecification_Parse(node: xmlP.XmlNode): PredefinedMetricSpecification {
  return {
    ...node.strings({
      optional: {"ResourceLabel":true},
    }),
    PredefinedMetricType: node.first("PredefinedMetricType", true, x => (x.content ?? '') as MetricType),
  };
}

// refs: 2 - tags: input, named, enum, output
export type MetricType =
| "ASGAverageCPUUtilization"
| "ASGAverageNetworkIn"
| "ASGAverageNetworkOut"
| "ALBRequestCountPerTarget"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface CustomizedMetricSpecification {
  MetricName: string;
  Namespace: string;
  Dimensions: MetricDimension[];
  Statistic: MetricStatistic;
  Unit?: string | null;
}
function CustomizedMetricSpecification_Serialize(body: URLSearchParams, prefix: string, params: CustomizedMetricSpecification) {
    body.append(prefix+".MetricName", (params["MetricName"] ?? '').toString());
    body.append(prefix+".Namespace", (params["Namespace"] ?? '').toString());
    if (params["Dimensions"]) qsP.appendList(body, prefix+".Dimensions", params["Dimensions"], {"appender":MetricDimension_Serialize,"entryPrefix":".member."})
    body.append(prefix+".Statistic", (params["Statistic"] ?? '').toString());
    if ("Unit" in params) body.append(prefix+".Unit", (params["Unit"] ?? '').toString());
}
function CustomizedMetricSpecification_Parse(node: xmlP.XmlNode): CustomizedMetricSpecification {
  return {
    ...node.strings({
      required: {"MetricName":true,"Namespace":true},
      optional: {"Unit":true},
    }),
    Dimensions: node.getList("Dimensions", "member").map(MetricDimension_Parse),
    Statistic: node.first("Statistic", true, x => (x.content ?? '') as MetricStatistic),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface MetricDimension {
  Name: string;
  Value: string;
}
function MetricDimension_Serialize(body: URLSearchParams, prefix: string, params: MetricDimension) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function MetricDimension_Parse(node: xmlP.XmlNode): MetricDimension {
  return node.strings({
    required: {"Name":true,"Value":true},
  });
}

// refs: 2 - tags: input, named, enum, output
export type MetricStatistic =
| "Average"
| "Minimum"
| "Maximum"
| "SampleCount"
| "Sum"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type RefreshStrategy =
| "Rolling"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface RefreshPreferences {
  MinHealthyPercentage?: number | null;
  InstanceWarmup?: number | null;
}
function RefreshPreferences_Serialize(body: URLSearchParams, prefix: string, params: RefreshPreferences) {
    if ("MinHealthyPercentage" in params) body.append(prefix+".MinHealthyPercentage", (params["MinHealthyPercentage"] ?? '').toString());
    if ("InstanceWarmup" in params) body.append(prefix+".InstanceWarmup", (params["InstanceWarmup"] ?? '').toString());
}

// refs: 2 - tags: output, named, interface
export interface FailedScheduledUpdateGroupActionRequest {
  ScheduledActionName: string;
  ErrorCode?: string | null;
  ErrorMessage?: string | null;
}
function FailedScheduledUpdateGroupActionRequest_Parse(node: xmlP.XmlNode): FailedScheduledUpdateGroupActionRequest {
  return node.strings({
    required: {"ScheduledActionName":true},
    optional: {"ErrorCode":true,"ErrorMessage":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface AdjustmentType {
  AdjustmentType?: string | null;
}
function AdjustmentType_Parse(node: xmlP.XmlNode): AdjustmentType {
  return node.strings({
    optional: {"AdjustmentType":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface AutoScalingGroup {
  AutoScalingGroupName: string;
  AutoScalingGroupARN?: string | null;
  LaunchConfigurationName?: string | null;
  LaunchTemplate?: LaunchTemplateSpecification | null;
  MixedInstancesPolicy?: MixedInstancesPolicy | null;
  MinSize: number;
  MaxSize: number;
  DesiredCapacity: number;
  DefaultCooldown: number;
  AvailabilityZones: string[];
  LoadBalancerNames: string[];
  TargetGroupARNs: string[];
  HealthCheckType: string;
  HealthCheckGracePeriod?: number | null;
  Instances: Instance[];
  CreatedTime: Date | number;
  SuspendedProcesses: SuspendedProcess[];
  PlacementGroup?: string | null;
  VPCZoneIdentifier?: string | null;
  EnabledMetrics: EnabledMetric[];
  Status?: string | null;
  Tags: TagDescription[];
  TerminationPolicies: string[];
  NewInstancesProtectedFromScaleIn?: boolean | null;
  ServiceLinkedRoleARN?: string | null;
  MaxInstanceLifetime?: number | null;
}
function AutoScalingGroup_Parse(node: xmlP.XmlNode): AutoScalingGroup {
  return {
    ...node.strings({
      required: {"AutoScalingGroupName":true,"HealthCheckType":true},
      optional: {"AutoScalingGroupARN":true,"LaunchConfigurationName":true,"PlacementGroup":true,"VPCZoneIdentifier":true,"Status":true,"ServiceLinkedRoleARN":true},
    }),
    LaunchTemplate: node.first("LaunchTemplate", false, LaunchTemplateSpecification_Parse),
    MixedInstancesPolicy: node.first("MixedInstancesPolicy", false, MixedInstancesPolicy_Parse),
    MinSize: node.first("MinSize", true, x => parseInt(x.content ?? '0')),
    MaxSize: node.first("MaxSize", true, x => parseInt(x.content ?? '0')),
    DesiredCapacity: node.first("DesiredCapacity", true, x => parseInt(x.content ?? '0')),
    DefaultCooldown: node.first("DefaultCooldown", true, x => parseInt(x.content ?? '0')),
    AvailabilityZones: node.getList("AvailabilityZones", "member").map(x => x.content ?? ''),
    LoadBalancerNames: node.getList("LoadBalancerNames", "member").map(x => x.content ?? ''),
    TargetGroupARNs: node.getList("TargetGroupARNs", "member").map(x => x.content ?? ''),
    HealthCheckGracePeriod: node.first("HealthCheckGracePeriod", false, x => parseInt(x.content ?? '0')),
    Instances: node.getList("Instances", "member").map(Instance_Parse),
    CreatedTime: node.first("CreatedTime", true, x => xmlP.parseTimestamp(x.content)),
    SuspendedProcesses: node.getList("SuspendedProcesses", "member").map(SuspendedProcess_Parse),
    EnabledMetrics: node.getList("EnabledMetrics", "member").map(EnabledMetric_Parse),
    Tags: node.getList("Tags", "member").map(TagDescription_Parse),
    TerminationPolicies: node.getList("TerminationPolicies", "member").map(x => x.content ?? ''),
    NewInstancesProtectedFromScaleIn: node.first("NewInstancesProtectedFromScaleIn", false, x => x.content === 'true'),
    MaxInstanceLifetime: node.first("MaxInstanceLifetime", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface Instance {
  InstanceId: string;
  InstanceType?: string | null;
  AvailabilityZone: string;
  LifecycleState: LifecycleState;
  HealthStatus: string;
  LaunchConfigurationName?: string | null;
  LaunchTemplate?: LaunchTemplateSpecification | null;
  ProtectedFromScaleIn: boolean;
  WeightedCapacity?: string | null;
}
function Instance_Parse(node: xmlP.XmlNode): Instance {
  return {
    ...node.strings({
      required: {"InstanceId":true,"AvailabilityZone":true,"HealthStatus":true},
      optional: {"InstanceType":true,"LaunchConfigurationName":true,"WeightedCapacity":true},
    }),
    LifecycleState: node.first("LifecycleState", true, x => (x.content ?? '') as LifecycleState),
    LaunchTemplate: node.first("LaunchTemplate", false, LaunchTemplateSpecification_Parse),
    ProtectedFromScaleIn: node.first("ProtectedFromScaleIn", true, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, enum
export type LifecycleState =
| "Pending"
| "Pending:Wait"
| "Pending:Proceed"
| "Quarantined"
| "InService"
| "Terminating"
| "Terminating:Wait"
| "Terminating:Proceed"
| "Terminated"
| "Detaching"
| "Detached"
| "EnteringStandby"
| "Standby"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface SuspendedProcess {
  ProcessName?: string | null;
  SuspensionReason?: string | null;
}
function SuspendedProcess_Parse(node: xmlP.XmlNode): SuspendedProcess {
  return node.strings({
    optional: {"ProcessName":true,"SuspensionReason":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface EnabledMetric {
  Metric?: string | null;
  Granularity?: string | null;
}
function EnabledMetric_Parse(node: xmlP.XmlNode): EnabledMetric {
  return node.strings({
    optional: {"Metric":true,"Granularity":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface TagDescription {
  ResourceId?: string | null;
  ResourceType?: string | null;
  Key?: string | null;
  Value?: string | null;
  PropagateAtLaunch?: boolean | null;
}
function TagDescription_Parse(node: xmlP.XmlNode): TagDescription {
  return {
    ...node.strings({
      optional: {"ResourceId":true,"ResourceType":true,"Key":true,"Value":true},
    }),
    PropagateAtLaunch: node.first("PropagateAtLaunch", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface AutoScalingInstanceDetails {
  InstanceId: string;
  InstanceType?: string | null;
  AutoScalingGroupName: string;
  AvailabilityZone: string;
  LifecycleState: string;
  HealthStatus: string;
  LaunchConfigurationName?: string | null;
  LaunchTemplate?: LaunchTemplateSpecification | null;
  ProtectedFromScaleIn: boolean;
  WeightedCapacity?: string | null;
}
function AutoScalingInstanceDetails_Parse(node: xmlP.XmlNode): AutoScalingInstanceDetails {
  return {
    ...node.strings({
      required: {"InstanceId":true,"AutoScalingGroupName":true,"AvailabilityZone":true,"LifecycleState":true,"HealthStatus":true},
      optional: {"InstanceType":true,"LaunchConfigurationName":true,"WeightedCapacity":true},
    }),
    LaunchTemplate: node.first("LaunchTemplate", false, LaunchTemplateSpecification_Parse),
    ProtectedFromScaleIn: node.first("ProtectedFromScaleIn", true, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface InstanceRefresh {
  InstanceRefreshId?: string | null;
  AutoScalingGroupName?: string | null;
  Status?: InstanceRefreshStatus | null;
  StatusReason?: string | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  PercentageComplete?: number | null;
  InstancesToUpdate?: number | null;
}
function InstanceRefresh_Parse(node: xmlP.XmlNode): InstanceRefresh {
  return {
    ...node.strings({
      optional: {"InstanceRefreshId":true,"AutoScalingGroupName":true,"StatusReason":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as InstanceRefreshStatus),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", false, x => xmlP.parseTimestamp(x.content)),
    PercentageComplete: node.first("PercentageComplete", false, x => parseInt(x.content ?? '0')),
    InstancesToUpdate: node.first("InstancesToUpdate", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, enum
export type InstanceRefreshStatus =
| "Pending"
| "InProgress"
| "Successful"
| "Failed"
| "Cancelling"
| "Cancelled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface LaunchConfiguration {
  LaunchConfigurationName: string;
  LaunchConfigurationARN?: string | null;
  ImageId: string;
  KeyName?: string | null;
  SecurityGroups: string[];
  ClassicLinkVPCId?: string | null;
  ClassicLinkVPCSecurityGroups: string[];
  UserData?: string | null;
  InstanceType: string;
  KernelId?: string | null;
  RamdiskId?: string | null;
  BlockDeviceMappings: BlockDeviceMapping[];
  InstanceMonitoring?: InstanceMonitoring | null;
  SpotPrice?: string | null;
  IamInstanceProfile?: string | null;
  CreatedTime: Date | number;
  EbsOptimized?: boolean | null;
  AssociatePublicIpAddress?: boolean | null;
  PlacementTenancy?: string | null;
  MetadataOptions?: InstanceMetadataOptions | null;
}
function LaunchConfiguration_Parse(node: xmlP.XmlNode): LaunchConfiguration {
  return {
    ...node.strings({
      required: {"LaunchConfigurationName":true,"ImageId":true,"InstanceType":true},
      optional: {"LaunchConfigurationARN":true,"KeyName":true,"ClassicLinkVPCId":true,"UserData":true,"KernelId":true,"RamdiskId":true,"SpotPrice":true,"IamInstanceProfile":true,"PlacementTenancy":true},
    }),
    SecurityGroups: node.getList("SecurityGroups", "member").map(x => x.content ?? ''),
    ClassicLinkVPCSecurityGroups: node.getList("ClassicLinkVPCSecurityGroups", "member").map(x => x.content ?? ''),
    BlockDeviceMappings: node.getList("BlockDeviceMappings", "member").map(BlockDeviceMapping_Parse),
    InstanceMonitoring: node.first("InstanceMonitoring", false, InstanceMonitoring_Parse),
    CreatedTime: node.first("CreatedTime", true, x => xmlP.parseTimestamp(x.content)),
    EbsOptimized: node.first("EbsOptimized", false, x => x.content === 'true'),
    AssociatePublicIpAddress: node.first("AssociatePublicIpAddress", false, x => x.content === 'true'),
    MetadataOptions: node.first("MetadataOptions", false, InstanceMetadataOptions_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface LifecycleHook {
  LifecycleHookName?: string | null;
  AutoScalingGroupName?: string | null;
  LifecycleTransition?: string | null;
  NotificationTargetARN?: string | null;
  RoleARN?: string | null;
  NotificationMetadata?: string | null;
  HeartbeatTimeout?: number | null;
  GlobalTimeout?: number | null;
  DefaultResult?: string | null;
}
function LifecycleHook_Parse(node: xmlP.XmlNode): LifecycleHook {
  return {
    ...node.strings({
      optional: {"LifecycleHookName":true,"AutoScalingGroupName":true,"LifecycleTransition":true,"NotificationTargetARN":true,"RoleARN":true,"NotificationMetadata":true,"DefaultResult":true},
    }),
    HeartbeatTimeout: node.first("HeartbeatTimeout", false, x => parseInt(x.content ?? '0')),
    GlobalTimeout: node.first("GlobalTimeout", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface LoadBalancerTargetGroupState {
  LoadBalancerTargetGroupARN?: string | null;
  State?: string | null;
}
function LoadBalancerTargetGroupState_Parse(node: xmlP.XmlNode): LoadBalancerTargetGroupState {
  return node.strings({
    optional: {"LoadBalancerTargetGroupARN":true,"State":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface LoadBalancerState {
  LoadBalancerName?: string | null;
  State?: string | null;
}
function LoadBalancerState_Parse(node: xmlP.XmlNode): LoadBalancerState {
  return node.strings({
    optional: {"LoadBalancerName":true,"State":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface MetricCollectionType {
  Metric?: string | null;
}
function MetricCollectionType_Parse(node: xmlP.XmlNode): MetricCollectionType {
  return node.strings({
    optional: {"Metric":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface MetricGranularityType {
  Granularity?: string | null;
}
function MetricGranularityType_Parse(node: xmlP.XmlNode): MetricGranularityType {
  return node.strings({
    optional: {"Granularity":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface NotificationConfiguration {
  AutoScalingGroupName?: string | null;
  TopicARN?: string | null;
  NotificationType?: string | null;
}
function NotificationConfiguration_Parse(node: xmlP.XmlNode): NotificationConfiguration {
  return node.strings({
    optional: {"AutoScalingGroupName":true,"TopicARN":true,"NotificationType":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface ScalingPolicy {
  AutoScalingGroupName?: string | null;
  PolicyName?: string | null;
  PolicyARN?: string | null;
  PolicyType?: string | null;
  AdjustmentType?: string | null;
  MinAdjustmentStep?: number | null;
  MinAdjustmentMagnitude?: number | null;
  ScalingAdjustment?: number | null;
  Cooldown?: number | null;
  StepAdjustments: StepAdjustment[];
  MetricAggregationType?: string | null;
  EstimatedInstanceWarmup?: number | null;
  Alarms: Alarm[];
  TargetTrackingConfiguration?: TargetTrackingConfiguration | null;
  Enabled?: boolean | null;
}
function ScalingPolicy_Parse(node: xmlP.XmlNode): ScalingPolicy {
  return {
    ...node.strings({
      optional: {"AutoScalingGroupName":true,"PolicyName":true,"PolicyARN":true,"PolicyType":true,"AdjustmentType":true,"MetricAggregationType":true},
    }),
    MinAdjustmentStep: node.first("MinAdjustmentStep", false, x => parseInt(x.content ?? '0')),
    MinAdjustmentMagnitude: node.first("MinAdjustmentMagnitude", false, x => parseInt(x.content ?? '0')),
    ScalingAdjustment: node.first("ScalingAdjustment", false, x => parseInt(x.content ?? '0')),
    Cooldown: node.first("Cooldown", false, x => parseInt(x.content ?? '0')),
    StepAdjustments: node.getList("StepAdjustments", "member").map(StepAdjustment_Parse),
    EstimatedInstanceWarmup: node.first("EstimatedInstanceWarmup", false, x => parseInt(x.content ?? '0')),
    Alarms: node.getList("Alarms", "member").map(Alarm_Parse),
    TargetTrackingConfiguration: node.first("TargetTrackingConfiguration", false, TargetTrackingConfiguration_Parse),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface Alarm {
  AlarmName?: string | null;
  AlarmARN?: string | null;
}
function Alarm_Parse(node: xmlP.XmlNode): Alarm {
  return node.strings({
    optional: {"AlarmName":true,"AlarmARN":true},
  });
}

// refs: 5 - tags: output, named, interface
export interface Activity {
  ActivityId: string;
  AutoScalingGroupName: string;
  Description?: string | null;
  Cause: string;
  StartTime: Date | number;
  EndTime?: Date | number | null;
  StatusCode: ScalingActivityStatusCode;
  StatusMessage?: string | null;
  Progress?: number | null;
  Details?: string | null;
}
function Activity_Parse(node: xmlP.XmlNode): Activity {
  return {
    ...node.strings({
      required: {"ActivityId":true,"AutoScalingGroupName":true,"Cause":true},
      optional: {"Description":true,"StatusMessage":true,"Details":true},
    }),
    StartTime: node.first("StartTime", true, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", false, x => xmlP.parseTimestamp(x.content)),
    StatusCode: node.first("StatusCode", true, x => (x.content ?? '') as ScalingActivityStatusCode),
    Progress: node.first("Progress", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 5 - tags: output, named, enum
export type ScalingActivityStatusCode =
| "PendingSpotBidPlacement"
| "WaitingForSpotInstanceRequestId"
| "WaitingForSpotInstanceId"
| "WaitingForInstanceId"
| "PreInService"
| "InProgress"
| "WaitingForELBConnectionDraining"
| "MidLifecycleAction"
| "WaitingForInstanceWarmup"
| "Successful"
| "Failed"
| "Cancelled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ProcessType {
  ProcessName: string;
}
function ProcessType_Parse(node: xmlP.XmlNode): ProcessType {
  return node.strings({
    required: {"ProcessName":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface ScheduledUpdateGroupAction {
  AutoScalingGroupName?: string | null;
  ScheduledActionName?: string | null;
  ScheduledActionARN?: string | null;
  Time?: Date | number | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Recurrence?: string | null;
  MinSize?: number | null;
  MaxSize?: number | null;
  DesiredCapacity?: number | null;
}
function ScheduledUpdateGroupAction_Parse(node: xmlP.XmlNode): ScheduledUpdateGroupAction {
  return {
    ...node.strings({
      optional: {"AutoScalingGroupName":true,"ScheduledActionName":true,"ScheduledActionARN":true,"Recurrence":true},
    }),
    Time: node.first("Time", false, x => xmlP.parseTimestamp(x.content)),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("EndTime", false, x => xmlP.parseTimestamp(x.content)),
    MinSize: node.first("MinSize", false, x => parseInt(x.content ?? '0')),
    MaxSize: node.first("MaxSize", false, x => parseInt(x.content ?? '0')),
    DesiredCapacity: node.first("DesiredCapacity", false, x => parseInt(x.content ?? '0')),
  };
}
