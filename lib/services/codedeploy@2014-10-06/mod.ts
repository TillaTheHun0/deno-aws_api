// Autogenerated API client for: AWS CodeDeploy

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class CodeDeploy {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodeDeploy.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2014-10-06",
    "endpointPrefix": "codedeploy",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "CodeDeploy",
    "serviceFullName": "AWS CodeDeploy",
    "serviceId": "CodeDeploy",
    "signatureVersion": "v4",
    "targetPrefix": "CodeDeploy_20141006",
    "uid": "codedeploy-2014-10-06"
  };

  async addTagsToOnPremisesInstances(
    {abortSignal, ...params}: RequestConfig & s.AddTagsToOnPremisesInstancesInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["tags"]?.map(x => fromTag(x)),
      instanceNames: params["instanceNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToOnPremisesInstances",
    });
  }

  async batchGetApplicationRevisions(
    {abortSignal, ...params}: RequestConfig & s.BatchGetApplicationRevisionsInput,
  ): Promise<s.BatchGetApplicationRevisionsOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      revisions: params["revisions"]?.map(x => fromRevisionLocation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetApplicationRevisions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationName": "s",
        "errorMessage": "s",
        "revisions": [toRevisionInfo],
      },
    }, await resp.json());
  }

  async batchGetApplications(
    {abortSignal, ...params}: RequestConfig & s.BatchGetApplicationsInput,
  ): Promise<s.BatchGetApplicationsOutput> {
    const body: jsonP.JSONObject = {
      applicationNames: params["applicationNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetApplications",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationsInfo": [toApplicationInfo],
      },
    }, await resp.json());
  }

  async batchGetDeploymentGroups(
    {abortSignal, ...params}: RequestConfig & s.BatchGetDeploymentGroupsInput,
  ): Promise<s.BatchGetDeploymentGroupsOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      deploymentGroupNames: params["deploymentGroupNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDeploymentGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentGroupsInfo": [toDeploymentGroupInfo],
        "errorMessage": "s",
      },
    }, await resp.json());
  }

  async batchGetDeploymentInstances(
    {abortSignal, ...params}: RequestConfig & s.BatchGetDeploymentInstancesInput,
  ): Promise<s.BatchGetDeploymentInstancesOutput> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
      instanceIds: params["instanceIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDeploymentInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instancesSummary": [toInstanceSummary],
        "errorMessage": "s",
      },
    }, await resp.json());
  }

  async batchGetDeploymentTargets(
    {abortSignal, ...params}: RequestConfig & s.BatchGetDeploymentTargetsInput = {},
  ): Promise<s.BatchGetDeploymentTargetsOutput> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
      targetIds: params["targetIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDeploymentTargets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentTargets": [toDeploymentTarget],
      },
    }, await resp.json());
  }

  async batchGetDeployments(
    {abortSignal, ...params}: RequestConfig & s.BatchGetDeploymentsInput,
  ): Promise<s.BatchGetDeploymentsOutput> {
    const body: jsonP.JSONObject = {
      deploymentIds: params["deploymentIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDeployments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentsInfo": [toDeploymentInfo],
      },
    }, await resp.json());
  }

  async batchGetOnPremisesInstances(
    {abortSignal, ...params}: RequestConfig & s.BatchGetOnPremisesInstancesInput,
  ): Promise<s.BatchGetOnPremisesInstancesOutput> {
    const body: jsonP.JSONObject = {
      instanceNames: params["instanceNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetOnPremisesInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceInfos": [toInstanceInfo],
      },
    }, await resp.json());
  }

  async continueDeployment(
    {abortSignal, ...params}: RequestConfig & s.ContinueDeploymentInput = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
      deploymentWaitType: params["deploymentWaitType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ContinueDeployment",
    });
  }

  async createApplication(
    {abortSignal, ...params}: RequestConfig & s.CreateApplicationInput,
  ): Promise<s.CreateApplicationOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      computePlatform: params["computePlatform"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationId": "s",
      },
    }, await resp.json());
  }

  async createDeployment(
    {abortSignal, ...params}: RequestConfig & s.CreateDeploymentInput,
  ): Promise<s.CreateDeploymentOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
      revision: fromRevisionLocation(params["revision"]),
      deploymentConfigName: params["deploymentConfigName"],
      description: params["description"],
      ignoreApplicationStopFailures: params["ignoreApplicationStopFailures"],
      targetInstances: fromTargetInstances(params["targetInstances"]),
      autoRollbackConfiguration: fromAutoRollbackConfiguration(params["autoRollbackConfiguration"]),
      updateOutdatedInstancesOnly: params["updateOutdatedInstancesOnly"],
      fileExistsBehavior: params["fileExistsBehavior"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeployment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentId": "s",
      },
    }, await resp.json());
  }

  async createDeploymentConfig(
    {abortSignal, ...params}: RequestConfig & s.CreateDeploymentConfigInput,
  ): Promise<s.CreateDeploymentConfigOutput> {
    const body: jsonP.JSONObject = {
      deploymentConfigName: params["deploymentConfigName"],
      minimumHealthyHosts: fromMinimumHealthyHosts(params["minimumHealthyHosts"]),
      trafficRoutingConfig: fromTrafficRoutingConfig(params["trafficRoutingConfig"]),
      computePlatform: params["computePlatform"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeploymentConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentConfigId": "s",
      },
    }, await resp.json());
  }

  async createDeploymentGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateDeploymentGroupInput,
  ): Promise<s.CreateDeploymentGroupOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
      deploymentConfigName: params["deploymentConfigName"],
      ec2TagFilters: params["ec2TagFilters"]?.map(x => fromEC2TagFilter(x)),
      onPremisesInstanceTagFilters: params["onPremisesInstanceTagFilters"]?.map(x => fromTagFilter(x)),
      autoScalingGroups: params["autoScalingGroups"],
      serviceRoleArn: params["serviceRoleArn"],
      triggerConfigurations: params["triggerConfigurations"]?.map(x => fromTriggerConfig(x)),
      alarmConfiguration: fromAlarmConfiguration(params["alarmConfiguration"]),
      autoRollbackConfiguration: fromAutoRollbackConfiguration(params["autoRollbackConfiguration"]),
      deploymentStyle: fromDeploymentStyle(params["deploymentStyle"]),
      blueGreenDeploymentConfiguration: fromBlueGreenDeploymentConfiguration(params["blueGreenDeploymentConfiguration"]),
      loadBalancerInfo: fromLoadBalancerInfo(params["loadBalancerInfo"]),
      ec2TagSet: fromEC2TagSet(params["ec2TagSet"]),
      ecsServices: params["ecsServices"]?.map(x => fromECSService(x)),
      onPremisesTagSet: fromOnPremisesTagSet(params["onPremisesTagSet"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeploymentGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentGroupId": "s",
      },
    }, await resp.json());
  }

  async deleteApplication(
    {abortSignal, ...params}: RequestConfig & s.DeleteApplicationInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplication",
    });
  }

  async deleteDeploymentConfig(
    {abortSignal, ...params}: RequestConfig & s.DeleteDeploymentConfigInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      deploymentConfigName: params["deploymentConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDeploymentConfig",
    });
  }

  async deleteDeploymentGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteDeploymentGroupInput,
  ): Promise<s.DeleteDeploymentGroupOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDeploymentGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "hooksNotCleanedUp": [toAutoScalingGroup],
      },
    }, await resp.json());
  }

  async deleteGitHubAccountToken(
    {abortSignal, ...params}: RequestConfig & s.DeleteGitHubAccountTokenInput = {},
  ): Promise<s.DeleteGitHubAccountTokenOutput> {
    const body: jsonP.JSONObject = {
      tokenName: params["tokenName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGitHubAccountToken",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tokenName": "s",
      },
    }, await resp.json());
  }

  async deleteResourcesByExternalId(
    {abortSignal, ...params}: RequestConfig & s.DeleteResourcesByExternalIdInput = {},
  ): Promise<s.DeleteResourcesByExternalIdOutput> {
    const body: jsonP.JSONObject = {
      externalId: params["externalId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourcesByExternalId",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deregisterOnPremisesInstance(
    {abortSignal, ...params}: RequestConfig & s.DeregisterOnPremisesInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterOnPremisesInstance",
    });
  }

  async getApplication(
    {abortSignal, ...params}: RequestConfig & s.GetApplicationInput,
  ): Promise<s.GetApplicationOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "application": toApplicationInfo,
      },
    }, await resp.json());
  }

  async getApplicationRevision(
    {abortSignal, ...params}: RequestConfig & s.GetApplicationRevisionInput,
  ): Promise<s.GetApplicationRevisionOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      revision: fromRevisionLocation(params["revision"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetApplicationRevision",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationName": "s",
        "revision": toRevisionLocation,
        "revisionInfo": toGenericRevisionInfo,
      },
    }, await resp.json());
  }

  async getDeployment(
    {abortSignal, ...params}: RequestConfig & s.GetDeploymentInput,
  ): Promise<s.GetDeploymentOutput> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeployment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentInfo": toDeploymentInfo,
      },
    }, await resp.json());
  }

  async getDeploymentConfig(
    {abortSignal, ...params}: RequestConfig & s.GetDeploymentConfigInput,
  ): Promise<s.GetDeploymentConfigOutput> {
    const body: jsonP.JSONObject = {
      deploymentConfigName: params["deploymentConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeploymentConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentConfigInfo": toDeploymentConfigInfo,
      },
    }, await resp.json());
  }

  async getDeploymentGroup(
    {abortSignal, ...params}: RequestConfig & s.GetDeploymentGroupInput,
  ): Promise<s.GetDeploymentGroupOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeploymentGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentGroupInfo": toDeploymentGroupInfo,
      },
    }, await resp.json());
  }

  async getDeploymentInstance(
    {abortSignal, ...params}: RequestConfig & s.GetDeploymentInstanceInput,
  ): Promise<s.GetDeploymentInstanceOutput> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
      instanceId: params["instanceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeploymentInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceSummary": toInstanceSummary,
      },
    }, await resp.json());
  }

  async getDeploymentTarget(
    {abortSignal, ...params}: RequestConfig & s.GetDeploymentTargetInput = {},
  ): Promise<s.GetDeploymentTargetOutput> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
      targetId: params["targetId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeploymentTarget",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentTarget": toDeploymentTarget,
      },
    }, await resp.json());
  }

  async getOnPremisesInstance(
    {abortSignal, ...params}: RequestConfig & s.GetOnPremisesInstanceInput,
  ): Promise<s.GetOnPremisesInstanceOutput> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOnPremisesInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceInfo": toInstanceInfo,
      },
    }, await resp.json());
  }

  async listApplicationRevisions(
    {abortSignal, ...params}: RequestConfig & s.ListApplicationRevisionsInput,
  ): Promise<s.ListApplicationRevisionsOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      sortBy: params["sortBy"],
      sortOrder: params["sortOrder"],
      s3Bucket: params["s3Bucket"],
      s3KeyPrefix: params["s3KeyPrefix"],
      deployed: params["deployed"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListApplicationRevisions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "revisions": [toRevisionLocation],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listApplications(
    {abortSignal, ...params}: RequestConfig & s.ListApplicationsInput = {},
  ): Promise<s.ListApplicationsOutput> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListApplications",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applications": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeploymentConfigs(
    {abortSignal, ...params}: RequestConfig & s.ListDeploymentConfigsInput = {},
  ): Promise<s.ListDeploymentConfigsOutput> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeploymentConfigs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentConfigsList": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeploymentGroups(
    {abortSignal, ...params}: RequestConfig & s.ListDeploymentGroupsInput,
  ): Promise<s.ListDeploymentGroupsOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeploymentGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationName": "s",
        "deploymentGroups": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeploymentInstances(
    {abortSignal, ...params}: RequestConfig & s.ListDeploymentInstancesInput,
  ): Promise<s.ListDeploymentInstancesOutput> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
      nextToken: params["nextToken"],
      instanceStatusFilter: params["instanceStatusFilter"],
      instanceTypeFilter: params["instanceTypeFilter"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeploymentInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instancesList": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeploymentTargets(
    {abortSignal, ...params}: RequestConfig & s.ListDeploymentTargetsInput = {},
  ): Promise<s.ListDeploymentTargetsOutput> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
      nextToken: params["nextToken"],
      targetFilters: params["targetFilters"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeploymentTargets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "targetIds": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeployments(
    {abortSignal, ...params}: RequestConfig & s.ListDeploymentsInput = {},
  ): Promise<s.ListDeploymentsOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
      externalId: params["externalId"],
      includeOnlyStatuses: params["includeOnlyStatuses"],
      createTimeRange: fromTimeRange(params["createTimeRange"]),
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeployments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deployments": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listGitHubAccountTokenNames(
    {abortSignal, ...params}: RequestConfig & s.ListGitHubAccountTokenNamesInput = {},
  ): Promise<s.ListGitHubAccountTokenNamesOutput> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGitHubAccountTokenNames",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tokenNameList": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listOnPremisesInstances(
    {abortSignal, ...params}: RequestConfig & s.ListOnPremisesInstancesInput = {},
  ): Promise<s.ListOnPremisesInstancesOutput> {
    const body: jsonP.JSONObject = {
      registrationStatus: params["registrationStatus"],
      tagFilters: params["tagFilters"]?.map(x => fromTagFilter(x)),
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListOnPremisesInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceInput,
  ): Promise<s.ListTagsForResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putLifecycleEventHookExecutionStatus(
    {abortSignal, ...params}: RequestConfig & s.PutLifecycleEventHookExecutionStatusInput = {},
  ): Promise<s.PutLifecycleEventHookExecutionStatusOutput> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
      lifecycleEventHookExecutionId: params["lifecycleEventHookExecutionId"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLifecycleEventHookExecutionStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "lifecycleEventHookExecutionId": "s",
      },
    }, await resp.json());
  }

  async registerApplicationRevision(
    {abortSignal, ...params}: RequestConfig & s.RegisterApplicationRevisionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      description: params["description"],
      revision: fromRevisionLocation(params["revision"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterApplicationRevision",
    });
  }

  async registerOnPremisesInstance(
    {abortSignal, ...params}: RequestConfig & s.RegisterOnPremisesInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
      iamSessionArn: params["iamSessionArn"],
      iamUserArn: params["iamUserArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterOnPremisesInstance",
    });
  }

  async removeTagsFromOnPremisesInstances(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsFromOnPremisesInstancesInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["tags"]?.map(x => fromTag(x)),
      instanceNames: params["instanceNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromOnPremisesInstances",
    });
  }

  async skipWaitTimeForInstanceTermination(
    {abortSignal, ...params}: RequestConfig & s.SkipWaitTimeForInstanceTerminationInput = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SkipWaitTimeForInstanceTermination",
    });
  }

  async stopDeployment(
    {abortSignal, ...params}: RequestConfig & s.StopDeploymentInput,
  ): Promise<s.StopDeploymentOutput> {
    const body: jsonP.JSONObject = {
      deploymentId: params["deploymentId"],
      autoRollbackEnabled: params["autoRollbackEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopDeployment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.StopStatus>(x),
        "statusMessage": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceInput,
  ): Promise<s.TagResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceInput,
  ): Promise<s.UntagResourceOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateApplication(
    {abortSignal, ...params}: RequestConfig & s.UpdateApplicationInput = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      newApplicationName: params["newApplicationName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApplication",
    });
  }

  async updateDeploymentGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateDeploymentGroupInput,
  ): Promise<s.UpdateDeploymentGroupOutput> {
    const body: jsonP.JSONObject = {
      applicationName: params["applicationName"],
      currentDeploymentGroupName: params["currentDeploymentGroupName"],
      newDeploymentGroupName: params["newDeploymentGroupName"],
      deploymentConfigName: params["deploymentConfigName"],
      ec2TagFilters: params["ec2TagFilters"]?.map(x => fromEC2TagFilter(x)),
      onPremisesInstanceTagFilters: params["onPremisesInstanceTagFilters"]?.map(x => fromTagFilter(x)),
      autoScalingGroups: params["autoScalingGroups"],
      serviceRoleArn: params["serviceRoleArn"],
      triggerConfigurations: params["triggerConfigurations"]?.map(x => fromTriggerConfig(x)),
      alarmConfiguration: fromAlarmConfiguration(params["alarmConfiguration"]),
      autoRollbackConfiguration: fromAutoRollbackConfiguration(params["autoRollbackConfiguration"]),
      deploymentStyle: fromDeploymentStyle(params["deploymentStyle"]),
      blueGreenDeploymentConfiguration: fromBlueGreenDeploymentConfiguration(params["blueGreenDeploymentConfiguration"]),
      loadBalancerInfo: fromLoadBalancerInfo(params["loadBalancerInfo"]),
      ec2TagSet: fromEC2TagSet(params["ec2TagSet"]),
      ecsServices: params["ecsServices"]?.map(x => fromECSService(x)),
      onPremisesTagSet: fromOnPremisesTagSet(params["onPremisesTagSet"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDeploymentGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "hooksNotCleanedUp": [toAutoScalingGroup],
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 120 times, 15 seconds apart (about 30 minutes max wait time). */
  async waitForDeploymentSuccessful(
    params: RequestConfig & s.GetDeploymentInput,
  ): Promise<s.GetDeploymentOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DeploymentSuccessful';
    for (let i = 0; i < 120; i++) {
      const resp = await this.getDeployment(params);
      const field = resp?.deploymentInfo?.status;
      if (field === "Succeeded") return resp;
      if (field === "Failed") throw new Error(errMessage);
      if (field === "Stopped") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromRevisionLocation(input?: s.RevisionLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    revisionType: input["revisionType"],
    s3Location: fromS3Location(input["s3Location"]),
    gitHubLocation: fromGitHubLocation(input["gitHubLocation"]),
    string: fromRawString(input["string"]),
    appSpecContent: fromAppSpecContent(input["appSpecContent"]),
  }
}
function toRevisionLocation(root: jsonP.JSONValue): s.RevisionLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "revisionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RevisionLocationType>(x),
      "s3Location": toS3Location,
      "gitHubLocation": toGitHubLocation,
      "string": toRawString,
      "appSpecContent": toAppSpecContent,
    },
  }, root);
}

function fromS3Location(input?: s.S3Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    key: input["key"],
    bundleType: input["bundleType"],
    version: input["version"],
    eTag: input["eTag"],
  }
}
function toS3Location(root: jsonP.JSONValue): s.S3Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "key": "s",
      "bundleType": (x: jsonP.JSONValue) => cmnP.readEnum<s.BundleType>(x),
      "version": "s",
      "eTag": "s",
    },
  }, root);
}

function fromGitHubLocation(input?: s.GitHubLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    repository: input["repository"],
    commitId: input["commitId"],
  }
}
function toGitHubLocation(root: jsonP.JSONValue): s.GitHubLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "repository": "s",
      "commitId": "s",
    },
  }, root);
}

function fromRawString(input?: s.RawString | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    content: input["content"],
    sha256: input["sha256"],
  }
}
function toRawString(root: jsonP.JSONValue): s.RawString {
  return jsonP.readObj({
    required: {},
    optional: {
      "content": "s",
      "sha256": "s",
    },
  }, root);
}

function fromAppSpecContent(input?: s.AppSpecContent | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    content: input["content"],
    sha256: input["sha256"],
  }
}
function toAppSpecContent(root: jsonP.JSONValue): s.AppSpecContent {
  return jsonP.readObj({
    required: {},
    optional: {
      "content": "s",
      "sha256": "s",
    },
  }, root);
}

function fromTargetInstances(input?: s.TargetInstances | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tagFilters: input["tagFilters"]?.map(x => fromEC2TagFilter(x)),
    autoScalingGroups: input["autoScalingGroups"],
    ec2TagSet: fromEC2TagSet(input["ec2TagSet"]),
  }
}
function toTargetInstances(root: jsonP.JSONValue): s.TargetInstances {
  return jsonP.readObj({
    required: {},
    optional: {
      "tagFilters": [toEC2TagFilter],
      "autoScalingGroups": ["s"],
      "ec2TagSet": toEC2TagSet,
    },
  }, root);
}

function fromEC2TagFilter(input?: s.EC2TagFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Type: input["Type"],
  }
}
function toEC2TagFilter(root: jsonP.JSONValue): s.EC2TagFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EC2TagFilterType>(x),
    },
  }, root);
}

function fromEC2TagSet(input?: s.EC2TagSet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ec2TagSetList: input["ec2TagSetList"]?.map(x => x?.map(fromEC2TagFilter)),
  }
}
function toEC2TagSet(root: jsonP.JSONValue): s.EC2TagSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "ec2TagSetList": [x => jsonP.readList(toEC2TagFilter, x)],
    },
  }, root);
}

function fromAutoRollbackConfiguration(input?: s.AutoRollbackConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
    events: input["events"],
  }
}
function toAutoRollbackConfiguration(root: jsonP.JSONValue): s.AutoRollbackConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "enabled": "b",
      "events": [(x: jsonP.JSONValue) => cmnP.readEnum<s.AutoRollbackEvent>(x)],
    },
  }, root);
}

function fromMinimumHealthyHosts(input?: s.MinimumHealthyHosts | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    type: input["type"],
  }
}
function toMinimumHealthyHosts(root: jsonP.JSONValue): s.MinimumHealthyHosts {
  return jsonP.readObj({
    required: {},
    optional: {
      "value": "n",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.MinimumHealthyHostsType>(x),
    },
  }, root);
}

function fromTrafficRoutingConfig(input?: s.TrafficRoutingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    timeBasedCanary: fromTimeBasedCanary(input["timeBasedCanary"]),
    timeBasedLinear: fromTimeBasedLinear(input["timeBasedLinear"]),
  }
}
function toTrafficRoutingConfig(root: jsonP.JSONValue): s.TrafficRoutingConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrafficRoutingType>(x),
      "timeBasedCanary": toTimeBasedCanary,
      "timeBasedLinear": toTimeBasedLinear,
    },
  }, root);
}

function fromTimeBasedCanary(input?: s.TimeBasedCanary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    canaryPercentage: input["canaryPercentage"],
    canaryInterval: input["canaryInterval"],
  }
}
function toTimeBasedCanary(root: jsonP.JSONValue): s.TimeBasedCanary {
  return jsonP.readObj({
    required: {},
    optional: {
      "canaryPercentage": "n",
      "canaryInterval": "n",
    },
  }, root);
}

function fromTimeBasedLinear(input?: s.TimeBasedLinear | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    linearPercentage: input["linearPercentage"],
    linearInterval: input["linearInterval"],
  }
}
function toTimeBasedLinear(root: jsonP.JSONValue): s.TimeBasedLinear {
  return jsonP.readObj({
    required: {},
    optional: {
      "linearPercentage": "n",
      "linearInterval": "n",
    },
  }, root);
}

function fromTagFilter(input?: s.TagFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Type: input["Type"],
  }
}
function toTagFilter(root: jsonP.JSONValue): s.TagFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.TagFilterType>(x),
    },
  }, root);
}

function fromTriggerConfig(input?: s.TriggerConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    triggerName: input["triggerName"],
    triggerTargetArn: input["triggerTargetArn"],
    triggerEvents: input["triggerEvents"],
  }
}
function toTriggerConfig(root: jsonP.JSONValue): s.TriggerConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "triggerName": "s",
      "triggerTargetArn": "s",
      "triggerEvents": [(x: jsonP.JSONValue) => cmnP.readEnum<s.TriggerEventType>(x)],
    },
  }, root);
}

function fromAlarmConfiguration(input?: s.AlarmConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
    ignorePollAlarmFailure: input["ignorePollAlarmFailure"],
    alarms: input["alarms"]?.map(x => fromAlarm(x)),
  }
}
function toAlarmConfiguration(root: jsonP.JSONValue): s.AlarmConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "enabled": "b",
      "ignorePollAlarmFailure": "b",
      "alarms": [toAlarm],
    },
  }, root);
}

function fromAlarm(input?: s.Alarm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toAlarm(root: jsonP.JSONValue): s.Alarm {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

function fromDeploymentStyle(input?: s.DeploymentStyle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deploymentType: input["deploymentType"],
    deploymentOption: input["deploymentOption"],
  }
}
function toDeploymentStyle(root: jsonP.JSONValue): s.DeploymentStyle {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentType>(x),
      "deploymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentOption>(x),
    },
  }, root);
}

function fromBlueGreenDeploymentConfiguration(input?: s.BlueGreenDeploymentConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    terminateBlueInstancesOnDeploymentSuccess: fromBlueInstanceTerminationOption(input["terminateBlueInstancesOnDeploymentSuccess"]),
    deploymentReadyOption: fromDeploymentReadyOption(input["deploymentReadyOption"]),
    greenFleetProvisioningOption: fromGreenFleetProvisioningOption(input["greenFleetProvisioningOption"]),
  }
}
function toBlueGreenDeploymentConfiguration(root: jsonP.JSONValue): s.BlueGreenDeploymentConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "terminateBlueInstancesOnDeploymentSuccess": toBlueInstanceTerminationOption,
      "deploymentReadyOption": toDeploymentReadyOption,
      "greenFleetProvisioningOption": toGreenFleetProvisioningOption,
    },
  }, root);
}

function fromBlueInstanceTerminationOption(input?: s.BlueInstanceTerminationOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: input["action"],
    terminationWaitTimeInMinutes: input["terminationWaitTimeInMinutes"],
  }
}
function toBlueInstanceTerminationOption(root: jsonP.JSONValue): s.BlueInstanceTerminationOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "action": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceAction>(x),
      "terminationWaitTimeInMinutes": "n",
    },
  }, root);
}

function fromDeploymentReadyOption(input?: s.DeploymentReadyOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actionOnTimeout: input["actionOnTimeout"],
    waitTimeInMinutes: input["waitTimeInMinutes"],
  }
}
function toDeploymentReadyOption(root: jsonP.JSONValue): s.DeploymentReadyOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionOnTimeout": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentReadyAction>(x),
      "waitTimeInMinutes": "n",
    },
  }, root);
}

function fromGreenFleetProvisioningOption(input?: s.GreenFleetProvisioningOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: input["action"],
  }
}
function toGreenFleetProvisioningOption(root: jsonP.JSONValue): s.GreenFleetProvisioningOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "action": (x: jsonP.JSONValue) => cmnP.readEnum<s.GreenFleetProvisioningAction>(x),
    },
  }, root);
}

function fromLoadBalancerInfo(input?: s.LoadBalancerInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    elbInfoList: input["elbInfoList"]?.map(x => fromELBInfo(x)),
    targetGroupInfoList: input["targetGroupInfoList"]?.map(x => fromTargetGroupInfo(x)),
    targetGroupPairInfoList: input["targetGroupPairInfoList"]?.map(x => fromTargetGroupPairInfo(x)),
  }
}
function toLoadBalancerInfo(root: jsonP.JSONValue): s.LoadBalancerInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "elbInfoList": [toELBInfo],
      "targetGroupInfoList": [toTargetGroupInfo],
      "targetGroupPairInfoList": [toTargetGroupPairInfo],
    },
  }, root);
}

function fromELBInfo(input?: s.ELBInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toELBInfo(root: jsonP.JSONValue): s.ELBInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

function fromTargetGroupInfo(input?: s.TargetGroupInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toTargetGroupInfo(root: jsonP.JSONValue): s.TargetGroupInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

function fromTargetGroupPairInfo(input?: s.TargetGroupPairInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    targetGroups: input["targetGroups"]?.map(x => fromTargetGroupInfo(x)),
    prodTrafficRoute: fromTrafficRoute(input["prodTrafficRoute"]),
    testTrafficRoute: fromTrafficRoute(input["testTrafficRoute"]),
  }
}
function toTargetGroupPairInfo(root: jsonP.JSONValue): s.TargetGroupPairInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "targetGroups": [toTargetGroupInfo],
      "prodTrafficRoute": toTrafficRoute,
      "testTrafficRoute": toTrafficRoute,
    },
  }, root);
}

function fromTrafficRoute(input?: s.TrafficRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    listenerArns: input["listenerArns"],
  }
}
function toTrafficRoute(root: jsonP.JSONValue): s.TrafficRoute {
  return jsonP.readObj({
    required: {},
    optional: {
      "listenerArns": ["s"],
    },
  }, root);
}

function fromECSService(input?: s.ECSService | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceName: input["serviceName"],
    clusterName: input["clusterName"],
  }
}
function toECSService(root: jsonP.JSONValue): s.ECSService {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceName": "s",
      "clusterName": "s",
    },
  }, root);
}

function fromOnPremisesTagSet(input?: s.OnPremisesTagSet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    onPremisesTagSetList: input["onPremisesTagSetList"]?.map(x => x?.map(fromTagFilter)),
  }
}
function toOnPremisesTagSet(root: jsonP.JSONValue): s.OnPremisesTagSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "onPremisesTagSetList": [x => jsonP.readList(toTagFilter, x)],
    },
  }, root);
}

function fromTimeRange(input?: s.TimeRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    start: jsonP.serializeDate_unixTimestamp(input["start"]),
    end: jsonP.serializeDate_unixTimestamp(input["end"]),
  }
}

function toRevisionInfo(root: jsonP.JSONValue): s.RevisionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "revisionLocation": toRevisionLocation,
      "genericRevisionInfo": toGenericRevisionInfo,
    },
  }, root);
}

function toGenericRevisionInfo(root: jsonP.JSONValue): s.GenericRevisionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "description": "s",
      "deploymentGroups": ["s"],
      "firstUsedTime": "d",
      "lastUsedTime": "d",
      "registerTime": "d",
    },
  }, root);
}

function toApplicationInfo(root: jsonP.JSONValue): s.ApplicationInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "applicationId": "s",
      "applicationName": "s",
      "createTime": "d",
      "linkedToGitHub": "b",
      "gitHubAccountName": "s",
      "computePlatform": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComputePlatform>(x),
    },
  }, root);
}

function toDeploymentGroupInfo(root: jsonP.JSONValue): s.DeploymentGroupInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "applicationName": "s",
      "deploymentGroupId": "s",
      "deploymentGroupName": "s",
      "deploymentConfigName": "s",
      "ec2TagFilters": [toEC2TagFilter],
      "onPremisesInstanceTagFilters": [toTagFilter],
      "autoScalingGroups": [toAutoScalingGroup],
      "serviceRoleArn": "s",
      "targetRevision": toRevisionLocation,
      "triggerConfigurations": [toTriggerConfig],
      "alarmConfiguration": toAlarmConfiguration,
      "autoRollbackConfiguration": toAutoRollbackConfiguration,
      "deploymentStyle": toDeploymentStyle,
      "blueGreenDeploymentConfiguration": toBlueGreenDeploymentConfiguration,
      "loadBalancerInfo": toLoadBalancerInfo,
      "lastSuccessfulDeployment": toLastDeploymentInfo,
      "lastAttemptedDeployment": toLastDeploymentInfo,
      "ec2TagSet": toEC2TagSet,
      "onPremisesTagSet": toOnPremisesTagSet,
      "computePlatform": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComputePlatform>(x),
      "ecsServices": [toECSService],
    },
  }, root);
}

function toAutoScalingGroup(root: jsonP.JSONValue): s.AutoScalingGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "hook": "s",
    },
  }, root);
}

function toLastDeploymentInfo(root: jsonP.JSONValue): s.LastDeploymentInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
      "endTime": "d",
      "createTime": "d",
    },
  }, root);
}

function toInstanceSummary(root: jsonP.JSONValue): s.InstanceSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "instanceId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceStatus>(x),
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "instanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceType>(x),
    },
  }, root);
}

function toLifecycleEvent(root: jsonP.JSONValue): s.LifecycleEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "lifecycleEventName": "s",
      "diagnostics": toDiagnostics,
      "startTime": "d",
      "endTime": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.LifecycleEventStatus>(x),
    },
  }, root);
}

function toDiagnostics(root: jsonP.JSONValue): s.Diagnostics {
  return jsonP.readObj({
    required: {},
    optional: {
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LifecycleErrorCode>(x),
      "scriptName": "s",
      "message": "s",
      "logTail": "s",
    },
  }, root);
}

function toDeploymentTarget(root: jsonP.JSONValue): s.DeploymentTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentTargetType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentTargetType>(x),
      "instanceTarget": toInstanceTarget,
      "lambdaTarget": toLambdaTarget,
      "ecsTarget": toECSTarget,
      "cloudFormationTarget": toCloudFormationTarget,
    },
  }, root);
}

function toInstanceTarget(root: jsonP.JSONValue): s.InstanceTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "targetId": "s",
      "targetArn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetStatus>(x),
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "instanceLabel": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetLabel>(x),
    },
  }, root);
}

function toLambdaTarget(root: jsonP.JSONValue): s.LambdaTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "targetId": "s",
      "targetArn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetStatus>(x),
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "lambdaFunctionInfo": toLambdaFunctionInfo,
    },
  }, root);
}

function toLambdaFunctionInfo(root: jsonP.JSONValue): s.LambdaFunctionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "functionName": "s",
      "functionAlias": "s",
      "currentVersion": "s",
      "targetVersion": "s",
      "targetVersionWeight": "n",
    },
  }, root);
}

function toECSTarget(root: jsonP.JSONValue): s.ECSTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "targetId": "s",
      "targetArn": "s",
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetStatus>(x),
      "taskSetsInfo": [toECSTaskSet],
    },
  }, root);
}

function toECSTaskSet(root: jsonP.JSONValue): s.ECSTaskSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "identifer": "s",
      "desiredCount": "n",
      "pendingCount": "n",
      "runningCount": "n",
      "status": "s",
      "trafficWeight": "n",
      "targetGroup": toTargetGroupInfo,
      "taskSetLabel": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetLabel>(x),
    },
  }, root);
}

function toCloudFormationTarget(root: jsonP.JSONValue): s.CloudFormationTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "targetId": "s",
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetStatus>(x),
      "resourceType": "s",
      "targetVersionWeight": "n",
    },
  }, root);
}

function toDeploymentInfo(root: jsonP.JSONValue): s.DeploymentInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "applicationName": "s",
      "deploymentGroupName": "s",
      "deploymentConfigName": "s",
      "deploymentId": "s",
      "previousRevision": toRevisionLocation,
      "revision": toRevisionLocation,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
      "errorInformation": toErrorInformation,
      "createTime": "d",
      "startTime": "d",
      "completeTime": "d",
      "deploymentOverview": toDeploymentOverview,
      "description": "s",
      "creator": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentCreator>(x),
      "ignoreApplicationStopFailures": "b",
      "autoRollbackConfiguration": toAutoRollbackConfiguration,
      "updateOutdatedInstancesOnly": "b",
      "rollbackInfo": toRollbackInfo,
      "deploymentStyle": toDeploymentStyle,
      "targetInstances": toTargetInstances,
      "instanceTerminationWaitTimeStarted": "b",
      "blueGreenDeploymentConfiguration": toBlueGreenDeploymentConfiguration,
      "loadBalancerInfo": toLoadBalancerInfo,
      "additionalDeploymentStatusInfo": "s",
      "fileExistsBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileExistsBehavior>(x),
      "deploymentStatusMessages": ["s"],
      "computePlatform": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComputePlatform>(x),
      "externalId": "s",
    },
  }, root);
}

function toErrorInformation(root: jsonP.JSONValue): s.ErrorInformation {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<s.ErrorCode>(x),
      "message": "s",
    },
  }, root);
}

function toDeploymentOverview(root: jsonP.JSONValue): s.DeploymentOverview {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pending": "n",
      "InProgress": "n",
      "Succeeded": "n",
      "Failed": "n",
      "Skipped": "n",
      "Ready": "n",
    },
  }, root);
}

function toRollbackInfo(root: jsonP.JSONValue): s.RollbackInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "rollbackDeploymentId": "s",
      "rollbackTriggeringDeploymentId": "s",
      "rollbackMessage": "s",
    },
  }, root);
}

function toInstanceInfo(root: jsonP.JSONValue): s.InstanceInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "instanceName": "s",
      "iamSessionArn": "s",
      "iamUserArn": "s",
      "instanceArn": "s",
      "registerTime": "d",
      "deregisterTime": "d",
      "tags": [toTag],
    },
  }, root);
}

function toDeploymentConfigInfo(root: jsonP.JSONValue): s.DeploymentConfigInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentConfigId": "s",
      "deploymentConfigName": "s",
      "minimumHealthyHosts": toMinimumHealthyHosts,
      "createTime": "d",
      "computePlatform": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComputePlatform>(x),
      "trafficRoutingConfig": toTrafficRoutingConfig,
    },
  }, root);
}
