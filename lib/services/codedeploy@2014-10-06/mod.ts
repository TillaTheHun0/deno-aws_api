// Autogenerated API client for: AWS CodeDeploy

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class CodeDeploy {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodeDeploy.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2014-10-06",
    "endpointPrefix": "codedeploy",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "CodeDeploy",
    "serviceFullName": "AWS CodeDeploy",
    "serviceId": "CodeDeploy",
    "signatureVersion": "v4",
    "targetPrefix": "CodeDeploy_20141006",
    "uid": "codedeploy-2014-10-06"
  };

  async addTagsToOnPremisesInstances(
    {abortSignal, ...params}: RequestConfig & AddTagsToOnPremisesInstancesInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      tags: params["tags"]?.map(x => fromTag(x)),
      instanceNames: params["instanceNames"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToOnPremisesInstances",
    });
  }

  async batchGetApplicationRevisions(
    {abortSignal, ...params}: RequestConfig & BatchGetApplicationRevisionsInput,
  ): Promise<BatchGetApplicationRevisionsOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      revisions: params["revisions"]?.map(x => fromRevisionLocation(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetApplicationRevisions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationName": "s",
        "errorMessage": "s",
        "revisions": [toRevisionInfo],
      },
    }, await resp.json());
  }

  async batchGetApplications(
    {abortSignal, ...params}: RequestConfig & BatchGetApplicationsInput,
  ): Promise<BatchGetApplicationsOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationNames: params["applicationNames"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetApplications",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationsInfo": [toApplicationInfo],
      },
    }, await resp.json());
  }

  async batchGetDeploymentGroups(
    {abortSignal, ...params}: RequestConfig & BatchGetDeploymentGroupsInput,
  ): Promise<BatchGetDeploymentGroupsOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      deploymentGroupNames: params["deploymentGroupNames"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDeploymentGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentGroupsInfo": [toDeploymentGroupInfo],
        "errorMessage": "s",
      },
    }, await resp.json());
  }

  async batchGetDeploymentInstances(
    {abortSignal, ...params}: RequestConfig & BatchGetDeploymentInstancesInput,
  ): Promise<BatchGetDeploymentInstancesOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
      instanceIds: params["instanceIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDeploymentInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instancesSummary": [toInstanceSummary],
        "errorMessage": "s",
      },
    }, await resp.json());
  }

  async batchGetDeploymentTargets(
    {abortSignal, ...params}: RequestConfig & BatchGetDeploymentTargetsInput = {},
  ): Promise<BatchGetDeploymentTargetsOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
      targetIds: params["targetIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDeploymentTargets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentTargets": [toDeploymentTarget],
      },
    }, await resp.json());
  }

  async batchGetDeployments(
    {abortSignal, ...params}: RequestConfig & BatchGetDeploymentsInput,
  ): Promise<BatchGetDeploymentsOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentIds: params["deploymentIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDeployments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentsInfo": [toDeploymentInfo],
      },
    }, await resp.json());
  }

  async batchGetOnPremisesInstances(
    {abortSignal, ...params}: RequestConfig & BatchGetOnPremisesInstancesInput,
  ): Promise<BatchGetOnPremisesInstancesOutput> {
    const body: jsonP.JSONObject = params ? {
      instanceNames: params["instanceNames"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetOnPremisesInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceInfos": [toInstanceInfo],
      },
    }, await resp.json());
  }

  async continueDeployment(
    {abortSignal, ...params}: RequestConfig & ContinueDeploymentInput = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
      deploymentWaitType: params["deploymentWaitType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ContinueDeployment",
    });
  }

  async createApplication(
    {abortSignal, ...params}: RequestConfig & CreateApplicationInput,
  ): Promise<CreateApplicationOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      computePlatform: params["computePlatform"],
      tags: params["tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationId": "s",
      },
    }, await resp.json());
  }

  async createDeployment(
    {abortSignal, ...params}: RequestConfig & CreateDeploymentInput,
  ): Promise<CreateDeploymentOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
      revision: fromRevisionLocation(params["revision"]),
      deploymentConfigName: params["deploymentConfigName"],
      description: params["description"],
      ignoreApplicationStopFailures: params["ignoreApplicationStopFailures"],
      targetInstances: fromTargetInstances(params["targetInstances"]),
      autoRollbackConfiguration: fromAutoRollbackConfiguration(params["autoRollbackConfiguration"]),
      updateOutdatedInstancesOnly: params["updateOutdatedInstancesOnly"],
      fileExistsBehavior: params["fileExistsBehavior"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeployment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentId": "s",
      },
    }, await resp.json());
  }

  async createDeploymentConfig(
    {abortSignal, ...params}: RequestConfig & CreateDeploymentConfigInput,
  ): Promise<CreateDeploymentConfigOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentConfigName: params["deploymentConfigName"],
      minimumHealthyHosts: fromMinimumHealthyHosts(params["minimumHealthyHosts"]),
      trafficRoutingConfig: fromTrafficRoutingConfig(params["trafficRoutingConfig"]),
      computePlatform: params["computePlatform"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeploymentConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentConfigId": "s",
      },
    }, await resp.json());
  }

  async createDeploymentGroup(
    {abortSignal, ...params}: RequestConfig & CreateDeploymentGroupInput,
  ): Promise<CreateDeploymentGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
      deploymentConfigName: params["deploymentConfigName"],
      ec2TagFilters: params["ec2TagFilters"]?.map(x => fromEC2TagFilter(x)),
      onPremisesInstanceTagFilters: params["onPremisesInstanceTagFilters"]?.map(x => fromTagFilter(x)),
      autoScalingGroups: params["autoScalingGroups"],
      serviceRoleArn: params["serviceRoleArn"],
      triggerConfigurations: params["triggerConfigurations"]?.map(x => fromTriggerConfig(x)),
      alarmConfiguration: fromAlarmConfiguration(params["alarmConfiguration"]),
      autoRollbackConfiguration: fromAutoRollbackConfiguration(params["autoRollbackConfiguration"]),
      deploymentStyle: fromDeploymentStyle(params["deploymentStyle"]),
      blueGreenDeploymentConfiguration: fromBlueGreenDeploymentConfiguration(params["blueGreenDeploymentConfiguration"]),
      loadBalancerInfo: fromLoadBalancerInfo(params["loadBalancerInfo"]),
      ec2TagSet: fromEC2TagSet(params["ec2TagSet"]),
      ecsServices: params["ecsServices"]?.map(x => fromECSService(x)),
      onPremisesTagSet: fromOnPremisesTagSet(params["onPremisesTagSet"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeploymentGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentGroupId": "s",
      },
    }, await resp.json());
  }

  async deleteApplication(
    {abortSignal, ...params}: RequestConfig & DeleteApplicationInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplication",
    });
  }

  async deleteDeploymentConfig(
    {abortSignal, ...params}: RequestConfig & DeleteDeploymentConfigInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      deploymentConfigName: params["deploymentConfigName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDeploymentConfig",
    });
  }

  async deleteDeploymentGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDeploymentGroupInput,
  ): Promise<DeleteDeploymentGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDeploymentGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "hooksNotCleanedUp": [toAutoScalingGroup],
      },
    }, await resp.json());
  }

  async deleteGitHubAccountToken(
    {abortSignal, ...params}: RequestConfig & DeleteGitHubAccountTokenInput = {},
  ): Promise<DeleteGitHubAccountTokenOutput> {
    const body: jsonP.JSONObject = params ? {
      tokenName: params["tokenName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGitHubAccountToken",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tokenName": "s",
      },
    }, await resp.json());
  }

  async deleteResourcesByExternalId(
    {abortSignal, ...params}: RequestConfig & DeleteResourcesByExternalIdInput = {},
  ): Promise<DeleteResourcesByExternalIdOutput> {
    const body: jsonP.JSONObject = params ? {
      externalId: params["externalId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourcesByExternalId",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deregisterOnPremisesInstance(
    {abortSignal, ...params}: RequestConfig & DeregisterOnPremisesInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      instanceName: params["instanceName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterOnPremisesInstance",
    });
  }

  async getApplication(
    {abortSignal, ...params}: RequestConfig & GetApplicationInput,
  ): Promise<GetApplicationOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "application": toApplicationInfo,
      },
    }, await resp.json());
  }

  async getApplicationRevision(
    {abortSignal, ...params}: RequestConfig & GetApplicationRevisionInput,
  ): Promise<GetApplicationRevisionOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      revision: fromRevisionLocation(params["revision"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetApplicationRevision",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationName": "s",
        "revision": toRevisionLocation,
        "revisionInfo": toGenericRevisionInfo,
      },
    }, await resp.json());
  }

  async getDeployment(
    {abortSignal, ...params}: RequestConfig & GetDeploymentInput,
  ): Promise<GetDeploymentOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeployment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentInfo": toDeploymentInfo,
      },
    }, await resp.json());
  }

  async getDeploymentConfig(
    {abortSignal, ...params}: RequestConfig & GetDeploymentConfigInput,
  ): Promise<GetDeploymentConfigOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentConfigName: params["deploymentConfigName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeploymentConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentConfigInfo": toDeploymentConfigInfo,
      },
    }, await resp.json());
  }

  async getDeploymentGroup(
    {abortSignal, ...params}: RequestConfig & GetDeploymentGroupInput,
  ): Promise<GetDeploymentGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeploymentGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentGroupInfo": toDeploymentGroupInfo,
      },
    }, await resp.json());
  }

  async getDeploymentInstance(
    {abortSignal, ...params}: RequestConfig & GetDeploymentInstanceInput,
  ): Promise<GetDeploymentInstanceOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
      instanceId: params["instanceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeploymentInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceSummary": toInstanceSummary,
      },
    }, await resp.json());
  }

  async getDeploymentTarget(
    {abortSignal, ...params}: RequestConfig & GetDeploymentTargetInput = {},
  ): Promise<GetDeploymentTargetOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
      targetId: params["targetId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeploymentTarget",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentTarget": toDeploymentTarget,
      },
    }, await resp.json());
  }

  async getOnPremisesInstance(
    {abortSignal, ...params}: RequestConfig & GetOnPremisesInstanceInput,
  ): Promise<GetOnPremisesInstanceOutput> {
    const body: jsonP.JSONObject = params ? {
      instanceName: params["instanceName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOnPremisesInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceInfo": toInstanceInfo,
      },
    }, await resp.json());
  }

  async listApplicationRevisions(
    {abortSignal, ...params}: RequestConfig & ListApplicationRevisionsInput,
  ): Promise<ListApplicationRevisionsOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      sortBy: params["sortBy"],
      sortOrder: params["sortOrder"],
      s3Bucket: params["s3Bucket"],
      s3KeyPrefix: params["s3KeyPrefix"],
      deployed: params["deployed"],
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListApplicationRevisions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "revisions": [toRevisionLocation],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listApplications(
    {abortSignal, ...params}: RequestConfig & ListApplicationsInput = {},
  ): Promise<ListApplicationsOutput> {
    const body: jsonP.JSONObject = params ? {
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListApplications",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applications": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeploymentConfigs(
    {abortSignal, ...params}: RequestConfig & ListDeploymentConfigsInput = {},
  ): Promise<ListDeploymentConfigsOutput> {
    const body: jsonP.JSONObject = params ? {
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeploymentConfigs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentConfigsList": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeploymentGroups(
    {abortSignal, ...params}: RequestConfig & ListDeploymentGroupsInput,
  ): Promise<ListDeploymentGroupsOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeploymentGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "applicationName": "s",
        "deploymentGroups": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeploymentInstances(
    {abortSignal, ...params}: RequestConfig & ListDeploymentInstancesInput,
  ): Promise<ListDeploymentInstancesOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
      nextToken: params["nextToken"],
      instanceStatusFilter: params["instanceStatusFilter"],
      instanceTypeFilter: params["instanceTypeFilter"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeploymentInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instancesList": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeploymentTargets(
    {abortSignal, ...params}: RequestConfig & ListDeploymentTargetsInput = {},
  ): Promise<ListDeploymentTargetsOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
      nextToken: params["nextToken"],
      targetFilters: params["targetFilters"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeploymentTargets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "targetIds": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDeployments(
    {abortSignal, ...params}: RequestConfig & ListDeploymentsInput = {},
  ): Promise<ListDeploymentsOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      deploymentGroupName: params["deploymentGroupName"],
      externalId: params["externalId"],
      includeOnlyStatuses: params["includeOnlyStatuses"],
      createTimeRange: fromTimeRange(params["createTimeRange"]),
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeployments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deployments": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listGitHubAccountTokenNames(
    {abortSignal, ...params}: RequestConfig & ListGitHubAccountTokenNamesInput = {},
  ): Promise<ListGitHubAccountTokenNamesOutput> {
    const body: jsonP.JSONObject = params ? {
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGitHubAccountTokenNames",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tokenNameList": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listOnPremisesInstances(
    {abortSignal, ...params}: RequestConfig & ListOnPremisesInstancesInput = {},
  ): Promise<ListOnPremisesInstancesOutput> {
    const body: jsonP.JSONObject = params ? {
      registrationStatus: params["registrationStatus"],
      tagFilters: params["tagFilters"]?.map(x => fromTagFilter(x)),
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListOnPremisesInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceInput,
  ): Promise<ListTagsForResourceOutput> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putLifecycleEventHookExecutionStatus(
    {abortSignal, ...params}: RequestConfig & PutLifecycleEventHookExecutionStatusInput = {},
  ): Promise<PutLifecycleEventHookExecutionStatusOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
      lifecycleEventHookExecutionId: params["lifecycleEventHookExecutionId"],
      status: params["status"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLifecycleEventHookExecutionStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "lifecycleEventHookExecutionId": "s",
      },
    }, await resp.json());
  }

  async registerApplicationRevision(
    {abortSignal, ...params}: RequestConfig & RegisterApplicationRevisionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      description: params["description"],
      revision: fromRevisionLocation(params["revision"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterApplicationRevision",
    });
  }

  async registerOnPremisesInstance(
    {abortSignal, ...params}: RequestConfig & RegisterOnPremisesInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      instanceName: params["instanceName"],
      iamSessionArn: params["iamSessionArn"],
      iamUserArn: params["iamUserArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterOnPremisesInstance",
    });
  }

  async removeTagsFromOnPremisesInstances(
    {abortSignal, ...params}: RequestConfig & RemoveTagsFromOnPremisesInstancesInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      tags: params["tags"]?.map(x => fromTag(x)),
      instanceNames: params["instanceNames"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromOnPremisesInstances",
    });
  }

  async skipWaitTimeForInstanceTermination(
    {abortSignal, ...params}: RequestConfig & SkipWaitTimeForInstanceTerminationInput = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SkipWaitTimeForInstanceTermination",
    });
  }

  async stopDeployment(
    {abortSignal, ...params}: RequestConfig & StopDeploymentInput,
  ): Promise<StopDeploymentOutput> {
    const body: jsonP.JSONObject = params ? {
      deploymentId: params["deploymentId"],
      autoRollbackEnabled: params["autoRollbackEnabled"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopDeployment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<StopStatus>(x),
        "statusMessage": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceInput,
  ): Promise<TagResourceOutput> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceInput,
  ): Promise<UntagResourceOutput> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateApplication(
    {abortSignal, ...params}: RequestConfig & UpdateApplicationInput = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      newApplicationName: params["newApplicationName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApplication",
    });
  }

  async updateDeploymentGroup(
    {abortSignal, ...params}: RequestConfig & UpdateDeploymentGroupInput,
  ): Promise<UpdateDeploymentGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      applicationName: params["applicationName"],
      currentDeploymentGroupName: params["currentDeploymentGroupName"],
      newDeploymentGroupName: params["newDeploymentGroupName"],
      deploymentConfigName: params["deploymentConfigName"],
      ec2TagFilters: params["ec2TagFilters"]?.map(x => fromEC2TagFilter(x)),
      onPremisesInstanceTagFilters: params["onPremisesInstanceTagFilters"]?.map(x => fromTagFilter(x)),
      autoScalingGroups: params["autoScalingGroups"],
      serviceRoleArn: params["serviceRoleArn"],
      triggerConfigurations: params["triggerConfigurations"]?.map(x => fromTriggerConfig(x)),
      alarmConfiguration: fromAlarmConfiguration(params["alarmConfiguration"]),
      autoRollbackConfiguration: fromAutoRollbackConfiguration(params["autoRollbackConfiguration"]),
      deploymentStyle: fromDeploymentStyle(params["deploymentStyle"]),
      blueGreenDeploymentConfiguration: fromBlueGreenDeploymentConfiguration(params["blueGreenDeploymentConfiguration"]),
      loadBalancerInfo: fromLoadBalancerInfo(params["loadBalancerInfo"]),
      ec2TagSet: fromEC2TagSet(params["ec2TagSet"]),
      ecsServices: params["ecsServices"]?.map(x => fromECSService(x)),
      onPremisesTagSet: fromOnPremisesTagSet(params["onPremisesTagSet"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDeploymentGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "hooksNotCleanedUp": [toAutoScalingGroup],
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 120 times, 15 seconds apart (about 30 minutes max wait time). */
  async waitForDeploymentSuccessful(
    params: RequestConfig & GetDeploymentInput,
  ): Promise<GetDeploymentOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DeploymentSuccessful';
    for (let i = 0; i < 120; i++) {
      const resp = await this.getDeployment(params);
      const field = resp?.deploymentInfo?.status;
      if (field === "Succeeded") return resp;
      if (field === "Failed") throw new Error(errMessage);
      if (field === "Stopped") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddTagsToOnPremisesInstancesInput {
  tags: Tag[];
  instanceNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetApplicationRevisionsInput {
  applicationName: string;
  revisions: RevisionLocation[];
}

// refs: 1 - tags: named, input
export interface BatchGetApplicationsInput {
  applicationNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetDeploymentGroupsInput {
  applicationName: string;
  deploymentGroupNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetDeploymentInstancesInput {
  deploymentId: string;
  instanceIds: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetDeploymentTargetsInput {
  deploymentId?: string | null;
  targetIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface BatchGetDeploymentsInput {
  deploymentIds: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetOnPremisesInstancesInput {
  instanceNames: string[];
}

// refs: 1 - tags: named, input
export interface ContinueDeploymentInput {
  deploymentId?: string | null;
  deploymentWaitType?: DeploymentWaitType | null;
}

// refs: 1 - tags: named, input
export interface CreateApplicationInput {
  applicationName: string;
  computePlatform?: ComputePlatform | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDeploymentInput {
  applicationName: string;
  deploymentGroupName?: string | null;
  revision?: RevisionLocation | null;
  deploymentConfigName?: string | null;
  description?: string | null;
  ignoreApplicationStopFailures?: boolean | null;
  targetInstances?: TargetInstances | null;
  autoRollbackConfiguration?: AutoRollbackConfiguration | null;
  updateOutdatedInstancesOnly?: boolean | null;
  fileExistsBehavior?: FileExistsBehavior | null;
}

// refs: 1 - tags: named, input
export interface CreateDeploymentConfigInput {
  deploymentConfigName: string;
  minimumHealthyHosts?: MinimumHealthyHosts | null;
  trafficRoutingConfig?: TrafficRoutingConfig | null;
  computePlatform?: ComputePlatform | null;
}

// refs: 1 - tags: named, input
export interface CreateDeploymentGroupInput {
  applicationName: string;
  deploymentGroupName: string;
  deploymentConfigName?: string | null;
  ec2TagFilters?: EC2TagFilter[] | null;
  onPremisesInstanceTagFilters?: TagFilter[] | null;
  autoScalingGroups?: string[] | null;
  serviceRoleArn: string;
  triggerConfigurations?: TriggerConfig[] | null;
  alarmConfiguration?: AlarmConfiguration | null;
  autoRollbackConfiguration?: AutoRollbackConfiguration | null;
  deploymentStyle?: DeploymentStyle | null;
  blueGreenDeploymentConfiguration?: BlueGreenDeploymentConfiguration | null;
  loadBalancerInfo?: LoadBalancerInfo | null;
  ec2TagSet?: EC2TagSet | null;
  ecsServices?: ECSService[] | null;
  onPremisesTagSet?: OnPremisesTagSet | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteApplicationInput {
  applicationName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDeploymentConfigInput {
  deploymentConfigName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDeploymentGroupInput {
  applicationName: string;
  deploymentGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteGitHubAccountTokenInput {
  tokenName?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteResourcesByExternalIdInput {
  externalId?: string | null;
}

// refs: 1 - tags: named, input
export interface DeregisterOnPremisesInstanceInput {
  instanceName: string;
}

// refs: 1 - tags: named, input
export interface GetApplicationInput {
  applicationName: string;
}

// refs: 1 - tags: named, input
export interface GetApplicationRevisionInput {
  applicationName: string;
  revision: RevisionLocation;
}

// refs: 1 - tags: named, input
export interface GetDeploymentInput {
  deploymentId: string;
}

// refs: 1 - tags: named, input
export interface GetDeploymentConfigInput {
  deploymentConfigName: string;
}

// refs: 1 - tags: named, input
export interface GetDeploymentGroupInput {
  applicationName: string;
  deploymentGroupName: string;
}

// refs: 1 - tags: named, input
export interface GetDeploymentInstanceInput {
  deploymentId: string;
  instanceId: string;
}

// refs: 1 - tags: named, input
export interface GetDeploymentTargetInput {
  deploymentId?: string | null;
  targetId?: string | null;
}

// refs: 1 - tags: named, input
export interface GetOnPremisesInstanceInput {
  instanceName: string;
}

// refs: 1 - tags: named, input
export interface ListApplicationRevisionsInput {
  applicationName: string;
  sortBy?: ApplicationRevisionSortBy | null;
  sortOrder?: SortOrder | null;
  s3Bucket?: string | null;
  s3KeyPrefix?: string | null;
  deployed?: ListStateFilterAction | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListApplicationsInput {
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDeploymentConfigsInput {
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDeploymentGroupsInput {
  applicationName: string;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDeploymentInstancesInput {
  deploymentId: string;
  nextToken?: string | null;
  instanceStatusFilter?: InstanceStatus[] | null;
  instanceTypeFilter?: InstanceType[] | null;
}

// refs: 1 - tags: named, input
export interface ListDeploymentTargetsInput {
  deploymentId?: string | null;
  nextToken?: string | null;
  targetFilters?: { [key in TargetFilterName]: string[] | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface ListDeploymentsInput {
  applicationName?: string | null;
  deploymentGroupName?: string | null;
  externalId?: string | null;
  includeOnlyStatuses?: DeploymentStatus[] | null;
  createTimeRange?: TimeRange | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListGitHubAccountTokenNamesInput {
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListOnPremisesInstancesInput {
  registrationStatus?: RegistrationStatus | null;
  tagFilters?: TagFilter[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceInput {
  ResourceArn: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PutLifecycleEventHookExecutionStatusInput {
  deploymentId?: string | null;
  lifecycleEventHookExecutionId?: string | null;
  status?: LifecycleEventStatus | null;
}

// refs: 1 - tags: named, input
export interface RegisterApplicationRevisionInput {
  applicationName: string;
  description?: string | null;
  revision: RevisionLocation;
}

// refs: 1 - tags: named, input
export interface RegisterOnPremisesInstanceInput {
  instanceName: string;
  iamSessionArn?: string | null;
  iamUserArn?: string | null;
}

// refs: 1 - tags: named, input
export interface RemoveTagsFromOnPremisesInstancesInput {
  tags: Tag[];
  instanceNames: string[];
}

// refs: 1 - tags: named, input
export interface SkipWaitTimeForInstanceTerminationInput {
  deploymentId?: string | null;
}

// refs: 1 - tags: named, input
export interface StopDeploymentInput {
  deploymentId: string;
  autoRollbackEnabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface TagResourceInput {
  ResourceArn: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceInput {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateApplicationInput {
  applicationName?: string | null;
  newApplicationName?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateDeploymentGroupInput {
  applicationName: string;
  currentDeploymentGroupName: string;
  newDeploymentGroupName?: string | null;
  deploymentConfigName?: string | null;
  ec2TagFilters?: EC2TagFilter[] | null;
  onPremisesInstanceTagFilters?: TagFilter[] | null;
  autoScalingGroups?: string[] | null;
  serviceRoleArn?: string | null;
  triggerConfigurations?: TriggerConfig[] | null;
  alarmConfiguration?: AlarmConfiguration | null;
  autoRollbackConfiguration?: AutoRollbackConfiguration | null;
  deploymentStyle?: DeploymentStyle | null;
  blueGreenDeploymentConfiguration?: BlueGreenDeploymentConfiguration | null;
  loadBalancerInfo?: LoadBalancerInfo | null;
  ec2TagSet?: EC2TagSet | null;
  ecsServices?: ECSService[] | null;
  onPremisesTagSet?: OnPremisesTagSet | null;
}

// refs: 1 - tags: named, output
export interface BatchGetApplicationRevisionsOutput {
  applicationName?: string | null;
  errorMessage?: string | null;
  revisions?: RevisionInfo[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetApplicationsOutput {
  applicationsInfo?: ApplicationInfo[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetDeploymentGroupsOutput {
  deploymentGroupsInfo?: DeploymentGroupInfo[] | null;
  errorMessage?: string | null;
}

// refs: 1 - tags: named, output
export interface BatchGetDeploymentInstancesOutput {
  instancesSummary?: InstanceSummary[] | null;
  errorMessage?: string | null;
}

// refs: 1 - tags: named, output
export interface BatchGetDeploymentTargetsOutput {
  deploymentTargets?: DeploymentTarget[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetDeploymentsOutput {
  deploymentsInfo?: DeploymentInfo[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetOnPremisesInstancesOutput {
  instanceInfos?: InstanceInfo[] | null;
}

// refs: 1 - tags: named, output
export interface CreateApplicationOutput {
  applicationId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDeploymentOutput {
  deploymentId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDeploymentConfigOutput {
  deploymentConfigId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDeploymentGroupOutput {
  deploymentGroupId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteDeploymentGroupOutput {
  hooksNotCleanedUp?: AutoScalingGroup[] | null;
}

// refs: 1 - tags: named, output
export interface DeleteGitHubAccountTokenOutput {
  tokenName?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteResourcesByExternalIdOutput {
}

// refs: 1 - tags: named, output
export interface GetApplicationOutput {
  application?: ApplicationInfo | null;
}

// refs: 1 - tags: named, output
export interface GetApplicationRevisionOutput {
  applicationName?: string | null;
  revision?: RevisionLocation | null;
  revisionInfo?: GenericRevisionInfo | null;
}

// refs: 1 - tags: named, output
export interface GetDeploymentOutput {
  deploymentInfo?: DeploymentInfo | null;
}

// refs: 1 - tags: named, output
export interface GetDeploymentConfigOutput {
  deploymentConfigInfo?: DeploymentConfigInfo | null;
}

// refs: 1 - tags: named, output
export interface GetDeploymentGroupOutput {
  deploymentGroupInfo?: DeploymentGroupInfo | null;
}

// refs: 1 - tags: named, output
export interface GetDeploymentInstanceOutput {
  instanceSummary?: InstanceSummary | null;
}

// refs: 1 - tags: named, output
export interface GetDeploymentTargetOutput {
  deploymentTarget?: DeploymentTarget | null;
}

// refs: 1 - tags: named, output
export interface GetOnPremisesInstanceOutput {
  instanceInfo?: InstanceInfo | null;
}

// refs: 1 - tags: named, output
export interface ListApplicationRevisionsOutput {
  revisions?: RevisionLocation[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListApplicationsOutput {
  applications?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDeploymentConfigsOutput {
  deploymentConfigsList?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDeploymentGroupsOutput {
  applicationName?: string | null;
  deploymentGroups?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDeploymentInstancesOutput {
  instancesList?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDeploymentTargetsOutput {
  targetIds?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDeploymentsOutput {
  deployments?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListGitHubAccountTokenNamesOutput {
  tokenNameList?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListOnPremisesInstancesOutput {
  instanceNames?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceOutput {
  Tags?: Tag[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutLifecycleEventHookExecutionStatusOutput {
  lifecycleEventHookExecutionId?: string | null;
}

// refs: 1 - tags: named, output
export interface StopDeploymentOutput {
  status?: StopStatus | null;
  statusMessage?: string | null;
}

// refs: 1 - tags: named, output
export interface TagResourceOutput {
}

// refs: 1 - tags: named, output
export interface UntagResourceOutput {
}

// refs: 1 - tags: named, output
export interface UpdateDeploymentGroupOutput {
  hooksNotCleanedUp?: AutoScalingGroup[] | null;
}

// refs: 8 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 13 - tags: input, named, interface, output
export interface RevisionLocation {
  revisionType?: RevisionLocationType | null;
  s3Location?: S3Location | null;
  gitHubLocation?: GitHubLocation | null;
  string?: RawString | null;
  appSpecContent?: AppSpecContent | null;
}
function fromRevisionLocation(input?: RevisionLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    revisionType: input["revisionType"],
    s3Location: fromS3Location(input["s3Location"]),
    gitHubLocation: fromGitHubLocation(input["gitHubLocation"]),
    string: fromRawString(input["string"]),
    appSpecContent: fromAppSpecContent(input["appSpecContent"]),
  }
}
function toRevisionLocation(root: jsonP.JSONValue): RevisionLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "revisionType": (x: jsonP.JSONValue) => cmnP.readEnum<RevisionLocationType>(x),
      "s3Location": toS3Location,
      "gitHubLocation": toGitHubLocation,
      "string": toRawString,
      "appSpecContent": toAppSpecContent,
    },
  }, root);
}

// refs: 13 - tags: input, named, enum, output
export type RevisionLocationType =
| "S3"
| "GitHub"
| "String"
| "AppSpecContent"
| cmnP.UnexpectedEnumValue;

// refs: 13 - tags: input, named, interface, output
export interface S3Location {
  bucket?: string | null;
  key?: string | null;
  bundleType?: BundleType | null;
  version?: string | null;
  eTag?: string | null;
}
function fromS3Location(input?: S3Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    key: input["key"],
    bundleType: input["bundleType"],
    version: input["version"],
    eTag: input["eTag"],
  }
}
function toS3Location(root: jsonP.JSONValue): S3Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "key": "s",
      "bundleType": (x: jsonP.JSONValue) => cmnP.readEnum<BundleType>(x),
      "version": "s",
      "eTag": "s",
    },
  }, root);
}

// refs: 13 - tags: input, named, enum, output
export type BundleType =
| "tar"
| "tgz"
| "zip"
| "YAML"
| "JSON"
| cmnP.UnexpectedEnumValue;

// refs: 13 - tags: input, named, interface, output
export interface GitHubLocation {
  repository?: string | null;
  commitId?: string | null;
}
function fromGitHubLocation(input?: GitHubLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    repository: input["repository"],
    commitId: input["commitId"],
  }
}
function toGitHubLocation(root: jsonP.JSONValue): GitHubLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "repository": "s",
      "commitId": "s",
    },
  }, root);
}

// refs: 13 - tags: input, named, interface, output
export interface RawString {
  content?: string | null;
  sha256?: string | null;
}
function fromRawString(input?: RawString | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    content: input["content"],
    sha256: input["sha256"],
  }
}
function toRawString(root: jsonP.JSONValue): RawString {
  return jsonP.readObj({
    required: {},
    optional: {
      "content": "s",
      "sha256": "s",
    },
  }, root);
}

// refs: 13 - tags: input, named, interface, output
export interface AppSpecContent {
  content?: string | null;
  sha256?: string | null;
}
function fromAppSpecContent(input?: AppSpecContent | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    content: input["content"],
    sha256: input["sha256"],
  }
}
function toAppSpecContent(root: jsonP.JSONValue): AppSpecContent {
  return jsonP.readObj({
    required: {},
    optional: {
      "content": "s",
      "sha256": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, enum
export type DeploymentWaitType =
| "READY_WAIT"
| "TERMINATION_WAIT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type ComputePlatform =
| "Server"
| "Lambda"
| "ECS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface TargetInstances {
  tagFilters?: EC2TagFilter[] | null;
  autoScalingGroups?: string[] | null;
  ec2TagSet?: EC2TagSet | null;
}
function fromTargetInstances(input?: TargetInstances | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tagFilters: input["tagFilters"]?.map(x => fromEC2TagFilter(x)),
    autoScalingGroups: input["autoScalingGroups"],
    ec2TagSet: fromEC2TagSet(input["ec2TagSet"]),
  }
}
function toTargetInstances(root: jsonP.JSONValue): TargetInstances {
  return jsonP.readObj({
    required: {},
    optional: {
      "tagFilters": [toEC2TagFilter],
      "autoScalingGroups": ["s"],
      "ec2TagSet": toEC2TagSet,
    },
  }, root);
}

// refs: 14 - tags: input, named, interface, output
export interface EC2TagFilter {
  Key?: string | null;
  Value?: string | null;
  Type?: EC2TagFilterType | null;
}
function fromEC2TagFilter(input?: EC2TagFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Type: input["Type"],
  }
}
function toEC2TagFilter(root: jsonP.JSONValue): EC2TagFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<EC2TagFilterType>(x),
    },
  }, root);
}

// refs: 14 - tags: input, named, enum, output
export type EC2TagFilterType =
| "KEY_ONLY"
| "VALUE_ONLY"
| "KEY_AND_VALUE"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface EC2TagSet {
  ec2TagSetList?: EC2TagFilter[][] | null;
}
function fromEC2TagSet(input?: EC2TagSet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ec2TagSetList: input["ec2TagSetList"]?.map(x => x?.map(fromEC2TagFilter)),
  }
}
function toEC2TagSet(root: jsonP.JSONValue): EC2TagSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "ec2TagSetList": [x => jsonP.readList(toEC2TagFilter, x)],
    },
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface AutoRollbackConfiguration {
  enabled?: boolean | null;
  events?: AutoRollbackEvent[] | null;
}
function fromAutoRollbackConfiguration(input?: AutoRollbackConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
    events: input["events"],
  }
}
function toAutoRollbackConfiguration(root: jsonP.JSONValue): AutoRollbackConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "enabled": "b",
      "events": [(x: jsonP.JSONValue) => cmnP.readEnum<AutoRollbackEvent>(x)],
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type AutoRollbackEvent =
| "DEPLOYMENT_FAILURE"
| "DEPLOYMENT_STOP_ON_ALARM"
| "DEPLOYMENT_STOP_ON_REQUEST"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type FileExistsBehavior =
| "DISALLOW"
| "OVERWRITE"
| "RETAIN"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface MinimumHealthyHosts {
  value?: number | null;
  type?: MinimumHealthyHostsType | null;
}
function fromMinimumHealthyHosts(input?: MinimumHealthyHosts | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    type: input["type"],
  }
}
function toMinimumHealthyHosts(root: jsonP.JSONValue): MinimumHealthyHosts {
  return jsonP.readObj({
    required: {},
    optional: {
      "value": "n",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<MinimumHealthyHostsType>(x),
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type MinimumHealthyHostsType =
| "HOST_COUNT"
| "FLEET_PERCENT"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface TrafficRoutingConfig {
  type?: TrafficRoutingType | null;
  timeBasedCanary?: TimeBasedCanary | null;
  timeBasedLinear?: TimeBasedLinear | null;
}
function fromTrafficRoutingConfig(input?: TrafficRoutingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    timeBasedCanary: fromTimeBasedCanary(input["timeBasedCanary"]),
    timeBasedLinear: fromTimeBasedLinear(input["timeBasedLinear"]),
  }
}
function toTrafficRoutingConfig(root: jsonP.JSONValue): TrafficRoutingConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<TrafficRoutingType>(x),
      "timeBasedCanary": toTimeBasedCanary,
      "timeBasedLinear": toTimeBasedLinear,
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type TrafficRoutingType =
| "TimeBasedCanary"
| "TimeBasedLinear"
| "AllAtOnce"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface TimeBasedCanary {
  canaryPercentage?: number | null;
  canaryInterval?: number | null;
}
function fromTimeBasedCanary(input?: TimeBasedCanary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    canaryPercentage: input["canaryPercentage"],
    canaryInterval: input["canaryInterval"],
  }
}
function toTimeBasedCanary(root: jsonP.JSONValue): TimeBasedCanary {
  return jsonP.readObj({
    required: {},
    optional: {
      "canaryPercentage": "n",
      "canaryInterval": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface TimeBasedLinear {
  linearPercentage?: number | null;
  linearInterval?: number | null;
}
function fromTimeBasedLinear(input?: TimeBasedLinear | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    linearPercentage: input["linearPercentage"],
    linearInterval: input["linearInterval"],
  }
}
function toTimeBasedLinear(root: jsonP.JSONValue): TimeBasedLinear {
  return jsonP.readObj({
    required: {},
    optional: {
      "linearPercentage": "n",
      "linearInterval": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface TagFilter {
  Key?: string | null;
  Value?: string | null;
  Type?: TagFilterType | null;
}
function fromTagFilter(input?: TagFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Type: input["Type"],
  }
}
function toTagFilter(root: jsonP.JSONValue): TagFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<TagFilterType>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type TagFilterType =
| "KEY_ONLY"
| "VALUE_ONLY"
| "KEY_AND_VALUE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface TriggerConfig {
  triggerName?: string | null;
  triggerTargetArn?: string | null;
  triggerEvents?: TriggerEventType[] | null;
}
function fromTriggerConfig(input?: TriggerConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    triggerName: input["triggerName"],
    triggerTargetArn: input["triggerTargetArn"],
    triggerEvents: input["triggerEvents"],
  }
}
function toTriggerConfig(root: jsonP.JSONValue): TriggerConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "triggerName": "s",
      "triggerTargetArn": "s",
      "triggerEvents": [(x: jsonP.JSONValue) => cmnP.readEnum<TriggerEventType>(x)],
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type TriggerEventType =
| "DeploymentStart"
| "DeploymentSuccess"
| "DeploymentFailure"
| "DeploymentStop"
| "DeploymentRollback"
| "DeploymentReady"
| "InstanceStart"
| "InstanceSuccess"
| "InstanceFailure"
| "InstanceReady"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface AlarmConfiguration {
  enabled?: boolean | null;
  ignorePollAlarmFailure?: boolean | null;
  alarms?: Alarm[] | null;
}
function fromAlarmConfiguration(input?: AlarmConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
    ignorePollAlarmFailure: input["ignorePollAlarmFailure"],
    alarms: input["alarms"]?.map(x => fromAlarm(x)),
  }
}
function toAlarmConfiguration(root: jsonP.JSONValue): AlarmConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "enabled": "b",
      "ignorePollAlarmFailure": "b",
      "alarms": [toAlarm],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Alarm {
  name?: string | null;
}
function fromAlarm(input?: Alarm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toAlarm(root: jsonP.JSONValue): Alarm {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface DeploymentStyle {
  deploymentType?: DeploymentType | null;
  deploymentOption?: DeploymentOption | null;
}
function fromDeploymentStyle(input?: DeploymentStyle | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deploymentType: input["deploymentType"],
    deploymentOption: input["deploymentOption"],
  }
}
function toDeploymentStyle(root: jsonP.JSONValue): DeploymentStyle {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentType": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentType>(x),
      "deploymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentOption>(x),
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type DeploymentType =
| "IN_PLACE"
| "BLUE_GREEN"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type DeploymentOption =
| "WITH_TRAFFIC_CONTROL"
| "WITHOUT_TRAFFIC_CONTROL"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface BlueGreenDeploymentConfiguration {
  terminateBlueInstancesOnDeploymentSuccess?: BlueInstanceTerminationOption | null;
  deploymentReadyOption?: DeploymentReadyOption | null;
  greenFleetProvisioningOption?: GreenFleetProvisioningOption | null;
}
function fromBlueGreenDeploymentConfiguration(input?: BlueGreenDeploymentConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    terminateBlueInstancesOnDeploymentSuccess: fromBlueInstanceTerminationOption(input["terminateBlueInstancesOnDeploymentSuccess"]),
    deploymentReadyOption: fromDeploymentReadyOption(input["deploymentReadyOption"]),
    greenFleetProvisioningOption: fromGreenFleetProvisioningOption(input["greenFleetProvisioningOption"]),
  }
}
function toBlueGreenDeploymentConfiguration(root: jsonP.JSONValue): BlueGreenDeploymentConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "terminateBlueInstancesOnDeploymentSuccess": toBlueInstanceTerminationOption,
      "deploymentReadyOption": toDeploymentReadyOption,
      "greenFleetProvisioningOption": toGreenFleetProvisioningOption,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface BlueInstanceTerminationOption {
  action?: InstanceAction | null;
  terminationWaitTimeInMinutes?: number | null;
}
function fromBlueInstanceTerminationOption(input?: BlueInstanceTerminationOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: input["action"],
    terminationWaitTimeInMinutes: input["terminationWaitTimeInMinutes"],
  }
}
function toBlueInstanceTerminationOption(root: jsonP.JSONValue): BlueInstanceTerminationOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "action": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceAction>(x),
      "terminationWaitTimeInMinutes": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type InstanceAction =
| "TERMINATE"
| "KEEP_ALIVE"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface DeploymentReadyOption {
  actionOnTimeout?: DeploymentReadyAction | null;
  waitTimeInMinutes?: number | null;
}
function fromDeploymentReadyOption(input?: DeploymentReadyOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actionOnTimeout: input["actionOnTimeout"],
    waitTimeInMinutes: input["waitTimeInMinutes"],
  }
}
function toDeploymentReadyOption(root: jsonP.JSONValue): DeploymentReadyOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionOnTimeout": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentReadyAction>(x),
      "waitTimeInMinutes": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type DeploymentReadyAction =
| "CONTINUE_DEPLOYMENT"
| "STOP_DEPLOYMENT"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface GreenFleetProvisioningOption {
  action?: GreenFleetProvisioningAction | null;
}
function fromGreenFleetProvisioningOption(input?: GreenFleetProvisioningOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: input["action"],
  }
}
function toGreenFleetProvisioningOption(root: jsonP.JSONValue): GreenFleetProvisioningOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "action": (x: jsonP.JSONValue) => cmnP.readEnum<GreenFleetProvisioningAction>(x),
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type GreenFleetProvisioningAction =
| "DISCOVER_EXISTING"
| "COPY_AUTO_SCALING_GROUP"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface LoadBalancerInfo {
  elbInfoList?: ELBInfo[] | null;
  targetGroupInfoList?: TargetGroupInfo[] | null;
  targetGroupPairInfoList?: TargetGroupPairInfo[] | null;
}
function fromLoadBalancerInfo(input?: LoadBalancerInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    elbInfoList: input["elbInfoList"]?.map(x => fromELBInfo(x)),
    targetGroupInfoList: input["targetGroupInfoList"]?.map(x => fromTargetGroupInfo(x)),
    targetGroupPairInfoList: input["targetGroupPairInfoList"]?.map(x => fromTargetGroupPairInfo(x)),
  }
}
function toLoadBalancerInfo(root: jsonP.JSONValue): LoadBalancerInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "elbInfoList": [toELBInfo],
      "targetGroupInfoList": [toTargetGroupInfo],
      "targetGroupPairInfoList": [toTargetGroupPairInfo],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ELBInfo {
  name?: string | null;
}
function fromELBInfo(input?: ELBInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toELBInfo(root: jsonP.JSONValue): ELBInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

// refs: 14 - tags: input, named, interface, output
export interface TargetGroupInfo {
  name?: string | null;
}
function fromTargetGroupInfo(input?: TargetGroupInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toTargetGroupInfo(root: jsonP.JSONValue): TargetGroupInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface TargetGroupPairInfo {
  targetGroups?: TargetGroupInfo[] | null;
  prodTrafficRoute?: TrafficRoute | null;
  testTrafficRoute?: TrafficRoute | null;
}
function fromTargetGroupPairInfo(input?: TargetGroupPairInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    targetGroups: input["targetGroups"]?.map(x => fromTargetGroupInfo(x)),
    prodTrafficRoute: fromTrafficRoute(input["prodTrafficRoute"]),
    testTrafficRoute: fromTrafficRoute(input["testTrafficRoute"]),
  }
}
function toTargetGroupPairInfo(root: jsonP.JSONValue): TargetGroupPairInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "targetGroups": [toTargetGroupInfo],
      "prodTrafficRoute": toTrafficRoute,
      "testTrafficRoute": toTrafficRoute,
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface TrafficRoute {
  listenerArns?: string[] | null;
}
function fromTrafficRoute(input?: TrafficRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    listenerArns: input["listenerArns"],
  }
}
function toTrafficRoute(root: jsonP.JSONValue): TrafficRoute {
  return jsonP.readObj({
    required: {},
    optional: {
      "listenerArns": ["s"],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ECSService {
  serviceName?: string | null;
  clusterName?: string | null;
}
function fromECSService(input?: ECSService | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceName: input["serviceName"],
    clusterName: input["clusterName"],
  }
}
function toECSService(root: jsonP.JSONValue): ECSService {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceName": "s",
      "clusterName": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface OnPremisesTagSet {
  onPremisesTagSetList?: TagFilter[][] | null;
}
function fromOnPremisesTagSet(input?: OnPremisesTagSet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    onPremisesTagSetList: input["onPremisesTagSetList"]?.map(x => x?.map(fromTagFilter)),
  }
}
function toOnPremisesTagSet(root: jsonP.JSONValue): OnPremisesTagSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "onPremisesTagSetList": [x => jsonP.readList(toTagFilter, x)],
    },
  }, root);
}

// refs: 1 - tags: input, named, enum
export type ApplicationRevisionSortBy =
| "registerTime"
| "firstUsedTime"
| "lastUsedTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SortOrder =
| "ascending"
| "descending"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ListStateFilterAction =
| "include"
| "exclude"
| "ignore"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type InstanceStatus =
| "Pending"
| "InProgress"
| "Succeeded"
| "Failed"
| "Skipped"
| "Unknown"
| "Ready"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type InstanceType =
| "Blue"
| "Green"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type TargetFilterName =
| "TargetStatus"
| "ServerInstanceLabel"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type DeploymentStatus =
| "Created"
| "Queued"
| "InProgress"
| "Baking"
| "Succeeded"
| "Failed"
| "Stopped"
| "Ready"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TimeRange {
  start?: Date | number | null;
  end?: Date | number | null;
}
function fromTimeRange(input?: TimeRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    start: jsonP.serializeDate_unixTimestamp(input["start"]),
    end: jsonP.serializeDate_unixTimestamp(input["end"]),
  }
}

// refs: 1 - tags: input, named, enum
export type RegistrationStatus =
| "Registered"
| "Deregistered"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, enum, output
export type LifecycleEventStatus =
| "Pending"
| "InProgress"
| "Succeeded"
| "Failed"
| "Skipped"
| "Unknown"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface RevisionInfo {
  revisionLocation?: RevisionLocation | null;
  genericRevisionInfo?: GenericRevisionInfo | null;
}
function toRevisionInfo(root: jsonP.JSONValue): RevisionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "revisionLocation": toRevisionLocation,
      "genericRevisionInfo": toGenericRevisionInfo,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface GenericRevisionInfo {
  description?: string | null;
  deploymentGroups?: string[] | null;
  firstUsedTime?: Date | number | null;
  lastUsedTime?: Date | number | null;
  registerTime?: Date | number | null;
}
function toGenericRevisionInfo(root: jsonP.JSONValue): GenericRevisionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "description": "s",
      "deploymentGroups": ["s"],
      "firstUsedTime": "d",
      "lastUsedTime": "d",
      "registerTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ApplicationInfo {
  applicationId?: string | null;
  applicationName?: string | null;
  createTime?: Date | number | null;
  linkedToGitHub?: boolean | null;
  gitHubAccountName?: string | null;
  computePlatform?: ComputePlatform | null;
}
function toApplicationInfo(root: jsonP.JSONValue): ApplicationInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "applicationId": "s",
      "applicationName": "s",
      "createTime": "d",
      "linkedToGitHub": "b",
      "gitHubAccountName": "s",
      "computePlatform": (x: jsonP.JSONValue) => cmnP.readEnum<ComputePlatform>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface DeploymentGroupInfo {
  applicationName?: string | null;
  deploymentGroupId?: string | null;
  deploymentGroupName?: string | null;
  deploymentConfigName?: string | null;
  ec2TagFilters?: EC2TagFilter[] | null;
  onPremisesInstanceTagFilters?: TagFilter[] | null;
  autoScalingGroups?: AutoScalingGroup[] | null;
  serviceRoleArn?: string | null;
  targetRevision?: RevisionLocation | null;
  triggerConfigurations?: TriggerConfig[] | null;
  alarmConfiguration?: AlarmConfiguration | null;
  autoRollbackConfiguration?: AutoRollbackConfiguration | null;
  deploymentStyle?: DeploymentStyle | null;
  blueGreenDeploymentConfiguration?: BlueGreenDeploymentConfiguration | null;
  loadBalancerInfo?: LoadBalancerInfo | null;
  lastSuccessfulDeployment?: LastDeploymentInfo | null;
  lastAttemptedDeployment?: LastDeploymentInfo | null;
  ec2TagSet?: EC2TagSet | null;
  onPremisesTagSet?: OnPremisesTagSet | null;
  computePlatform?: ComputePlatform | null;
  ecsServices?: ECSService[] | null;
}
function toDeploymentGroupInfo(root: jsonP.JSONValue): DeploymentGroupInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "applicationName": "s",
      "deploymentGroupId": "s",
      "deploymentGroupName": "s",
      "deploymentConfigName": "s",
      "ec2TagFilters": [toEC2TagFilter],
      "onPremisesInstanceTagFilters": [toTagFilter],
      "autoScalingGroups": [toAutoScalingGroup],
      "serviceRoleArn": "s",
      "targetRevision": toRevisionLocation,
      "triggerConfigurations": [toTriggerConfig],
      "alarmConfiguration": toAlarmConfiguration,
      "autoRollbackConfiguration": toAutoRollbackConfiguration,
      "deploymentStyle": toDeploymentStyle,
      "blueGreenDeploymentConfiguration": toBlueGreenDeploymentConfiguration,
      "loadBalancerInfo": toLoadBalancerInfo,
      "lastSuccessfulDeployment": toLastDeploymentInfo,
      "lastAttemptedDeployment": toLastDeploymentInfo,
      "ec2TagSet": toEC2TagSet,
      "onPremisesTagSet": toOnPremisesTagSet,
      "computePlatform": (x: jsonP.JSONValue) => cmnP.readEnum<ComputePlatform>(x),
      "ecsServices": [toECSService],
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface AutoScalingGroup {
  name?: string | null;
  hook?: string | null;
}
function toAutoScalingGroup(root: jsonP.JSONValue): AutoScalingGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "hook": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface LastDeploymentInfo {
  deploymentId?: string | null;
  status?: DeploymentStatus | null;
  endTime?: Date | number | null;
  createTime?: Date | number | null;
}
function toLastDeploymentInfo(root: jsonP.JSONValue): LastDeploymentInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentStatus>(x),
      "endTime": "d",
      "createTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface InstanceSummary {
  deploymentId?: string | null;
  instanceId?: string | null;
  status?: InstanceStatus | null;
  lastUpdatedAt?: Date | number | null;
  lifecycleEvents?: LifecycleEvent[] | null;
  instanceType?: InstanceType | null;
}
function toInstanceSummary(root: jsonP.JSONValue): InstanceSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "instanceId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceStatus>(x),
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "instanceType": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceType>(x),
    },
  }, root);
}

// refs: 10 - tags: output, named, interface
export interface LifecycleEvent {
  lifecycleEventName?: string | null;
  diagnostics?: Diagnostics | null;
  startTime?: Date | number | null;
  endTime?: Date | number | null;
  status?: LifecycleEventStatus | null;
}
function toLifecycleEvent(root: jsonP.JSONValue): LifecycleEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "lifecycleEventName": "s",
      "diagnostics": toDiagnostics,
      "startTime": "d",
      "endTime": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<LifecycleEventStatus>(x),
    },
  }, root);
}

// refs: 10 - tags: output, named, interface
export interface Diagnostics {
  errorCode?: LifecycleErrorCode | null;
  scriptName?: string | null;
  message?: string | null;
  logTail?: string | null;
}
function toDiagnostics(root: jsonP.JSONValue): Diagnostics {
  return jsonP.readObj({
    required: {},
    optional: {
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<LifecycleErrorCode>(x),
      "scriptName": "s",
      "message": "s",
      "logTail": "s",
    },
  }, root);
}

// refs: 10 - tags: output, named, enum
export type LifecycleErrorCode =
| "Success"
| "ScriptMissing"
| "ScriptNotExecutable"
| "ScriptTimedOut"
| "ScriptFailed"
| "UnknownError"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface DeploymentTarget {
  deploymentTargetType?: DeploymentTargetType | null;
  instanceTarget?: InstanceTarget | null;
  lambdaTarget?: LambdaTarget | null;
  ecsTarget?: ECSTarget | null;
  cloudFormationTarget?: CloudFormationTarget | null;
}
function toDeploymentTarget(root: jsonP.JSONValue): DeploymentTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentTargetType": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentTargetType>(x),
      "instanceTarget": toInstanceTarget,
      "lambdaTarget": toLambdaTarget,
      "ecsTarget": toECSTarget,
      "cloudFormationTarget": toCloudFormationTarget,
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DeploymentTargetType =
| "InstanceTarget"
| "LambdaTarget"
| "ECSTarget"
| "CloudFormationTarget"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface InstanceTarget {
  deploymentId?: string | null;
  targetId?: string | null;
  targetArn?: string | null;
  status?: TargetStatus | null;
  lastUpdatedAt?: Date | number | null;
  lifecycleEvents?: LifecycleEvent[] | null;
  instanceLabel?: TargetLabel | null;
}
function toInstanceTarget(root: jsonP.JSONValue): InstanceTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "targetId": "s",
      "targetArn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<TargetStatus>(x),
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "instanceLabel": (x: jsonP.JSONValue) => cmnP.readEnum<TargetLabel>(x),
    },
  }, root);
}

// refs: 8 - tags: output, named, enum
export type TargetStatus =
| "Pending"
| "InProgress"
| "Succeeded"
| "Failed"
| "Skipped"
| "Unknown"
| "Ready"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type TargetLabel =
| "Blue"
| "Green"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface LambdaTarget {
  deploymentId?: string | null;
  targetId?: string | null;
  targetArn?: string | null;
  status?: TargetStatus | null;
  lastUpdatedAt?: Date | number | null;
  lifecycleEvents?: LifecycleEvent[] | null;
  lambdaFunctionInfo?: LambdaFunctionInfo | null;
}
function toLambdaTarget(root: jsonP.JSONValue): LambdaTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "targetId": "s",
      "targetArn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<TargetStatus>(x),
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "lambdaFunctionInfo": toLambdaFunctionInfo,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface LambdaFunctionInfo {
  functionName?: string | null;
  functionAlias?: string | null;
  currentVersion?: string | null;
  targetVersion?: string | null;
  targetVersionWeight?: number | null;
}
function toLambdaFunctionInfo(root: jsonP.JSONValue): LambdaFunctionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "functionName": "s",
      "functionAlias": "s",
      "currentVersion": "s",
      "targetVersion": "s",
      "targetVersionWeight": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ECSTarget {
  deploymentId?: string | null;
  targetId?: string | null;
  targetArn?: string | null;
  lastUpdatedAt?: Date | number | null;
  lifecycleEvents?: LifecycleEvent[] | null;
  status?: TargetStatus | null;
  taskSetsInfo?: ECSTaskSet[] | null;
}
function toECSTarget(root: jsonP.JSONValue): ECSTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "targetId": "s",
      "targetArn": "s",
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<TargetStatus>(x),
      "taskSetsInfo": [toECSTaskSet],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ECSTaskSet {
  identifer?: string | null;
  desiredCount?: number | null;
  pendingCount?: number | null;
  runningCount?: number | null;
  status?: string | null;
  trafficWeight?: number | null;
  targetGroup?: TargetGroupInfo | null;
  taskSetLabel?: TargetLabel | null;
}
function toECSTaskSet(root: jsonP.JSONValue): ECSTaskSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "identifer": "s",
      "desiredCount": "n",
      "pendingCount": "n",
      "runningCount": "n",
      "status": "s",
      "trafficWeight": "n",
      "targetGroup": toTargetGroupInfo,
      "taskSetLabel": (x: jsonP.JSONValue) => cmnP.readEnum<TargetLabel>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface CloudFormationTarget {
  deploymentId?: string | null;
  targetId?: string | null;
  lastUpdatedAt?: Date | number | null;
  lifecycleEvents?: LifecycleEvent[] | null;
  status?: TargetStatus | null;
  resourceType?: string | null;
  targetVersionWeight?: number | null;
}
function toCloudFormationTarget(root: jsonP.JSONValue): CloudFormationTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentId": "s",
      "targetId": "s",
      "lastUpdatedAt": "d",
      "lifecycleEvents": [toLifecycleEvent],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<TargetStatus>(x),
      "resourceType": "s",
      "targetVersionWeight": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface DeploymentInfo {
  applicationName?: string | null;
  deploymentGroupName?: string | null;
  deploymentConfigName?: string | null;
  deploymentId?: string | null;
  previousRevision?: RevisionLocation | null;
  revision?: RevisionLocation | null;
  status?: DeploymentStatus | null;
  errorInformation?: ErrorInformation | null;
  createTime?: Date | number | null;
  startTime?: Date | number | null;
  completeTime?: Date | number | null;
  deploymentOverview?: DeploymentOverview | null;
  description?: string | null;
  creator?: DeploymentCreator | null;
  ignoreApplicationStopFailures?: boolean | null;
  autoRollbackConfiguration?: AutoRollbackConfiguration | null;
  updateOutdatedInstancesOnly?: boolean | null;
  rollbackInfo?: RollbackInfo | null;
  deploymentStyle?: DeploymentStyle | null;
  targetInstances?: TargetInstances | null;
  instanceTerminationWaitTimeStarted?: boolean | null;
  blueGreenDeploymentConfiguration?: BlueGreenDeploymentConfiguration | null;
  loadBalancerInfo?: LoadBalancerInfo | null;
  additionalDeploymentStatusInfo?: string | null;
  fileExistsBehavior?: FileExistsBehavior | null;
  deploymentStatusMessages?: string[] | null;
  computePlatform?: ComputePlatform | null;
  externalId?: string | null;
}
function toDeploymentInfo(root: jsonP.JSONValue): DeploymentInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "applicationName": "s",
      "deploymentGroupName": "s",
      "deploymentConfigName": "s",
      "deploymentId": "s",
      "previousRevision": toRevisionLocation,
      "revision": toRevisionLocation,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentStatus>(x),
      "errorInformation": toErrorInformation,
      "createTime": "d",
      "startTime": "d",
      "completeTime": "d",
      "deploymentOverview": toDeploymentOverview,
      "description": "s",
      "creator": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentCreator>(x),
      "ignoreApplicationStopFailures": "b",
      "autoRollbackConfiguration": toAutoRollbackConfiguration,
      "updateOutdatedInstancesOnly": "b",
      "rollbackInfo": toRollbackInfo,
      "deploymentStyle": toDeploymentStyle,
      "targetInstances": toTargetInstances,
      "instanceTerminationWaitTimeStarted": "b",
      "blueGreenDeploymentConfiguration": toBlueGreenDeploymentConfiguration,
      "loadBalancerInfo": toLoadBalancerInfo,
      "additionalDeploymentStatusInfo": "s",
      "fileExistsBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<FileExistsBehavior>(x),
      "deploymentStatusMessages": ["s"],
      "computePlatform": (x: jsonP.JSONValue) => cmnP.readEnum<ComputePlatform>(x),
      "externalId": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ErrorInformation {
  code?: ErrorCode | null;
  message?: string | null;
}
function toErrorInformation(root: jsonP.JSONValue): ErrorInformation {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<ErrorCode>(x),
      "message": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ErrorCode =
| "AGENT_ISSUE"
| "ALARM_ACTIVE"
| "APPLICATION_MISSING"
| "AUTOSCALING_VALIDATION_ERROR"
| "AUTO_SCALING_CONFIGURATION"
| "AUTO_SCALING_IAM_ROLE_PERMISSIONS"
| "CODEDEPLOY_RESOURCE_CANNOT_BE_FOUND"
| "CUSTOMER_APPLICATION_UNHEALTHY"
| "DEPLOYMENT_GROUP_MISSING"
| "ECS_UPDATE_ERROR"
| "ELASTIC_LOAD_BALANCING_INVALID"
| "ELB_INVALID_INSTANCE"
| "HEALTH_CONSTRAINTS"
| "HEALTH_CONSTRAINTS_INVALID"
| "HOOK_EXECUTION_FAILURE"
| "IAM_ROLE_MISSING"
| "IAM_ROLE_PERMISSIONS"
| "INTERNAL_ERROR"
| "INVALID_ECS_SERVICE"
| "INVALID_LAMBDA_CONFIGURATION"
| "INVALID_LAMBDA_FUNCTION"
| "INVALID_REVISION"
| "MANUAL_STOP"
| "MISSING_BLUE_GREEN_DEPLOYMENT_CONFIGURATION"
| "MISSING_ELB_INFORMATION"
| "MISSING_GITHUB_TOKEN"
| "NO_EC2_SUBSCRIPTION"
| "NO_INSTANCES"
| "OVER_MAX_INSTANCES"
| "RESOURCE_LIMIT_EXCEEDED"
| "REVISION_MISSING"
| "THROTTLED"
| "TIMEOUT"
| "CLOUDFORMATION_STACK_FAILURE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface DeploymentOverview {
  Pending?: number | null;
  InProgress?: number | null;
  Succeeded?: number | null;
  Failed?: number | null;
  Skipped?: number | null;
  Ready?: number | null;
}
function toDeploymentOverview(root: jsonP.JSONValue): DeploymentOverview {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pending": "n",
      "InProgress": "n",
      "Succeeded": "n",
      "Failed": "n",
      "Skipped": "n",
      "Ready": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DeploymentCreator =
| "user"
| "autoscaling"
| "codeDeployRollback"
| "CodeDeploy"
| "CloudFormation"
| "CloudFormationRollback"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface RollbackInfo {
  rollbackDeploymentId?: string | null;
  rollbackTriggeringDeploymentId?: string | null;
  rollbackMessage?: string | null;
}
function toRollbackInfo(root: jsonP.JSONValue): RollbackInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "rollbackDeploymentId": "s",
      "rollbackTriggeringDeploymentId": "s",
      "rollbackMessage": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface InstanceInfo {
  instanceName?: string | null;
  iamSessionArn?: string | null;
  iamUserArn?: string | null;
  instanceArn?: string | null;
  registerTime?: Date | number | null;
  deregisterTime?: Date | number | null;
  tags?: Tag[] | null;
}
function toInstanceInfo(root: jsonP.JSONValue): InstanceInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "instanceName": "s",
      "iamSessionArn": "s",
      "iamUserArn": "s",
      "instanceArn": "s",
      "registerTime": "d",
      "deregisterTime": "d",
      "tags": [toTag],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DeploymentConfigInfo {
  deploymentConfigId?: string | null;
  deploymentConfigName?: string | null;
  minimumHealthyHosts?: MinimumHealthyHosts | null;
  createTime?: Date | number | null;
  computePlatform?: ComputePlatform | null;
  trafficRoutingConfig?: TrafficRoutingConfig | null;
}
function toDeploymentConfigInfo(root: jsonP.JSONValue): DeploymentConfigInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentConfigId": "s",
      "deploymentConfigName": "s",
      "minimumHealthyHosts": toMinimumHealthyHosts,
      "createTime": "d",
      "computePlatform": (x: jsonP.JSONValue) => cmnP.readEnum<ComputePlatform>(x),
      "trafficRoutingConfig": toTrafficRoutingConfig,
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type StopStatus =
| "Pending"
| "Succeeded"
| cmnP.UnexpectedEnumValue;
