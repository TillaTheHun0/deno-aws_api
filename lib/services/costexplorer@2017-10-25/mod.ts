// Autogenerated API client for: AWS Cost Explorer Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class CostExplorer {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CostExplorer.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-10-25",
    "endpointPrefix": "ce",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "AWS Cost Explorer",
    "serviceFullName": "AWS Cost Explorer Service",
    "serviceId": "Cost Explorer",
    "signatureVersion": "v4",
    "signingName": "ce",
    "targetPrefix": "AWSInsightsIndexService",
    "uid": "ce-2017-10-25"
  };

  async createAnomalyMonitor(
    {abortSignal, ...params}: RequestConfig & CreateAnomalyMonitorRequest,
  ): Promise<CreateAnomalyMonitorResponse> {
    const body: jsonP.JSONObject = {
      AnomalyMonitor: fromAnomalyMonitor(params["AnomalyMonitor"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAnomalyMonitor",
    });
    return jsonP.readObj({
      required: {
        "MonitorArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createAnomalySubscription(
    {abortSignal, ...params}: RequestConfig & CreateAnomalySubscriptionRequest,
  ): Promise<CreateAnomalySubscriptionResponse> {
    const body: jsonP.JSONObject = {
      AnomalySubscription: fromAnomalySubscription(params["AnomalySubscription"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAnomalySubscription",
    });
    return jsonP.readObj({
      required: {
        "SubscriptionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createCostCategoryDefinition(
    {abortSignal, ...params}: RequestConfig & CreateCostCategoryDefinitionRequest,
  ): Promise<CreateCostCategoryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RuleVersion: params["RuleVersion"],
      Rules: params["Rules"]?.map(x => fromCostCategoryRule(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCostCategoryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategoryArn": "s",
        "EffectiveStart": "s",
      },
    }, await resp.json());
  }

  async deleteAnomalyMonitor(
    {abortSignal, ...params}: RequestConfig & DeleteAnomalyMonitorRequest,
  ): Promise<DeleteAnomalyMonitorResponse> {
    const body: jsonP.JSONObject = {
      MonitorArn: params["MonitorArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAnomalyMonitor",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteAnomalySubscription(
    {abortSignal, ...params}: RequestConfig & DeleteAnomalySubscriptionRequest,
  ): Promise<DeleteAnomalySubscriptionResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionArn: params["SubscriptionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAnomalySubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteCostCategoryDefinition(
    {abortSignal, ...params}: RequestConfig & DeleteCostCategoryDefinitionRequest,
  ): Promise<DeleteCostCategoryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      CostCategoryArn: params["CostCategoryArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCostCategoryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategoryArn": "s",
        "EffectiveEnd": "s",
      },
    }, await resp.json());
  }

  async describeCostCategoryDefinition(
    {abortSignal, ...params}: RequestConfig & DescribeCostCategoryDefinitionRequest,
  ): Promise<DescribeCostCategoryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      CostCategoryArn: params["CostCategoryArn"],
      EffectiveOn: params["EffectiveOn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCostCategoryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategory": toCostCategory,
      },
    }, await resp.json());
  }

  async getAnomalies(
    {abortSignal, ...params}: RequestConfig & GetAnomaliesRequest,
  ): Promise<GetAnomaliesResponse> {
    const body: jsonP.JSONObject = {
      MonitorArn: params["MonitorArn"],
      DateInterval: fromAnomalyDateInterval(params["DateInterval"]),
      Feedback: params["Feedback"],
      TotalImpact: fromTotalImpactFilter(params["TotalImpact"]),
      NextPageToken: params["NextPageToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAnomalies",
    });
    return jsonP.readObj({
      required: {
        "Anomalies": [toAnomaly],
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getAnomalyMonitors(
    {abortSignal, ...params}: RequestConfig & GetAnomalyMonitorsRequest = {},
  ): Promise<GetAnomalyMonitorsResponse> {
    const body: jsonP.JSONObject = {
      MonitorArnList: params["MonitorArnList"],
      NextPageToken: params["NextPageToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAnomalyMonitors",
    });
    return jsonP.readObj({
      required: {
        "AnomalyMonitors": [toAnomalyMonitor],
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getAnomalySubscriptions(
    {abortSignal, ...params}: RequestConfig & GetAnomalySubscriptionsRequest = {},
  ): Promise<GetAnomalySubscriptionsResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionArnList: params["SubscriptionArnList"],
      MonitorArn: params["MonitorArn"],
      NextPageToken: params["NextPageToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAnomalySubscriptions",
    });
    return jsonP.readObj({
      required: {
        "AnomalySubscriptions": [toAnomalySubscription],
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getCostAndUsage(
    {abortSignal, ...params}: RequestConfig & GetCostAndUsageRequest,
  ): Promise<GetCostAndUsageResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      Metrics: params["Metrics"],
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCostAndUsage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextPageToken": "s",
        "GroupDefinitions": [toGroupDefinition],
        "ResultsByTime": [toResultByTime],
        "DimensionValueAttributes": [toDimensionValuesWithAttributes],
      },
    }, await resp.json());
  }

  async getCostAndUsageWithResources(
    {abortSignal, ...params}: RequestConfig & GetCostAndUsageWithResourcesRequest,
  ): Promise<GetCostAndUsageWithResourcesResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      Metrics: params["Metrics"],
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCostAndUsageWithResources",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextPageToken": "s",
        "GroupDefinitions": [toGroupDefinition],
        "ResultsByTime": [toResultByTime],
        "DimensionValueAttributes": [toDimensionValuesWithAttributes],
      },
    }, await resp.json());
  }

  async getCostCategories(
    {abortSignal, ...params}: RequestConfig & GetCostCategoriesRequest,
  ): Promise<GetCostCategoriesResponse> {
    const body: jsonP.JSONObject = {
      SearchString: params["SearchString"],
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      CostCategoryName: params["CostCategoryName"],
      Filter: fromExpression(params["Filter"]),
      SortBy: params["SortBy"]?.map(x => fromSortDefinition(x)),
      MaxResults: params["MaxResults"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCostCategories",
    });
    return jsonP.readObj({
      required: {
        "ReturnSize": "n",
        "TotalSize": "n",
      },
      optional: {
        "NextPageToken": "s",
        "CostCategoryNames": ["s"],
        "CostCategoryValues": ["s"],
      },
    }, await resp.json());
  }

  async getCostForecast(
    {abortSignal, ...params}: RequestConfig & GetCostForecastRequest,
  ): Promise<GetCostForecastResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Metric: params["Metric"],
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      PredictionIntervalLevel: params["PredictionIntervalLevel"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCostForecast",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Total": toMetricValue,
        "ForecastResultsByTime": [toForecastResult],
      },
    }, await resp.json());
  }

  async getDimensionValues(
    {abortSignal, ...params}: RequestConfig & GetDimensionValuesRequest,
  ): Promise<GetDimensionValuesResponse> {
    const body: jsonP.JSONObject = {
      SearchString: params["SearchString"],
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Dimension: params["Dimension"],
      Context: params["Context"],
      Filter: fromExpression(params["Filter"]),
      SortBy: params["SortBy"]?.map(x => fromSortDefinition(x)),
      MaxResults: params["MaxResults"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDimensionValues",
    });
    return jsonP.readObj({
      required: {
        "DimensionValues": [toDimensionValuesWithAttributes],
        "ReturnSize": "n",
        "TotalSize": "n",
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getReservationCoverage(
    {abortSignal, ...params}: RequestConfig & GetReservationCoverageRequest,
  ): Promise<GetReservationCoverageResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      Metrics: params["Metrics"],
      NextPageToken: params["NextPageToken"],
      SortBy: fromSortDefinition(params["SortBy"]),
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservationCoverage",
    });
    return jsonP.readObj({
      required: {
        "CoveragesByTime": [toCoverageByTime],
      },
      optional: {
        "Total": toCoverage,
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getReservationPurchaseRecommendation(
    {abortSignal, ...params}: RequestConfig & GetReservationPurchaseRecommendationRequest,
  ): Promise<GetReservationPurchaseRecommendationResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      Service: params["Service"],
      Filter: fromExpression(params["Filter"]),
      AccountScope: params["AccountScope"],
      LookbackPeriodInDays: params["LookbackPeriodInDays"],
      TermInYears: params["TermInYears"],
      PaymentOption: params["PaymentOption"],
      ServiceSpecification: fromServiceSpecification(params["ServiceSpecification"]),
      PageSize: params["PageSize"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservationPurchaseRecommendation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toReservationPurchaseRecommendationMetadata,
        "Recommendations": [toReservationPurchaseRecommendation],
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getReservationUtilization(
    {abortSignal, ...params}: RequestConfig & GetReservationUtilizationRequest,
  ): Promise<GetReservationUtilizationResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      SortBy: fromSortDefinition(params["SortBy"]),
      NextPageToken: params["NextPageToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservationUtilization",
    });
    return jsonP.readObj({
      required: {
        "UtilizationsByTime": [toUtilizationByTime],
      },
      optional: {
        "Total": toReservationAggregates,
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getRightsizingRecommendation(
    {abortSignal, ...params}: RequestConfig & GetRightsizingRecommendationRequest,
  ): Promise<GetRightsizingRecommendationResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromExpression(params["Filter"]),
      Configuration: fromRightsizingRecommendationConfiguration(params["Configuration"]),
      Service: params["Service"],
      PageSize: params["PageSize"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRightsizingRecommendation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toRightsizingRecommendationMetadata,
        "Summary": toRightsizingRecommendationSummary,
        "RightsizingRecommendations": [toRightsizingRecommendation],
        "NextPageToken": "s",
        "Configuration": toRightsizingRecommendationConfiguration,
      },
    }, await resp.json());
  }

  async getSavingsPlansCoverage(
    {abortSignal, ...params}: RequestConfig & GetSavingsPlansCoverageRequest,
  ): Promise<GetSavingsPlansCoverageResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      Metrics: params["Metrics"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: fromSortDefinition(params["SortBy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSavingsPlansCoverage",
    });
    return jsonP.readObj({
      required: {
        "SavingsPlansCoverages": [toSavingsPlansCoverage],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getSavingsPlansPurchaseRecommendation(
    {abortSignal, ...params}: RequestConfig & GetSavingsPlansPurchaseRecommendationRequest,
  ): Promise<GetSavingsPlansPurchaseRecommendationResponse> {
    const body: jsonP.JSONObject = {
      SavingsPlansType: params["SavingsPlansType"],
      TermInYears: params["TermInYears"],
      PaymentOption: params["PaymentOption"],
      AccountScope: params["AccountScope"],
      NextPageToken: params["NextPageToken"],
      PageSize: params["PageSize"],
      LookbackPeriodInDays: params["LookbackPeriodInDays"],
      Filter: fromExpression(params["Filter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSavingsPlansPurchaseRecommendation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toSavingsPlansPurchaseRecommendationMetadata,
        "SavingsPlansPurchaseRecommendation": toSavingsPlansPurchaseRecommendation,
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getSavingsPlansUtilization(
    {abortSignal, ...params}: RequestConfig & GetSavingsPlansUtilizationRequest,
  ): Promise<GetSavingsPlansUtilizationResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      SortBy: fromSortDefinition(params["SortBy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSavingsPlansUtilization",
    });
    return jsonP.readObj({
      required: {
        "Total": toSavingsPlansUtilizationAggregates,
      },
      optional: {
        "SavingsPlansUtilizationsByTime": [toSavingsPlansUtilizationByTime],
      },
    }, await resp.json());
  }

  async getSavingsPlansUtilizationDetails(
    {abortSignal, ...params}: RequestConfig & GetSavingsPlansUtilizationDetailsRequest,
  ): Promise<GetSavingsPlansUtilizationDetailsResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Filter: fromExpression(params["Filter"]),
      DataType: params["DataType"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: fromSortDefinition(params["SortBy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSavingsPlansUtilizationDetails",
    });
    return jsonP.readObj({
      required: {
        "SavingsPlansUtilizationDetails": [toSavingsPlansUtilizationDetail],
        "TimePeriod": toDateInterval,
      },
      optional: {
        "Total": toSavingsPlansUtilizationAggregates,
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTags(
    {abortSignal, ...params}: RequestConfig & GetTagsRequest,
  ): Promise<GetTagsResponse> {
    const body: jsonP.JSONObject = {
      SearchString: params["SearchString"],
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      TagKey: params["TagKey"],
      Filter: fromExpression(params["Filter"]),
      SortBy: params["SortBy"]?.map(x => fromSortDefinition(x)),
      MaxResults: params["MaxResults"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTags",
    });
    return jsonP.readObj({
      required: {
        "Tags": ["s"],
        "ReturnSize": "n",
        "TotalSize": "n",
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getUsageForecast(
    {abortSignal, ...params}: RequestConfig & GetUsageForecastRequest,
  ): Promise<GetUsageForecastResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Metric: params["Metric"],
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      PredictionIntervalLevel: params["PredictionIntervalLevel"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUsageForecast",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Total": toMetricValue,
        "ForecastResultsByTime": [toForecastResult],
      },
    }, await resp.json());
  }

  async listCostCategoryDefinitions(
    {abortSignal, ...params}: RequestConfig & ListCostCategoryDefinitionsRequest = {},
  ): Promise<ListCostCategoryDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      EffectiveOn: params["EffectiveOn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCostCategoryDefinitions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategoryReferences": [toCostCategoryReference],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async provideAnomalyFeedback(
    {abortSignal, ...params}: RequestConfig & ProvideAnomalyFeedbackRequest,
  ): Promise<ProvideAnomalyFeedbackResponse> {
    const body: jsonP.JSONObject = {
      AnomalyId: params["AnomalyId"],
      Feedback: params["Feedback"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ProvideAnomalyFeedback",
    });
    return jsonP.readObj({
      required: {
        "AnomalyId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateAnomalyMonitor(
    {abortSignal, ...params}: RequestConfig & UpdateAnomalyMonitorRequest,
  ): Promise<UpdateAnomalyMonitorResponse> {
    const body: jsonP.JSONObject = {
      MonitorArn: params["MonitorArn"],
      MonitorName: params["MonitorName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAnomalyMonitor",
    });
    return jsonP.readObj({
      required: {
        "MonitorArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateAnomalySubscription(
    {abortSignal, ...params}: RequestConfig & UpdateAnomalySubscriptionRequest,
  ): Promise<UpdateAnomalySubscriptionResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionArn: params["SubscriptionArn"],
      Threshold: params["Threshold"],
      Frequency: params["Frequency"],
      MonitorArnList: params["MonitorArnList"],
      Subscribers: params["Subscribers"]?.map(x => fromSubscriber(x)),
      SubscriptionName: params["SubscriptionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAnomalySubscription",
    });
    return jsonP.readObj({
      required: {
        "SubscriptionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateCostCategoryDefinition(
    {abortSignal, ...params}: RequestConfig & UpdateCostCategoryDefinitionRequest,
  ): Promise<UpdateCostCategoryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      CostCategoryArn: params["CostCategoryArn"],
      RuleVersion: params["RuleVersion"],
      Rules: params["Rules"]?.map(x => fromCostCategoryRule(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCostCategoryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategoryArn": "s",
        "EffectiveStart": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CreateAnomalyMonitorRequest {
  AnomalyMonitor: AnomalyMonitor;
}

// refs: 1 - tags: named, input
export interface CreateAnomalySubscriptionRequest {
  AnomalySubscription: AnomalySubscription;
}

// refs: 1 - tags: named, input
export interface CreateCostCategoryDefinitionRequest {
  Name: string;
  RuleVersion: CostCategoryRuleVersion;
  Rules: CostCategoryRule[];
}

// refs: 1 - tags: named, input
export interface DeleteAnomalyMonitorRequest {
  MonitorArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteAnomalySubscriptionRequest {
  SubscriptionArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteCostCategoryDefinitionRequest {
  CostCategoryArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeCostCategoryDefinitionRequest {
  CostCategoryArn: string;
  EffectiveOn?: string | null;
}

// refs: 1 - tags: named, input
export interface GetAnomaliesRequest {
  MonitorArn?: string | null;
  DateInterval: AnomalyDateInterval;
  Feedback?: AnomalyFeedbackType | null;
  TotalImpact?: TotalImpactFilter | null;
  NextPageToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetAnomalyMonitorsRequest {
  MonitorArnList?: string[] | null;
  NextPageToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetAnomalySubscriptionsRequest {
  SubscriptionArnList?: string[] | null;
  MonitorArn?: string | null;
  NextPageToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetCostAndUsageRequest {
  TimePeriod: DateInterval;
  Granularity?: Granularity | null;
  Filter?: Expression | null;
  Metrics: string[];
  GroupBy?: GroupDefinition[] | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetCostAndUsageWithResourcesRequest {
  TimePeriod: DateInterval;
  Granularity?: Granularity | null;
  Filter: Expression;
  Metrics?: string[] | null;
  GroupBy?: GroupDefinition[] | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetCostCategoriesRequest {
  SearchString?: string | null;
  TimePeriod: DateInterval;
  CostCategoryName?: string | null;
  Filter?: Expression | null;
  SortBy?: SortDefinition[] | null;
  MaxResults?: number | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetCostForecastRequest {
  TimePeriod: DateInterval;
  Metric: Metric;
  Granularity: Granularity;
  Filter?: Expression | null;
  PredictionIntervalLevel?: number | null;
}

// refs: 1 - tags: named, input
export interface GetDimensionValuesRequest {
  SearchString?: string | null;
  TimePeriod: DateInterval;
  Dimension: Dimension;
  Context?: Context | null;
  Filter?: Expression | null;
  SortBy?: SortDefinition[] | null;
  MaxResults?: number | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetReservationCoverageRequest {
  TimePeriod: DateInterval;
  GroupBy?: GroupDefinition[] | null;
  Granularity?: Granularity | null;
  Filter?: Expression | null;
  Metrics?: string[] | null;
  NextPageToken?: string | null;
  SortBy?: SortDefinition | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetReservationPurchaseRecommendationRequest {
  AccountId?: string | null;
  Service: string;
  Filter?: Expression | null;
  AccountScope?: AccountScope | null;
  LookbackPeriodInDays?: LookbackPeriodInDays | null;
  TermInYears?: TermInYears | null;
  PaymentOption?: PaymentOption | null;
  ServiceSpecification?: ServiceSpecification | null;
  PageSize?: number | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetReservationUtilizationRequest {
  TimePeriod: DateInterval;
  GroupBy?: GroupDefinition[] | null;
  Granularity?: Granularity | null;
  Filter?: Expression | null;
  SortBy?: SortDefinition | null;
  NextPageToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetRightsizingRecommendationRequest {
  Filter?: Expression | null;
  Configuration?: RightsizingRecommendationConfiguration | null;
  Service: string;
  PageSize?: number | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetSavingsPlansCoverageRequest {
  TimePeriod: DateInterval;
  GroupBy?: GroupDefinition[] | null;
  Granularity?: Granularity | null;
  Filter?: Expression | null;
  Metrics?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  SortBy?: SortDefinition | null;
}

// refs: 1 - tags: named, input
export interface GetSavingsPlansPurchaseRecommendationRequest {
  SavingsPlansType: SupportedSavingsPlansType;
  TermInYears: TermInYears;
  PaymentOption: PaymentOption;
  AccountScope?: AccountScope | null;
  NextPageToken?: string | null;
  PageSize?: number | null;
  LookbackPeriodInDays: LookbackPeriodInDays;
  Filter?: Expression | null;
}

// refs: 1 - tags: named, input
export interface GetSavingsPlansUtilizationRequest {
  TimePeriod: DateInterval;
  Granularity?: Granularity | null;
  Filter?: Expression | null;
  SortBy?: SortDefinition | null;
}

// refs: 1 - tags: named, input
export interface GetSavingsPlansUtilizationDetailsRequest {
  TimePeriod: DateInterval;
  Filter?: Expression | null;
  DataType?: SavingsPlansDataType[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  SortBy?: SortDefinition | null;
}

// refs: 1 - tags: named, input
export interface GetTagsRequest {
  SearchString?: string | null;
  TimePeriod: DateInterval;
  TagKey?: string | null;
  Filter?: Expression | null;
  SortBy?: SortDefinition[] | null;
  MaxResults?: number | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetUsageForecastRequest {
  TimePeriod: DateInterval;
  Metric: Metric;
  Granularity: Granularity;
  Filter?: Expression | null;
  PredictionIntervalLevel?: number | null;
}

// refs: 1 - tags: named, input
export interface ListCostCategoryDefinitionsRequest {
  EffectiveOn?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ProvideAnomalyFeedbackRequest {
  AnomalyId: string;
  Feedback: AnomalyFeedbackType;
}

// refs: 1 - tags: named, input
export interface UpdateAnomalyMonitorRequest {
  MonitorArn: string;
  MonitorName?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateAnomalySubscriptionRequest {
  SubscriptionArn: string;
  Threshold?: number | null;
  Frequency?: AnomalySubscriptionFrequency | null;
  MonitorArnList?: string[] | null;
  Subscribers?: Subscriber[] | null;
  SubscriptionName?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateCostCategoryDefinitionRequest {
  CostCategoryArn: string;
  RuleVersion: CostCategoryRuleVersion;
  Rules: CostCategoryRule[];
}

// refs: 1 - tags: named, output
export interface CreateAnomalyMonitorResponse {
  MonitorArn: string;
}

// refs: 1 - tags: named, output
export interface CreateAnomalySubscriptionResponse {
  SubscriptionArn: string;
}

// refs: 1 - tags: named, output
export interface CreateCostCategoryDefinitionResponse {
  CostCategoryArn?: string | null;
  EffectiveStart?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteAnomalyMonitorResponse {
}

// refs: 1 - tags: named, output
export interface DeleteAnomalySubscriptionResponse {
}

// refs: 1 - tags: named, output
export interface DeleteCostCategoryDefinitionResponse {
  CostCategoryArn?: string | null;
  EffectiveEnd?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeCostCategoryDefinitionResponse {
  CostCategory?: CostCategory | null;
}

// refs: 1 - tags: named, output
export interface GetAnomaliesResponse {
  Anomalies: Anomaly[];
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAnomalyMonitorsResponse {
  AnomalyMonitors: AnomalyMonitor[];
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAnomalySubscriptionsResponse {
  AnomalySubscriptions: AnomalySubscription[];
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCostAndUsageResponse {
  NextPageToken?: string | null;
  GroupDefinitions?: GroupDefinition[] | null;
  ResultsByTime?: ResultByTime[] | null;
  DimensionValueAttributes?: DimensionValuesWithAttributes[] | null;
}

// refs: 1 - tags: named, output
export interface GetCostAndUsageWithResourcesResponse {
  NextPageToken?: string | null;
  GroupDefinitions?: GroupDefinition[] | null;
  ResultsByTime?: ResultByTime[] | null;
  DimensionValueAttributes?: DimensionValuesWithAttributes[] | null;
}

// refs: 1 - tags: named, output
export interface GetCostCategoriesResponse {
  NextPageToken?: string | null;
  CostCategoryNames?: string[] | null;
  CostCategoryValues?: string[] | null;
  ReturnSize: number;
  TotalSize: number;
}

// refs: 1 - tags: named, output
export interface GetCostForecastResponse {
  Total?: MetricValue | null;
  ForecastResultsByTime?: ForecastResult[] | null;
}

// refs: 1 - tags: named, output
export interface GetDimensionValuesResponse {
  DimensionValues: DimensionValuesWithAttributes[];
  ReturnSize: number;
  TotalSize: number;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetReservationCoverageResponse {
  CoveragesByTime: CoverageByTime[];
  Total?: Coverage | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetReservationPurchaseRecommendationResponse {
  Metadata?: ReservationPurchaseRecommendationMetadata | null;
  Recommendations?: ReservationPurchaseRecommendation[] | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetReservationUtilizationResponse {
  UtilizationsByTime: UtilizationByTime[];
  Total?: ReservationAggregates | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetRightsizingRecommendationResponse {
  Metadata?: RightsizingRecommendationMetadata | null;
  Summary?: RightsizingRecommendationSummary | null;
  RightsizingRecommendations?: RightsizingRecommendation[] | null;
  NextPageToken?: string | null;
  Configuration?: RightsizingRecommendationConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetSavingsPlansCoverageResponse {
  SavingsPlansCoverages: SavingsPlansCoverage[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSavingsPlansPurchaseRecommendationResponse {
  Metadata?: SavingsPlansPurchaseRecommendationMetadata | null;
  SavingsPlansPurchaseRecommendation?: SavingsPlansPurchaseRecommendation | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSavingsPlansUtilizationResponse {
  SavingsPlansUtilizationsByTime?: SavingsPlansUtilizationByTime[] | null;
  Total: SavingsPlansUtilizationAggregates;
}

// refs: 1 - tags: named, output
export interface GetSavingsPlansUtilizationDetailsResponse {
  SavingsPlansUtilizationDetails: SavingsPlansUtilizationDetail[];
  Total?: SavingsPlansUtilizationAggregates | null;
  TimePeriod: DateInterval;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTagsResponse {
  NextPageToken?: string | null;
  Tags: string[];
  ReturnSize: number;
  TotalSize: number;
}

// refs: 1 - tags: named, output
export interface GetUsageForecastResponse {
  Total?: MetricValue | null;
  ForecastResultsByTime?: ForecastResult[] | null;
}

// refs: 1 - tags: named, output
export interface ListCostCategoryDefinitionsResponse {
  CostCategoryReferences?: CostCategoryReference[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ProvideAnomalyFeedbackResponse {
  AnomalyId: string;
}

// refs: 1 - tags: named, output
export interface UpdateAnomalyMonitorResponse {
  MonitorArn: string;
}

// refs: 1 - tags: named, output
export interface UpdateAnomalySubscriptionResponse {
  SubscriptionArn: string;
}

// refs: 1 - tags: named, output
export interface UpdateCostCategoryDefinitionResponse {
  CostCategoryArn?: string | null;
  EffectiveStart?: string | null;
}

// refs: 2 - tags: input, named, interface, output
export interface AnomalyMonitor {
  MonitorArn?: string | null;
  MonitorName: string;
  CreationDate?: string | null;
  LastUpdatedDate?: string | null;
  LastEvaluatedDate?: string | null;
  MonitorType: MonitorType;
  MonitorDimension?: MonitorDimension | null;
  MonitorSpecification?: Expression | null;
  DimensionalValueCount?: number | null;
}
function fromAnomalyMonitor(input?: AnomalyMonitor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MonitorArn: input["MonitorArn"],
    MonitorName: input["MonitorName"],
    CreationDate: input["CreationDate"],
    LastUpdatedDate: input["LastUpdatedDate"],
    LastEvaluatedDate: input["LastEvaluatedDate"],
    MonitorType: input["MonitorType"],
    MonitorDimension: input["MonitorDimension"],
    MonitorSpecification: fromExpression(input["MonitorSpecification"]),
    DimensionalValueCount: input["DimensionalValueCount"],
  }
}
function toAnomalyMonitor(root: jsonP.JSONValue): AnomalyMonitor {
  return jsonP.readObj({
    required: {
      "MonitorName": "s",
      "MonitorType": (x: jsonP.JSONValue) => cmnP.readEnum<MonitorType>(x),
    },
    optional: {
      "MonitorArn": "s",
      "CreationDate": "s",
      "LastUpdatedDate": "s",
      "LastEvaluatedDate": "s",
      "MonitorDimension": (x: jsonP.JSONValue) => cmnP.readEnum<MonitorDimension>(x),
      "MonitorSpecification": toExpression,
      "DimensionalValueCount": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type MonitorType =
| "DIMENSIONAL"
| "CUSTOM"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type MonitorDimension =
| "SERVICE"
| cmnP.UnexpectedEnumValue;

// refs: 80 - tags: input, named, interface, recursed, recursive, output
export interface Expression {
  Or?: Expression[] | null;
  And?: Expression[] | null;
  Not?: Expression | null;
  Dimensions?: DimensionValues | null;
  Tags?: TagValues | null;
  CostCategories?: CostCategoryValues | null;
}
function fromExpression(input?: Expression | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Or: input["Or"]?.map(x => fromExpression(x)),
    And: input["And"]?.map(x => fromExpression(x)),
    Not: fromExpression(input["Not"]),
    Dimensions: fromDimensionValues(input["Dimensions"]),
    Tags: fromTagValues(input["Tags"]),
    CostCategories: fromCostCategoryValues(input["CostCategories"]),
  }
}
function toExpression(root: jsonP.JSONValue): Expression {
  return jsonP.readObj({
    required: {},
    optional: {
      "Or": [toExpression],
      "And": [toExpression],
      "Not": toExpression,
      "Dimensions": toDimensionValues,
      "Tags": toTagValues,
      "CostCategories": toCostCategoryValues,
    },
  }, root);
}

// refs: 20 - tags: input, named, interface, output
export interface DimensionValues {
  Key?: Dimension | null;
  Values?: string[] | null;
  MatchOptions?: MatchOption[] | null;
}
function fromDimensionValues(input?: DimensionValues | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    MatchOptions: input["MatchOptions"],
  }
}
function toDimensionValues(root: jsonP.JSONValue): DimensionValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": (x: jsonP.JSONValue) => cmnP.readEnum<Dimension>(x),
      "Values": ["s"],
      "MatchOptions": [(x: jsonP.JSONValue) => cmnP.readEnum<MatchOption>(x)],
    },
  }, root);
}

// refs: 21 - tags: input, named, enum, output
export type Dimension =
| "AZ"
| "INSTANCE_TYPE"
| "LINKED_ACCOUNT"
| "LINKED_ACCOUNT_NAME"
| "OPERATION"
| "PURCHASE_TYPE"
| "REGION"
| "SERVICE"
| "SERVICE_CODE"
| "USAGE_TYPE"
| "USAGE_TYPE_GROUP"
| "RECORD_TYPE"
| "OPERATING_SYSTEM"
| "TENANCY"
| "SCOPE"
| "PLATFORM"
| "SUBSCRIPTION_ID"
| "LEGAL_ENTITY_NAME"
| "DEPLOYMENT_OPTION"
| "DATABASE_ENGINE"
| "CACHE_ENGINE"
| "INSTANCE_TYPE_FAMILY"
| "BILLING_ENTITY"
| "RESERVATION_ID"
| "RESOURCE_ID"
| "RIGHTSIZING_TYPE"
| "SAVINGS_PLANS_TYPE"
| "SAVINGS_PLAN_ARN"
| "PAYMENT_OPTION"
| "AGREEMENT_END_DATE_TIME_AFTER"
| "AGREEMENT_END_DATE_TIME_BEFORE"
| cmnP.UnexpectedEnumValue;

// refs: 61 - tags: input, named, enum, output
export type MatchOption =
| "EQUALS"
| "ABSENT"
| "STARTS_WITH"
| "ENDS_WITH"
| "CONTAINS"
| "CASE_SENSITIVE"
| "CASE_INSENSITIVE"
| cmnP.UnexpectedEnumValue;

// refs: 21 - tags: input, named, interface, output
export interface TagValues {
  Key?: string | null;
  Values?: string[] | null;
  MatchOptions?: MatchOption[] | null;
}
function fromTagValues(input?: TagValues | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    MatchOptions: input["MatchOptions"],
  }
}
function toTagValues(root: jsonP.JSONValue): TagValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Values": ["s"],
      "MatchOptions": [(x: jsonP.JSONValue) => cmnP.readEnum<MatchOption>(x)],
    },
  }, root);
}

// refs: 20 - tags: input, named, interface, output
export interface CostCategoryValues {
  Key?: string | null;
  Values?: string[] | null;
  MatchOptions?: MatchOption[] | null;
}
function fromCostCategoryValues(input?: CostCategoryValues | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    MatchOptions: input["MatchOptions"],
  }
}
function toCostCategoryValues(root: jsonP.JSONValue): CostCategoryValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Values": ["s"],
      "MatchOptions": [(x: jsonP.JSONValue) => cmnP.readEnum<MatchOption>(x)],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface AnomalySubscription {
  SubscriptionArn?: string | null;
  AccountId?: string | null;
  MonitorArnList: string[];
  Subscribers: Subscriber[];
  Threshold: number;
  Frequency: AnomalySubscriptionFrequency;
  SubscriptionName: string;
}
function fromAnomalySubscription(input?: AnomalySubscription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubscriptionArn: input["SubscriptionArn"],
    AccountId: input["AccountId"],
    MonitorArnList: input["MonitorArnList"],
    Subscribers: input["Subscribers"]?.map(x => fromSubscriber(x)),
    Threshold: input["Threshold"],
    Frequency: input["Frequency"],
    SubscriptionName: input["SubscriptionName"],
  }
}
function toAnomalySubscription(root: jsonP.JSONValue): AnomalySubscription {
  return jsonP.readObj({
    required: {
      "MonitorArnList": ["s"],
      "Subscribers": [toSubscriber],
      "Threshold": "n",
      "Frequency": (x: jsonP.JSONValue) => cmnP.readEnum<AnomalySubscriptionFrequency>(x),
      "SubscriptionName": "s",
    },
    optional: {
      "SubscriptionArn": "s",
      "AccountId": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Subscriber {
  Address?: string | null;
  Type?: SubscriberType | null;
  Status?: SubscriberStatus | null;
}
function fromSubscriber(input?: Subscriber | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Address: input["Address"],
    Type: input["Type"],
    Status: input["Status"],
  }
}
function toSubscriber(root: jsonP.JSONValue): Subscriber {
  return jsonP.readObj({
    required: {},
    optional: {
      "Address": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<SubscriberType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<SubscriberStatus>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type SubscriberType =
| "EMAIL"
| "SNS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type SubscriberStatus =
| "CONFIRMED"
| "DECLINED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type AnomalySubscriptionFrequency =
| "DAILY"
| "IMMEDIATE"
| "WEEKLY"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type CostCategoryRuleVersion =
| "CostCategoryExpression.v1"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface CostCategoryRule {
  Value: string;
  Rule: Expression;
}
function fromCostCategoryRule(input?: CostCategoryRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: input["Value"],
    Rule: fromExpression(input["Rule"]),
  }
}
function toCostCategoryRule(root: jsonP.JSONValue): CostCategoryRule {
  return jsonP.readObj({
    required: {
      "Value": "s",
      "Rule": toExpression,
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface AnomalyDateInterval {
  StartDate: string;
  EndDate?: string | null;
}
function fromAnomalyDateInterval(input?: AnomalyDateInterval | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartDate: input["StartDate"],
    EndDate: input["EndDate"],
  }
}

// refs: 3 - tags: input, named, enum, output
export type AnomalyFeedbackType =
| "YES"
| "NO"
| "PLANNED_ACTIVITY"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TotalImpactFilter {
  NumericOperator: NumericOperator;
  StartValue: number;
  EndValue?: number | null;
}
function fromTotalImpactFilter(input?: TotalImpactFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NumericOperator: input["NumericOperator"],
    StartValue: input["StartValue"],
    EndValue: input["EndValue"],
  }
}

// refs: 1 - tags: input, named, enum
export type NumericOperator =
| "EQUAL"
| "GREATER_THAN_OR_EQUAL"
| "LESS_THAN_OR_EQUAL"
| "GREATER_THAN"
| "LESS_THAN"
| "BETWEEN"
| cmnP.UnexpectedEnumValue;

// refs: 21 - tags: input, named, interface, output
export interface DateInterval {
  Start: string;
  End: string;
}
function fromDateInterval(input?: DateInterval | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Start: input["Start"],
    End: input["End"],
  }
}
function toDateInterval(root: jsonP.JSONValue): DateInterval {
  return jsonP.readObj({
    required: {
      "Start": "s",
      "End": "s",
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, enum
export type Granularity =
| "DAILY"
| "MONTHLY"
| "HOURLY"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface GroupDefinition {
  Type?: GroupDefinitionType | null;
  Key?: string | null;
}
function fromGroupDefinition(input?: GroupDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Key: input["Key"],
  }
}
function toGroupDefinition(root: jsonP.JSONValue): GroupDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<GroupDefinitionType>(x),
      "Key": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type GroupDefinitionType =
| "DIMENSION"
| "TAG"
| "COST_CATEGORY"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface
export interface SortDefinition {
  Key: string;
  SortOrder?: SortOrder | null;
}
function fromSortDefinition(input?: SortDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    SortOrder: input["SortOrder"],
  }
}

// refs: 8 - tags: input, named, enum
export type SortOrder =
| "ASCENDING"
| "DESCENDING"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type Metric =
| "BLENDED_COST"
| "UNBLENDED_COST"
| "AMORTIZED_COST"
| "NET_UNBLENDED_COST"
| "NET_AMORTIZED_COST"
| "USAGE_QUANTITY"
| "NORMALIZED_USAGE_AMOUNT"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type Context =
| "COST_AND_USAGE"
| "RESERVATIONS"
| "SAVINGS_PLANS"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type AccountScope =
| "PAYER"
| "LINKED"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type LookbackPeriodInDays =
| "SEVEN_DAYS"
| "THIRTY_DAYS"
| "SIXTY_DAYS"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type TermInYears =
| "ONE_YEAR"
| "THREE_YEARS"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type PaymentOption =
| "NO_UPFRONT"
| "PARTIAL_UPFRONT"
| "ALL_UPFRONT"
| "LIGHT_UTILIZATION"
| "MEDIUM_UTILIZATION"
| "HEAVY_UTILIZATION"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ServiceSpecification {
  EC2Specification?: EC2Specification | null;
}
function fromServiceSpecification(input?: ServiceSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EC2Specification: fromEC2Specification(input["EC2Specification"]),
  }
}
function toServiceSpecification(root: jsonP.JSONValue): ServiceSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2Specification": toEC2Specification,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface EC2Specification {
  OfferingClass?: OfferingClass | null;
}
function fromEC2Specification(input?: EC2Specification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OfferingClass: input["OfferingClass"],
  }
}
function toEC2Specification(root: jsonP.JSONValue): EC2Specification {
  return jsonP.readObj({
    required: {},
    optional: {
      "OfferingClass": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingClass>(x),
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type OfferingClass =
| "STANDARD"
| "CONVERTIBLE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface RightsizingRecommendationConfiguration {
  RecommendationTarget: RecommendationTarget;
  BenefitsConsidered: boolean;
}
function fromRightsizingRecommendationConfiguration(input?: RightsizingRecommendationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecommendationTarget: input["RecommendationTarget"],
    BenefitsConsidered: input["BenefitsConsidered"],
  }
}
function toRightsizingRecommendationConfiguration(root: jsonP.JSONValue): RightsizingRecommendationConfiguration {
  return jsonP.readObj({
    required: {
      "RecommendationTarget": (x: jsonP.JSONValue) => cmnP.readEnum<RecommendationTarget>(x),
      "BenefitsConsidered": "b",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type RecommendationTarget =
| "SAME_INSTANCE_FAMILY"
| "CROSS_INSTANCE_FAMILY"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type SupportedSavingsPlansType =
| "COMPUTE_SP"
| "EC2_INSTANCE_SP"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SavingsPlansDataType =
| "ATTRIBUTES"
| "UTILIZATION"
| "AMORTIZED_COMMITMENT"
| "SAVINGS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CostCategory {
  CostCategoryArn: string;
  EffectiveStart: string;
  EffectiveEnd?: string | null;
  Name: string;
  RuleVersion: CostCategoryRuleVersion;
  Rules: CostCategoryRule[];
  ProcessingStatus?: CostCategoryProcessingStatus[] | null;
}
function toCostCategory(root: jsonP.JSONValue): CostCategory {
  return jsonP.readObj({
    required: {
      "CostCategoryArn": "s",
      "EffectiveStart": "s",
      "Name": "s",
      "RuleVersion": (x: jsonP.JSONValue) => cmnP.readEnum<CostCategoryRuleVersion>(x),
      "Rules": [toCostCategoryRule],
    },
    optional: {
      "EffectiveEnd": "s",
      "ProcessingStatus": [toCostCategoryProcessingStatus],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface CostCategoryProcessingStatus {
  Component?: CostCategoryStatusComponent | null;
  Status?: CostCategoryStatus | null;
}
function toCostCategoryProcessingStatus(root: jsonP.JSONValue): CostCategoryProcessingStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "Component": (x: jsonP.JSONValue) => cmnP.readEnum<CostCategoryStatusComponent>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<CostCategoryStatus>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type CostCategoryStatusComponent =
| "COST_EXPLORER"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type CostCategoryStatus =
| "PROCESSING"
| "APPLIED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Anomaly {
  AnomalyId: string;
  AnomalyStartDate?: string | null;
  AnomalyEndDate?: string | null;
  DimensionValue?: string | null;
  RootCauses?: RootCause[] | null;
  AnomalyScore: AnomalyScore;
  Impact: Impact;
  MonitorArn: string;
  Feedback?: AnomalyFeedbackType | null;
}
function toAnomaly(root: jsonP.JSONValue): Anomaly {
  return jsonP.readObj({
    required: {
      "AnomalyId": "s",
      "AnomalyScore": toAnomalyScore,
      "Impact": toImpact,
      "MonitorArn": "s",
    },
    optional: {
      "AnomalyStartDate": "s",
      "AnomalyEndDate": "s",
      "DimensionValue": "s",
      "RootCauses": [toRootCause],
      "Feedback": (x: jsonP.JSONValue) => cmnP.readEnum<AnomalyFeedbackType>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RootCause {
  Service?: string | null;
  Region?: string | null;
  LinkedAccount?: string | null;
  UsageType?: string | null;
}
function toRootCause(root: jsonP.JSONValue): RootCause {
  return jsonP.readObj({
    required: {},
    optional: {
      "Service": "s",
      "Region": "s",
      "LinkedAccount": "s",
      "UsageType": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AnomalyScore {
  MaxScore: number;
  CurrentScore: number;
}
function toAnomalyScore(root: jsonP.JSONValue): AnomalyScore {
  return jsonP.readObj({
    required: {
      "MaxScore": "n",
      "CurrentScore": "n",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Impact {
  MaxImpact: number;
  TotalImpact?: number | null;
}
function toImpact(root: jsonP.JSONValue): Impact {
  return jsonP.readObj({
    required: {
      "MaxImpact": "n",
    },
    optional: {
      "TotalImpact": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ResultByTime {
  TimePeriod?: DateInterval | null;
  Total?: { [key: string]: MetricValue | null | undefined } | null;
  Groups?: Group[] | null;
  Estimated?: boolean | null;
}
function toResultByTime(root: jsonP.JSONValue): ResultByTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimePeriod": toDateInterval,
      "Total": x => jsonP.readMap(String, toMetricValue, x),
      "Groups": [toGroup],
      "Estimated": "b",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface MetricValue {
  Amount?: string | null;
  Unit?: string | null;
}
function toMetricValue(root: jsonP.JSONValue): MetricValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "Amount": "s",
      "Unit": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Group {
  Keys?: string[] | null;
  Metrics?: { [key: string]: MetricValue | null | undefined } | null;
}
function toGroup(root: jsonP.JSONValue): Group {
  return jsonP.readObj({
    required: {},
    optional: {
      "Keys": ["s"],
      "Metrics": x => jsonP.readMap(String, toMetricValue, x),
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface DimensionValuesWithAttributes {
  Value?: string | null;
  Attributes?: { [key: string]: string | null | undefined } | null;
}
function toDimensionValuesWithAttributes(root: jsonP.JSONValue): DimensionValuesWithAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "s",
      "Attributes": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ForecastResult {
  TimePeriod?: DateInterval | null;
  MeanValue?: string | null;
  PredictionIntervalLowerBound?: string | null;
  PredictionIntervalUpperBound?: string | null;
}
function toForecastResult(root: jsonP.JSONValue): ForecastResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimePeriod": toDateInterval,
      "MeanValue": "s",
      "PredictionIntervalLowerBound": "s",
      "PredictionIntervalUpperBound": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CoverageByTime {
  TimePeriod?: DateInterval | null;
  Groups?: ReservationCoverageGroup[] | null;
  Total?: Coverage | null;
}
function toCoverageByTime(root: jsonP.JSONValue): CoverageByTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimePeriod": toDateInterval,
      "Groups": [toReservationCoverageGroup],
      "Total": toCoverage,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReservationCoverageGroup {
  Attributes?: { [key: string]: string | null | undefined } | null;
  Coverage?: Coverage | null;
}
function toReservationCoverageGroup(root: jsonP.JSONValue): ReservationCoverageGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": x => jsonP.readMap(String, String, x),
      "Coverage": toCoverage,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Coverage {
  CoverageHours?: CoverageHours | null;
  CoverageNormalizedUnits?: CoverageNormalizedUnits | null;
  CoverageCost?: CoverageCost | null;
}
function toCoverage(root: jsonP.JSONValue): Coverage {
  return jsonP.readObj({
    required: {},
    optional: {
      "CoverageHours": toCoverageHours,
      "CoverageNormalizedUnits": toCoverageNormalizedUnits,
      "CoverageCost": toCoverageCost,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface CoverageHours {
  OnDemandHours?: string | null;
  ReservedHours?: string | null;
  TotalRunningHours?: string | null;
  CoverageHoursPercentage?: string | null;
}
function toCoverageHours(root: jsonP.JSONValue): CoverageHours {
  return jsonP.readObj({
    required: {},
    optional: {
      "OnDemandHours": "s",
      "ReservedHours": "s",
      "TotalRunningHours": "s",
      "CoverageHoursPercentage": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface CoverageNormalizedUnits {
  OnDemandNormalizedUnits?: string | null;
  ReservedNormalizedUnits?: string | null;
  TotalRunningNormalizedUnits?: string | null;
  CoverageNormalizedUnitsPercentage?: string | null;
}
function toCoverageNormalizedUnits(root: jsonP.JSONValue): CoverageNormalizedUnits {
  return jsonP.readObj({
    required: {},
    optional: {
      "OnDemandNormalizedUnits": "s",
      "ReservedNormalizedUnits": "s",
      "TotalRunningNormalizedUnits": "s",
      "CoverageNormalizedUnitsPercentage": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface CoverageCost {
  OnDemandCost?: string | null;
}
function toCoverageCost(root: jsonP.JSONValue): CoverageCost {
  return jsonP.readObj({
    required: {},
    optional: {
      "OnDemandCost": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReservationPurchaseRecommendationMetadata {
  RecommendationId?: string | null;
  GenerationTimestamp?: string | null;
}
function toReservationPurchaseRecommendationMetadata(root: jsonP.JSONValue): ReservationPurchaseRecommendationMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecommendationId": "s",
      "GenerationTimestamp": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReservationPurchaseRecommendation {
  AccountScope?: AccountScope | null;
  LookbackPeriodInDays?: LookbackPeriodInDays | null;
  TermInYears?: TermInYears | null;
  PaymentOption?: PaymentOption | null;
  ServiceSpecification?: ServiceSpecification | null;
  RecommendationDetails?: ReservationPurchaseRecommendationDetail[] | null;
  RecommendationSummary?: ReservationPurchaseRecommendationSummary | null;
}
function toReservationPurchaseRecommendation(root: jsonP.JSONValue): ReservationPurchaseRecommendation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountScope": (x: jsonP.JSONValue) => cmnP.readEnum<AccountScope>(x),
      "LookbackPeriodInDays": (x: jsonP.JSONValue) => cmnP.readEnum<LookbackPeriodInDays>(x),
      "TermInYears": (x: jsonP.JSONValue) => cmnP.readEnum<TermInYears>(x),
      "PaymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<PaymentOption>(x),
      "ServiceSpecification": toServiceSpecification,
      "RecommendationDetails": [toReservationPurchaseRecommendationDetail],
      "RecommendationSummary": toReservationPurchaseRecommendationSummary,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReservationPurchaseRecommendationDetail {
  AccountId?: string | null;
  InstanceDetails?: InstanceDetails | null;
  RecommendedNumberOfInstancesToPurchase?: string | null;
  RecommendedNormalizedUnitsToPurchase?: string | null;
  MinimumNumberOfInstancesUsedPerHour?: string | null;
  MinimumNormalizedUnitsUsedPerHour?: string | null;
  MaximumNumberOfInstancesUsedPerHour?: string | null;
  MaximumNormalizedUnitsUsedPerHour?: string | null;
  AverageNumberOfInstancesUsedPerHour?: string | null;
  AverageNormalizedUnitsUsedPerHour?: string | null;
  AverageUtilization?: string | null;
  EstimatedBreakEvenInMonths?: string | null;
  CurrencyCode?: string | null;
  EstimatedMonthlySavingsAmount?: string | null;
  EstimatedMonthlySavingsPercentage?: string | null;
  EstimatedMonthlyOnDemandCost?: string | null;
  EstimatedReservationCostForLookbackPeriod?: string | null;
  UpfrontCost?: string | null;
  RecurringStandardMonthlyCost?: string | null;
}
function toReservationPurchaseRecommendationDetail(root: jsonP.JSONValue): ReservationPurchaseRecommendationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountId": "s",
      "InstanceDetails": toInstanceDetails,
      "RecommendedNumberOfInstancesToPurchase": "s",
      "RecommendedNormalizedUnitsToPurchase": "s",
      "MinimumNumberOfInstancesUsedPerHour": "s",
      "MinimumNormalizedUnitsUsedPerHour": "s",
      "MaximumNumberOfInstancesUsedPerHour": "s",
      "MaximumNormalizedUnitsUsedPerHour": "s",
      "AverageNumberOfInstancesUsedPerHour": "s",
      "AverageNormalizedUnitsUsedPerHour": "s",
      "AverageUtilization": "s",
      "EstimatedBreakEvenInMonths": "s",
      "CurrencyCode": "s",
      "EstimatedMonthlySavingsAmount": "s",
      "EstimatedMonthlySavingsPercentage": "s",
      "EstimatedMonthlyOnDemandCost": "s",
      "EstimatedReservationCostForLookbackPeriod": "s",
      "UpfrontCost": "s",
      "RecurringStandardMonthlyCost": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceDetails {
  EC2InstanceDetails?: EC2InstanceDetails | null;
  RDSInstanceDetails?: RDSInstanceDetails | null;
  RedshiftInstanceDetails?: RedshiftInstanceDetails | null;
  ElastiCacheInstanceDetails?: ElastiCacheInstanceDetails | null;
  ESInstanceDetails?: ESInstanceDetails | null;
}
function toInstanceDetails(root: jsonP.JSONValue): InstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2InstanceDetails": toEC2InstanceDetails,
      "RDSInstanceDetails": toRDSInstanceDetails,
      "RedshiftInstanceDetails": toRedshiftInstanceDetails,
      "ElastiCacheInstanceDetails": toElastiCacheInstanceDetails,
      "ESInstanceDetails": toESInstanceDetails,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EC2InstanceDetails {
  Family?: string | null;
  InstanceType?: string | null;
  Region?: string | null;
  AvailabilityZone?: string | null;
  Platform?: string | null;
  Tenancy?: string | null;
  CurrentGeneration?: boolean | null;
  SizeFlexEligible?: boolean | null;
}
function toEC2InstanceDetails(root: jsonP.JSONValue): EC2InstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "InstanceType": "s",
      "Region": "s",
      "AvailabilityZone": "s",
      "Platform": "s",
      "Tenancy": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RDSInstanceDetails {
  Family?: string | null;
  InstanceType?: string | null;
  Region?: string | null;
  DatabaseEngine?: string | null;
  DatabaseEdition?: string | null;
  DeploymentOption?: string | null;
  LicenseModel?: string | null;
  CurrentGeneration?: boolean | null;
  SizeFlexEligible?: boolean | null;
}
function toRDSInstanceDetails(root: jsonP.JSONValue): RDSInstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "InstanceType": "s",
      "Region": "s",
      "DatabaseEngine": "s",
      "DatabaseEdition": "s",
      "DeploymentOption": "s",
      "LicenseModel": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RedshiftInstanceDetails {
  Family?: string | null;
  NodeType?: string | null;
  Region?: string | null;
  CurrentGeneration?: boolean | null;
  SizeFlexEligible?: boolean | null;
}
function toRedshiftInstanceDetails(root: jsonP.JSONValue): RedshiftInstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "NodeType": "s",
      "Region": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ElastiCacheInstanceDetails {
  Family?: string | null;
  NodeType?: string | null;
  Region?: string | null;
  ProductDescription?: string | null;
  CurrentGeneration?: boolean | null;
  SizeFlexEligible?: boolean | null;
}
function toElastiCacheInstanceDetails(root: jsonP.JSONValue): ElastiCacheInstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "NodeType": "s",
      "Region": "s",
      "ProductDescription": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ESInstanceDetails {
  InstanceClass?: string | null;
  InstanceSize?: string | null;
  Region?: string | null;
  CurrentGeneration?: boolean | null;
  SizeFlexEligible?: boolean | null;
}
function toESInstanceDetails(root: jsonP.JSONValue): ESInstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceClass": "s",
      "InstanceSize": "s",
      "Region": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReservationPurchaseRecommendationSummary {
  TotalEstimatedMonthlySavingsAmount?: string | null;
  TotalEstimatedMonthlySavingsPercentage?: string | null;
  CurrencyCode?: string | null;
}
function toReservationPurchaseRecommendationSummary(root: jsonP.JSONValue): ReservationPurchaseRecommendationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalEstimatedMonthlySavingsAmount": "s",
      "TotalEstimatedMonthlySavingsPercentage": "s",
      "CurrencyCode": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UtilizationByTime {
  TimePeriod?: DateInterval | null;
  Groups?: ReservationUtilizationGroup[] | null;
  Total?: ReservationAggregates | null;
}
function toUtilizationByTime(root: jsonP.JSONValue): UtilizationByTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimePeriod": toDateInterval,
      "Groups": [toReservationUtilizationGroup],
      "Total": toReservationAggregates,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReservationUtilizationGroup {
  Key?: string | null;
  Value?: string | null;
  Attributes?: { [key: string]: string | null | undefined } | null;
  Utilization?: ReservationAggregates | null;
}
function toReservationUtilizationGroup(root: jsonP.JSONValue): ReservationUtilizationGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
      "Attributes": x => jsonP.readMap(String, String, x),
      "Utilization": toReservationAggregates,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface ReservationAggregates {
  UtilizationPercentage?: string | null;
  UtilizationPercentageInUnits?: string | null;
  PurchasedHours?: string | null;
  PurchasedUnits?: string | null;
  TotalActualHours?: string | null;
  TotalActualUnits?: string | null;
  UnusedHours?: string | null;
  UnusedUnits?: string | null;
  OnDemandCostOfRIHoursUsed?: string | null;
  NetRISavings?: string | null;
  TotalPotentialRISavings?: string | null;
  AmortizedUpfrontFee?: string | null;
  AmortizedRecurringFee?: string | null;
  TotalAmortizedFee?: string | null;
  RICostForUnusedHours?: string | null;
  RealizedSavings?: string | null;
  UnrealizedSavings?: string | null;
}
function toReservationAggregates(root: jsonP.JSONValue): ReservationAggregates {
  return jsonP.readObj({
    required: {},
    optional: {
      "UtilizationPercentage": "s",
      "UtilizationPercentageInUnits": "s",
      "PurchasedHours": "s",
      "PurchasedUnits": "s",
      "TotalActualHours": "s",
      "TotalActualUnits": "s",
      "UnusedHours": "s",
      "UnusedUnits": "s",
      "OnDemandCostOfRIHoursUsed": "s",
      "NetRISavings": "s",
      "TotalPotentialRISavings": "s",
      "AmortizedUpfrontFee": "s",
      "AmortizedRecurringFee": "s",
      "TotalAmortizedFee": "s",
      "RICostForUnusedHours": "s",
      "RealizedSavings": "s",
      "UnrealizedSavings": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RightsizingRecommendationMetadata {
  RecommendationId?: string | null;
  GenerationTimestamp?: string | null;
  LookbackPeriodInDays?: LookbackPeriodInDays | null;
  AdditionalMetadata?: string | null;
}
function toRightsizingRecommendationMetadata(root: jsonP.JSONValue): RightsizingRecommendationMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecommendationId": "s",
      "GenerationTimestamp": "s",
      "LookbackPeriodInDays": (x: jsonP.JSONValue) => cmnP.readEnum<LookbackPeriodInDays>(x),
      "AdditionalMetadata": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RightsizingRecommendationSummary {
  TotalRecommendationCount?: string | null;
  EstimatedTotalMonthlySavingsAmount?: string | null;
  SavingsCurrencyCode?: string | null;
  SavingsPercentage?: string | null;
}
function toRightsizingRecommendationSummary(root: jsonP.JSONValue): RightsizingRecommendationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalRecommendationCount": "s",
      "EstimatedTotalMonthlySavingsAmount": "s",
      "SavingsCurrencyCode": "s",
      "SavingsPercentage": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RightsizingRecommendation {
  AccountId?: string | null;
  CurrentInstance?: CurrentInstance | null;
  RightsizingType?: RightsizingType | null;
  ModifyRecommendationDetail?: ModifyRecommendationDetail | null;
  TerminateRecommendationDetail?: TerminateRecommendationDetail | null;
}
function toRightsizingRecommendation(root: jsonP.JSONValue): RightsizingRecommendation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountId": "s",
      "CurrentInstance": toCurrentInstance,
      "RightsizingType": (x: jsonP.JSONValue) => cmnP.readEnum<RightsizingType>(x),
      "ModifyRecommendationDetail": toModifyRecommendationDetail,
      "TerminateRecommendationDetail": toTerminateRecommendationDetail,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CurrentInstance {
  ResourceId?: string | null;
  InstanceName?: string | null;
  Tags?: TagValues[] | null;
  ResourceDetails?: ResourceDetails | null;
  ResourceUtilization?: ResourceUtilization | null;
  ReservationCoveredHoursInLookbackPeriod?: string | null;
  SavingsPlansCoveredHoursInLookbackPeriod?: string | null;
  OnDemandHoursInLookbackPeriod?: string | null;
  TotalRunningHoursInLookbackPeriod?: string | null;
  MonthlyCost?: string | null;
  CurrencyCode?: string | null;
}
function toCurrentInstance(root: jsonP.JSONValue): CurrentInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceId": "s",
      "InstanceName": "s",
      "Tags": [toTagValues],
      "ResourceDetails": toResourceDetails,
      "ResourceUtilization": toResourceUtilization,
      "ReservationCoveredHoursInLookbackPeriod": "s",
      "SavingsPlansCoveredHoursInLookbackPeriod": "s",
      "OnDemandHoursInLookbackPeriod": "s",
      "TotalRunningHoursInLookbackPeriod": "s",
      "MonthlyCost": "s",
      "CurrencyCode": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ResourceDetails {
  EC2ResourceDetails?: EC2ResourceDetails | null;
}
function toResourceDetails(root: jsonP.JSONValue): ResourceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2ResourceDetails": toEC2ResourceDetails,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EC2ResourceDetails {
  HourlyOnDemandRate?: string | null;
  InstanceType?: string | null;
  Platform?: string | null;
  Region?: string | null;
  Sku?: string | null;
  Memory?: string | null;
  NetworkPerformance?: string | null;
  Storage?: string | null;
  Vcpu?: string | null;
}
function toEC2ResourceDetails(root: jsonP.JSONValue): EC2ResourceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "HourlyOnDemandRate": "s",
      "InstanceType": "s",
      "Platform": "s",
      "Region": "s",
      "Sku": "s",
      "Memory": "s",
      "NetworkPerformance": "s",
      "Storage": "s",
      "Vcpu": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ResourceUtilization {
  EC2ResourceUtilization?: EC2ResourceUtilization | null;
}
function toResourceUtilization(root: jsonP.JSONValue): ResourceUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2ResourceUtilization": toEC2ResourceUtilization,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EC2ResourceUtilization {
  MaxCpuUtilizationPercentage?: string | null;
  MaxMemoryUtilizationPercentage?: string | null;
  MaxStorageUtilizationPercentage?: string | null;
  EBSResourceUtilization?: EBSResourceUtilization | null;
}
function toEC2ResourceUtilization(root: jsonP.JSONValue): EC2ResourceUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxCpuUtilizationPercentage": "s",
      "MaxMemoryUtilizationPercentage": "s",
      "MaxStorageUtilizationPercentage": "s",
      "EBSResourceUtilization": toEBSResourceUtilization,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EBSResourceUtilization {
  EbsReadOpsPerSecond?: string | null;
  EbsWriteOpsPerSecond?: string | null;
  EbsReadBytesPerSecond?: string | null;
  EbsWriteBytesPerSecond?: string | null;
}
function toEBSResourceUtilization(root: jsonP.JSONValue): EBSResourceUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "EbsReadOpsPerSecond": "s",
      "EbsWriteOpsPerSecond": "s",
      "EbsReadBytesPerSecond": "s",
      "EbsWriteBytesPerSecond": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type RightsizingType =
| "TERMINATE"
| "MODIFY"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ModifyRecommendationDetail {
  TargetInstances?: TargetInstance[] | null;
}
function toModifyRecommendationDetail(root: jsonP.JSONValue): ModifyRecommendationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetInstances": [toTargetInstance],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TargetInstance {
  EstimatedMonthlyCost?: string | null;
  EstimatedMonthlySavings?: string | null;
  CurrencyCode?: string | null;
  DefaultTargetInstance?: boolean | null;
  ResourceDetails?: ResourceDetails | null;
  ExpectedResourceUtilization?: ResourceUtilization | null;
}
function toTargetInstance(root: jsonP.JSONValue): TargetInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "EstimatedMonthlyCost": "s",
      "EstimatedMonthlySavings": "s",
      "CurrencyCode": "s",
      "DefaultTargetInstance": "b",
      "ResourceDetails": toResourceDetails,
      "ExpectedResourceUtilization": toResourceUtilization,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TerminateRecommendationDetail {
  EstimatedMonthlySavings?: string | null;
  CurrencyCode?: string | null;
}
function toTerminateRecommendationDetail(root: jsonP.JSONValue): TerminateRecommendationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "EstimatedMonthlySavings": "s",
      "CurrencyCode": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SavingsPlansCoverage {
  Attributes?: { [key: string]: string | null | undefined } | null;
  Coverage?: SavingsPlansCoverageData | null;
  TimePeriod?: DateInterval | null;
}
function toSavingsPlansCoverage(root: jsonP.JSONValue): SavingsPlansCoverage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": x => jsonP.readMap(String, String, x),
      "Coverage": toSavingsPlansCoverageData,
      "TimePeriod": toDateInterval,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SavingsPlansCoverageData {
  SpendCoveredBySavingsPlans?: string | null;
  OnDemandCost?: string | null;
  TotalCost?: string | null;
  CoveragePercentage?: string | null;
}
function toSavingsPlansCoverageData(root: jsonP.JSONValue): SavingsPlansCoverageData {
  return jsonP.readObj({
    required: {},
    optional: {
      "SpendCoveredBySavingsPlans": "s",
      "OnDemandCost": "s",
      "TotalCost": "s",
      "CoveragePercentage": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SavingsPlansPurchaseRecommendationMetadata {
  RecommendationId?: string | null;
  GenerationTimestamp?: string | null;
  AdditionalMetadata?: string | null;
}
function toSavingsPlansPurchaseRecommendationMetadata(root: jsonP.JSONValue): SavingsPlansPurchaseRecommendationMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecommendationId": "s",
      "GenerationTimestamp": "s",
      "AdditionalMetadata": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SavingsPlansPurchaseRecommendation {
  AccountScope?: AccountScope | null;
  SavingsPlansType?: SupportedSavingsPlansType | null;
  TermInYears?: TermInYears | null;
  PaymentOption?: PaymentOption | null;
  LookbackPeriodInDays?: LookbackPeriodInDays | null;
  SavingsPlansPurchaseRecommendationDetails?: SavingsPlansPurchaseRecommendationDetail[] | null;
  SavingsPlansPurchaseRecommendationSummary?: SavingsPlansPurchaseRecommendationSummary | null;
}
function toSavingsPlansPurchaseRecommendation(root: jsonP.JSONValue): SavingsPlansPurchaseRecommendation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountScope": (x: jsonP.JSONValue) => cmnP.readEnum<AccountScope>(x),
      "SavingsPlansType": (x: jsonP.JSONValue) => cmnP.readEnum<SupportedSavingsPlansType>(x),
      "TermInYears": (x: jsonP.JSONValue) => cmnP.readEnum<TermInYears>(x),
      "PaymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<PaymentOption>(x),
      "LookbackPeriodInDays": (x: jsonP.JSONValue) => cmnP.readEnum<LookbackPeriodInDays>(x),
      "SavingsPlansPurchaseRecommendationDetails": [toSavingsPlansPurchaseRecommendationDetail],
      "SavingsPlansPurchaseRecommendationSummary": toSavingsPlansPurchaseRecommendationSummary,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SavingsPlansPurchaseRecommendationDetail {
  SavingsPlansDetails?: SavingsPlansDetails | null;
  AccountId?: string | null;
  UpfrontCost?: string | null;
  EstimatedROI?: string | null;
  CurrencyCode?: string | null;
  EstimatedSPCost?: string | null;
  EstimatedOnDemandCost?: string | null;
  EstimatedOnDemandCostWithCurrentCommitment?: string | null;
  EstimatedSavingsAmount?: string | null;
  EstimatedSavingsPercentage?: string | null;
  HourlyCommitmentToPurchase?: string | null;
  EstimatedAverageUtilization?: string | null;
  EstimatedMonthlySavingsAmount?: string | null;
  CurrentMinimumHourlyOnDemandSpend?: string | null;
  CurrentMaximumHourlyOnDemandSpend?: string | null;
  CurrentAverageHourlyOnDemandSpend?: string | null;
}
function toSavingsPlansPurchaseRecommendationDetail(root: jsonP.JSONValue): SavingsPlansPurchaseRecommendationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "SavingsPlansDetails": toSavingsPlansDetails,
      "AccountId": "s",
      "UpfrontCost": "s",
      "EstimatedROI": "s",
      "CurrencyCode": "s",
      "EstimatedSPCost": "s",
      "EstimatedOnDemandCost": "s",
      "EstimatedOnDemandCostWithCurrentCommitment": "s",
      "EstimatedSavingsAmount": "s",
      "EstimatedSavingsPercentage": "s",
      "HourlyCommitmentToPurchase": "s",
      "EstimatedAverageUtilization": "s",
      "EstimatedMonthlySavingsAmount": "s",
      "CurrentMinimumHourlyOnDemandSpend": "s",
      "CurrentMaximumHourlyOnDemandSpend": "s",
      "CurrentAverageHourlyOnDemandSpend": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SavingsPlansDetails {
  Region?: string | null;
  InstanceFamily?: string | null;
  OfferingId?: string | null;
}
function toSavingsPlansDetails(root: jsonP.JSONValue): SavingsPlansDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Region": "s",
      "InstanceFamily": "s",
      "OfferingId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SavingsPlansPurchaseRecommendationSummary {
  EstimatedROI?: string | null;
  CurrencyCode?: string | null;
  EstimatedTotalCost?: string | null;
  CurrentOnDemandSpend?: string | null;
  EstimatedSavingsAmount?: string | null;
  TotalRecommendationCount?: string | null;
  DailyCommitmentToPurchase?: string | null;
  HourlyCommitmentToPurchase?: string | null;
  EstimatedSavingsPercentage?: string | null;
  EstimatedMonthlySavingsAmount?: string | null;
  EstimatedOnDemandCostWithCurrentCommitment?: string | null;
}
function toSavingsPlansPurchaseRecommendationSummary(root: jsonP.JSONValue): SavingsPlansPurchaseRecommendationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "EstimatedROI": "s",
      "CurrencyCode": "s",
      "EstimatedTotalCost": "s",
      "CurrentOnDemandSpend": "s",
      "EstimatedSavingsAmount": "s",
      "TotalRecommendationCount": "s",
      "DailyCommitmentToPurchase": "s",
      "HourlyCommitmentToPurchase": "s",
      "EstimatedSavingsPercentage": "s",
      "EstimatedMonthlySavingsAmount": "s",
      "EstimatedOnDemandCostWithCurrentCommitment": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SavingsPlansUtilizationByTime {
  TimePeriod: DateInterval;
  Utilization: SavingsPlansUtilization;
  Savings?: SavingsPlansSavings | null;
  AmortizedCommitment?: SavingsPlansAmortizedCommitment | null;
}
function toSavingsPlansUtilizationByTime(root: jsonP.JSONValue): SavingsPlansUtilizationByTime {
  return jsonP.readObj({
    required: {
      "TimePeriod": toDateInterval,
      "Utilization": toSavingsPlansUtilization,
    },
    optional: {
      "Savings": toSavingsPlansSavings,
      "AmortizedCommitment": toSavingsPlansAmortizedCommitment,
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface SavingsPlansUtilization {
  TotalCommitment?: string | null;
  UsedCommitment?: string | null;
  UnusedCommitment?: string | null;
  UtilizationPercentage?: string | null;
}
function toSavingsPlansUtilization(root: jsonP.JSONValue): SavingsPlansUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalCommitment": "s",
      "UsedCommitment": "s",
      "UnusedCommitment": "s",
      "UtilizationPercentage": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface SavingsPlansSavings {
  NetSavings?: string | null;
  OnDemandCostEquivalent?: string | null;
}
function toSavingsPlansSavings(root: jsonP.JSONValue): SavingsPlansSavings {
  return jsonP.readObj({
    required: {},
    optional: {
      "NetSavings": "s",
      "OnDemandCostEquivalent": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface SavingsPlansAmortizedCommitment {
  AmortizedRecurringCommitment?: string | null;
  AmortizedUpfrontCommitment?: string | null;
  TotalAmortizedCommitment?: string | null;
}
function toSavingsPlansAmortizedCommitment(root: jsonP.JSONValue): SavingsPlansAmortizedCommitment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AmortizedRecurringCommitment": "s",
      "AmortizedUpfrontCommitment": "s",
      "TotalAmortizedCommitment": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SavingsPlansUtilizationAggregates {
  Utilization: SavingsPlansUtilization;
  Savings?: SavingsPlansSavings | null;
  AmortizedCommitment?: SavingsPlansAmortizedCommitment | null;
}
function toSavingsPlansUtilizationAggregates(root: jsonP.JSONValue): SavingsPlansUtilizationAggregates {
  return jsonP.readObj({
    required: {
      "Utilization": toSavingsPlansUtilization,
    },
    optional: {
      "Savings": toSavingsPlansSavings,
      "AmortizedCommitment": toSavingsPlansAmortizedCommitment,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SavingsPlansUtilizationDetail {
  SavingsPlanArn?: string | null;
  Attributes?: { [key: string]: string | null | undefined } | null;
  Utilization?: SavingsPlansUtilization | null;
  Savings?: SavingsPlansSavings | null;
  AmortizedCommitment?: SavingsPlansAmortizedCommitment | null;
}
function toSavingsPlansUtilizationDetail(root: jsonP.JSONValue): SavingsPlansUtilizationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "SavingsPlanArn": "s",
      "Attributes": x => jsonP.readMap(String, String, x),
      "Utilization": toSavingsPlansUtilization,
      "Savings": toSavingsPlansSavings,
      "AmortizedCommitment": toSavingsPlansAmortizedCommitment,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CostCategoryReference {
  CostCategoryArn?: string | null;
  Name?: string | null;
  EffectiveStart?: string | null;
  EffectiveEnd?: string | null;
  NumberOfRules?: number | null;
  ProcessingStatus?: CostCategoryProcessingStatus[] | null;
  Values?: string[] | null;
}
function toCostCategoryReference(root: jsonP.JSONValue): CostCategoryReference {
  return jsonP.readObj({
    required: {},
    optional: {
      "CostCategoryArn": "s",
      "Name": "s",
      "EffectiveStart": "s",
      "EffectiveEnd": "s",
      "NumberOfRules": "n",
      "ProcessingStatus": [toCostCategoryProcessingStatus],
      "Values": ["s"],
    },
  }, root);
}
