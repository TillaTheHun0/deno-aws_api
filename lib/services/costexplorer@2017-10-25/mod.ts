// Autogenerated API client for: AWS Cost Explorer Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class CostExplorer {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CostExplorer.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-10-25",
    "endpointPrefix": "ce",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "AWS Cost Explorer",
    "serviceFullName": "AWS Cost Explorer Service",
    "serviceId": "Cost Explorer",
    "signatureVersion": "v4",
    "signingName": "ce",
    "targetPrefix": "AWSInsightsIndexService",
    "uid": "ce-2017-10-25"
  };

  async createAnomalyMonitor(
    {abortSignal, ...params}: RequestConfig & s.CreateAnomalyMonitorRequest,
  ): Promise<s.CreateAnomalyMonitorResponse> {
    const body: jsonP.JSONObject = {
      AnomalyMonitor: fromAnomalyMonitor(params["AnomalyMonitor"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAnomalyMonitor",
    });
    return jsonP.readObj({
      required: {
        "MonitorArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createAnomalySubscription(
    {abortSignal, ...params}: RequestConfig & s.CreateAnomalySubscriptionRequest,
  ): Promise<s.CreateAnomalySubscriptionResponse> {
    const body: jsonP.JSONObject = {
      AnomalySubscription: fromAnomalySubscription(params["AnomalySubscription"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAnomalySubscription",
    });
    return jsonP.readObj({
      required: {
        "SubscriptionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createCostCategoryDefinition(
    {abortSignal, ...params}: RequestConfig & s.CreateCostCategoryDefinitionRequest,
  ): Promise<s.CreateCostCategoryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RuleVersion: params["RuleVersion"],
      Rules: params["Rules"]?.map(x => fromCostCategoryRule(x)),
      DefaultValue: params["DefaultValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCostCategoryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategoryArn": "s",
        "EffectiveStart": "s",
      },
    }, await resp.json());
  }

  async deleteAnomalyMonitor(
    {abortSignal, ...params}: RequestConfig & s.DeleteAnomalyMonitorRequest,
  ): Promise<s.DeleteAnomalyMonitorResponse> {
    const body: jsonP.JSONObject = {
      MonitorArn: params["MonitorArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAnomalyMonitor",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteAnomalySubscription(
    {abortSignal, ...params}: RequestConfig & s.DeleteAnomalySubscriptionRequest,
  ): Promise<s.DeleteAnomalySubscriptionResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionArn: params["SubscriptionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAnomalySubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteCostCategoryDefinition(
    {abortSignal, ...params}: RequestConfig & s.DeleteCostCategoryDefinitionRequest,
  ): Promise<s.DeleteCostCategoryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      CostCategoryArn: params["CostCategoryArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCostCategoryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategoryArn": "s",
        "EffectiveEnd": "s",
      },
    }, await resp.json());
  }

  async describeCostCategoryDefinition(
    {abortSignal, ...params}: RequestConfig & s.DescribeCostCategoryDefinitionRequest,
  ): Promise<s.DescribeCostCategoryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      CostCategoryArn: params["CostCategoryArn"],
      EffectiveOn: params["EffectiveOn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCostCategoryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategory": toCostCategory,
      },
    }, await resp.json());
  }

  async getAnomalies(
    {abortSignal, ...params}: RequestConfig & s.GetAnomaliesRequest,
  ): Promise<s.GetAnomaliesResponse> {
    const body: jsonP.JSONObject = {
      MonitorArn: params["MonitorArn"],
      DateInterval: fromAnomalyDateInterval(params["DateInterval"]),
      Feedback: params["Feedback"],
      TotalImpact: fromTotalImpactFilter(params["TotalImpact"]),
      NextPageToken: params["NextPageToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAnomalies",
    });
    return jsonP.readObj({
      required: {
        "Anomalies": [toAnomaly],
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getAnomalyMonitors(
    {abortSignal, ...params}: RequestConfig & s.GetAnomalyMonitorsRequest = {},
  ): Promise<s.GetAnomalyMonitorsResponse> {
    const body: jsonP.JSONObject = {
      MonitorArnList: params["MonitorArnList"],
      NextPageToken: params["NextPageToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAnomalyMonitors",
    });
    return jsonP.readObj({
      required: {
        "AnomalyMonitors": [toAnomalyMonitor],
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getAnomalySubscriptions(
    {abortSignal, ...params}: RequestConfig & s.GetAnomalySubscriptionsRequest = {},
  ): Promise<s.GetAnomalySubscriptionsResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionArnList: params["SubscriptionArnList"],
      MonitorArn: params["MonitorArn"],
      NextPageToken: params["NextPageToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAnomalySubscriptions",
    });
    return jsonP.readObj({
      required: {
        "AnomalySubscriptions": [toAnomalySubscription],
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getCostAndUsage(
    {abortSignal, ...params}: RequestConfig & s.GetCostAndUsageRequest,
  ): Promise<s.GetCostAndUsageResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      Metrics: params["Metrics"],
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCostAndUsage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextPageToken": "s",
        "GroupDefinitions": [toGroupDefinition],
        "ResultsByTime": [toResultByTime],
        "DimensionValueAttributes": [toDimensionValuesWithAttributes],
      },
    }, await resp.json());
  }

  async getCostAndUsageWithResources(
    {abortSignal, ...params}: RequestConfig & s.GetCostAndUsageWithResourcesRequest,
  ): Promise<s.GetCostAndUsageWithResourcesResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      Metrics: params["Metrics"],
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCostAndUsageWithResources",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextPageToken": "s",
        "GroupDefinitions": [toGroupDefinition],
        "ResultsByTime": [toResultByTime],
        "DimensionValueAttributes": [toDimensionValuesWithAttributes],
      },
    }, await resp.json());
  }

  async getCostCategories(
    {abortSignal, ...params}: RequestConfig & s.GetCostCategoriesRequest,
  ): Promise<s.GetCostCategoriesResponse> {
    const body: jsonP.JSONObject = {
      SearchString: params["SearchString"],
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      CostCategoryName: params["CostCategoryName"],
      Filter: fromExpression(params["Filter"]),
      SortBy: params["SortBy"]?.map(x => fromSortDefinition(x)),
      MaxResults: params["MaxResults"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCostCategories",
    });
    return jsonP.readObj({
      required: {
        "ReturnSize": "n",
        "TotalSize": "n",
      },
      optional: {
        "NextPageToken": "s",
        "CostCategoryNames": ["s"],
        "CostCategoryValues": ["s"],
      },
    }, await resp.json());
  }

  async getCostForecast(
    {abortSignal, ...params}: RequestConfig & s.GetCostForecastRequest,
  ): Promise<s.GetCostForecastResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Metric: params["Metric"],
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      PredictionIntervalLevel: params["PredictionIntervalLevel"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCostForecast",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Total": toMetricValue,
        "ForecastResultsByTime": [toForecastResult],
      },
    }, await resp.json());
  }

  async getDimensionValues(
    {abortSignal, ...params}: RequestConfig & s.GetDimensionValuesRequest,
  ): Promise<s.GetDimensionValuesResponse> {
    const body: jsonP.JSONObject = {
      SearchString: params["SearchString"],
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Dimension: params["Dimension"],
      Context: params["Context"],
      Filter: fromExpression(params["Filter"]),
      SortBy: params["SortBy"]?.map(x => fromSortDefinition(x)),
      MaxResults: params["MaxResults"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDimensionValues",
    });
    return jsonP.readObj({
      required: {
        "DimensionValues": [toDimensionValuesWithAttributes],
        "ReturnSize": "n",
        "TotalSize": "n",
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getReservationCoverage(
    {abortSignal, ...params}: RequestConfig & s.GetReservationCoverageRequest,
  ): Promise<s.GetReservationCoverageResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      Metrics: params["Metrics"],
      NextPageToken: params["NextPageToken"],
      SortBy: fromSortDefinition(params["SortBy"]),
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservationCoverage",
    });
    return jsonP.readObj({
      required: {
        "CoveragesByTime": [toCoverageByTime],
      },
      optional: {
        "Total": toCoverage,
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getReservationPurchaseRecommendation(
    {abortSignal, ...params}: RequestConfig & s.GetReservationPurchaseRecommendationRequest,
  ): Promise<s.GetReservationPurchaseRecommendationResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      Service: params["Service"],
      Filter: fromExpression(params["Filter"]),
      AccountScope: params["AccountScope"],
      LookbackPeriodInDays: params["LookbackPeriodInDays"],
      TermInYears: params["TermInYears"],
      PaymentOption: params["PaymentOption"],
      ServiceSpecification: fromServiceSpecification(params["ServiceSpecification"]),
      PageSize: params["PageSize"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservationPurchaseRecommendation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toReservationPurchaseRecommendationMetadata,
        "Recommendations": [toReservationPurchaseRecommendation],
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getReservationUtilization(
    {abortSignal, ...params}: RequestConfig & s.GetReservationUtilizationRequest,
  ): Promise<s.GetReservationUtilizationResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      SortBy: fromSortDefinition(params["SortBy"]),
      NextPageToken: params["NextPageToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservationUtilization",
    });
    return jsonP.readObj({
      required: {
        "UtilizationsByTime": [toUtilizationByTime],
      },
      optional: {
        "Total": toReservationAggregates,
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getRightsizingRecommendation(
    {abortSignal, ...params}: RequestConfig & s.GetRightsizingRecommendationRequest,
  ): Promise<s.GetRightsizingRecommendationResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromExpression(params["Filter"]),
      Configuration: fromRightsizingRecommendationConfiguration(params["Configuration"]),
      Service: params["Service"],
      PageSize: params["PageSize"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRightsizingRecommendation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toRightsizingRecommendationMetadata,
        "Summary": toRightsizingRecommendationSummary,
        "RightsizingRecommendations": [toRightsizingRecommendation],
        "NextPageToken": "s",
        "Configuration": toRightsizingRecommendationConfiguration,
      },
    }, await resp.json());
  }

  async getSavingsPlansCoverage(
    {abortSignal, ...params}: RequestConfig & s.GetSavingsPlansCoverageRequest,
  ): Promise<s.GetSavingsPlansCoverageResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      GroupBy: params["GroupBy"]?.map(x => fromGroupDefinition(x)),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      Metrics: params["Metrics"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: fromSortDefinition(params["SortBy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSavingsPlansCoverage",
    });
    return jsonP.readObj({
      required: {
        "SavingsPlansCoverages": [toSavingsPlansCoverage],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getSavingsPlansPurchaseRecommendation(
    {abortSignal, ...params}: RequestConfig & s.GetSavingsPlansPurchaseRecommendationRequest,
  ): Promise<s.GetSavingsPlansPurchaseRecommendationResponse> {
    const body: jsonP.JSONObject = {
      SavingsPlansType: params["SavingsPlansType"],
      TermInYears: params["TermInYears"],
      PaymentOption: params["PaymentOption"],
      AccountScope: params["AccountScope"],
      NextPageToken: params["NextPageToken"],
      PageSize: params["PageSize"],
      LookbackPeriodInDays: params["LookbackPeriodInDays"],
      Filter: fromExpression(params["Filter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSavingsPlansPurchaseRecommendation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toSavingsPlansPurchaseRecommendationMetadata,
        "SavingsPlansPurchaseRecommendation": toSavingsPlansPurchaseRecommendation,
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getSavingsPlansUtilization(
    {abortSignal, ...params}: RequestConfig & s.GetSavingsPlansUtilizationRequest,
  ): Promise<s.GetSavingsPlansUtilizationResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      SortBy: fromSortDefinition(params["SortBy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSavingsPlansUtilization",
    });
    return jsonP.readObj({
      required: {
        "Total": toSavingsPlansUtilizationAggregates,
      },
      optional: {
        "SavingsPlansUtilizationsByTime": [toSavingsPlansUtilizationByTime],
      },
    }, await resp.json());
  }

  async getSavingsPlansUtilizationDetails(
    {abortSignal, ...params}: RequestConfig & s.GetSavingsPlansUtilizationDetailsRequest,
  ): Promise<s.GetSavingsPlansUtilizationDetailsResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Filter: fromExpression(params["Filter"]),
      DataType: params["DataType"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: fromSortDefinition(params["SortBy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSavingsPlansUtilizationDetails",
    });
    return jsonP.readObj({
      required: {
        "SavingsPlansUtilizationDetails": [toSavingsPlansUtilizationDetail],
        "TimePeriod": toDateInterval,
      },
      optional: {
        "Total": toSavingsPlansUtilizationAggregates,
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTags(
    {abortSignal, ...params}: RequestConfig & s.GetTagsRequest,
  ): Promise<s.GetTagsResponse> {
    const body: jsonP.JSONObject = {
      SearchString: params["SearchString"],
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      TagKey: params["TagKey"],
      Filter: fromExpression(params["Filter"]),
      SortBy: params["SortBy"]?.map(x => fromSortDefinition(x)),
      MaxResults: params["MaxResults"],
      NextPageToken: params["NextPageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTags",
    });
    return jsonP.readObj({
      required: {
        "Tags": ["s"],
        "ReturnSize": "n",
        "TotalSize": "n",
      },
      optional: {
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async getUsageForecast(
    {abortSignal, ...params}: RequestConfig & s.GetUsageForecastRequest,
  ): Promise<s.GetUsageForecastResponse> {
    const body: jsonP.JSONObject = {
      TimePeriod: fromDateInterval(params["TimePeriod"]),
      Metric: params["Metric"],
      Granularity: params["Granularity"],
      Filter: fromExpression(params["Filter"]),
      PredictionIntervalLevel: params["PredictionIntervalLevel"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUsageForecast",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Total": toMetricValue,
        "ForecastResultsByTime": [toForecastResult],
      },
    }, await resp.json());
  }

  async listCostCategoryDefinitions(
    {abortSignal, ...params}: RequestConfig & s.ListCostCategoryDefinitionsRequest = {},
  ): Promise<s.ListCostCategoryDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      EffectiveOn: params["EffectiveOn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCostCategoryDefinitions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategoryReferences": [toCostCategoryReference],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async provideAnomalyFeedback(
    {abortSignal, ...params}: RequestConfig & s.ProvideAnomalyFeedbackRequest,
  ): Promise<s.ProvideAnomalyFeedbackResponse> {
    const body: jsonP.JSONObject = {
      AnomalyId: params["AnomalyId"],
      Feedback: params["Feedback"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ProvideAnomalyFeedback",
    });
    return jsonP.readObj({
      required: {
        "AnomalyId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateAnomalyMonitor(
    {abortSignal, ...params}: RequestConfig & s.UpdateAnomalyMonitorRequest,
  ): Promise<s.UpdateAnomalyMonitorResponse> {
    const body: jsonP.JSONObject = {
      MonitorArn: params["MonitorArn"],
      MonitorName: params["MonitorName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAnomalyMonitor",
    });
    return jsonP.readObj({
      required: {
        "MonitorArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateAnomalySubscription(
    {abortSignal, ...params}: RequestConfig & s.UpdateAnomalySubscriptionRequest,
  ): Promise<s.UpdateAnomalySubscriptionResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionArn: params["SubscriptionArn"],
      Threshold: params["Threshold"],
      Frequency: params["Frequency"],
      MonitorArnList: params["MonitorArnList"],
      Subscribers: params["Subscribers"]?.map(x => fromSubscriber(x)),
      SubscriptionName: params["SubscriptionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAnomalySubscription",
    });
    return jsonP.readObj({
      required: {
        "SubscriptionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateCostCategoryDefinition(
    {abortSignal, ...params}: RequestConfig & s.UpdateCostCategoryDefinitionRequest,
  ): Promise<s.UpdateCostCategoryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      CostCategoryArn: params["CostCategoryArn"],
      RuleVersion: params["RuleVersion"],
      Rules: params["Rules"]?.map(x => fromCostCategoryRule(x)),
      DefaultValue: params["DefaultValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCostCategoryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CostCategoryArn": "s",
        "EffectiveStart": "s",
      },
    }, await resp.json());
  }

}

function fromAnomalyMonitor(input?: s.AnomalyMonitor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MonitorArn: input["MonitorArn"],
    MonitorName: input["MonitorName"],
    CreationDate: input["CreationDate"],
    LastUpdatedDate: input["LastUpdatedDate"],
    LastEvaluatedDate: input["LastEvaluatedDate"],
    MonitorType: input["MonitorType"],
    MonitorDimension: input["MonitorDimension"],
    MonitorSpecification: fromExpression(input["MonitorSpecification"]),
    DimensionalValueCount: input["DimensionalValueCount"],
  }
}
function toAnomalyMonitor(root: jsonP.JSONValue): s.AnomalyMonitor {
  return jsonP.readObj({
    required: {
      "MonitorName": "s",
      "MonitorType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MonitorType>(x),
    },
    optional: {
      "MonitorArn": "s",
      "CreationDate": "s",
      "LastUpdatedDate": "s",
      "LastEvaluatedDate": "s",
      "MonitorDimension": (x: jsonP.JSONValue) => cmnP.readEnum<s.MonitorDimension>(x),
      "MonitorSpecification": toExpression,
      "DimensionalValueCount": "n",
    },
  }, root);
}

function fromExpression(input?: s.Expression | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Or: input["Or"]?.map(x => fromExpression(x)),
    And: input["And"]?.map(x => fromExpression(x)),
    Not: fromExpression(input["Not"]),
    Dimensions: fromDimensionValues(input["Dimensions"]),
    Tags: fromTagValues(input["Tags"]),
    CostCategories: fromCostCategoryValues(input["CostCategories"]),
  }
}
function toExpression(root: jsonP.JSONValue): s.Expression {
  return jsonP.readObj({
    required: {},
    optional: {
      "Or": [toExpression],
      "And": [toExpression],
      "Not": toExpression,
      "Dimensions": toDimensionValues,
      "Tags": toTagValues,
      "CostCategories": toCostCategoryValues,
    },
  }, root);
}

function fromDimensionValues(input?: s.DimensionValues | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    MatchOptions: input["MatchOptions"],
  }
}
function toDimensionValues(root: jsonP.JSONValue): s.DimensionValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": (x: jsonP.JSONValue) => cmnP.readEnum<s.Dimension>(x),
      "Values": ["s"],
      "MatchOptions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.MatchOption>(x)],
    },
  }, root);
}

function fromTagValues(input?: s.TagValues | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    MatchOptions: input["MatchOptions"],
  }
}
function toTagValues(root: jsonP.JSONValue): s.TagValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Values": ["s"],
      "MatchOptions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.MatchOption>(x)],
    },
  }, root);
}

function fromCostCategoryValues(input?: s.CostCategoryValues | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    MatchOptions: input["MatchOptions"],
  }
}
function toCostCategoryValues(root: jsonP.JSONValue): s.CostCategoryValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Values": ["s"],
      "MatchOptions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.MatchOption>(x)],
    },
  }, root);
}

function fromAnomalySubscription(input?: s.AnomalySubscription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubscriptionArn: input["SubscriptionArn"],
    AccountId: input["AccountId"],
    MonitorArnList: input["MonitorArnList"],
    Subscribers: input["Subscribers"]?.map(x => fromSubscriber(x)),
    Threshold: input["Threshold"],
    Frequency: input["Frequency"],
    SubscriptionName: input["SubscriptionName"],
  }
}
function toAnomalySubscription(root: jsonP.JSONValue): s.AnomalySubscription {
  return jsonP.readObj({
    required: {
      "MonitorArnList": ["s"],
      "Subscribers": [toSubscriber],
      "Threshold": "n",
      "Frequency": (x: jsonP.JSONValue) => cmnP.readEnum<s.AnomalySubscriptionFrequency>(x),
      "SubscriptionName": "s",
    },
    optional: {
      "SubscriptionArn": "s",
      "AccountId": "s",
    },
  }, root);
}

function fromSubscriber(input?: s.Subscriber | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Address: input["Address"],
    Type: input["Type"],
    Status: input["Status"],
  }
}
function toSubscriber(root: jsonP.JSONValue): s.Subscriber {
  return jsonP.readObj({
    required: {},
    optional: {
      "Address": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.SubscriberType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SubscriberStatus>(x),
    },
  }, root);
}

function fromCostCategoryRule(input?: s.CostCategoryRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: input["Value"],
    Rule: fromExpression(input["Rule"]),
    InheritedValue: fromCostCategoryInheritedValueDimension(input["InheritedValue"]),
    Type: input["Type"],
  }
}
function toCostCategoryRule(root: jsonP.JSONValue): s.CostCategoryRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "s",
      "Rule": toExpression,
      "InheritedValue": toCostCategoryInheritedValueDimension,
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.CostCategoryRuleType>(x),
    },
  }, root);
}

function fromCostCategoryInheritedValueDimension(input?: s.CostCategoryInheritedValueDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DimensionName: input["DimensionName"],
    DimensionKey: input["DimensionKey"],
  }
}
function toCostCategoryInheritedValueDimension(root: jsonP.JSONValue): s.CostCategoryInheritedValueDimension {
  return jsonP.readObj({
    required: {},
    optional: {
      "DimensionName": (x: jsonP.JSONValue) => cmnP.readEnum<s.CostCategoryInheritedValueDimensionName>(x),
      "DimensionKey": "s",
    },
  }, root);
}

function fromAnomalyDateInterval(input?: s.AnomalyDateInterval | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartDate: input["StartDate"],
    EndDate: input["EndDate"],
  }
}

function fromTotalImpactFilter(input?: s.TotalImpactFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NumericOperator: input["NumericOperator"],
    StartValue: input["StartValue"],
    EndValue: input["EndValue"],
  }
}

function fromDateInterval(input?: s.DateInterval | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Start: input["Start"],
    End: input["End"],
  }
}
function toDateInterval(root: jsonP.JSONValue): s.DateInterval {
  return jsonP.readObj({
    required: {
      "Start": "s",
      "End": "s",
    },
    optional: {},
  }, root);
}

function fromGroupDefinition(input?: s.GroupDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Key: input["Key"],
  }
}
function toGroupDefinition(root: jsonP.JSONValue): s.GroupDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.GroupDefinitionType>(x),
      "Key": "s",
    },
  }, root);
}

function fromSortDefinition(input?: s.SortDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    SortOrder: input["SortOrder"],
  }
}

function fromServiceSpecification(input?: s.ServiceSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EC2Specification: fromEC2Specification(input["EC2Specification"]),
  }
}
function toServiceSpecification(root: jsonP.JSONValue): s.ServiceSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2Specification": toEC2Specification,
    },
  }, root);
}

function fromEC2Specification(input?: s.EC2Specification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OfferingClass: input["OfferingClass"],
  }
}
function toEC2Specification(root: jsonP.JSONValue): s.EC2Specification {
  return jsonP.readObj({
    required: {},
    optional: {
      "OfferingClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingClass>(x),
    },
  }, root);
}

function fromRightsizingRecommendationConfiguration(input?: s.RightsizingRecommendationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecommendationTarget: input["RecommendationTarget"],
    BenefitsConsidered: input["BenefitsConsidered"],
  }
}
function toRightsizingRecommendationConfiguration(root: jsonP.JSONValue): s.RightsizingRecommendationConfiguration {
  return jsonP.readObj({
    required: {
      "RecommendationTarget": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecommendationTarget>(x),
      "BenefitsConsidered": "b",
    },
    optional: {},
  }, root);
}

function toCostCategory(root: jsonP.JSONValue): s.CostCategory {
  return jsonP.readObj({
    required: {
      "CostCategoryArn": "s",
      "EffectiveStart": "s",
      "Name": "s",
      "RuleVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.CostCategoryRuleVersion>(x),
      "Rules": [toCostCategoryRule],
    },
    optional: {
      "EffectiveEnd": "s",
      "ProcessingStatus": [toCostCategoryProcessingStatus],
      "DefaultValue": "s",
    },
  }, root);
}

function toCostCategoryProcessingStatus(root: jsonP.JSONValue): s.CostCategoryProcessingStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "Component": (x: jsonP.JSONValue) => cmnP.readEnum<s.CostCategoryStatusComponent>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CostCategoryStatus>(x),
    },
  }, root);
}

function toAnomaly(root: jsonP.JSONValue): s.Anomaly {
  return jsonP.readObj({
    required: {
      "AnomalyId": "s",
      "AnomalyScore": toAnomalyScore,
      "Impact": toImpact,
      "MonitorArn": "s",
    },
    optional: {
      "AnomalyStartDate": "s",
      "AnomalyEndDate": "s",
      "DimensionValue": "s",
      "RootCauses": [toRootCause],
      "Feedback": (x: jsonP.JSONValue) => cmnP.readEnum<s.AnomalyFeedbackType>(x),
    },
  }, root);
}

function toRootCause(root: jsonP.JSONValue): s.RootCause {
  return jsonP.readObj({
    required: {},
    optional: {
      "Service": "s",
      "Region": "s",
      "LinkedAccount": "s",
      "UsageType": "s",
    },
  }, root);
}

function toAnomalyScore(root: jsonP.JSONValue): s.AnomalyScore {
  return jsonP.readObj({
    required: {
      "MaxScore": "n",
      "CurrentScore": "n",
    },
    optional: {},
  }, root);
}

function toImpact(root: jsonP.JSONValue): s.Impact {
  return jsonP.readObj({
    required: {
      "MaxImpact": "n",
    },
    optional: {
      "TotalImpact": "n",
    },
  }, root);
}

function toResultByTime(root: jsonP.JSONValue): s.ResultByTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimePeriod": toDateInterval,
      "Total": x => jsonP.readMap(String, toMetricValue, x),
      "Groups": [toGroup],
      "Estimated": "b",
    },
  }, root);
}

function toMetricValue(root: jsonP.JSONValue): s.MetricValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "Amount": "s",
      "Unit": "s",
    },
  }, root);
}

function toGroup(root: jsonP.JSONValue): s.Group {
  return jsonP.readObj({
    required: {},
    optional: {
      "Keys": ["s"],
      "Metrics": x => jsonP.readMap(String, toMetricValue, x),
    },
  }, root);
}

function toDimensionValuesWithAttributes(root: jsonP.JSONValue): s.DimensionValuesWithAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "s",
      "Attributes": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toForecastResult(root: jsonP.JSONValue): s.ForecastResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimePeriod": toDateInterval,
      "MeanValue": "s",
      "PredictionIntervalLowerBound": "s",
      "PredictionIntervalUpperBound": "s",
    },
  }, root);
}

function toCoverageByTime(root: jsonP.JSONValue): s.CoverageByTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimePeriod": toDateInterval,
      "Groups": [toReservationCoverageGroup],
      "Total": toCoverage,
    },
  }, root);
}

function toReservationCoverageGroup(root: jsonP.JSONValue): s.ReservationCoverageGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": x => jsonP.readMap(String, String, x),
      "Coverage": toCoverage,
    },
  }, root);
}

function toCoverage(root: jsonP.JSONValue): s.Coverage {
  return jsonP.readObj({
    required: {},
    optional: {
      "CoverageHours": toCoverageHours,
      "CoverageNormalizedUnits": toCoverageNormalizedUnits,
      "CoverageCost": toCoverageCost,
    },
  }, root);
}

function toCoverageHours(root: jsonP.JSONValue): s.CoverageHours {
  return jsonP.readObj({
    required: {},
    optional: {
      "OnDemandHours": "s",
      "ReservedHours": "s",
      "TotalRunningHours": "s",
      "CoverageHoursPercentage": "s",
    },
  }, root);
}

function toCoverageNormalizedUnits(root: jsonP.JSONValue): s.CoverageNormalizedUnits {
  return jsonP.readObj({
    required: {},
    optional: {
      "OnDemandNormalizedUnits": "s",
      "ReservedNormalizedUnits": "s",
      "TotalRunningNormalizedUnits": "s",
      "CoverageNormalizedUnitsPercentage": "s",
    },
  }, root);
}

function toCoverageCost(root: jsonP.JSONValue): s.CoverageCost {
  return jsonP.readObj({
    required: {},
    optional: {
      "OnDemandCost": "s",
    },
  }, root);
}

function toReservationPurchaseRecommendationMetadata(root: jsonP.JSONValue): s.ReservationPurchaseRecommendationMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecommendationId": "s",
      "GenerationTimestamp": "s",
    },
  }, root);
}

function toReservationPurchaseRecommendation(root: jsonP.JSONValue): s.ReservationPurchaseRecommendation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountScope": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccountScope>(x),
      "LookbackPeriodInDays": (x: jsonP.JSONValue) => cmnP.readEnum<s.LookbackPeriodInDays>(x),
      "TermInYears": (x: jsonP.JSONValue) => cmnP.readEnum<s.TermInYears>(x),
      "PaymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<s.PaymentOption>(x),
      "ServiceSpecification": toServiceSpecification,
      "RecommendationDetails": [toReservationPurchaseRecommendationDetail],
      "RecommendationSummary": toReservationPurchaseRecommendationSummary,
    },
  }, root);
}

function toReservationPurchaseRecommendationDetail(root: jsonP.JSONValue): s.ReservationPurchaseRecommendationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountId": "s",
      "InstanceDetails": toInstanceDetails,
      "RecommendedNumberOfInstancesToPurchase": "s",
      "RecommendedNormalizedUnitsToPurchase": "s",
      "MinimumNumberOfInstancesUsedPerHour": "s",
      "MinimumNormalizedUnitsUsedPerHour": "s",
      "MaximumNumberOfInstancesUsedPerHour": "s",
      "MaximumNormalizedUnitsUsedPerHour": "s",
      "AverageNumberOfInstancesUsedPerHour": "s",
      "AverageNormalizedUnitsUsedPerHour": "s",
      "AverageUtilization": "s",
      "EstimatedBreakEvenInMonths": "s",
      "CurrencyCode": "s",
      "EstimatedMonthlySavingsAmount": "s",
      "EstimatedMonthlySavingsPercentage": "s",
      "EstimatedMonthlyOnDemandCost": "s",
      "EstimatedReservationCostForLookbackPeriod": "s",
      "UpfrontCost": "s",
      "RecurringStandardMonthlyCost": "s",
    },
  }, root);
}

function toInstanceDetails(root: jsonP.JSONValue): s.InstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2InstanceDetails": toEC2InstanceDetails,
      "RDSInstanceDetails": toRDSInstanceDetails,
      "RedshiftInstanceDetails": toRedshiftInstanceDetails,
      "ElastiCacheInstanceDetails": toElastiCacheInstanceDetails,
      "ESInstanceDetails": toESInstanceDetails,
    },
  }, root);
}

function toEC2InstanceDetails(root: jsonP.JSONValue): s.EC2InstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "InstanceType": "s",
      "Region": "s",
      "AvailabilityZone": "s",
      "Platform": "s",
      "Tenancy": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

function toRDSInstanceDetails(root: jsonP.JSONValue): s.RDSInstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "InstanceType": "s",
      "Region": "s",
      "DatabaseEngine": "s",
      "DatabaseEdition": "s",
      "DeploymentOption": "s",
      "LicenseModel": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

function toRedshiftInstanceDetails(root: jsonP.JSONValue): s.RedshiftInstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "NodeType": "s",
      "Region": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

function toElastiCacheInstanceDetails(root: jsonP.JSONValue): s.ElastiCacheInstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Family": "s",
      "NodeType": "s",
      "Region": "s",
      "ProductDescription": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

function toESInstanceDetails(root: jsonP.JSONValue): s.ESInstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceClass": "s",
      "InstanceSize": "s",
      "Region": "s",
      "CurrentGeneration": "b",
      "SizeFlexEligible": "b",
    },
  }, root);
}

function toReservationPurchaseRecommendationSummary(root: jsonP.JSONValue): s.ReservationPurchaseRecommendationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalEstimatedMonthlySavingsAmount": "s",
      "TotalEstimatedMonthlySavingsPercentage": "s",
      "CurrencyCode": "s",
    },
  }, root);
}

function toUtilizationByTime(root: jsonP.JSONValue): s.UtilizationByTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimePeriod": toDateInterval,
      "Groups": [toReservationUtilizationGroup],
      "Total": toReservationAggregates,
    },
  }, root);
}

function toReservationUtilizationGroup(root: jsonP.JSONValue): s.ReservationUtilizationGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
      "Attributes": x => jsonP.readMap(String, String, x),
      "Utilization": toReservationAggregates,
    },
  }, root);
}

function toReservationAggregates(root: jsonP.JSONValue): s.ReservationAggregates {
  return jsonP.readObj({
    required: {},
    optional: {
      "UtilizationPercentage": "s",
      "UtilizationPercentageInUnits": "s",
      "PurchasedHours": "s",
      "PurchasedUnits": "s",
      "TotalActualHours": "s",
      "TotalActualUnits": "s",
      "UnusedHours": "s",
      "UnusedUnits": "s",
      "OnDemandCostOfRIHoursUsed": "s",
      "NetRISavings": "s",
      "TotalPotentialRISavings": "s",
      "AmortizedUpfrontFee": "s",
      "AmortizedRecurringFee": "s",
      "TotalAmortizedFee": "s",
      "RICostForUnusedHours": "s",
      "RealizedSavings": "s",
      "UnrealizedSavings": "s",
    },
  }, root);
}

function toRightsizingRecommendationMetadata(root: jsonP.JSONValue): s.RightsizingRecommendationMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecommendationId": "s",
      "GenerationTimestamp": "s",
      "LookbackPeriodInDays": (x: jsonP.JSONValue) => cmnP.readEnum<s.LookbackPeriodInDays>(x),
      "AdditionalMetadata": "s",
    },
  }, root);
}

function toRightsizingRecommendationSummary(root: jsonP.JSONValue): s.RightsizingRecommendationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalRecommendationCount": "s",
      "EstimatedTotalMonthlySavingsAmount": "s",
      "SavingsCurrencyCode": "s",
      "SavingsPercentage": "s",
    },
  }, root);
}

function toRightsizingRecommendation(root: jsonP.JSONValue): s.RightsizingRecommendation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountId": "s",
      "CurrentInstance": toCurrentInstance,
      "RightsizingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RightsizingType>(x),
      "ModifyRecommendationDetail": toModifyRecommendationDetail,
      "TerminateRecommendationDetail": toTerminateRecommendationDetail,
    },
  }, root);
}

function toCurrentInstance(root: jsonP.JSONValue): s.CurrentInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceId": "s",
      "InstanceName": "s",
      "Tags": [toTagValues],
      "ResourceDetails": toResourceDetails,
      "ResourceUtilization": toResourceUtilization,
      "ReservationCoveredHoursInLookbackPeriod": "s",
      "SavingsPlansCoveredHoursInLookbackPeriod": "s",
      "OnDemandHoursInLookbackPeriod": "s",
      "TotalRunningHoursInLookbackPeriod": "s",
      "MonthlyCost": "s",
      "CurrencyCode": "s",
    },
  }, root);
}

function toResourceDetails(root: jsonP.JSONValue): s.ResourceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2ResourceDetails": toEC2ResourceDetails,
    },
  }, root);
}

function toEC2ResourceDetails(root: jsonP.JSONValue): s.EC2ResourceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "HourlyOnDemandRate": "s",
      "InstanceType": "s",
      "Platform": "s",
      "Region": "s",
      "Sku": "s",
      "Memory": "s",
      "NetworkPerformance": "s",
      "Storage": "s",
      "Vcpu": "s",
    },
  }, root);
}

function toResourceUtilization(root: jsonP.JSONValue): s.ResourceUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2ResourceUtilization": toEC2ResourceUtilization,
    },
  }, root);
}

function toEC2ResourceUtilization(root: jsonP.JSONValue): s.EC2ResourceUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxCpuUtilizationPercentage": "s",
      "MaxMemoryUtilizationPercentage": "s",
      "MaxStorageUtilizationPercentage": "s",
      "EBSResourceUtilization": toEBSResourceUtilization,
    },
  }, root);
}

function toEBSResourceUtilization(root: jsonP.JSONValue): s.EBSResourceUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "EbsReadOpsPerSecond": "s",
      "EbsWriteOpsPerSecond": "s",
      "EbsReadBytesPerSecond": "s",
      "EbsWriteBytesPerSecond": "s",
    },
  }, root);
}

function toModifyRecommendationDetail(root: jsonP.JSONValue): s.ModifyRecommendationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetInstances": [toTargetInstance],
    },
  }, root);
}

function toTargetInstance(root: jsonP.JSONValue): s.TargetInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "EstimatedMonthlyCost": "s",
      "EstimatedMonthlySavings": "s",
      "CurrencyCode": "s",
      "DefaultTargetInstance": "b",
      "ResourceDetails": toResourceDetails,
      "ExpectedResourceUtilization": toResourceUtilization,
    },
  }, root);
}

function toTerminateRecommendationDetail(root: jsonP.JSONValue): s.TerminateRecommendationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "EstimatedMonthlySavings": "s",
      "CurrencyCode": "s",
    },
  }, root);
}

function toSavingsPlansCoverage(root: jsonP.JSONValue): s.SavingsPlansCoverage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": x => jsonP.readMap(String, String, x),
      "Coverage": toSavingsPlansCoverageData,
      "TimePeriod": toDateInterval,
    },
  }, root);
}

function toSavingsPlansCoverageData(root: jsonP.JSONValue): s.SavingsPlansCoverageData {
  return jsonP.readObj({
    required: {},
    optional: {
      "SpendCoveredBySavingsPlans": "s",
      "OnDemandCost": "s",
      "TotalCost": "s",
      "CoveragePercentage": "s",
    },
  }, root);
}

function toSavingsPlansPurchaseRecommendationMetadata(root: jsonP.JSONValue): s.SavingsPlansPurchaseRecommendationMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecommendationId": "s",
      "GenerationTimestamp": "s",
      "AdditionalMetadata": "s",
    },
  }, root);
}

function toSavingsPlansPurchaseRecommendation(root: jsonP.JSONValue): s.SavingsPlansPurchaseRecommendation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountScope": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccountScope>(x),
      "SavingsPlansType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SupportedSavingsPlansType>(x),
      "TermInYears": (x: jsonP.JSONValue) => cmnP.readEnum<s.TermInYears>(x),
      "PaymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<s.PaymentOption>(x),
      "LookbackPeriodInDays": (x: jsonP.JSONValue) => cmnP.readEnum<s.LookbackPeriodInDays>(x),
      "SavingsPlansPurchaseRecommendationDetails": [toSavingsPlansPurchaseRecommendationDetail],
      "SavingsPlansPurchaseRecommendationSummary": toSavingsPlansPurchaseRecommendationSummary,
    },
  }, root);
}

function toSavingsPlansPurchaseRecommendationDetail(root: jsonP.JSONValue): s.SavingsPlansPurchaseRecommendationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "SavingsPlansDetails": toSavingsPlansDetails,
      "AccountId": "s",
      "UpfrontCost": "s",
      "EstimatedROI": "s",
      "CurrencyCode": "s",
      "EstimatedSPCost": "s",
      "EstimatedOnDemandCost": "s",
      "EstimatedOnDemandCostWithCurrentCommitment": "s",
      "EstimatedSavingsAmount": "s",
      "EstimatedSavingsPercentage": "s",
      "HourlyCommitmentToPurchase": "s",
      "EstimatedAverageUtilization": "s",
      "EstimatedMonthlySavingsAmount": "s",
      "CurrentMinimumHourlyOnDemandSpend": "s",
      "CurrentMaximumHourlyOnDemandSpend": "s",
      "CurrentAverageHourlyOnDemandSpend": "s",
    },
  }, root);
}

function toSavingsPlansDetails(root: jsonP.JSONValue): s.SavingsPlansDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Region": "s",
      "InstanceFamily": "s",
      "OfferingId": "s",
    },
  }, root);
}

function toSavingsPlansPurchaseRecommendationSummary(root: jsonP.JSONValue): s.SavingsPlansPurchaseRecommendationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "EstimatedROI": "s",
      "CurrencyCode": "s",
      "EstimatedTotalCost": "s",
      "CurrentOnDemandSpend": "s",
      "EstimatedSavingsAmount": "s",
      "TotalRecommendationCount": "s",
      "DailyCommitmentToPurchase": "s",
      "HourlyCommitmentToPurchase": "s",
      "EstimatedSavingsPercentage": "s",
      "EstimatedMonthlySavingsAmount": "s",
      "EstimatedOnDemandCostWithCurrentCommitment": "s",
    },
  }, root);
}

function toSavingsPlansUtilizationByTime(root: jsonP.JSONValue): s.SavingsPlansUtilizationByTime {
  return jsonP.readObj({
    required: {
      "TimePeriod": toDateInterval,
      "Utilization": toSavingsPlansUtilization,
    },
    optional: {
      "Savings": toSavingsPlansSavings,
      "AmortizedCommitment": toSavingsPlansAmortizedCommitment,
    },
  }, root);
}

function toSavingsPlansUtilization(root: jsonP.JSONValue): s.SavingsPlansUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalCommitment": "s",
      "UsedCommitment": "s",
      "UnusedCommitment": "s",
      "UtilizationPercentage": "s",
    },
  }, root);
}

function toSavingsPlansSavings(root: jsonP.JSONValue): s.SavingsPlansSavings {
  return jsonP.readObj({
    required: {},
    optional: {
      "NetSavings": "s",
      "OnDemandCostEquivalent": "s",
    },
  }, root);
}

function toSavingsPlansAmortizedCommitment(root: jsonP.JSONValue): s.SavingsPlansAmortizedCommitment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AmortizedRecurringCommitment": "s",
      "AmortizedUpfrontCommitment": "s",
      "TotalAmortizedCommitment": "s",
    },
  }, root);
}

function toSavingsPlansUtilizationAggregates(root: jsonP.JSONValue): s.SavingsPlansUtilizationAggregates {
  return jsonP.readObj({
    required: {
      "Utilization": toSavingsPlansUtilization,
    },
    optional: {
      "Savings": toSavingsPlansSavings,
      "AmortizedCommitment": toSavingsPlansAmortizedCommitment,
    },
  }, root);
}

function toSavingsPlansUtilizationDetail(root: jsonP.JSONValue): s.SavingsPlansUtilizationDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "SavingsPlanArn": "s",
      "Attributes": x => jsonP.readMap(String, String, x),
      "Utilization": toSavingsPlansUtilization,
      "Savings": toSavingsPlansSavings,
      "AmortizedCommitment": toSavingsPlansAmortizedCommitment,
    },
  }, root);
}

function toCostCategoryReference(root: jsonP.JSONValue): s.CostCategoryReference {
  return jsonP.readObj({
    required: {},
    optional: {
      "CostCategoryArn": "s",
      "Name": "s",
      "EffectiveStart": "s",
      "EffectiveEnd": "s",
      "NumberOfRules": "n",
      "ProcessingStatus": [toCostCategoryProcessingStatus],
      "Values": ["s"],
      "DefaultValue": "s",
    },
  }, root);
}
