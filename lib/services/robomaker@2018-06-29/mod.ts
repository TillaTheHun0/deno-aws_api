// Autogenerated API client for: AWS RoboMaker

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class RoboMaker {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(RoboMaker.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-06-29",
    "endpointPrefix": "robomaker",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "RoboMaker",
    "serviceFullName": "AWS RoboMaker",
    "serviceId": "RoboMaker",
    "signatureVersion": "v4",
    "signingName": "robomaker",
    "uid": "robomaker-2018-06-29"
  };

  async batchDeleteWorlds(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteWorldsRequest,
  ): Promise<s.BatchDeleteWorldsResponse> {
    const body: jsonP.JSONObject = {
      worlds: params["worlds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteWorlds",
      requestUri: "/batchDeleteWorlds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "unprocessedWorlds": ["s"],
      },
    }, await resp.json());
  }

  async batchDescribeSimulationJob(
    {abortSignal, ...params}: RequestConfig & s.BatchDescribeSimulationJobRequest,
  ): Promise<s.BatchDescribeSimulationJobResponse> {
    const body: jsonP.JSONObject = {
      jobs: params["jobs"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDescribeSimulationJob",
      requestUri: "/batchDescribeSimulationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobs": [toSimulationJob],
        "unprocessedJobs": ["s"],
      },
    }, await resp.json());
  }

  async cancelDeploymentJob(
    {abortSignal, ...params}: RequestConfig & s.CancelDeploymentJobRequest,
  ): Promise<s.CancelDeploymentJobResponse> {
    const body: jsonP.JSONObject = {
      job: params["job"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelDeploymentJob",
      requestUri: "/cancelDeploymentJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelSimulationJob(
    {abortSignal, ...params}: RequestConfig & s.CancelSimulationJobRequest,
  ): Promise<s.CancelSimulationJobResponse> {
    const body: jsonP.JSONObject = {
      job: params["job"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSimulationJob",
      requestUri: "/cancelSimulationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelSimulationJobBatch(
    {abortSignal, ...params}: RequestConfig & s.CancelSimulationJobBatchRequest,
  ): Promise<s.CancelSimulationJobBatchResponse> {
    const body: jsonP.JSONObject = {
      batch: params["batch"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSimulationJobBatch",
      requestUri: "/cancelSimulationJobBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelWorldExportJob(
    {abortSignal, ...params}: RequestConfig & s.CancelWorldExportJobRequest,
  ): Promise<s.CancelWorldExportJobResponse> {
    const body: jsonP.JSONObject = {
      job: params["job"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelWorldExportJob",
      requestUri: "/cancelWorldExportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelWorldGenerationJob(
    {abortSignal, ...params}: RequestConfig & s.CancelWorldGenerationJobRequest,
  ): Promise<s.CancelWorldGenerationJobResponse> {
    const body: jsonP.JSONObject = {
      job: params["job"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelWorldGenerationJob",
      requestUri: "/cancelWorldGenerationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createDeploymentJob(
    {abortSignal, ...params}: RequestConfig & s.CreateDeploymentJobRequest,
  ): Promise<s.CreateDeploymentJobResponse> {
    const body: jsonP.JSONObject = {
      deploymentConfig: fromDeploymentConfig(params["deploymentConfig"]),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      fleet: params["fleet"],
      deploymentApplicationConfigs: params["deploymentApplicationConfigs"]?.map(x => fromDeploymentApplicationConfig(x)),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeploymentJob",
      requestUri: "/createDeploymentJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "fleet": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
        "deploymentApplicationConfigs": [toDeploymentApplicationConfig],
        "failureReason": "s",
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentJobErrorCode>(x),
        "createdAt": "d",
        "deploymentConfig": toDeploymentConfig,
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createFleet(
    {abortSignal, ...params}: RequestConfig & s.CreateFleetRequest,
  ): Promise<s.CreateFleetResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFleet",
      requestUri: "/createFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "createdAt": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createRobot(
    {abortSignal, ...params}: RequestConfig & s.CreateRobotRequest,
  ): Promise<s.CreateRobotResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      architecture: params["architecture"],
      greengrassGroupId: params["greengrassGroupId"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRobot",
      requestUri: "/createRobot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "createdAt": "d",
        "greengrassGroupId": "s",
        "architecture": (x: jsonP.JSONValue) => cmnP.readEnum<s.Architecture>(x),
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createRobotApplication(
    {abortSignal, ...params}: RequestConfig & s.CreateRobotApplicationRequest,
  ): Promise<s.CreateRobotApplicationResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      sources: params["sources"]?.map(x => fromSourceConfig(x)),
      robotSoftwareSuite: fromRobotSoftwareSuite(params["robotSoftwareSuite"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRobotApplication",
      requestUri: "/createRobotApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "version": "s",
        "sources": [toSource],
        "robotSoftwareSuite": toRobotSoftwareSuite,
        "lastUpdatedAt": "d",
        "revisionId": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createRobotApplicationVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateRobotApplicationVersionRequest,
  ): Promise<s.CreateRobotApplicationVersionResponse> {
    const body: jsonP.JSONObject = {
      application: params["application"],
      currentRevisionId: params["currentRevisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRobotApplicationVersion",
      requestUri: "/createRobotApplicationVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "version": "s",
        "sources": [toSource],
        "robotSoftwareSuite": toRobotSoftwareSuite,
        "lastUpdatedAt": "d",
        "revisionId": "s",
      },
    }, await resp.json());
  }

  async createSimulationApplication(
    {abortSignal, ...params}: RequestConfig & s.CreateSimulationApplicationRequest,
  ): Promise<s.CreateSimulationApplicationResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      sources: params["sources"]?.map(x => fromSourceConfig(x)),
      simulationSoftwareSuite: fromSimulationSoftwareSuite(params["simulationSoftwareSuite"]),
      robotSoftwareSuite: fromRobotSoftwareSuite(params["robotSoftwareSuite"]),
      renderingEngine: fromRenderingEngine(params["renderingEngine"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSimulationApplication",
      requestUri: "/createSimulationApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "version": "s",
        "sources": [toSource],
        "simulationSoftwareSuite": toSimulationSoftwareSuite,
        "robotSoftwareSuite": toRobotSoftwareSuite,
        "renderingEngine": toRenderingEngine,
        "lastUpdatedAt": "d",
        "revisionId": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createSimulationApplicationVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateSimulationApplicationVersionRequest,
  ): Promise<s.CreateSimulationApplicationVersionResponse> {
    const body: jsonP.JSONObject = {
      application: params["application"],
      currentRevisionId: params["currentRevisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSimulationApplicationVersion",
      requestUri: "/createSimulationApplicationVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "version": "s",
        "sources": [toSource],
        "simulationSoftwareSuite": toSimulationSoftwareSuite,
        "robotSoftwareSuite": toRobotSoftwareSuite,
        "renderingEngine": toRenderingEngine,
        "lastUpdatedAt": "d",
        "revisionId": "s",
      },
    }, await resp.json());
  }

  async createSimulationJob(
    {abortSignal, ...params}: RequestConfig & s.CreateSimulationJobRequest,
  ): Promise<s.CreateSimulationJobResponse> {
    const body: jsonP.JSONObject = {
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      outputLocation: fromOutputLocation(params["outputLocation"]),
      loggingConfig: fromLoggingConfig(params["loggingConfig"]),
      maxJobDurationInSeconds: params["maxJobDurationInSeconds"],
      iamRole: params["iamRole"],
      failureBehavior: params["failureBehavior"],
      robotApplications: params["robotApplications"]?.map(x => fromRobotApplicationConfig(x)),
      simulationApplications: params["simulationApplications"]?.map(x => fromSimulationApplicationConfig(x)),
      dataSources: params["dataSources"]?.map(x => fromDataSourceConfig(x)),
      tags: params["tags"],
      vpcConfig: fromVPCConfig(params["vpcConfig"]),
      compute: fromCompute(params["compute"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSimulationJob",
      requestUri: "/createSimulationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobStatus>(x),
        "lastStartedAt": "d",
        "lastUpdatedAt": "d",
        "failureBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.FailureBehavior>(x),
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobErrorCode>(x),
        "clientRequestToken": "s",
        "outputLocation": toOutputLocation,
        "loggingConfig": toLoggingConfig,
        "maxJobDurationInSeconds": "n",
        "simulationTimeMillis": "n",
        "iamRole": "s",
        "robotApplications": [toRobotApplicationConfig],
        "simulationApplications": [toSimulationApplicationConfig],
        "dataSources": [toDataSource],
        "tags": x => jsonP.readMap(String, String, x),
        "vpcConfig": toVPCConfigResponse,
        "compute": toComputeResponse,
      },
    }, await resp.json());
  }

  async createWorldExportJob(
    {abortSignal, ...params}: RequestConfig & s.CreateWorldExportJobRequest,
  ): Promise<s.CreateWorldExportJobResponse> {
    const body: jsonP.JSONObject = {
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      worlds: params["worlds"],
      outputLocation: fromOutputLocation(params["outputLocation"]),
      iamRole: params["iamRole"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorldExportJob",
      requestUri: "/createWorldExportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldExportJobStatus>(x),
        "createdAt": "d",
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldExportJobErrorCode>(x),
        "clientRequestToken": "s",
        "outputLocation": toOutputLocation,
        "iamRole": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createWorldGenerationJob(
    {abortSignal, ...params}: RequestConfig & s.CreateWorldGenerationJobRequest,
  ): Promise<s.CreateWorldGenerationJobResponse> {
    const body: jsonP.JSONObject = {
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      template: params["template"],
      worldCount: fromWorldCount(params["worldCount"]),
      tags: params["tags"],
      worldTags: params["worldTags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorldGenerationJob",
      requestUri: "/createWorldGenerationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldGenerationJobStatus>(x),
        "createdAt": "d",
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldGenerationJobErrorCode>(x),
        "clientRequestToken": "s",
        "template": "s",
        "worldCount": toWorldCount,
        "tags": x => jsonP.readMap(String, String, x),
        "worldTags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createWorldTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateWorldTemplateRequest = {},
  ): Promise<s.CreateWorldTemplateResponse> {
    const body: jsonP.JSONObject = {
      clientRequestToken: params["clientRequestToken"],
      name: params["name"],
      templateBody: params["templateBody"],
      templateLocation: fromTemplateLocation(params["templateLocation"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorldTemplate",
      requestUri: "/createWorldTemplate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "clientRequestToken": "s",
        "createdAt": "d",
        "name": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async deleteFleet(
    {abortSignal, ...params}: RequestConfig & s.DeleteFleetRequest,
  ): Promise<s.DeleteFleetResponse> {
    const body: jsonP.JSONObject = {
      fleet: params["fleet"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFleet",
      requestUri: "/deleteFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteRobot(
    {abortSignal, ...params}: RequestConfig & s.DeleteRobotRequest,
  ): Promise<s.DeleteRobotResponse> {
    const body: jsonP.JSONObject = {
      robot: params["robot"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRobot",
      requestUri: "/deleteRobot",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteRobotApplication(
    {abortSignal, ...params}: RequestConfig & s.DeleteRobotApplicationRequest,
  ): Promise<s.DeleteRobotApplicationResponse> {
    const body: jsonP.JSONObject = {
      application: params["application"],
      applicationVersion: params["applicationVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRobotApplication",
      requestUri: "/deleteRobotApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteSimulationApplication(
    {abortSignal, ...params}: RequestConfig & s.DeleteSimulationApplicationRequest,
  ): Promise<s.DeleteSimulationApplicationResponse> {
    const body: jsonP.JSONObject = {
      application: params["application"],
      applicationVersion: params["applicationVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSimulationApplication",
      requestUri: "/deleteSimulationApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteWorldTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteWorldTemplateRequest,
  ): Promise<s.DeleteWorldTemplateResponse> {
    const body: jsonP.JSONObject = {
      template: params["template"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWorldTemplate",
      requestUri: "/deleteWorldTemplate",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deregisterRobot(
    {abortSignal, ...params}: RequestConfig & s.DeregisterRobotRequest,
  ): Promise<s.DeregisterRobotResponse> {
    const body: jsonP.JSONObject = {
      fleet: params["fleet"],
      robot: params["robot"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterRobot",
      requestUri: "/deregisterRobot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fleet": "s",
        "robot": "s",
      },
    }, await resp.json());
  }

  async describeDeploymentJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeDeploymentJobRequest,
  ): Promise<s.DescribeDeploymentJobResponse> {
    const body: jsonP.JSONObject = {
      job: params["job"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDeploymentJob",
      requestUri: "/describeDeploymentJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "fleet": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
        "deploymentConfig": toDeploymentConfig,
        "deploymentApplicationConfigs": [toDeploymentApplicationConfig],
        "failureReason": "s",
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentJobErrorCode>(x),
        "createdAt": "d",
        "robotDeploymentSummary": [toRobotDeployment],
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeFleet(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetRequest,
  ): Promise<s.DescribeFleetResponse> {
    const body: jsonP.JSONObject = {
      fleet: params["fleet"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleet",
      requestUri: "/describeFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "arn": "s",
        "robots": [toRobot],
        "createdAt": "d",
        "lastDeploymentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
        "lastDeploymentJob": "s",
        "lastDeploymentTime": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeRobot(
    {abortSignal, ...params}: RequestConfig & s.DescribeRobotRequest,
  ): Promise<s.DescribeRobotResponse> {
    const body: jsonP.JSONObject = {
      robot: params["robot"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRobot",
      requestUri: "/describeRobot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "fleetArn": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RobotStatus>(x),
        "greengrassGroupId": "s",
        "createdAt": "d",
        "architecture": (x: jsonP.JSONValue) => cmnP.readEnum<s.Architecture>(x),
        "lastDeploymentJob": "s",
        "lastDeploymentTime": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeRobotApplication(
    {abortSignal, ...params}: RequestConfig & s.DescribeRobotApplicationRequest,
  ): Promise<s.DescribeRobotApplicationResponse> {
    const body: jsonP.JSONObject = {
      application: params["application"],
      applicationVersion: params["applicationVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRobotApplication",
      requestUri: "/describeRobotApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "version": "s",
        "sources": [toSource],
        "robotSoftwareSuite": toRobotSoftwareSuite,
        "revisionId": "s",
        "lastUpdatedAt": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeSimulationApplication(
    {abortSignal, ...params}: RequestConfig & s.DescribeSimulationApplicationRequest,
  ): Promise<s.DescribeSimulationApplicationResponse> {
    const body: jsonP.JSONObject = {
      application: params["application"],
      applicationVersion: params["applicationVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSimulationApplication",
      requestUri: "/describeSimulationApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "version": "s",
        "sources": [toSource],
        "simulationSoftwareSuite": toSimulationSoftwareSuite,
        "robotSoftwareSuite": toRobotSoftwareSuite,
        "renderingEngine": toRenderingEngine,
        "revisionId": "s",
        "lastUpdatedAt": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeSimulationJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeSimulationJobRequest,
  ): Promise<s.DescribeSimulationJobResponse> {
    const body: jsonP.JSONObject = {
      job: params["job"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSimulationJob",
      requestUri: "/describeSimulationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobStatus>(x),
        "lastStartedAt": "d",
        "lastUpdatedAt": "d",
        "failureBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.FailureBehavior>(x),
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobErrorCode>(x),
        "failureReason": "s",
        "clientRequestToken": "s",
        "outputLocation": toOutputLocation,
        "loggingConfig": toLoggingConfig,
        "maxJobDurationInSeconds": "n",
        "simulationTimeMillis": "n",
        "iamRole": "s",
        "robotApplications": [toRobotApplicationConfig],
        "simulationApplications": [toSimulationApplicationConfig],
        "dataSources": [toDataSource],
        "tags": x => jsonP.readMap(String, String, x),
        "vpcConfig": toVPCConfigResponse,
        "networkInterface": toNetworkInterface,
        "compute": toComputeResponse,
      },
    }, await resp.json());
  }

  async describeSimulationJobBatch(
    {abortSignal, ...params}: RequestConfig & s.DescribeSimulationJobBatchRequest,
  ): Promise<s.DescribeSimulationJobBatchResponse> {
    const body: jsonP.JSONObject = {
      batch: params["batch"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSimulationJobBatch",
      requestUri: "/describeSimulationJobBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobBatchStatus>(x),
        "lastUpdatedAt": "d",
        "createdAt": "d",
        "clientRequestToken": "s",
        "batchPolicy": toBatchPolicy,
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobBatchErrorCode>(x),
        "failureReason": "s",
        "failedRequests": [toFailedCreateSimulationJobRequest],
        "pendingRequests": [toSimulationJobRequest],
        "createdRequests": [toSimulationJobSummary],
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeWorld(
    {abortSignal, ...params}: RequestConfig & s.DescribeWorldRequest,
  ): Promise<s.DescribeWorldResponse> {
    const body: jsonP.JSONObject = {
      world: params["world"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorld",
      requestUri: "/describeWorld",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "generationJob": "s",
        "template": "s",
        "createdAt": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeWorldExportJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeWorldExportJobRequest,
  ): Promise<s.DescribeWorldExportJobResponse> {
    const body: jsonP.JSONObject = {
      job: params["job"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorldExportJob",
      requestUri: "/describeWorldExportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldExportJobStatus>(x),
        "createdAt": "d",
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldExportJobErrorCode>(x),
        "failureReason": "s",
        "clientRequestToken": "s",
        "worlds": ["s"],
        "outputLocation": toOutputLocation,
        "iamRole": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeWorldGenerationJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeWorldGenerationJobRequest,
  ): Promise<s.DescribeWorldGenerationJobResponse> {
    const body: jsonP.JSONObject = {
      job: params["job"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorldGenerationJob",
      requestUri: "/describeWorldGenerationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldGenerationJobStatus>(x),
        "createdAt": "d",
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldGenerationJobErrorCode>(x),
        "failureReason": "s",
        "clientRequestToken": "s",
        "template": "s",
        "worldCount": toWorldCount,
        "finishedWorldsSummary": toFinishedWorldsSummary,
        "tags": x => jsonP.readMap(String, String, x),
        "worldTags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeWorldTemplate(
    {abortSignal, ...params}: RequestConfig & s.DescribeWorldTemplateRequest,
  ): Promise<s.DescribeWorldTemplateResponse> {
    const body: jsonP.JSONObject = {
      template: params["template"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorldTemplate",
      requestUri: "/describeWorldTemplate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "clientRequestToken": "s",
        "name": "s",
        "createdAt": "d",
        "lastUpdatedAt": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getWorldTemplateBody(
    {abortSignal, ...params}: RequestConfig & s.GetWorldTemplateBodyRequest = {},
  ): Promise<s.GetWorldTemplateBodyResponse> {
    const body: jsonP.JSONObject = {
      template: params["template"],
      generationJob: params["generationJob"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorldTemplateBody",
      requestUri: "/getWorldTemplateBody",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "templateBody": "s",
      },
    }, await resp.json());
  }

  async listDeploymentJobs(
    {abortSignal, ...params}: RequestConfig & s.ListDeploymentJobsRequest = {},
  ): Promise<s.ListDeploymentJobsResponse> {
    const body: jsonP.JSONObject = {
      filters: params["filters"]?.map(x => fromFilter(x)),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeploymentJobs",
      requestUri: "/listDeploymentJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deploymentJobs": [toDeploymentJob],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFleets(
    {abortSignal, ...params}: RequestConfig & s.ListFleetsRequest = {},
  ): Promise<s.ListFleetsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filters: params["filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFleets",
      requestUri: "/listFleets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fleetDetails": [toFleet],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRobotApplications(
    {abortSignal, ...params}: RequestConfig & s.ListRobotApplicationsRequest = {},
  ): Promise<s.ListRobotApplicationsResponse> {
    const body: jsonP.JSONObject = {
      versionQualifier: params["versionQualifier"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filters: params["filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRobotApplications",
      requestUri: "/listRobotApplications",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "robotApplicationSummaries": [toRobotApplicationSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRobots(
    {abortSignal, ...params}: RequestConfig & s.ListRobotsRequest = {},
  ): Promise<s.ListRobotsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filters: params["filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRobots",
      requestUri: "/listRobots",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "robots": [toRobot],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSimulationApplications(
    {abortSignal, ...params}: RequestConfig & s.ListSimulationApplicationsRequest = {},
  ): Promise<s.ListSimulationApplicationsResponse> {
    const body: jsonP.JSONObject = {
      versionQualifier: params["versionQualifier"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filters: params["filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSimulationApplications",
      requestUri: "/listSimulationApplications",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "simulationApplicationSummaries": [toSimulationApplicationSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSimulationJobBatches(
    {abortSignal, ...params}: RequestConfig & s.ListSimulationJobBatchesRequest = {},
  ): Promise<s.ListSimulationJobBatchesResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filters: params["filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSimulationJobBatches",
      requestUri: "/listSimulationJobBatches",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "simulationJobBatchSummaries": [toSimulationJobBatchSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSimulationJobs(
    {abortSignal, ...params}: RequestConfig & s.ListSimulationJobsRequest = {},
  ): Promise<s.ListSimulationJobsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filters: params["filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSimulationJobs",
      requestUri: "/listSimulationJobs",
    });
    return jsonP.readObj({
      required: {
        "simulationJobSummaries": [toSimulationJobSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listWorldExportJobs(
    {abortSignal, ...params}: RequestConfig & s.ListWorldExportJobsRequest = {},
  ): Promise<s.ListWorldExportJobsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filters: params["filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorldExportJobs",
      requestUri: "/listWorldExportJobs",
    });
    return jsonP.readObj({
      required: {
        "worldExportJobSummaries": [toWorldExportJobSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listWorldGenerationJobs(
    {abortSignal, ...params}: RequestConfig & s.ListWorldGenerationJobsRequest = {},
  ): Promise<s.ListWorldGenerationJobsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filters: params["filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorldGenerationJobs",
      requestUri: "/listWorldGenerationJobs",
    });
    return jsonP.readObj({
      required: {
        "worldGenerationJobSummaries": [toWorldGenerationJobSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listWorldTemplates(
    {abortSignal, ...params}: RequestConfig & s.ListWorldTemplatesRequest = {},
  ): Promise<s.ListWorldTemplatesResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorldTemplates",
      requestUri: "/listWorldTemplates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "templateSummaries": [toTemplateSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listWorlds(
    {abortSignal, ...params}: RequestConfig & s.ListWorldsRequest = {},
  ): Promise<s.ListWorldsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filters: params["filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorlds",
      requestUri: "/listWorlds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "worldSummaries": [toWorldSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async registerRobot(
    {abortSignal, ...params}: RequestConfig & s.RegisterRobotRequest,
  ): Promise<s.RegisterRobotResponse> {
    const body: jsonP.JSONObject = {
      fleet: params["fleet"],
      robot: params["robot"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterRobot",
      requestUri: "/registerRobot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fleet": "s",
        "robot": "s",
      },
    }, await resp.json());
  }

  async restartSimulationJob(
    {abortSignal, ...params}: RequestConfig & s.RestartSimulationJobRequest,
  ): Promise<s.RestartSimulationJobResponse> {
    const body: jsonP.JSONObject = {
      job: params["job"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestartSimulationJob",
      requestUri: "/restartSimulationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startSimulationJobBatch(
    {abortSignal, ...params}: RequestConfig & s.StartSimulationJobBatchRequest,
  ): Promise<s.StartSimulationJobBatchResponse> {
    const body: jsonP.JSONObject = {
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      batchPolicy: fromBatchPolicy(params["batchPolicy"]),
      createSimulationJobRequests: params["createSimulationJobRequests"]?.map(x => fromSimulationJobRequest(x)),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartSimulationJobBatch",
      requestUri: "/startSimulationJobBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobBatchStatus>(x),
        "createdAt": "d",
        "clientRequestToken": "s",
        "batchPolicy": toBatchPolicy,
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobBatchErrorCode>(x),
        "failureReason": "s",
        "failedRequests": [toFailedCreateSimulationJobRequest],
        "pendingRequests": [toSimulationJobRequest],
        "createdRequests": [toSimulationJobSummary],
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async syncDeploymentJob(
    {abortSignal, ...params}: RequestConfig & s.SyncDeploymentJobRequest,
  ): Promise<s.SyncDeploymentJobResponse> {
    const body: jsonP.JSONObject = {
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      fleet: params["fleet"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SyncDeploymentJob",
      requestUri: "/syncDeploymentJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "fleet": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
        "deploymentConfig": toDeploymentConfig,
        "deploymentApplicationConfigs": [toDeploymentApplicationConfig],
        "failureReason": "s",
        "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentJobErrorCode>(x),
        "createdAt": "d",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateRobotApplication(
    {abortSignal, ...params}: RequestConfig & s.UpdateRobotApplicationRequest,
  ): Promise<s.UpdateRobotApplicationResponse> {
    const body: jsonP.JSONObject = {
      application: params["application"],
      sources: params["sources"]?.map(x => fromSourceConfig(x)),
      robotSoftwareSuite: fromRobotSoftwareSuite(params["robotSoftwareSuite"]),
      currentRevisionId: params["currentRevisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRobotApplication",
      requestUri: "/updateRobotApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "version": "s",
        "sources": [toSource],
        "robotSoftwareSuite": toRobotSoftwareSuite,
        "lastUpdatedAt": "d",
        "revisionId": "s",
      },
    }, await resp.json());
  }

  async updateSimulationApplication(
    {abortSignal, ...params}: RequestConfig & s.UpdateSimulationApplicationRequest,
  ): Promise<s.UpdateSimulationApplicationResponse> {
    const body: jsonP.JSONObject = {
      application: params["application"],
      sources: params["sources"]?.map(x => fromSourceConfig(x)),
      simulationSoftwareSuite: fromSimulationSoftwareSuite(params["simulationSoftwareSuite"]),
      robotSoftwareSuite: fromRobotSoftwareSuite(params["robotSoftwareSuite"]),
      renderingEngine: fromRenderingEngine(params["renderingEngine"]),
      currentRevisionId: params["currentRevisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSimulationApplication",
      requestUri: "/updateSimulationApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "version": "s",
        "sources": [toSource],
        "simulationSoftwareSuite": toSimulationSoftwareSuite,
        "robotSoftwareSuite": toRobotSoftwareSuite,
        "renderingEngine": toRenderingEngine,
        "lastUpdatedAt": "d",
        "revisionId": "s",
      },
    }, await resp.json());
  }

  async updateWorldTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateWorldTemplateRequest,
  ): Promise<s.UpdateWorldTemplateResponse> {
    const body: jsonP.JSONObject = {
      template: params["template"],
      name: params["name"],
      templateBody: params["templateBody"],
      templateLocation: fromTemplateLocation(params["templateLocation"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWorldTemplate",
      requestUri: "/updateWorldTemplate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "name": "s",
        "createdAt": "d",
        "lastUpdatedAt": "d",
      },
    }, await resp.json());
  }

}

function fromDeploymentConfig(input?: s.DeploymentConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    concurrentDeploymentPercentage: input["concurrentDeploymentPercentage"],
    failureThresholdPercentage: input["failureThresholdPercentage"],
    robotDeploymentTimeoutInSeconds: input["robotDeploymentTimeoutInSeconds"],
    downloadConditionFile: fromS3Object(input["downloadConditionFile"]),
  }
}
function toDeploymentConfig(root: jsonP.JSONValue): s.DeploymentConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "concurrentDeploymentPercentage": "n",
      "failureThresholdPercentage": "n",
      "robotDeploymentTimeoutInSeconds": "n",
      "downloadConditionFile": toS3Object,
    },
  }, root);
}

function fromS3Object(input?: s.S3Object | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    key: input["key"],
    etag: input["etag"],
  }
}
function toS3Object(root: jsonP.JSONValue): s.S3Object {
  return jsonP.readObj({
    required: {
      "bucket": "s",
      "key": "s",
    },
    optional: {
      "etag": "s",
    },
  }, root);
}

function fromDeploymentApplicationConfig(input?: s.DeploymentApplicationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    application: input["application"],
    applicationVersion: input["applicationVersion"],
    launchConfig: fromDeploymentLaunchConfig(input["launchConfig"]),
  }
}
function toDeploymentApplicationConfig(root: jsonP.JSONValue): s.DeploymentApplicationConfig {
  return jsonP.readObj({
    required: {
      "application": "s",
      "applicationVersion": "s",
      "launchConfig": toDeploymentLaunchConfig,
    },
    optional: {},
  }, root);
}

function fromDeploymentLaunchConfig(input?: s.DeploymentLaunchConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    packageName: input["packageName"],
    preLaunchFile: input["preLaunchFile"],
    launchFile: input["launchFile"],
    postLaunchFile: input["postLaunchFile"],
    environmentVariables: input["environmentVariables"],
  }
}
function toDeploymentLaunchConfig(root: jsonP.JSONValue): s.DeploymentLaunchConfig {
  return jsonP.readObj({
    required: {
      "packageName": "s",
      "launchFile": "s",
    },
    optional: {
      "preLaunchFile": "s",
      "postLaunchFile": "s",
      "environmentVariables": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromSourceConfig(input?: s.SourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Bucket: input["s3Bucket"],
    s3Key: input["s3Key"],
    architecture: input["architecture"],
  }
}

function fromRobotSoftwareSuite(input?: s.RobotSoftwareSuite | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    version: input["version"],
  }
}
function toRobotSoftwareSuite(root: jsonP.JSONValue): s.RobotSoftwareSuite {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<s.RobotSoftwareSuiteType>(x),
      "version": (x: jsonP.JSONValue) => cmnP.readEnum<s.RobotSoftwareSuiteVersionType>(x),
    },
  }, root);
}

function fromSimulationSoftwareSuite(input?: s.SimulationSoftwareSuite | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    version: input["version"],
  }
}
function toSimulationSoftwareSuite(root: jsonP.JSONValue): s.SimulationSoftwareSuite {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationSoftwareSuiteType>(x),
      "version": "s",
    },
  }, root);
}

function fromRenderingEngine(input?: s.RenderingEngine | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    version: input["version"],
  }
}
function toRenderingEngine(root: jsonP.JSONValue): s.RenderingEngine {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<s.RenderingEngineType>(x),
      "version": "s",
    },
  }, root);
}

function fromOutputLocation(input?: s.OutputLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Bucket: input["s3Bucket"],
    s3Prefix: input["s3Prefix"],
  }
}
function toOutputLocation(root: jsonP.JSONValue): s.OutputLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3Bucket": "s",
      "s3Prefix": "s",
    },
  }, root);
}

function fromLoggingConfig(input?: s.LoggingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    recordAllRosTopics: input["recordAllRosTopics"],
  }
}
function toLoggingConfig(root: jsonP.JSONValue): s.LoggingConfig {
  return jsonP.readObj({
    required: {
      "recordAllRosTopics": "b",
    },
    optional: {},
  }, root);
}

function fromRobotApplicationConfig(input?: s.RobotApplicationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    application: input["application"],
    applicationVersion: input["applicationVersion"],
    launchConfig: fromLaunchConfig(input["launchConfig"]),
    uploadConfigurations: input["uploadConfigurations"]?.map(x => fromUploadConfiguration(x)),
    useDefaultUploadConfigurations: input["useDefaultUploadConfigurations"],
  }
}
function toRobotApplicationConfig(root: jsonP.JSONValue): s.RobotApplicationConfig {
  return jsonP.readObj({
    required: {
      "application": "s",
      "launchConfig": toLaunchConfig,
    },
    optional: {
      "applicationVersion": "s",
      "uploadConfigurations": [toUploadConfiguration],
      "useDefaultUploadConfigurations": "b",
    },
  }, root);
}

function fromLaunchConfig(input?: s.LaunchConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    packageName: input["packageName"],
    launchFile: input["launchFile"],
    environmentVariables: input["environmentVariables"],
    portForwardingConfig: fromPortForwardingConfig(input["portForwardingConfig"]),
    streamUI: input["streamUI"],
  }
}
function toLaunchConfig(root: jsonP.JSONValue): s.LaunchConfig {
  return jsonP.readObj({
    required: {
      "packageName": "s",
      "launchFile": "s",
    },
    optional: {
      "environmentVariables": x => jsonP.readMap(String, String, x),
      "portForwardingConfig": toPortForwardingConfig,
      "streamUI": "b",
    },
  }, root);
}

function fromPortForwardingConfig(input?: s.PortForwardingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    portMappings: input["portMappings"]?.map(x => fromPortMapping(x)),
  }
}
function toPortForwardingConfig(root: jsonP.JSONValue): s.PortForwardingConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "portMappings": [toPortMapping],
    },
  }, root);
}

function fromPortMapping(input?: s.PortMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    jobPort: input["jobPort"],
    applicationPort: input["applicationPort"],
    enableOnPublicIp: input["enableOnPublicIp"],
  }
}
function toPortMapping(root: jsonP.JSONValue): s.PortMapping {
  return jsonP.readObj({
    required: {
      "jobPort": "n",
      "applicationPort": "n",
    },
    optional: {
      "enableOnPublicIp": "b",
    },
  }, root);
}

function fromUploadConfiguration(input?: s.UploadConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    path: input["path"],
    uploadBehavior: input["uploadBehavior"],
  }
}
function toUploadConfiguration(root: jsonP.JSONValue): s.UploadConfiguration {
  return jsonP.readObj({
    required: {
      "name": "s",
      "path": "s",
      "uploadBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.UploadBehavior>(x),
    },
    optional: {},
  }, root);
}

function fromSimulationApplicationConfig(input?: s.SimulationApplicationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    application: input["application"],
    applicationVersion: input["applicationVersion"],
    launchConfig: fromLaunchConfig(input["launchConfig"]),
    uploadConfigurations: input["uploadConfigurations"]?.map(x => fromUploadConfiguration(x)),
    worldConfigs: input["worldConfigs"]?.map(x => fromWorldConfig(x)),
    useDefaultUploadConfigurations: input["useDefaultUploadConfigurations"],
  }
}
function toSimulationApplicationConfig(root: jsonP.JSONValue): s.SimulationApplicationConfig {
  return jsonP.readObj({
    required: {
      "application": "s",
      "launchConfig": toLaunchConfig,
    },
    optional: {
      "applicationVersion": "s",
      "uploadConfigurations": [toUploadConfiguration],
      "worldConfigs": [toWorldConfig],
      "useDefaultUploadConfigurations": "b",
    },
  }, root);
}

function fromWorldConfig(input?: s.WorldConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    world: input["world"],
  }
}
function toWorldConfig(root: jsonP.JSONValue): s.WorldConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "world": "s",
    },
  }, root);
}

function fromDataSourceConfig(input?: s.DataSourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    s3Bucket: input["s3Bucket"],
    s3Keys: input["s3Keys"],
  }
}
function toDataSourceConfig(root: jsonP.JSONValue): s.DataSourceConfig {
  return jsonP.readObj({
    required: {
      "name": "s",
      "s3Bucket": "s",
      "s3Keys": ["s"],
    },
    optional: {},
  }, root);
}

function fromVPCConfig(input?: s.VPCConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subnets: input["subnets"],
    securityGroups: input["securityGroups"],
    assignPublicIp: input["assignPublicIp"],
  }
}
function toVPCConfig(root: jsonP.JSONValue): s.VPCConfig {
  return jsonP.readObj({
    required: {
      "subnets": ["s"],
    },
    optional: {
      "securityGroups": ["s"],
      "assignPublicIp": "b",
    },
  }, root);
}

function fromCompute(input?: s.Compute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    simulationUnitLimit: input["simulationUnitLimit"],
  }
}
function toCompute(root: jsonP.JSONValue): s.Compute {
  return jsonP.readObj({
    required: {},
    optional: {
      "simulationUnitLimit": "n",
    },
  }, root);
}

function fromWorldCount(input?: s.WorldCount | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    floorplanCount: input["floorplanCount"],
    interiorCountPerFloorplan: input["interiorCountPerFloorplan"],
  }
}
function toWorldCount(root: jsonP.JSONValue): s.WorldCount {
  return jsonP.readObj({
    required: {},
    optional: {
      "floorplanCount": "n",
      "interiorCountPerFloorplan": "n",
    },
  }, root);
}

function fromTemplateLocation(input?: s.TemplateLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Bucket: input["s3Bucket"],
    s3Key: input["s3Key"],
  }
}

function fromFilter(input?: s.Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
  }
}

function fromBatchPolicy(input?: s.BatchPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timeoutInSeconds: input["timeoutInSeconds"],
    maxConcurrency: input["maxConcurrency"],
  }
}
function toBatchPolicy(root: jsonP.JSONValue): s.BatchPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "timeoutInSeconds": "n",
      "maxConcurrency": "n",
    },
  }, root);
}

function fromSimulationJobRequest(input?: s.SimulationJobRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    outputLocation: fromOutputLocation(input["outputLocation"]),
    loggingConfig: fromLoggingConfig(input["loggingConfig"]),
    maxJobDurationInSeconds: input["maxJobDurationInSeconds"],
    iamRole: input["iamRole"],
    failureBehavior: input["failureBehavior"],
    useDefaultApplications: input["useDefaultApplications"],
    robotApplications: input["robotApplications"]?.map(x => fromRobotApplicationConfig(x)),
    simulationApplications: input["simulationApplications"]?.map(x => fromSimulationApplicationConfig(x)),
    dataSources: input["dataSources"]?.map(x => fromDataSourceConfig(x)),
    vpcConfig: fromVPCConfig(input["vpcConfig"]),
    compute: fromCompute(input["compute"]),
    tags: input["tags"],
  }
}
function toSimulationJobRequest(root: jsonP.JSONValue): s.SimulationJobRequest {
  return jsonP.readObj({
    required: {
      "maxJobDurationInSeconds": "n",
    },
    optional: {
      "outputLocation": toOutputLocation,
      "loggingConfig": toLoggingConfig,
      "iamRole": "s",
      "failureBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.FailureBehavior>(x),
      "useDefaultApplications": "b",
      "robotApplications": [toRobotApplicationConfig],
      "simulationApplications": [toSimulationApplicationConfig],
      "dataSources": [toDataSourceConfig],
      "vpcConfig": toVPCConfig,
      "compute": toCompute,
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toSimulationJob(root: jsonP.JSONValue): s.SimulationJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobStatus>(x),
      "lastStartedAt": "d",
      "lastUpdatedAt": "d",
      "failureBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.FailureBehavior>(x),
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobErrorCode>(x),
      "failureReason": "s",
      "clientRequestToken": "s",
      "outputLocation": toOutputLocation,
      "loggingConfig": toLoggingConfig,
      "maxJobDurationInSeconds": "n",
      "simulationTimeMillis": "n",
      "iamRole": "s",
      "robotApplications": [toRobotApplicationConfig],
      "simulationApplications": [toSimulationApplicationConfig],
      "dataSources": [toDataSource],
      "tags": x => jsonP.readMap(String, String, x),
      "vpcConfig": toVPCConfigResponse,
      "networkInterface": toNetworkInterface,
      "compute": toComputeResponse,
    },
  }, root);
}

function toDataSource(root: jsonP.JSONValue): s.DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "s3Bucket": "s",
      "s3Keys": [toS3KeyOutput],
    },
  }, root);
}

function toS3KeyOutput(root: jsonP.JSONValue): s.S3KeyOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3Key": "s",
      "etag": "s",
    },
  }, root);
}

function toVPCConfigResponse(root: jsonP.JSONValue): s.VPCConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "subnets": ["s"],
      "securityGroups": ["s"],
      "vpcId": "s",
      "assignPublicIp": "b",
    },
  }, root);
}

function toNetworkInterface(root: jsonP.JSONValue): s.NetworkInterface {
  return jsonP.readObj({
    required: {},
    optional: {
      "networkInterfaceId": "s",
      "privateIpAddress": "s",
      "publicIpAddress": "s",
    },
  }, root);
}

function toComputeResponse(root: jsonP.JSONValue): s.ComputeResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "simulationUnitLimit": "n",
    },
  }, root);
}

function toSource(root: jsonP.JSONValue): s.Source {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3Bucket": "s",
      "s3Key": "s",
      "etag": "s",
      "architecture": (x: jsonP.JSONValue) => cmnP.readEnum<s.Architecture>(x),
    },
  }, root);
}

function toRobotDeployment(root: jsonP.JSONValue): s.RobotDeployment {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "deploymentStartTime": "d",
      "deploymentFinishTime": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RobotStatus>(x),
      "progressDetail": toProgressDetail,
      "failureReason": "s",
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentJobErrorCode>(x),
    },
  }, root);
}

function toProgressDetail(root: jsonP.JSONValue): s.ProgressDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "currentProgress": (x: jsonP.JSONValue) => cmnP.readEnum<s.RobotDeploymentStep>(x),
      "percentDone": "n",
      "estimatedTimeRemainingSeconds": "n",
      "targetResource": "s",
    },
  }, root);
}

function toRobot(root: jsonP.JSONValue): s.Robot {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "fleetArn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RobotStatus>(x),
      "greenGrassGroupId": "s",
      "createdAt": "d",
      "architecture": (x: jsonP.JSONValue) => cmnP.readEnum<s.Architecture>(x),
      "lastDeploymentJob": "s",
      "lastDeploymentTime": "d",
    },
  }, root);
}

function toFailedCreateSimulationJobRequest(root: jsonP.JSONValue): s.FailedCreateSimulationJobRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "request": toSimulationJobRequest,
      "failureReason": "s",
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobErrorCode>(x),
      "failedAt": "d",
    },
  }, root);
}

function toSimulationJobSummary(root: jsonP.JSONValue): s.SimulationJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "lastUpdatedAt": "d",
      "name": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobStatus>(x),
      "simulationApplicationNames": ["s"],
      "robotApplicationNames": ["s"],
      "dataSourceNames": ["s"],
    },
  }, root);
}

function toFinishedWorldsSummary(root: jsonP.JSONValue): s.FinishedWorldsSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "finishedCount": "n",
      "succeededWorlds": ["s"],
      "failureSummary": toFailureSummary,
    },
  }, root);
}

function toFailureSummary(root: jsonP.JSONValue): s.FailureSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "totalFailureCount": "n",
      "failures": [toWorldFailure],
    },
  }, root);
}

function toWorldFailure(root: jsonP.JSONValue): s.WorldFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldGenerationJobErrorCode>(x),
      "sampleFailureReason": "s",
      "failureCount": "n",
    },
  }, root);
}

function toDeploymentJob(root: jsonP.JSONValue): s.DeploymentJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "fleet": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
      "deploymentApplicationConfigs": [toDeploymentApplicationConfig],
      "deploymentConfig": toDeploymentConfig,
      "failureReason": "s",
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentJobErrorCode>(x),
      "createdAt": "d",
    },
  }, root);
}

function toFleet(root: jsonP.JSONValue): s.Fleet {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "createdAt": "d",
      "lastDeploymentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
      "lastDeploymentJob": "s",
      "lastDeploymentTime": "d",
    },
  }, root);
}

function toRobotApplicationSummary(root: jsonP.JSONValue): s.RobotApplicationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "version": "s",
      "lastUpdatedAt": "d",
      "robotSoftwareSuite": toRobotSoftwareSuite,
    },
  }, root);
}

function toSimulationApplicationSummary(root: jsonP.JSONValue): s.SimulationApplicationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "version": "s",
      "lastUpdatedAt": "d",
      "robotSoftwareSuite": toRobotSoftwareSuite,
      "simulationSoftwareSuite": toSimulationSoftwareSuite,
    },
  }, root);
}

function toSimulationJobBatchSummary(root: jsonP.JSONValue): s.SimulationJobBatchSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "lastUpdatedAt": "d",
      "createdAt": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SimulationJobBatchStatus>(x),
      "failedRequestCount": "n",
      "pendingRequestCount": "n",
      "createdRequestCount": "n",
    },
  }, root);
}

function toWorldExportJobSummary(root: jsonP.JSONValue): s.WorldExportJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldExportJobStatus>(x),
      "createdAt": "d",
      "worlds": ["s"],
    },
  }, root);
}

function toWorldGenerationJobSummary(root: jsonP.JSONValue): s.WorldGenerationJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "template": "s",
      "createdAt": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorldGenerationJobStatus>(x),
      "worldCount": toWorldCount,
      "succeededWorldCount": "n",
      "failedWorldCount": "n",
    },
  }, root);
}

function toTemplateSummary(root: jsonP.JSONValue): s.TemplateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "name": "s",
    },
  }, root);
}

function toWorldSummary(root: jsonP.JSONValue): s.WorldSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "createdAt": "d",
      "generationJob": "s",
      "template": "s",
    },
  }, root);
}
