// Autogenerated API client for: Amazon Relational Database Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { readXmlResult, readXmlMap, parseTimestamp, XmlNode } from '../../encoding/xml.ts';
import * as prt from "../../encoding/querystring.ts";

export default class RDS {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(RDS.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2014-10-31",
    "endpointPrefix": "rds",
    "protocol": "query",
    "serviceAbbreviation": "Amazon RDS",
    "serviceFullName": "Amazon Relational Database Service",
    "serviceId": "RDS",
    "signatureVersion": "v4",
    "uid": "rds-2014-10-31",
    "xmlNamespace": "http://rds.amazonaws.com/doc/2014-10-31/"
  };

  async addRoleToDBCluster(
    {abortSignal, ...params}: RequestConfig & AddRoleToDBClusterMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    body.append(prefix+"RoleArn", (params["RoleArn"] ?? '').toString());
    if ("FeatureName" in params) body.append(prefix+"FeatureName", (params["FeatureName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddRoleToDBCluster",
    });
  }

  async addRoleToDBInstance(
    {abortSignal, ...params}: RequestConfig & AddRoleToDBInstanceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"RoleArn", (params["RoleArn"] ?? '').toString());
    body.append(prefix+"FeatureName", (params["FeatureName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddRoleToDBInstance",
    });
  }

  async addSourceIdentifierToSubscription(
    {abortSignal, ...params}: RequestConfig & AddSourceIdentifierToSubscriptionMessage,
  ): Promise<AddSourceIdentifierToSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddSourceIdentifierToSubscription",
    });
    const xml = readXmlResult(await resp.text(), "AddSourceIdentifierToSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & AddTagsToResourceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
  }

  async applyPendingMaintenanceAction(
    {abortSignal, ...params}: RequestConfig & ApplyPendingMaintenanceActionMessage,
  ): Promise<ApplyPendingMaintenanceActionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceIdentifier", (params["ResourceIdentifier"] ?? '').toString());
    body.append(prefix+"ApplyAction", (params["ApplyAction"] ?? '').toString());
    body.append(prefix+"OptInType", (params["OptInType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplyPendingMaintenanceAction",
    });
    const xml = readXmlResult(await resp.text(), "ApplyPendingMaintenanceActionResult");
    return {
      ResourcePendingMaintenanceActions: xml.first("ResourcePendingMaintenanceActions", false, ResourcePendingMaintenanceActions_Parse),
    };
  }

  async authorizeDBSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & AuthorizeDBSecurityGroupIngressMessage,
  ): Promise<AuthorizeDBSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupId" in params) body.append(prefix+"EC2SecurityGroupId", (params["EC2SecurityGroupId"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeDBSecurityGroupIngress",
    });
    const xml = readXmlResult(await resp.text(), "AuthorizeDBSecurityGroupIngressResult");
    return {
      DBSecurityGroup: xml.first("DBSecurityGroup", false, DBSecurityGroup_Parse),
    };
  }

  async backtrackDBCluster(
    {abortSignal, ...params}: RequestConfig & BacktrackDBClusterMessage,
  ): Promise<DBClusterBacktrack> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    body.append(prefix+"BacktrackTo", prt.encodeDate_iso8601(params["BacktrackTo"]));
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    if ("UseEarliestTimeOnPointInTimeUnavailable" in params) body.append(prefix+"UseEarliestTimeOnPointInTimeUnavailable", (params["UseEarliestTimeOnPointInTimeUnavailable"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BacktrackDBCluster",
    });
    const xml = readXmlResult(await resp.text(), "BacktrackDBClusterResult");
    return DBClusterBacktrack_Parse(xml);
  }

  async cancelExportTask(
    {abortSignal, ...params}: RequestConfig & CancelExportTaskMessage,
  ): Promise<ExportTask> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ExportTaskIdentifier", (params["ExportTaskIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelExportTask",
    });
    const xml = readXmlResult(await resp.text(), "CancelExportTaskResult");
    return ExportTask_Parse(xml);
  }

  async copyDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & CopyDBClusterParameterGroupMessage,
  ): Promise<CopyDBClusterParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBClusterParameterGroupIdentifier", (params["SourceDBClusterParameterGroupIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBClusterParameterGroupIdentifier", (params["TargetDBClusterParameterGroupIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBClusterParameterGroupDescription", (params["TargetDBClusterParameterGroupDescription"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyDBClusterParameterGroup",
    });
    const xml = readXmlResult(await resp.text(), "CopyDBClusterParameterGroupResult");
    return {
      DBClusterParameterGroup: xml.first("DBClusterParameterGroup", false, DBClusterParameterGroup_Parse),
    };
  }

  async copyDBClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & CopyDBClusterSnapshotMessage,
  ): Promise<CopyDBClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBClusterSnapshotIdentifier", (params["SourceDBClusterSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBClusterSnapshotIdentifier", (params["TargetDBClusterSnapshotIdentifier"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("PreSignedUrl" in params) body.append(prefix+"PreSignedUrl", (params["PreSignedUrl"] ?? '').toString());
    if ("CopyTags" in params) body.append(prefix+"CopyTags", (params["CopyTags"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("SourceRegion" in params) body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyDBClusterSnapshot",
    });
    const xml = readXmlResult(await resp.text(), "CopyDBClusterSnapshotResult");
    return {
      DBClusterSnapshot: xml.first("DBClusterSnapshot", false, DBClusterSnapshot_Parse),
    };
  }

  async copyDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & CopyDBParameterGroupMessage,
  ): Promise<CopyDBParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBParameterGroupIdentifier", (params["SourceDBParameterGroupIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBParameterGroupIdentifier", (params["TargetDBParameterGroupIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBParameterGroupDescription", (params["TargetDBParameterGroupDescription"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyDBParameterGroup",
    });
    const xml = readXmlResult(await resp.text(), "CopyDBParameterGroupResult");
    return {
      DBParameterGroup: xml.first("DBParameterGroup", false, DBParameterGroup_Parse),
    };
  }

  async copyDBSnapshot(
    {abortSignal, ...params}: RequestConfig & CopyDBSnapshotMessage,
  ): Promise<CopyDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBSnapshotIdentifier", (params["SourceDBSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBSnapshotIdentifier", (params["TargetDBSnapshotIdentifier"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("CopyTags" in params) body.append(prefix+"CopyTags", (params["CopyTags"] ?? '').toString());
    if ("PreSignedUrl" in params) body.append(prefix+"PreSignedUrl", (params["PreSignedUrl"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("SourceRegion" in params) body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyDBSnapshot",
    });
    const xml = readXmlResult(await resp.text(), "CopyDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async copyOptionGroup(
    {abortSignal, ...params}: RequestConfig & CopyOptionGroupMessage,
  ): Promise<CopyOptionGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceOptionGroupIdentifier", (params["SourceOptionGroupIdentifier"] ?? '').toString());
    body.append(prefix+"TargetOptionGroupIdentifier", (params["TargetOptionGroupIdentifier"] ?? '').toString());
    body.append(prefix+"TargetOptionGroupDescription", (params["TargetOptionGroupDescription"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyOptionGroup",
    });
    const xml = readXmlResult(await resp.text(), "CopyOptionGroupResult");
    return {
      OptionGroup: xml.first("OptionGroup", false, OptionGroup_Parse),
    };
  }

  async createCustomAvailabilityZone(
    {abortSignal, ...params}: RequestConfig & CreateCustomAvailabilityZoneMessage,
  ): Promise<CreateCustomAvailabilityZoneResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CustomAvailabilityZoneName", (params["CustomAvailabilityZoneName"] ?? '').toString());
    if ("ExistingVpnId" in params) body.append(prefix+"ExistingVpnId", (params["ExistingVpnId"] ?? '').toString());
    if ("NewVpnTunnelName" in params) body.append(prefix+"NewVpnTunnelName", (params["NewVpnTunnelName"] ?? '').toString());
    if ("VpnTunnelOriginatorIP" in params) body.append(prefix+"VpnTunnelOriginatorIP", (params["VpnTunnelOriginatorIP"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomAvailabilityZone",
    });
    const xml = readXmlResult(await resp.text(), "CreateCustomAvailabilityZoneResult");
    return {
      CustomAvailabilityZone: xml.first("CustomAvailabilityZone", false, CustomAvailabilityZone_Parse),
    };
  }

  async createDBCluster(
    {abortSignal, ...params}: RequestConfig & CreateDBClusterMessage,
  ): Promise<CreateDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AvailabilityZones"]) prt.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".AvailabilityZone."})
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("CharacterSetName" in params) body.append(prefix+"CharacterSetName", (params["CharacterSetName"] ?? '').toString());
    if ("DatabaseName" in params) body.append(prefix+"DatabaseName", (params["DatabaseName"] ?? '').toString());
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("DBClusterParameterGroupName" in params) body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("MasterUsername" in params) body.append(prefix+"MasterUsername", (params["MasterUsername"] ?? '').toString());
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("ReplicationSourceIdentifier" in params) body.append(prefix+"ReplicationSourceIdentifier", (params["ReplicationSourceIdentifier"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("StorageEncrypted" in params) body.append(prefix+"StorageEncrypted", (params["StorageEncrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("PreSignedUrl" in params) body.append(prefix+"PreSignedUrl", (params["PreSignedUrl"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    if ("BacktrackWindow" in params) body.append(prefix+"BacktrackWindow", (params["BacktrackWindow"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) prt.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if ("EngineMode" in params) body.append(prefix+"EngineMode", (params["EngineMode"] ?? '').toString());
    if (params["ScalingConfiguration"] != null) ScalingConfiguration_Serialize(body, prefix+"ScalingConfiguration", params["ScalingConfiguration"]);
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("GlobalClusterIdentifier" in params) body.append(prefix+"GlobalClusterIdentifier", (params["GlobalClusterIdentifier"] ?? '').toString());
    if ("EnableHttpEndpoint" in params) body.append(prefix+"EnableHttpEndpoint", (params["EnableHttpEndpoint"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    if ("EnableGlobalWriteForwarding" in params) body.append(prefix+"EnableGlobalWriteForwarding", (params["EnableGlobalWriteForwarding"] ?? '').toString());
    if ("SourceRegion" in params) body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBCluster",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async createDBClusterEndpoint(
    {abortSignal, ...params}: RequestConfig & CreateDBClusterEndpointMessage,
  ): Promise<DBClusterEndpoint> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    body.append(prefix+"DBClusterEndpointIdentifier", (params["DBClusterEndpointIdentifier"] ?? '').toString());
    body.append(prefix+"EndpointType", (params["EndpointType"] ?? '').toString());
    if (params["StaticMembers"]) prt.appendList(body, prefix+"StaticMembers", params["StaticMembers"], {"entryPrefix":".member."})
    if (params["ExcludedMembers"]) prt.appendList(body, prefix+"ExcludedMembers", params["ExcludedMembers"], {"entryPrefix":".member."})
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBClusterEndpoint",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBClusterEndpointResult");
    return DBClusterEndpoint_Parse(xml);
  }

  async createDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & CreateDBClusterParameterGroupMessage,
  ): Promise<CreateDBClusterParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBClusterParameterGroup",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBClusterParameterGroupResult");
    return {
      DBClusterParameterGroup: xml.first("DBClusterParameterGroup", false, DBClusterParameterGroup_Parse),
    };
  }

  async createDBClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & CreateDBClusterSnapshotMessage,
  ): Promise<CreateDBClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBClusterSnapshot",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBClusterSnapshotResult");
    return {
      DBClusterSnapshot: xml.first("DBClusterSnapshot", false, DBClusterSnapshot_Parse),
    };
  }

  async createDBInstance(
    {abortSignal, ...params}: RequestConfig & CreateDBInstanceMessage,
  ): Promise<CreateDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("AllocatedStorage" in params) body.append(prefix+"AllocatedStorage", (params["AllocatedStorage"] ?? '').toString());
    body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("MasterUsername" in params) body.append(prefix+"MasterUsername", (params["MasterUsername"] ?? '').toString());
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if (params["DBSecurityGroups"]) prt.appendList(body, prefix+"DBSecurityGroups", params["DBSecurityGroups"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("CharacterSetName" in params) body.append(prefix+"CharacterSetName", (params["CharacterSetName"] ?? '').toString());
    if ("NcharCharacterSetName" in params) body.append(prefix+"NcharCharacterSetName", (params["NcharCharacterSetName"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("DBClusterIdentifier" in params) body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("StorageType" in params) body.append(prefix+"StorageType", (params["StorageType"] ?? '').toString());
    if ("TdeCredentialArn" in params) body.append(prefix+"TdeCredentialArn", (params["TdeCredentialArn"] ?? '').toString());
    if ("TdeCredentialPassword" in params) body.append(prefix+"TdeCredentialPassword", (params["TdeCredentialPassword"] ?? '').toString());
    if ("StorageEncrypted" in params) body.append(prefix+"StorageEncrypted", (params["StorageEncrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("MonitoringInterval" in params) body.append(prefix+"MonitoringInterval", (params["MonitoringInterval"] ?? '').toString());
    if ("MonitoringRoleArn" in params) body.append(prefix+"MonitoringRoleArn", (params["MonitoringRoleArn"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    if ("PromotionTier" in params) body.append(prefix+"PromotionTier", (params["PromotionTier"] ?? '').toString());
    if ("Timezone" in params) body.append(prefix+"Timezone", (params["Timezone"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    if ("EnablePerformanceInsights" in params) body.append(prefix+"EnablePerformanceInsights", (params["EnablePerformanceInsights"] ?? '').toString());
    if ("PerformanceInsightsKMSKeyId" in params) body.append(prefix+"PerformanceInsightsKMSKeyId", (params["PerformanceInsightsKMSKeyId"] ?? '').toString());
    if ("PerformanceInsightsRetentionPeriod" in params) body.append(prefix+"PerformanceInsightsRetentionPeriod", (params["PerformanceInsightsRetentionPeriod"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) prt.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if (params["ProcessorFeatures"]) prt.appendList(body, prefix+"ProcessorFeatures", params["ProcessorFeatures"], {"appender":ProcessorFeature_Serialize,"entryPrefix":".ProcessorFeature."})
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("MaxAllocatedStorage" in params) body.append(prefix+"MaxAllocatedStorage", (params["MaxAllocatedStorage"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBInstance",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async createDBInstanceReadReplica(
    {abortSignal, ...params}: RequestConfig & CreateDBInstanceReadReplicaMessage,
  ): Promise<CreateDBInstanceReadReplicaResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"SourceDBInstanceIdentifier", (params["SourceDBInstanceIdentifier"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("StorageType" in params) body.append(prefix+"StorageType", (params["StorageType"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("MonitoringInterval" in params) body.append(prefix+"MonitoringInterval", (params["MonitoringInterval"] ?? '').toString());
    if ("MonitoringRoleArn" in params) body.append(prefix+"MonitoringRoleArn", (params["MonitoringRoleArn"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("PreSignedUrl" in params) body.append(prefix+"PreSignedUrl", (params["PreSignedUrl"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    if ("EnablePerformanceInsights" in params) body.append(prefix+"EnablePerformanceInsights", (params["EnablePerformanceInsights"] ?? '').toString());
    if ("PerformanceInsightsKMSKeyId" in params) body.append(prefix+"PerformanceInsightsKMSKeyId", (params["PerformanceInsightsKMSKeyId"] ?? '').toString());
    if ("PerformanceInsightsRetentionPeriod" in params) body.append(prefix+"PerformanceInsightsRetentionPeriod", (params["PerformanceInsightsRetentionPeriod"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) prt.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if (params["ProcessorFeatures"]) prt.appendList(body, prefix+"ProcessorFeatures", params["ProcessorFeatures"], {"appender":ProcessorFeature_Serialize,"entryPrefix":".ProcessorFeature."})
    if ("UseDefaultProcessorFeatures" in params) body.append(prefix+"UseDefaultProcessorFeatures", (params["UseDefaultProcessorFeatures"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    if ("ReplicaMode" in params) body.append(prefix+"ReplicaMode", (params["ReplicaMode"] ?? '').toString());
    if ("SourceRegion" in params) body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBInstanceReadReplica",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBInstanceReadReplicaResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async createDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & CreateDBParameterGroupMessage,
  ): Promise<CreateDBParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBParameterGroup",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBParameterGroupResult");
    return {
      DBParameterGroup: xml.first("DBParameterGroup", false, DBParameterGroup_Parse),
    };
  }

  async createDBProxy(
    {abortSignal, ...params}: RequestConfig & CreateDBProxyRequest,
  ): Promise<CreateDBProxyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBProxyName", (params["DBProxyName"] ?? '').toString());
    body.append(prefix+"EngineFamily", (params["EngineFamily"] ?? '').toString());
    if (params["Auth"]) prt.appendList(body, prefix+"Auth", params["Auth"], {"appender":UserAuthConfig_Serialize,"entryPrefix":".member."})
    body.append(prefix+"RoleArn", (params["RoleArn"] ?? '').toString());
    if (params["VpcSubnetIds"]) prt.appendList(body, prefix+"VpcSubnetIds", params["VpcSubnetIds"], {"entryPrefix":".member."})
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".member."})
    if ("RequireTLS" in params) body.append(prefix+"RequireTLS", (params["RequireTLS"] ?? '').toString());
    if ("IdleClientTimeout" in params) body.append(prefix+"IdleClientTimeout", (params["IdleClientTimeout"] ?? '').toString());
    if ("DebugLogging" in params) body.append(prefix+"DebugLogging", (params["DebugLogging"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBProxy",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBProxyResult");
    return {
      DBProxy: xml.first("DBProxy", false, DBProxy_Parse),
    };
  }

  async createDBSecurityGroup(
    {abortSignal, ...params}: RequestConfig & CreateDBSecurityGroupMessage,
  ): Promise<CreateDBSecurityGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    body.append(prefix+"DBSecurityGroupDescription", (params["DBSecurityGroupDescription"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSecurityGroup",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBSecurityGroupResult");
    return {
      DBSecurityGroup: xml.first("DBSecurityGroup", false, DBSecurityGroup_Parse),
    };
  }

  async createDBSnapshot(
    {abortSignal, ...params}: RequestConfig & CreateDBSnapshotMessage,
  ): Promise<CreateDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSnapshot",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async createDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & CreateDBSubnetGroupMessage,
  ): Promise<CreateDBSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    body.append(prefix+"DBSubnetGroupDescription", (params["DBSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) prt.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSubnetGroup",
    });
    const xml = readXmlResult(await resp.text(), "CreateDBSubnetGroupResult");
    return {
      DBSubnetGroup: xml.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    };
  }

  async createEventSubscription(
    {abortSignal, ...params}: RequestConfig & CreateEventSubscriptionMessage,
  ): Promise<CreateEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["EventCategories"]) prt.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if (params["SourceIds"]) prt.appendList(body, prefix+"SourceIds", params["SourceIds"], {"entryPrefix":".SourceId."})
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventSubscription",
    });
    const xml = readXmlResult(await resp.text(), "CreateEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async createGlobalCluster(
    {abortSignal, ...params}: RequestConfig & CreateGlobalClusterMessage = {},
  ): Promise<CreateGlobalClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("GlobalClusterIdentifier" in params) body.append(prefix+"GlobalClusterIdentifier", (params["GlobalClusterIdentifier"] ?? '').toString());
    if ("SourceDBClusterIdentifier" in params) body.append(prefix+"SourceDBClusterIdentifier", (params["SourceDBClusterIdentifier"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("DatabaseName" in params) body.append(prefix+"DatabaseName", (params["DatabaseName"] ?? '').toString());
    if ("StorageEncrypted" in params) body.append(prefix+"StorageEncrypted", (params["StorageEncrypted"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGlobalCluster",
    });
    const xml = readXmlResult(await resp.text(), "CreateGlobalClusterResult");
    return {
      GlobalCluster: xml.first("GlobalCluster", false, GlobalCluster_Parse),
    };
  }

  async createOptionGroup(
    {abortSignal, ...params}: RequestConfig & CreateOptionGroupMessage,
  ): Promise<CreateOptionGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    body.append(prefix+"EngineName", (params["EngineName"] ?? '').toString());
    body.append(prefix+"MajorEngineVersion", (params["MajorEngineVersion"] ?? '').toString());
    body.append(prefix+"OptionGroupDescription", (params["OptionGroupDescription"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOptionGroup",
    });
    const xml = readXmlResult(await resp.text(), "CreateOptionGroupResult");
    return {
      OptionGroup: xml.first("OptionGroup", false, OptionGroup_Parse),
    };
  }

  async deleteCustomAvailabilityZone(
    {abortSignal, ...params}: RequestConfig & DeleteCustomAvailabilityZoneMessage,
  ): Promise<DeleteCustomAvailabilityZoneResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CustomAvailabilityZoneId", (params["CustomAvailabilityZoneId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCustomAvailabilityZone",
    });
    const xml = readXmlResult(await resp.text(), "DeleteCustomAvailabilityZoneResult");
    return {
      CustomAvailabilityZone: xml.first("CustomAvailabilityZone", false, CustomAvailabilityZone_Parse),
    };
  }

  async deleteDBCluster(
    {abortSignal, ...params}: RequestConfig & DeleteDBClusterMessage,
  ): Promise<DeleteDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("SkipFinalSnapshot" in params) body.append(prefix+"SkipFinalSnapshot", (params["SkipFinalSnapshot"] ?? '').toString());
    if ("FinalDBSnapshotIdentifier" in params) body.append(prefix+"FinalDBSnapshotIdentifier", (params["FinalDBSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBCluster",
    });
    const xml = readXmlResult(await resp.text(), "DeleteDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async deleteDBClusterEndpoint(
    {abortSignal, ...params}: RequestConfig & DeleteDBClusterEndpointMessage,
  ): Promise<DBClusterEndpoint> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterEndpointIdentifier", (params["DBClusterEndpointIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBClusterEndpoint",
    });
    const xml = readXmlResult(await resp.text(), "DeleteDBClusterEndpointResult");
    return DBClusterEndpoint_Parse(xml);
  }

  async deleteDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDBClusterParameterGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBClusterParameterGroup",
    });
  }

  async deleteDBClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & DeleteDBClusterSnapshotMessage,
  ): Promise<DeleteDBClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBClusterSnapshot",
    });
    const xml = readXmlResult(await resp.text(), "DeleteDBClusterSnapshotResult");
    return {
      DBClusterSnapshot: xml.first("DBClusterSnapshot", false, DBClusterSnapshot_Parse),
    };
  }

  async deleteDBInstance(
    {abortSignal, ...params}: RequestConfig & DeleteDBInstanceMessage,
  ): Promise<DeleteDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("SkipFinalSnapshot" in params) body.append(prefix+"SkipFinalSnapshot", (params["SkipFinalSnapshot"] ?? '').toString());
    if ("FinalDBSnapshotIdentifier" in params) body.append(prefix+"FinalDBSnapshotIdentifier", (params["FinalDBSnapshotIdentifier"] ?? '').toString());
    if ("DeleteAutomatedBackups" in params) body.append(prefix+"DeleteAutomatedBackups", (params["DeleteAutomatedBackups"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBInstance",
    });
    const xml = readXmlResult(await resp.text(), "DeleteDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async deleteDBInstanceAutomatedBackup(
    {abortSignal, ...params}: RequestConfig & DeleteDBInstanceAutomatedBackupMessage,
  ): Promise<DeleteDBInstanceAutomatedBackupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DbiResourceId", (params["DbiResourceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBInstanceAutomatedBackup",
    });
    const xml = readXmlResult(await resp.text(), "DeleteDBInstanceAutomatedBackupResult");
    return {
      DBInstanceAutomatedBackup: xml.first("DBInstanceAutomatedBackup", false, DBInstanceAutomatedBackup_Parse),
    };
  }

  async deleteDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDBParameterGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBParameterGroup",
    });
  }

  async deleteDBProxy(
    {abortSignal, ...params}: RequestConfig & DeleteDBProxyRequest,
  ): Promise<DeleteDBProxyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBProxyName", (params["DBProxyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBProxy",
    });
    const xml = readXmlResult(await resp.text(), "DeleteDBProxyResult");
    return {
      DBProxy: xml.first("DBProxy", false, DBProxy_Parse),
    };
  }

  async deleteDBSecurityGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDBSecurityGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSecurityGroup",
    });
  }

  async deleteDBSnapshot(
    {abortSignal, ...params}: RequestConfig & DeleteDBSnapshotMessage,
  ): Promise<DeleteDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSnapshot",
    });
    const xml = readXmlResult(await resp.text(), "DeleteDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async deleteDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDBSubnetGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSubnetGroup",
    });
  }

  async deleteEventSubscription(
    {abortSignal, ...params}: RequestConfig & DeleteEventSubscriptionMessage,
  ): Promise<DeleteEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventSubscription",
    });
    const xml = readXmlResult(await resp.text(), "DeleteEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async deleteGlobalCluster(
    {abortSignal, ...params}: RequestConfig & DeleteGlobalClusterMessage,
  ): Promise<DeleteGlobalClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalClusterIdentifier", (params["GlobalClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGlobalCluster",
    });
    const xml = readXmlResult(await resp.text(), "DeleteGlobalClusterResult");
    return {
      GlobalCluster: xml.first("GlobalCluster", false, GlobalCluster_Parse),
    };
  }

  async deleteInstallationMedia(
    {abortSignal, ...params}: RequestConfig & DeleteInstallationMediaMessage,
  ): Promise<InstallationMedia> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstallationMediaId", (params["InstallationMediaId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInstallationMedia",
    });
    const xml = readXmlResult(await resp.text(), "DeleteInstallationMediaResult");
    return InstallationMedia_Parse(xml);
  }

  async deleteOptionGroup(
    {abortSignal, ...params}: RequestConfig & DeleteOptionGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteOptionGroup",
    });
  }

  async deregisterDBProxyTargets(
    {abortSignal, ...params}: RequestConfig & DeregisterDBProxyTargetsRequest,
  ): Promise<DeregisterDBProxyTargetsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBProxyName", (params["DBProxyName"] ?? '').toString());
    if ("TargetGroupName" in params) body.append(prefix+"TargetGroupName", (params["TargetGroupName"] ?? '').toString());
    if (params["DBInstanceIdentifiers"]) prt.appendList(body, prefix+"DBInstanceIdentifiers", params["DBInstanceIdentifiers"], {"entryPrefix":".member."})
    if (params["DBClusterIdentifiers"]) prt.appendList(body, prefix+"DBClusterIdentifiers", params["DBClusterIdentifiers"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterDBProxyTargets",
    });
    const xml = readXmlResult(await resp.text(), "DeregisterDBProxyTargetsResult");
    return {};
  }

  async describeAccountAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeAccountAttributesMessage = {},
  ): Promise<AccountAttributesMessage> {
    const body = new URLSearchParams;
    const prefix = '';

    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountAttributes",
    });
    const xml = readXmlResult(await resp.text(), "DescribeAccountAttributesResult");
    return {
      AccountQuotas: xml.getList("AccountQuotas", "AccountQuota").map(AccountQuota_Parse),
    };
  }

  async describeCertificates(
    {abortSignal, ...params}: RequestConfig & DescribeCertificatesMessage = {},
  ): Promise<CertificateMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CertificateIdentifier" in params) body.append(prefix+"CertificateIdentifier", (params["CertificateIdentifier"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCertificates",
    });
    const xml = readXmlResult(await resp.text(), "DescribeCertificatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Certificates: xml.getList("Certificates", "Certificate").map(Certificate_Parse),
    };
  }

  async describeCustomAvailabilityZones(
    {abortSignal, ...params}: RequestConfig & DescribeCustomAvailabilityZonesMessage = {},
  ): Promise<CustomAvailabilityZoneMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CustomAvailabilityZoneId" in params) body.append(prefix+"CustomAvailabilityZoneId", (params["CustomAvailabilityZoneId"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCustomAvailabilityZones",
    });
    const xml = readXmlResult(await resp.text(), "DescribeCustomAvailabilityZonesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CustomAvailabilityZones: xml.getList("CustomAvailabilityZones", "CustomAvailabilityZone").map(CustomAvailabilityZone_Parse),
    };
  }

  async describeDBClusterBacktracks(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterBacktracksMessage,
  ): Promise<DBClusterBacktrackMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("BacktrackIdentifier" in params) body.append(prefix+"BacktrackIdentifier", (params["BacktrackIdentifier"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterBacktracks",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBClusterBacktracksResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBClusterBacktracks: xml.getList("DBClusterBacktracks", "DBClusterBacktrack").map(DBClusterBacktrack_Parse),
    };
  }

  async describeDBClusterEndpoints(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterEndpointsMessage = {},
  ): Promise<DBClusterEndpointMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBClusterIdentifier" in params) body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("DBClusterEndpointIdentifier" in params) body.append(prefix+"DBClusterEndpointIdentifier", (params["DBClusterEndpointIdentifier"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterEndpoints",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBClusterEndpointsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBClusterEndpoints: xml.getList("DBClusterEndpoints", "DBClusterEndpointList").map(DBClusterEndpoint_Parse),
    };
  }

  async describeDBClusterParameterGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterParameterGroupsMessage = {},
  ): Promise<DBClusterParameterGroupsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBClusterParameterGroupName" in params) body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterParameterGroups",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBClusterParameterGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBClusterParameterGroups: xml.getList("DBClusterParameterGroups", "DBClusterParameterGroup").map(DBClusterParameterGroup_Parse),
    };
  }

  async describeDBClusterParameters(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterParametersMessage,
  ): Promise<DBClusterParameterGroupDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterParameters",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBClusterParametersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Parameters: xml.getList("Parameters", "Parameter").map(Parameter_Parse),
    };
  }

  async describeDBClusterSnapshotAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterSnapshotAttributesMessage,
  ): Promise<DescribeDBClusterSnapshotAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterSnapshotAttributes",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBClusterSnapshotAttributesResult");
    return {
      DBClusterSnapshotAttributesResult: xml.first("DBClusterSnapshotAttributesResult", false, DBClusterSnapshotAttributesResult_Parse),
    };
  }

  async describeDBClusterSnapshots(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterSnapshotsMessage = {},
  ): Promise<DBClusterSnapshotMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBClusterIdentifier" in params) body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("DBClusterSnapshotIdentifier" in params) body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    if ("SnapshotType" in params) body.append(prefix+"SnapshotType", (params["SnapshotType"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("IncludeShared" in params) body.append(prefix+"IncludeShared", (params["IncludeShared"] ?? '').toString());
    if ("IncludePublic" in params) body.append(prefix+"IncludePublic", (params["IncludePublic"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterSnapshots",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBClusterSnapshotsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBClusterSnapshots: xml.getList("DBClusterSnapshots", "DBClusterSnapshot").map(DBClusterSnapshot_Parse),
    };
  }

  async describeDBClusters(
    {abortSignal, ...params}: RequestConfig & DescribeDBClustersMessage = {},
  ): Promise<DBClusterMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBClusterIdentifier" in params) body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("IncludeShared" in params) body.append(prefix+"IncludeShared", (params["IncludeShared"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusters",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBClustersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBClusters: xml.getList("DBClusters", "DBCluster").map(DBCluster_Parse),
    };
  }

  async describeDBEngineVersions(
    {abortSignal, ...params}: RequestConfig & DescribeDBEngineVersionsMessage = {},
  ): Promise<DBEngineVersionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DBParameterGroupFamily" in params) body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("DefaultOnly" in params) body.append(prefix+"DefaultOnly", (params["DefaultOnly"] ?? '').toString());
    if ("ListSupportedCharacterSets" in params) body.append(prefix+"ListSupportedCharacterSets", (params["ListSupportedCharacterSets"] ?? '').toString());
    if ("ListSupportedTimezones" in params) body.append(prefix+"ListSupportedTimezones", (params["ListSupportedTimezones"] ?? '').toString());
    if ("IncludeAll" in params) body.append(prefix+"IncludeAll", (params["IncludeAll"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBEngineVersions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBEngineVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBEngineVersions: xml.getList("DBEngineVersions", "DBEngineVersion").map(DBEngineVersion_Parse),
    };
  }

  async describeDBInstanceAutomatedBackups(
    {abortSignal, ...params}: RequestConfig & DescribeDBInstanceAutomatedBackupsMessage = {},
  ): Promise<DBInstanceAutomatedBackupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DbiResourceId" in params) body.append(prefix+"DbiResourceId", (params["DbiResourceId"] ?? '').toString());
    if ("DBInstanceIdentifier" in params) body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBInstanceAutomatedBackups",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBInstanceAutomatedBackupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBInstanceAutomatedBackups: xml.getList("DBInstanceAutomatedBackups", "DBInstanceAutomatedBackup").map(DBInstanceAutomatedBackup_Parse),
    };
  }

  async describeDBInstances(
    {abortSignal, ...params}: RequestConfig & DescribeDBInstancesMessage = {},
  ): Promise<DBInstanceMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBInstanceIdentifier" in params) body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBInstances",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBInstancesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBInstances: xml.getList("DBInstances", "DBInstance").map(DBInstance_Parse),
    };
  }

  async describeDBLogFiles(
    {abortSignal, ...params}: RequestConfig & DescribeDBLogFilesMessage,
  ): Promise<DescribeDBLogFilesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("FilenameContains" in params) body.append(prefix+"FilenameContains", (params["FilenameContains"] ?? '').toString());
    if ("FileLastWritten" in params) body.append(prefix+"FileLastWritten", (params["FileLastWritten"] ?? '').toString());
    if ("FileSize" in params) body.append(prefix+"FileSize", (params["FileSize"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBLogFiles",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBLogFilesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DescribeDBLogFiles: xml.getList("DescribeDBLogFiles", "DescribeDBLogFilesDetails").map(DescribeDBLogFilesDetails_Parse),
    };
  }

  async describeDBParameterGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBParameterGroupsMessage = {},
  ): Promise<DBParameterGroupsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBParameterGroups",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBParameterGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBParameterGroups: xml.getList("DBParameterGroups", "DBParameterGroup").map(DBParameterGroup_Parse),
    };
  }

  async describeDBParameters(
    {abortSignal, ...params}: RequestConfig & DescribeDBParametersMessage,
  ): Promise<DBParameterGroupDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBParameters",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBParametersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Parameters: xml.getList("Parameters", "Parameter").map(Parameter_Parse),
    };
  }

  async describeDBProxies(
    {abortSignal, ...params}: RequestConfig & DescribeDBProxiesRequest = {},
  ): Promise<DescribeDBProxiesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBProxyName" in params) body.append(prefix+"DBProxyName", (params["DBProxyName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBProxies",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBProxiesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBProxies: xml.getList("DBProxies", "member").map(DBProxy_Parse),
    };
  }

  async describeDBProxyTargetGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBProxyTargetGroupsRequest,
  ): Promise<DescribeDBProxyTargetGroupsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBProxyName", (params["DBProxyName"] ?? '').toString());
    if ("TargetGroupName" in params) body.append(prefix+"TargetGroupName", (params["TargetGroupName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBProxyTargetGroups",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBProxyTargetGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      TargetGroups: xml.getList("TargetGroups", "member").map(DBProxyTargetGroup_Parse),
    };
  }

  async describeDBProxyTargets(
    {abortSignal, ...params}: RequestConfig & DescribeDBProxyTargetsRequest,
  ): Promise<DescribeDBProxyTargetsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBProxyName", (params["DBProxyName"] ?? '').toString());
    if ("TargetGroupName" in params) body.append(prefix+"TargetGroupName", (params["TargetGroupName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBProxyTargets",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBProxyTargetsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Targets: xml.getList("Targets", "member").map(DBProxyTarget_Parse),
    };
  }

  async describeDBSecurityGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBSecurityGroupsMessage = {},
  ): Promise<DBSecurityGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBSecurityGroupName" in params) body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSecurityGroups",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBSecurityGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSecurityGroups: xml.getList("DBSecurityGroups", "DBSecurityGroup").map(DBSecurityGroup_Parse),
    };
  }

  async describeDBSnapshotAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeDBSnapshotAttributesMessage,
  ): Promise<DescribeDBSnapshotAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSnapshotAttributes",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBSnapshotAttributesResult");
    return {
      DBSnapshotAttributesResult: xml.first("DBSnapshotAttributesResult", false, DBSnapshotAttributesResult_Parse),
    };
  }

  async describeDBSnapshots(
    {abortSignal, ...params}: RequestConfig & DescribeDBSnapshotsMessage = {},
  ): Promise<DBSnapshotMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBInstanceIdentifier" in params) body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("DBSnapshotIdentifier" in params) body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    if ("SnapshotType" in params) body.append(prefix+"SnapshotType", (params["SnapshotType"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("IncludeShared" in params) body.append(prefix+"IncludeShared", (params["IncludeShared"] ?? '').toString());
    if ("IncludePublic" in params) body.append(prefix+"IncludePublic", (params["IncludePublic"] ?? '').toString());
    if ("DbiResourceId" in params) body.append(prefix+"DbiResourceId", (params["DbiResourceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSnapshots",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBSnapshotsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSnapshots: xml.getList("DBSnapshots", "DBSnapshot").map(DBSnapshot_Parse),
    };
  }

  async describeDBSubnetGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBSubnetGroupsMessage = {},
  ): Promise<DBSubnetGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSubnetGroups",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDBSubnetGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSubnetGroups: xml.getList("DBSubnetGroups", "DBSubnetGroup").map(DBSubnetGroup_Parse),
    };
  }

  async describeEngineDefaultClusterParameters(
    {abortSignal, ...params}: RequestConfig & DescribeEngineDefaultClusterParametersMessage,
  ): Promise<DescribeEngineDefaultClusterParametersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEngineDefaultClusterParameters",
    });
    const xml = readXmlResult(await resp.text(), "DescribeEngineDefaultClusterParametersResult");
    return {
      EngineDefaults: xml.first("EngineDefaults", false, EngineDefaults_Parse),
    };
  }

  async describeEngineDefaultParameters(
    {abortSignal, ...params}: RequestConfig & DescribeEngineDefaultParametersMessage,
  ): Promise<DescribeEngineDefaultParametersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEngineDefaultParameters",
    });
    const xml = readXmlResult(await resp.text(), "DescribeEngineDefaultParametersResult");
    return {
      EngineDefaults: xml.first("EngineDefaults", false, EngineDefaults_Parse),
    };
  }

  async describeEventCategories(
    {abortSignal, ...params}: RequestConfig & DescribeEventCategoriesMessage = {},
  ): Promise<EventCategoriesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventCategories",
    });
    const xml = readXmlResult(await resp.text(), "DescribeEventCategoriesResult");
    return {
      EventCategoriesMapList: xml.getList("EventCategoriesMapList", "EventCategoriesMap").map(EventCategoriesMap_Parse),
    };
  }

  async describeEventSubscriptions(
    {abortSignal, ...params}: RequestConfig & DescribeEventSubscriptionsMessage = {},
  ): Promise<EventSubscriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SubscriptionName" in params) body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventSubscriptions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeEventSubscriptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      EventSubscriptionsList: xml.getList("EventSubscriptionsList", "EventSubscription").map(EventSubscription_Parse),
    };
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & DescribeEventsMessage = {},
  ): Promise<EventsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceIdentifier" in params) body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", prt.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", prt.encodeDate_iso8601(params["EndTime"]));
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if (params["EventCategories"]) prt.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    const xml = readXmlResult(await resp.text(), "DescribeEventsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Events: xml.getList("Events", "Event").map(Event_Parse),
    };
  }

  async describeExportTasks(
    {abortSignal, ...params}: RequestConfig & DescribeExportTasksMessage = {},
  ): Promise<ExportTasksMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ExportTaskIdentifier" in params) body.append(prefix+"ExportTaskIdentifier", (params["ExportTaskIdentifier"] ?? '').toString());
    if ("SourceArn" in params) body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExportTasks",
    });
    const xml = readXmlResult(await resp.text(), "DescribeExportTasksResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ExportTasks: xml.getList("ExportTasks", "ExportTask").map(ExportTask_Parse),
    };
  }

  async describeGlobalClusters(
    {abortSignal, ...params}: RequestConfig & DescribeGlobalClustersMessage = {},
  ): Promise<GlobalClustersMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("GlobalClusterIdentifier" in params) body.append(prefix+"GlobalClusterIdentifier", (params["GlobalClusterIdentifier"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGlobalClusters",
    });
    const xml = readXmlResult(await resp.text(), "DescribeGlobalClustersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      GlobalClusters: xml.getList("GlobalClusters", "GlobalClusterMember").map(GlobalCluster_Parse),
    };
  }

  async describeInstallationMedia(
    {abortSignal, ...params}: RequestConfig & DescribeInstallationMediaMessage = {},
  ): Promise<InstallationMediaMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("InstallationMediaId" in params) body.append(prefix+"InstallationMediaId", (params["InstallationMediaId"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstallationMedia",
    });
    const xml = readXmlResult(await resp.text(), "DescribeInstallationMediaResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      InstallationMedia: xml.getList("InstallationMedia", "InstallationMedia").map(InstallationMedia_Parse),
    };
  }

  async describeOptionGroupOptions(
    {abortSignal, ...params}: RequestConfig & DescribeOptionGroupOptionsMessage,
  ): Promise<OptionGroupOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EngineName", (params["EngineName"] ?? '').toString());
    if ("MajorEngineVersion" in params) body.append(prefix+"MajorEngineVersion", (params["MajorEngineVersion"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOptionGroupOptions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeOptionGroupOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OptionGroupOptions: xml.getList("OptionGroupOptions", "OptionGroupOption").map(OptionGroupOption_Parse),
    };
  }

  async describeOptionGroups(
    {abortSignal, ...params}: RequestConfig & DescribeOptionGroupsMessage = {},
  ): Promise<OptionGroups> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("EngineName" in params) body.append(prefix+"EngineName", (params["EngineName"] ?? '').toString());
    if ("MajorEngineVersion" in params) body.append(prefix+"MajorEngineVersion", (params["MajorEngineVersion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOptionGroups",
    });
    const xml = readXmlResult(await resp.text(), "DescribeOptionGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OptionGroupsList: xml.getList("OptionGroupsList", "OptionGroup").map(OptionGroup_Parse),
    };
  }

  async describeOrderableDBInstanceOptions(
    {abortSignal, ...params}: RequestConfig & DescribeOrderableDBInstanceOptionsMessage,
  ): Promise<OrderableDBInstanceOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("AvailabilityZoneGroup" in params) body.append(prefix+"AvailabilityZoneGroup", (params["AvailabilityZoneGroup"] ?? '').toString());
    if ("Vpc" in params) body.append(prefix+"Vpc", (params["Vpc"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOrderableDBInstanceOptions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeOrderableDBInstanceOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OrderableDBInstanceOptions: xml.getList("OrderableDBInstanceOptions", "OrderableDBInstanceOption").map(OrderableDBInstanceOption_Parse),
    };
  }

  async describePendingMaintenanceActions(
    {abortSignal, ...params}: RequestConfig & DescribePendingMaintenanceActionsMessage = {},
  ): Promise<PendingMaintenanceActionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ResourceIdentifier" in params) body.append(prefix+"ResourceIdentifier", (params["ResourceIdentifier"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePendingMaintenanceActions",
    });
    const xml = readXmlResult(await resp.text(), "DescribePendingMaintenanceActionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PendingMaintenanceActions: xml.getList("PendingMaintenanceActions", "ResourcePendingMaintenanceActions").map(ResourcePendingMaintenanceActions_Parse),
    };
  }

  async describeReservedDBInstances(
    {abortSignal, ...params}: RequestConfig & DescribeReservedDBInstancesMessage = {},
  ): Promise<ReservedDBInstanceMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedDBInstanceId" in params) body.append(prefix+"ReservedDBInstanceId", (params["ReservedDBInstanceId"] ?? '').toString());
    if ("ReservedDBInstancesOfferingId" in params) body.append(prefix+"ReservedDBInstancesOfferingId", (params["ReservedDBInstancesOfferingId"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("LeaseId" in params) body.append(prefix+"LeaseId", (params["LeaseId"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedDBInstances",
    });
    const xml = readXmlResult(await resp.text(), "DescribeReservedDBInstancesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedDBInstances: xml.getList("ReservedDBInstances", "ReservedDBInstance").map(ReservedDBInstance_Parse),
    };
  }

  async describeReservedDBInstancesOfferings(
    {abortSignal, ...params}: RequestConfig & DescribeReservedDBInstancesOfferingsMessage = {},
  ): Promise<ReservedDBInstancesOfferingMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedDBInstancesOfferingId" in params) body.append(prefix+"ReservedDBInstancesOfferingId", (params["ReservedDBInstancesOfferingId"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedDBInstancesOfferings",
    });
    const xml = readXmlResult(await resp.text(), "DescribeReservedDBInstancesOfferingsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedDBInstancesOfferings: xml.getList("ReservedDBInstancesOfferings", "ReservedDBInstancesOffering").map(ReservedDBInstancesOffering_Parse),
    };
  }

  async describeSourceRegions(
    {abortSignal, ...params}: RequestConfig & DescribeSourceRegionsMessage = {},
  ): Promise<SourceRegionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("RegionName" in params) body.append(prefix+"RegionName", (params["RegionName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSourceRegions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeSourceRegionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      SourceRegions: xml.getList("SourceRegions", "SourceRegion").map(SourceRegion_Parse),
    };
  }

  async describeValidDBInstanceModifications(
    {abortSignal, ...params}: RequestConfig & DescribeValidDBInstanceModificationsMessage,
  ): Promise<DescribeValidDBInstanceModificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeValidDBInstanceModifications",
    });
    const xml = readXmlResult(await resp.text(), "DescribeValidDBInstanceModificationsResult");
    return {
      ValidDBInstanceModificationsMessage: xml.first("ValidDBInstanceModificationsMessage", false, ValidDBInstanceModificationsMessage_Parse),
    };
  }

  async downloadDBLogFilePortion(
    {abortSignal, ...params}: RequestConfig & DownloadDBLogFilePortionMessage,
  ): Promise<DownloadDBLogFilePortionDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"LogFileName", (params["LogFileName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("NumberOfLines" in params) body.append(prefix+"NumberOfLines", (params["NumberOfLines"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DownloadDBLogFilePortion",
    });
    const xml = readXmlResult(await resp.text(), "DownloadDBLogFilePortionResult");
    return {
      ...xml.strings({
        optional: {"LogFileData":true,"Marker":true},
      }),
      AdditionalDataPending: xml.first("AdditionalDataPending", false, x => x.content === 'true'),
    };
  }

  async failoverDBCluster(
    {abortSignal, ...params}: RequestConfig & FailoverDBClusterMessage,
  ): Promise<FailoverDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("TargetDBInstanceIdentifier" in params) body.append(prefix+"TargetDBInstanceIdentifier", (params["TargetDBInstanceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "FailoverDBCluster",
    });
    const xml = readXmlResult(await resp.text(), "FailoverDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async importInstallationMedia(
    {abortSignal, ...params}: RequestConfig & ImportInstallationMediaMessage,
  ): Promise<InstallationMedia> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CustomAvailabilityZoneId", (params["CustomAvailabilityZoneId"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    body.append(prefix+"EngineInstallationMediaPath", (params["EngineInstallationMediaPath"] ?? '').toString());
    body.append(prefix+"OSInstallationMediaPath", (params["OSInstallationMediaPath"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportInstallationMedia",
    });
    const xml = readXmlResult(await resp.text(), "ImportInstallationMediaResult");
    return InstallationMedia_Parse(xml);
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceMessage,
  ): Promise<TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Filters"]) prt.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    const xml = readXmlResult(await resp.text(), "ListTagsForResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async modifyCertificates(
    {abortSignal, ...params}: RequestConfig & ModifyCertificatesMessage = {},
  ): Promise<ModifyCertificatesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CertificateIdentifier" in params) body.append(prefix+"CertificateIdentifier", (params["CertificateIdentifier"] ?? '').toString());
    if ("RemoveCustomerOverride" in params) body.append(prefix+"RemoveCustomerOverride", (params["RemoveCustomerOverride"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCertificates",
    });
    const xml = readXmlResult(await resp.text(), "ModifyCertificatesResult");
    return {
      Certificate: xml.first("Certificate", false, Certificate_Parse),
    };
  }

  async modifyCurrentDBClusterCapacity(
    {abortSignal, ...params}: RequestConfig & ModifyCurrentDBClusterCapacityMessage,
  ): Promise<DBClusterCapacityInfo> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("Capacity" in params) body.append(prefix+"Capacity", (params["Capacity"] ?? '').toString());
    if ("SecondsBeforeTimeout" in params) body.append(prefix+"SecondsBeforeTimeout", (params["SecondsBeforeTimeout"] ?? '').toString());
    if ("TimeoutAction" in params) body.append(prefix+"TimeoutAction", (params["TimeoutAction"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCurrentDBClusterCapacity",
    });
    const xml = readXmlResult(await resp.text(), "ModifyCurrentDBClusterCapacityResult");
    return {
      ...xml.strings({
        optional: {"DBClusterIdentifier":true,"TimeoutAction":true},
      }),
      PendingCapacity: xml.first("PendingCapacity", false, x => parseInt(x.content ?? '0')),
      CurrentCapacity: xml.first("CurrentCapacity", false, x => parseInt(x.content ?? '0')),
      SecondsBeforeTimeout: xml.first("SecondsBeforeTimeout", false, x => parseInt(x.content ?? '0')),
    };
  }

  async modifyDBCluster(
    {abortSignal, ...params}: RequestConfig & ModifyDBClusterMessage,
  ): Promise<ModifyDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("NewDBClusterIdentifier" in params) body.append(prefix+"NewDBClusterIdentifier", (params["NewDBClusterIdentifier"] ?? '').toString());
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("DBClusterParameterGroupName" in params) body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    if ("BacktrackWindow" in params) body.append(prefix+"BacktrackWindow", (params["BacktrackWindow"] ?? '').toString());
    if (params["CloudwatchLogsExportConfiguration"] != null) CloudwatchLogsExportConfiguration_Serialize(body, prefix+"CloudwatchLogsExportConfiguration", params["CloudwatchLogsExportConfiguration"]);
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AllowMajorVersionUpgrade" in params) body.append(prefix+"AllowMajorVersionUpgrade", (params["AllowMajorVersionUpgrade"] ?? '').toString());
    if ("DBInstanceParameterGroupName" in params) body.append(prefix+"DBInstanceParameterGroupName", (params["DBInstanceParameterGroupName"] ?? '').toString());
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    if (params["ScalingConfiguration"] != null) ScalingConfiguration_Serialize(body, prefix+"ScalingConfiguration", params["ScalingConfiguration"]);
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("EnableHttpEndpoint" in params) body.append(prefix+"EnableHttpEndpoint", (params["EnableHttpEndpoint"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("EnableGlobalWriteForwarding" in params) body.append(prefix+"EnableGlobalWriteForwarding", (params["EnableGlobalWriteForwarding"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBCluster",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async modifyDBClusterEndpoint(
    {abortSignal, ...params}: RequestConfig & ModifyDBClusterEndpointMessage,
  ): Promise<DBClusterEndpoint> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterEndpointIdentifier", (params["DBClusterEndpointIdentifier"] ?? '').toString());
    if ("EndpointType" in params) body.append(prefix+"EndpointType", (params["EndpointType"] ?? '').toString());
    if (params["StaticMembers"]) prt.appendList(body, prefix+"StaticMembers", params["StaticMembers"], {"entryPrefix":".member."})
    if (params["ExcludedMembers"]) prt.appendList(body, prefix+"ExcludedMembers", params["ExcludedMembers"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBClusterEndpoint",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBClusterEndpointResult");
    return DBClusterEndpoint_Parse(xml);
  }

  async modifyDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & ModifyDBClusterParameterGroupMessage,
  ): Promise<DBClusterParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if (params["Parameters"]) prt.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBClusterParameterGroup",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBClusterParameterGroupResult");
    return xml.strings({
      optional: {"DBClusterParameterGroupName":true},
    });
  }

  async modifyDBClusterSnapshotAttribute(
    {abortSignal, ...params}: RequestConfig & ModifyDBClusterSnapshotAttributeMessage,
  ): Promise<ModifyDBClusterSnapshotAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"AttributeName", (params["AttributeName"] ?? '').toString());
    if (params["ValuesToAdd"]) prt.appendList(body, prefix+"ValuesToAdd", params["ValuesToAdd"], {"entryPrefix":".AttributeValue."})
    if (params["ValuesToRemove"]) prt.appendList(body, prefix+"ValuesToRemove", params["ValuesToRemove"], {"entryPrefix":".AttributeValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBClusterSnapshotAttribute",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBClusterSnapshotAttributeResult");
    return {
      DBClusterSnapshotAttributesResult: xml.first("DBClusterSnapshotAttributesResult", false, DBClusterSnapshotAttributesResult_Parse),
    };
  }

  async modifyDBInstance(
    {abortSignal, ...params}: RequestConfig & ModifyDBInstanceMessage,
  ): Promise<ModifyDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("AllocatedStorage" in params) body.append(prefix+"AllocatedStorage", (params["AllocatedStorage"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if (params["DBSecurityGroups"]) prt.appendList(body, prefix+"DBSecurityGroups", params["DBSecurityGroups"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AllowMajorVersionUpgrade" in params) body.append(prefix+"AllowMajorVersionUpgrade", (params["AllowMajorVersionUpgrade"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("NewDBInstanceIdentifier" in params) body.append(prefix+"NewDBInstanceIdentifier", (params["NewDBInstanceIdentifier"] ?? '').toString());
    if ("StorageType" in params) body.append(prefix+"StorageType", (params["StorageType"] ?? '').toString());
    if ("TdeCredentialArn" in params) body.append(prefix+"TdeCredentialArn", (params["TdeCredentialArn"] ?? '').toString());
    if ("TdeCredentialPassword" in params) body.append(prefix+"TdeCredentialPassword", (params["TdeCredentialPassword"] ?? '').toString());
    if ("CACertificateIdentifier" in params) body.append(prefix+"CACertificateIdentifier", (params["CACertificateIdentifier"] ?? '').toString());
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("MonitoringInterval" in params) body.append(prefix+"MonitoringInterval", (params["MonitoringInterval"] ?? '').toString());
    if ("DBPortNumber" in params) body.append(prefix+"DBPortNumber", (params["DBPortNumber"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("MonitoringRoleArn" in params) body.append(prefix+"MonitoringRoleArn", (params["MonitoringRoleArn"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    if ("PromotionTier" in params) body.append(prefix+"PromotionTier", (params["PromotionTier"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    if ("EnablePerformanceInsights" in params) body.append(prefix+"EnablePerformanceInsights", (params["EnablePerformanceInsights"] ?? '').toString());
    if ("PerformanceInsightsKMSKeyId" in params) body.append(prefix+"PerformanceInsightsKMSKeyId", (params["PerformanceInsightsKMSKeyId"] ?? '').toString());
    if ("PerformanceInsightsRetentionPeriod" in params) body.append(prefix+"PerformanceInsightsRetentionPeriod", (params["PerformanceInsightsRetentionPeriod"] ?? '').toString());
    if (params["CloudwatchLogsExportConfiguration"] != null) CloudwatchLogsExportConfiguration_Serialize(body, prefix+"CloudwatchLogsExportConfiguration", params["CloudwatchLogsExportConfiguration"]);
    if (params["ProcessorFeatures"]) prt.appendList(body, prefix+"ProcessorFeatures", params["ProcessorFeatures"], {"appender":ProcessorFeature_Serialize,"entryPrefix":".ProcessorFeature."})
    if ("UseDefaultProcessorFeatures" in params) body.append(prefix+"UseDefaultProcessorFeatures", (params["UseDefaultProcessorFeatures"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("MaxAllocatedStorage" in params) body.append(prefix+"MaxAllocatedStorage", (params["MaxAllocatedStorage"] ?? '').toString());
    if ("CertificateRotationRestart" in params) body.append(prefix+"CertificateRotationRestart", (params["CertificateRotationRestart"] ?? '').toString());
    if ("ReplicaMode" in params) body.append(prefix+"ReplicaMode", (params["ReplicaMode"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBInstance",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async modifyDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & ModifyDBParameterGroupMessage,
  ): Promise<DBParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if (params["Parameters"]) prt.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBParameterGroup",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBParameterGroupResult");
    return xml.strings({
      optional: {"DBParameterGroupName":true},
    });
  }

  async modifyDBProxy(
    {abortSignal, ...params}: RequestConfig & ModifyDBProxyRequest,
  ): Promise<ModifyDBProxyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBProxyName", (params["DBProxyName"] ?? '').toString());
    if ("NewDBProxyName" in params) body.append(prefix+"NewDBProxyName", (params["NewDBProxyName"] ?? '').toString());
    if (params["Auth"]) prt.appendList(body, prefix+"Auth", params["Auth"], {"appender":UserAuthConfig_Serialize,"entryPrefix":".member."})
    if ("RequireTLS" in params) body.append(prefix+"RequireTLS", (params["RequireTLS"] ?? '').toString());
    if ("IdleClientTimeout" in params) body.append(prefix+"IdleClientTimeout", (params["IdleClientTimeout"] ?? '').toString());
    if ("DebugLogging" in params) body.append(prefix+"DebugLogging", (params["DebugLogging"] ?? '').toString());
    if ("RoleArn" in params) body.append(prefix+"RoleArn", (params["RoleArn"] ?? '').toString());
    if (params["SecurityGroups"]) prt.appendList(body, prefix+"SecurityGroups", params["SecurityGroups"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBProxy",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBProxyResult");
    return {
      DBProxy: xml.first("DBProxy", false, DBProxy_Parse),
    };
  }

  async modifyDBProxyTargetGroup(
    {abortSignal, ...params}: RequestConfig & ModifyDBProxyTargetGroupRequest,
  ): Promise<ModifyDBProxyTargetGroupResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupName", (params["TargetGroupName"] ?? '').toString());
    body.append(prefix+"DBProxyName", (params["DBProxyName"] ?? '').toString());
    if (params["ConnectionPoolConfig"] != null) ConnectionPoolConfiguration_Serialize(body, prefix+"ConnectionPoolConfig", params["ConnectionPoolConfig"]);
    if ("NewName" in params) body.append(prefix+"NewName", (params["NewName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBProxyTargetGroup",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBProxyTargetGroupResult");
    return {
      DBProxyTargetGroup: xml.first("DBProxyTargetGroup", false, DBProxyTargetGroup_Parse),
    };
  }

  async modifyDBSnapshot(
    {abortSignal, ...params}: RequestConfig & ModifyDBSnapshotMessage,
  ): Promise<ModifyDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBSnapshot",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async modifyDBSnapshotAttribute(
    {abortSignal, ...params}: RequestConfig & ModifyDBSnapshotAttributeMessage,
  ): Promise<ModifyDBSnapshotAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"AttributeName", (params["AttributeName"] ?? '').toString());
    if (params["ValuesToAdd"]) prt.appendList(body, prefix+"ValuesToAdd", params["ValuesToAdd"], {"entryPrefix":".AttributeValue."})
    if (params["ValuesToRemove"]) prt.appendList(body, prefix+"ValuesToRemove", params["ValuesToRemove"], {"entryPrefix":".AttributeValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBSnapshotAttribute",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBSnapshotAttributeResult");
    return {
      DBSnapshotAttributesResult: xml.first("DBSnapshotAttributesResult", false, DBSnapshotAttributesResult_Parse),
    };
  }

  async modifyDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & ModifyDBSubnetGroupMessage,
  ): Promise<ModifyDBSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("DBSubnetGroupDescription" in params) body.append(prefix+"DBSubnetGroupDescription", (params["DBSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) prt.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBSubnetGroup",
    });
    const xml = readXmlResult(await resp.text(), "ModifyDBSubnetGroupResult");
    return {
      DBSubnetGroup: xml.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    };
  }

  async modifyEventSubscription(
    {abortSignal, ...params}: RequestConfig & ModifyEventSubscriptionMessage,
  ): Promise<ModifyEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if ("SnsTopicArn" in params) body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["EventCategories"]) prt.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEventSubscription",
    });
    const xml = readXmlResult(await resp.text(), "ModifyEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async modifyGlobalCluster(
    {abortSignal, ...params}: RequestConfig & ModifyGlobalClusterMessage = {},
  ): Promise<ModifyGlobalClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("GlobalClusterIdentifier" in params) body.append(prefix+"GlobalClusterIdentifier", (params["GlobalClusterIdentifier"] ?? '').toString());
    if ("NewGlobalClusterIdentifier" in params) body.append(prefix+"NewGlobalClusterIdentifier", (params["NewGlobalClusterIdentifier"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyGlobalCluster",
    });
    const xml = readXmlResult(await resp.text(), "ModifyGlobalClusterResult");
    return {
      GlobalCluster: xml.first("GlobalCluster", false, GlobalCluster_Parse),
    };
  }

  async modifyOptionGroup(
    {abortSignal, ...params}: RequestConfig & ModifyOptionGroupMessage,
  ): Promise<ModifyOptionGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["OptionsToInclude"]) prt.appendList(body, prefix+"OptionsToInclude", params["OptionsToInclude"], {"appender":OptionConfiguration_Serialize,"entryPrefix":".OptionConfiguration."})
    if (params["OptionsToRemove"]) prt.appendList(body, prefix+"OptionsToRemove", params["OptionsToRemove"], {"entryPrefix":".member."})
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyOptionGroup",
    });
    const xml = readXmlResult(await resp.text(), "ModifyOptionGroupResult");
    return {
      OptionGroup: xml.first("OptionGroup", false, OptionGroup_Parse),
    };
  }

  async promoteReadReplica(
    {abortSignal, ...params}: RequestConfig & PromoteReadReplicaMessage,
  ): Promise<PromoteReadReplicaResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PromoteReadReplica",
    });
    const xml = readXmlResult(await resp.text(), "PromoteReadReplicaResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async promoteReadReplicaDBCluster(
    {abortSignal, ...params}: RequestConfig & PromoteReadReplicaDBClusterMessage,
  ): Promise<PromoteReadReplicaDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PromoteReadReplicaDBCluster",
    });
    const xml = readXmlResult(await resp.text(), "PromoteReadReplicaDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async purchaseReservedDBInstancesOffering(
    {abortSignal, ...params}: RequestConfig & PurchaseReservedDBInstancesOfferingMessage,
  ): Promise<PurchaseReservedDBInstancesOfferingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedDBInstancesOfferingId", (params["ReservedDBInstancesOfferingId"] ?? '').toString());
    if ("ReservedDBInstanceId" in params) body.append(prefix+"ReservedDBInstanceId", (params["ReservedDBInstanceId"] ?? '').toString());
    if ("DBInstanceCount" in params) body.append(prefix+"DBInstanceCount", (params["DBInstanceCount"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedDBInstancesOffering",
    });
    const xml = readXmlResult(await resp.text(), "PurchaseReservedDBInstancesOfferingResult");
    return {
      ReservedDBInstance: xml.first("ReservedDBInstance", false, ReservedDBInstance_Parse),
    };
  }

  async rebootDBInstance(
    {abortSignal, ...params}: RequestConfig & RebootDBInstanceMessage,
  ): Promise<RebootDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("ForceFailover" in params) body.append(prefix+"ForceFailover", (params["ForceFailover"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootDBInstance",
    });
    const xml = readXmlResult(await resp.text(), "RebootDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async registerDBProxyTargets(
    {abortSignal, ...params}: RequestConfig & RegisterDBProxyTargetsRequest,
  ): Promise<RegisterDBProxyTargetsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBProxyName", (params["DBProxyName"] ?? '').toString());
    if ("TargetGroupName" in params) body.append(prefix+"TargetGroupName", (params["TargetGroupName"] ?? '').toString());
    if (params["DBInstanceIdentifiers"]) prt.appendList(body, prefix+"DBInstanceIdentifiers", params["DBInstanceIdentifiers"], {"entryPrefix":".member."})
    if (params["DBClusterIdentifiers"]) prt.appendList(body, prefix+"DBClusterIdentifiers", params["DBClusterIdentifiers"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterDBProxyTargets",
    });
    const xml = readXmlResult(await resp.text(), "RegisterDBProxyTargetsResult");
    return {
      DBProxyTargets: xml.getList("DBProxyTargets", "member").map(DBProxyTarget_Parse),
    };
  }

  async removeFromGlobalCluster(
    {abortSignal, ...params}: RequestConfig & RemoveFromGlobalClusterMessage = {},
  ): Promise<RemoveFromGlobalClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("GlobalClusterIdentifier" in params) body.append(prefix+"GlobalClusterIdentifier", (params["GlobalClusterIdentifier"] ?? '').toString());
    if ("DbClusterIdentifier" in params) body.append(prefix+"DbClusterIdentifier", (params["DbClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveFromGlobalCluster",
    });
    const xml = readXmlResult(await resp.text(), "RemoveFromGlobalClusterResult");
    return {
      GlobalCluster: xml.first("GlobalCluster", false, GlobalCluster_Parse),
    };
  }

  async removeRoleFromDBCluster(
    {abortSignal, ...params}: RequestConfig & RemoveRoleFromDBClusterMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    body.append(prefix+"RoleArn", (params["RoleArn"] ?? '').toString());
    if ("FeatureName" in params) body.append(prefix+"FeatureName", (params["FeatureName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveRoleFromDBCluster",
    });
  }

  async removeRoleFromDBInstance(
    {abortSignal, ...params}: RequestConfig & RemoveRoleFromDBInstanceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"RoleArn", (params["RoleArn"] ?? '').toString());
    body.append(prefix+"FeatureName", (params["FeatureName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveRoleFromDBInstance",
    });
  }

  async removeSourceIdentifierFromSubscription(
    {abortSignal, ...params}: RequestConfig & RemoveSourceIdentifierFromSubscriptionMessage,
  ): Promise<RemoveSourceIdentifierFromSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveSourceIdentifierFromSubscription",
    });
    const xml = readXmlResult(await resp.text(), "RemoveSourceIdentifierFromSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & RemoveTagsFromResourceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["TagKeys"]) prt.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
  }

  async resetDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & ResetDBClusterParameterGroupMessage,
  ): Promise<DBClusterParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if ("ResetAllParameters" in params) body.append(prefix+"ResetAllParameters", (params["ResetAllParameters"] ?? '').toString());
    if (params["Parameters"]) prt.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetDBClusterParameterGroup",
    });
    const xml = readXmlResult(await resp.text(), "ResetDBClusterParameterGroupResult");
    return xml.strings({
      optional: {"DBClusterParameterGroupName":true},
    });
  }

  async resetDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & ResetDBParameterGroupMessage,
  ): Promise<DBParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("ResetAllParameters" in params) body.append(prefix+"ResetAllParameters", (params["ResetAllParameters"] ?? '').toString());
    if (params["Parameters"]) prt.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetDBParameterGroup",
    });
    const xml = readXmlResult(await resp.text(), "ResetDBParameterGroupResult");
    return xml.strings({
      optional: {"DBParameterGroupName":true},
    });
  }

  async restoreDBClusterFromS3(
    {abortSignal, ...params}: RequestConfig & RestoreDBClusterFromS3Message,
  ): Promise<RestoreDBClusterFromS3Result> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AvailabilityZones"]) prt.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".AvailabilityZone."})
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("CharacterSetName" in params) body.append(prefix+"CharacterSetName", (params["CharacterSetName"] ?? '').toString());
    if ("DatabaseName" in params) body.append(prefix+"DatabaseName", (params["DatabaseName"] ?? '').toString());
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("DBClusterParameterGroupName" in params) body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    body.append(prefix+"MasterUsername", (params["MasterUsername"] ?? '').toString());
    body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("StorageEncrypted" in params) body.append(prefix+"StorageEncrypted", (params["StorageEncrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    body.append(prefix+"SourceEngine", (params["SourceEngine"] ?? '').toString());
    body.append(prefix+"SourceEngineVersion", (params["SourceEngineVersion"] ?? '').toString());
    body.append(prefix+"S3BucketName", (params["S3BucketName"] ?? '').toString());
    if ("S3Prefix" in params) body.append(prefix+"S3Prefix", (params["S3Prefix"] ?? '').toString());
    body.append(prefix+"S3IngestionRoleArn", (params["S3IngestionRoleArn"] ?? '').toString());
    if ("BacktrackWindow" in params) body.append(prefix+"BacktrackWindow", (params["BacktrackWindow"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) prt.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBClusterFromS3",
    });
    const xml = readXmlResult(await resp.text(), "RestoreDBClusterFromS3Result");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async restoreDBClusterFromSnapshot(
    {abortSignal, ...params}: RequestConfig & RestoreDBClusterFromSnapshotMessage,
  ): Promise<RestoreDBClusterFromSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AvailabilityZones"]) prt.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".AvailabilityZone."})
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("DatabaseName" in params) body.append(prefix+"DatabaseName", (params["DatabaseName"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    if ("BacktrackWindow" in params) body.append(prefix+"BacktrackWindow", (params["BacktrackWindow"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) prt.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if ("EngineMode" in params) body.append(prefix+"EngineMode", (params["EngineMode"] ?? '').toString());
    if (params["ScalingConfiguration"] != null) ScalingConfiguration_Serialize(body, prefix+"ScalingConfiguration", params["ScalingConfiguration"]);
    if ("DBClusterParameterGroupName" in params) body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBClusterFromSnapshot",
    });
    const xml = readXmlResult(await resp.text(), "RestoreDBClusterFromSnapshotResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async restoreDBClusterToPointInTime(
    {abortSignal, ...params}: RequestConfig & RestoreDBClusterToPointInTimeMessage,
  ): Promise<RestoreDBClusterToPointInTimeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("RestoreType" in params) body.append(prefix+"RestoreType", (params["RestoreType"] ?? '').toString());
    body.append(prefix+"SourceDBClusterIdentifier", (params["SourceDBClusterIdentifier"] ?? '').toString());
    if ("RestoreToTime" in params) body.append(prefix+"RestoreToTime", prt.encodeDate_iso8601(params["RestoreToTime"]));
    if ("UseLatestRestorableTime" in params) body.append(prefix+"UseLatestRestorableTime", (params["UseLatestRestorableTime"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    if ("BacktrackWindow" in params) body.append(prefix+"BacktrackWindow", (params["BacktrackWindow"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) prt.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if ("DBClusterParameterGroupName" in params) body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBClusterToPointInTime",
    });
    const xml = readXmlResult(await resp.text(), "RestoreDBClusterToPointInTimeResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async restoreDBInstanceFromDBSnapshot(
    {abortSignal, ...params}: RequestConfig & RestoreDBInstanceFromDBSnapshotMessage,
  ): Promise<RestoreDBInstanceFromDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("StorageType" in params) body.append(prefix+"StorageType", (params["StorageType"] ?? '').toString());
    if ("TdeCredentialArn" in params) body.append(prefix+"TdeCredentialArn", (params["TdeCredentialArn"] ?? '').toString());
    if ("TdeCredentialPassword" in params) body.append(prefix+"TdeCredentialPassword", (params["TdeCredentialPassword"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) prt.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if (params["ProcessorFeatures"]) prt.appendList(body, prefix+"ProcessorFeatures", params["ProcessorFeatures"], {"appender":ProcessorFeature_Serialize,"entryPrefix":".ProcessorFeature."})
    if ("UseDefaultProcessorFeatures" in params) body.append(prefix+"UseDefaultProcessorFeatures", (params["UseDefaultProcessorFeatures"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBInstanceFromDBSnapshot",
    });
    const xml = readXmlResult(await resp.text(), "RestoreDBInstanceFromDBSnapshotResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async restoreDBInstanceFromS3(
    {abortSignal, ...params}: RequestConfig & RestoreDBInstanceFromS3Message,
  ): Promise<RestoreDBInstanceFromS3Result> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("AllocatedStorage" in params) body.append(prefix+"AllocatedStorage", (params["AllocatedStorage"] ?? '').toString());
    body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("MasterUsername" in params) body.append(prefix+"MasterUsername", (params["MasterUsername"] ?? '').toString());
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if (params["DBSecurityGroups"]) prt.appendList(body, prefix+"DBSecurityGroups", params["DBSecurityGroups"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("StorageType" in params) body.append(prefix+"StorageType", (params["StorageType"] ?? '').toString());
    if ("StorageEncrypted" in params) body.append(prefix+"StorageEncrypted", (params["StorageEncrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if ("MonitoringInterval" in params) body.append(prefix+"MonitoringInterval", (params["MonitoringInterval"] ?? '').toString());
    if ("MonitoringRoleArn" in params) body.append(prefix+"MonitoringRoleArn", (params["MonitoringRoleArn"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    body.append(prefix+"SourceEngine", (params["SourceEngine"] ?? '').toString());
    body.append(prefix+"SourceEngineVersion", (params["SourceEngineVersion"] ?? '').toString());
    body.append(prefix+"S3BucketName", (params["S3BucketName"] ?? '').toString());
    if ("S3Prefix" in params) body.append(prefix+"S3Prefix", (params["S3Prefix"] ?? '').toString());
    body.append(prefix+"S3IngestionRoleArn", (params["S3IngestionRoleArn"] ?? '').toString());
    if ("EnablePerformanceInsights" in params) body.append(prefix+"EnablePerformanceInsights", (params["EnablePerformanceInsights"] ?? '').toString());
    if ("PerformanceInsightsKMSKeyId" in params) body.append(prefix+"PerformanceInsightsKMSKeyId", (params["PerformanceInsightsKMSKeyId"] ?? '').toString());
    if ("PerformanceInsightsRetentionPeriod" in params) body.append(prefix+"PerformanceInsightsRetentionPeriod", (params["PerformanceInsightsRetentionPeriod"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) prt.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if (params["ProcessorFeatures"]) prt.appendList(body, prefix+"ProcessorFeatures", params["ProcessorFeatures"], {"appender":ProcessorFeature_Serialize,"entryPrefix":".ProcessorFeature."})
    if ("UseDefaultProcessorFeatures" in params) body.append(prefix+"UseDefaultProcessorFeatures", (params["UseDefaultProcessorFeatures"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBInstanceFromS3",
    });
    const xml = readXmlResult(await resp.text(), "RestoreDBInstanceFromS3Result");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async restoreDBInstanceToPointInTime(
    {abortSignal, ...params}: RequestConfig & RestoreDBInstanceToPointInTimeMessage,
  ): Promise<RestoreDBInstanceToPointInTimeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceDBInstanceIdentifier" in params) body.append(prefix+"SourceDBInstanceIdentifier", (params["SourceDBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBInstanceIdentifier", (params["TargetDBInstanceIdentifier"] ?? '').toString());
    if ("RestoreTime" in params) body.append(prefix+"RestoreTime", prt.encodeDate_iso8601(params["RestoreTime"]));
    if ("UseLatestRestorableTime" in params) body.append(prefix+"UseLatestRestorableTime", (params["UseLatestRestorableTime"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("CopyTagsToSnapshot" in params) body.append(prefix+"CopyTagsToSnapshot", (params["CopyTagsToSnapshot"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("StorageType" in params) body.append(prefix+"StorageType", (params["StorageType"] ?? '').toString());
    if ("TdeCredentialArn" in params) body.append(prefix+"TdeCredentialArn", (params["TdeCredentialArn"] ?? '').toString());
    if ("TdeCredentialPassword" in params) body.append(prefix+"TdeCredentialPassword", (params["TdeCredentialPassword"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) prt.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("DomainIAMRoleName" in params) body.append(prefix+"DomainIAMRoleName", (params["DomainIAMRoleName"] ?? '').toString());
    if ("EnableIAMDatabaseAuthentication" in params) body.append(prefix+"EnableIAMDatabaseAuthentication", (params["EnableIAMDatabaseAuthentication"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) prt.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if (params["ProcessorFeatures"]) prt.appendList(body, prefix+"ProcessorFeatures", params["ProcessorFeatures"], {"appender":ProcessorFeature_Serialize,"entryPrefix":".ProcessorFeature."})
    if ("UseDefaultProcessorFeatures" in params) body.append(prefix+"UseDefaultProcessorFeatures", (params["UseDefaultProcessorFeatures"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    if ("SourceDbiResourceId" in params) body.append(prefix+"SourceDbiResourceId", (params["SourceDbiResourceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBInstanceToPointInTime",
    });
    const xml = readXmlResult(await resp.text(), "RestoreDBInstanceToPointInTimeResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async revokeDBSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & RevokeDBSecurityGroupIngressMessage,
  ): Promise<RevokeDBSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupId" in params) body.append(prefix+"EC2SecurityGroupId", (params["EC2SecurityGroupId"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeDBSecurityGroupIngress",
    });
    const xml = readXmlResult(await resp.text(), "RevokeDBSecurityGroupIngressResult");
    return {
      DBSecurityGroup: xml.first("DBSecurityGroup", false, DBSecurityGroup_Parse),
    };
  }

  async startActivityStream(
    {abortSignal, ...params}: RequestConfig & StartActivityStreamRequest,
  ): Promise<StartActivityStreamResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceArn", (params["ResourceArn"] ?? '').toString());
    body.append(prefix+"Mode", (params["Mode"] ?? '').toString());
    body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartActivityStream",
    });
    const xml = readXmlResult(await resp.text(), "StartActivityStreamResult");
    return {
      ...xml.strings({
        optional: {"KmsKeyId":true,"KinesisStreamName":true},
      }),
      Status: xml.first("Status", false, x => (x.content ?? '') as ActivityStreamStatus),
      Mode: xml.first("Mode", false, x => (x.content ?? '') as ActivityStreamMode),
      ApplyImmediately: xml.first("ApplyImmediately", false, x => x.content === 'true'),
    };
  }

  async startDBCluster(
    {abortSignal, ...params}: RequestConfig & StartDBClusterMessage,
  ): Promise<StartDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDBCluster",
    });
    const xml = readXmlResult(await resp.text(), "StartDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async startDBInstance(
    {abortSignal, ...params}: RequestConfig & StartDBInstanceMessage,
  ): Promise<StartDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDBInstance",
    });
    const xml = readXmlResult(await resp.text(), "StartDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async startExportTask(
    {abortSignal, ...params}: RequestConfig & StartExportTaskMessage,
  ): Promise<ExportTask> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ExportTaskIdentifier", (params["ExportTaskIdentifier"] ?? '').toString());
    body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    body.append(prefix+"S3BucketName", (params["S3BucketName"] ?? '').toString());
    body.append(prefix+"IamRoleArn", (params["IamRoleArn"] ?? '').toString());
    body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("S3Prefix" in params) body.append(prefix+"S3Prefix", (params["S3Prefix"] ?? '').toString());
    if (params["ExportOnly"]) prt.appendList(body, prefix+"ExportOnly", params["ExportOnly"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartExportTask",
    });
    const xml = readXmlResult(await resp.text(), "StartExportTaskResult");
    return ExportTask_Parse(xml);
  }

  async stopActivityStream(
    {abortSignal, ...params}: RequestConfig & StopActivityStreamRequest,
  ): Promise<StopActivityStreamResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceArn", (params["ResourceArn"] ?? '').toString());
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopActivityStream",
    });
    const xml = readXmlResult(await resp.text(), "StopActivityStreamResult");
    return {
      ...xml.strings({
        optional: {"KmsKeyId":true,"KinesisStreamName":true},
      }),
      Status: xml.first("Status", false, x => (x.content ?? '') as ActivityStreamStatus),
    };
  }

  async stopDBCluster(
    {abortSignal, ...params}: RequestConfig & StopDBClusterMessage,
  ): Promise<StopDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopDBCluster",
    });
    const xml = readXmlResult(await resp.text(), "StopDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async stopDBInstance(
    {abortSignal, ...params}: RequestConfig & StopDBInstanceMessage,
  ): Promise<StopDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("DBSnapshotIdentifier" in params) body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopDBInstance",
    });
    const xml = readXmlResult(await resp.text(), "StopDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBInstanceAvailable(
    params: RequestConfig & DescribeDBInstancesMessage,
  ): Promise<DBInstanceMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBInstanceAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDBInstances(params);
      const field = resp["DBInstances"].flatMap(x => x["DBInstanceStatus"]);
      if (field.every(x => x === "available")) return resp;
      if (field.some(x => x === "deleted")) throw new Error(errMessage);
      if (field.some(x => x === "deleting")) throw new Error(errMessage);
      if (field.some(x => x === "failed")) throw new Error(errMessage);
      if (field.some(x => x === "incompatible-restore")) throw new Error(errMessage);
      if (field.some(x => x === "incompatible-parameters")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBInstanceDeleted(
    params: RequestConfig & DescribeDBInstancesMessage,
  ): Promise<Error | DBInstanceMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBInstanceDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeDBInstances(params);
        if (resp["DBInstances"].length == 0) return resp;
        if (resp["DBInstances"].flatMap(x => x["DBInstanceStatus"]).some(x => x === "creating")) throw new Error(errMessage);
        if (resp["DBInstances"].flatMap(x => x["DBInstanceStatus"]).some(x => x === "modifying")) throw new Error(errMessage);
        if (resp["DBInstances"].flatMap(x => x["DBInstanceStatus"]).some(x => x === "rebooting")) throw new Error(errMessage);
        if (resp["DBInstances"].flatMap(x => x["DBInstanceStatus"]).some(x => x === "resetting-master-credentials")) throw new Error(errMessage);
      } catch (err) {
        if (["DBInstanceNotFound"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBSnapshotAvailable(
    params: RequestConfig & DescribeDBSnapshotsMessage,
  ): Promise<DBSnapshotMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBSnapshotAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDBSnapshots(params);
      const field = resp["DBSnapshots"].flatMap(x => x["Status"]);
      if (field.every(x => x === "available")) return resp;
      if (field.some(x => x === "deleted")) throw new Error(errMessage);
      if (field.some(x => x === "deleting")) throw new Error(errMessage);
      if (field.some(x => x === "failed")) throw new Error(errMessage);
      if (field.some(x => x === "incompatible-restore")) throw new Error(errMessage);
      if (field.some(x => x === "incompatible-parameters")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBSnapshotDeleted(
    params: RequestConfig & DescribeDBSnapshotsMessage,
  ): Promise<Error | DBSnapshotMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBSnapshotDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeDBSnapshots(params);
        if (resp["DBSnapshots"].length == 0) return resp;
        if (resp["DBSnapshots"].flatMap(x => x["Status"]).some(x => x === "creating")) throw new Error(errMessage);
        if (resp["DBSnapshots"].flatMap(x => x["Status"]).some(x => x === "modifying")) throw new Error(errMessage);
        if (resp["DBSnapshots"].flatMap(x => x["Status"]).some(x => x === "rebooting")) throw new Error(errMessage);
        if (resp["DBSnapshots"].flatMap(x => x["Status"]).some(x => x === "resetting-master-credentials")) throw new Error(errMessage);
      } catch (err) {
        if (["DBSnapshotNotFound"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBClusterSnapshotAvailable(
    params: RequestConfig & DescribeDBClusterSnapshotsMessage,
  ): Promise<DBClusterSnapshotMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBClusterSnapshotAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDBClusterSnapshots(params);
      const field = resp["DBClusterSnapshots"].flatMap(x => x["Status"]);
      if (field.every(x => x === "available")) return resp;
      if (field.some(x => x === "deleted")) throw new Error(errMessage);
      if (field.some(x => x === "deleting")) throw new Error(errMessage);
      if (field.some(x => x === "failed")) throw new Error(errMessage);
      if (field.some(x => x === "incompatible-restore")) throw new Error(errMessage);
      if (field.some(x => x === "incompatible-parameters")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBClusterSnapshotDeleted(
    params: RequestConfig & DescribeDBClusterSnapshotsMessage,
  ): Promise<Error | DBClusterSnapshotMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBClusterSnapshotDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeDBClusterSnapshots(params);
        if (resp["DBClusterSnapshots"].length == 0) return resp;
        if (resp["DBClusterSnapshots"].flatMap(x => x["Status"]).some(x => x === "creating")) throw new Error(errMessage);
        if (resp["DBClusterSnapshots"].flatMap(x => x["Status"]).some(x => x === "modifying")) throw new Error(errMessage);
        if (resp["DBClusterSnapshots"].flatMap(x => x["Status"]).some(x => x === "rebooting")) throw new Error(errMessage);
        if (resp["DBClusterSnapshots"].flatMap(x => x["Status"]).some(x => x === "resetting-master-credentials")) throw new Error(errMessage);
      } catch (err) {
        if (["DBClusterSnapshotNotFoundFault"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddRoleToDBClusterMessage {
  DBClusterIdentifier: string;
  RoleArn: string;
  FeatureName?: string | null;
}

// refs: 1 - tags: named, input
export interface AddRoleToDBInstanceMessage {
  DBInstanceIdentifier: string;
  RoleArn: string;
  FeatureName: string;
}

// refs: 1 - tags: named, input
export interface AddSourceIdentifierToSubscriptionMessage {
  SubscriptionName: string;
  SourceIdentifier: string;
}

// refs: 1 - tags: named, input
export interface AddTagsToResourceMessage {
  ResourceName: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface ApplyPendingMaintenanceActionMessage {
  ResourceIdentifier: string;
  ApplyAction: string;
  OptInType: string;
}

// refs: 1 - tags: named, input
export interface AuthorizeDBSecurityGroupIngressMessage {
  DBSecurityGroupName: string;
  CIDRIP?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupId?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
}

// refs: 1 - tags: named, input
export interface BacktrackDBClusterMessage {
  DBClusterIdentifier: string;
  BacktrackTo: Date | number;
  Force?: boolean | null;
  UseEarliestTimeOnPointInTimeUnavailable?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CancelExportTaskMessage {
  ExportTaskIdentifier: string;
}

// refs: 1 - tags: named, input
export interface CopyDBClusterParameterGroupMessage {
  SourceDBClusterParameterGroupIdentifier: string;
  TargetDBClusterParameterGroupIdentifier: string;
  TargetDBClusterParameterGroupDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CopyDBClusterSnapshotMessage {
  SourceDBClusterSnapshotIdentifier: string;
  TargetDBClusterSnapshotIdentifier: string;
  KmsKeyId?: string | null;
  PreSignedUrl?: string | null;
  CopyTags?: boolean | null;
  Tags?: Tag[] | null;
  SourceRegion?: string | null;
}

// refs: 1 - tags: named, input
export interface CopyDBParameterGroupMessage {
  SourceDBParameterGroupIdentifier: string;
  TargetDBParameterGroupIdentifier: string;
  TargetDBParameterGroupDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CopyDBSnapshotMessage {
  SourceDBSnapshotIdentifier: string;
  TargetDBSnapshotIdentifier: string;
  KmsKeyId?: string | null;
  Tags?: Tag[] | null;
  CopyTags?: boolean | null;
  PreSignedUrl?: string | null;
  OptionGroupName?: string | null;
  SourceRegion?: string | null;
}

// refs: 1 - tags: named, input
export interface CopyOptionGroupMessage {
  SourceOptionGroupIdentifier: string;
  TargetOptionGroupIdentifier: string;
  TargetOptionGroupDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateCustomAvailabilityZoneMessage {
  CustomAvailabilityZoneName: string;
  ExistingVpnId?: string | null;
  NewVpnTunnelName?: string | null;
  VpnTunnelOriginatorIP?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateDBClusterMessage {
  AvailabilityZones?: string[] | null;
  BackupRetentionPeriod?: number | null;
  CharacterSetName?: string | null;
  DatabaseName?: string | null;
  DBClusterIdentifier: string;
  DBClusterParameterGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  DBSubnetGroupName?: string | null;
  Engine: string;
  EngineVersion?: string | null;
  Port?: number | null;
  MasterUsername?: string | null;
  MasterUserPassword?: string | null;
  OptionGroupName?: string | null;
  PreferredBackupWindow?: string | null;
  PreferredMaintenanceWindow?: string | null;
  ReplicationSourceIdentifier?: string | null;
  Tags?: Tag[] | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  PreSignedUrl?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  BacktrackWindow?: number | null;
  EnableCloudwatchLogsExports?: string[] | null;
  EngineMode?: string | null;
  ScalingConfiguration?: ScalingConfiguration | null;
  DeletionProtection?: boolean | null;
  GlobalClusterIdentifier?: string | null;
  EnableHttpEndpoint?: boolean | null;
  CopyTagsToSnapshot?: boolean | null;
  Domain?: string | null;
  DomainIAMRoleName?: string | null;
  EnableGlobalWriteForwarding?: boolean | null;
  SourceRegion?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateDBClusterEndpointMessage {
  DBClusterIdentifier: string;
  DBClusterEndpointIdentifier: string;
  EndpointType: string;
  StaticMembers?: string[] | null;
  ExcludedMembers?: string[] | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBClusterParameterGroupMessage {
  DBClusterParameterGroupName: string;
  DBParameterGroupFamily: string;
  Description: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBClusterSnapshotMessage {
  DBClusterSnapshotIdentifier: string;
  DBClusterIdentifier: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBInstanceMessage {
  DBName?: string | null;
  DBInstanceIdentifier: string;
  AllocatedStorage?: number | null;
  DBInstanceClass: string;
  Engine: string;
  MasterUsername?: string | null;
  MasterUserPassword?: string | null;
  DBSecurityGroups?: string[] | null;
  VpcSecurityGroupIds?: string[] | null;
  AvailabilityZone?: string | null;
  DBSubnetGroupName?: string | null;
  PreferredMaintenanceWindow?: string | null;
  DBParameterGroupName?: string | null;
  BackupRetentionPeriod?: number | null;
  PreferredBackupWindow?: string | null;
  Port?: number | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  LicenseModel?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  CharacterSetName?: string | null;
  NcharCharacterSetName?: string | null;
  PubliclyAccessible?: boolean | null;
  Tags?: Tag[] | null;
  DBClusterIdentifier?: string | null;
  StorageType?: string | null;
  TdeCredentialArn?: string | null;
  TdeCredentialPassword?: string | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  Domain?: string | null;
  CopyTagsToSnapshot?: boolean | null;
  MonitoringInterval?: number | null;
  MonitoringRoleArn?: string | null;
  DomainIAMRoleName?: string | null;
  PromotionTier?: number | null;
  Timezone?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  EnablePerformanceInsights?: boolean | null;
  PerformanceInsightsKMSKeyId?: string | null;
  PerformanceInsightsRetentionPeriod?: number | null;
  EnableCloudwatchLogsExports?: string[] | null;
  ProcessorFeatures?: ProcessorFeature[] | null;
  DeletionProtection?: boolean | null;
  MaxAllocatedStorage?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateDBInstanceReadReplicaMessage {
  DBInstanceIdentifier: string;
  SourceDBInstanceIdentifier: string;
  DBInstanceClass?: string | null;
  AvailabilityZone?: string | null;
  Port?: number | null;
  MultiAZ?: boolean | null;
  AutoMinorVersionUpgrade?: boolean | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  DBParameterGroupName?: string | null;
  PubliclyAccessible?: boolean | null;
  Tags?: Tag[] | null;
  DBSubnetGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  StorageType?: string | null;
  CopyTagsToSnapshot?: boolean | null;
  MonitoringInterval?: number | null;
  MonitoringRoleArn?: string | null;
  KmsKeyId?: string | null;
  PreSignedUrl?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  EnablePerformanceInsights?: boolean | null;
  PerformanceInsightsKMSKeyId?: string | null;
  PerformanceInsightsRetentionPeriod?: number | null;
  EnableCloudwatchLogsExports?: string[] | null;
  ProcessorFeatures?: ProcessorFeature[] | null;
  UseDefaultProcessorFeatures?: boolean | null;
  DeletionProtection?: boolean | null;
  Domain?: string | null;
  DomainIAMRoleName?: string | null;
  ReplicaMode?: ReplicaMode | null;
  SourceRegion?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateDBParameterGroupMessage {
  DBParameterGroupName: string;
  DBParameterGroupFamily: string;
  Description: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBProxyRequest {
  DBProxyName: string;
  EngineFamily: EngineFamily;
  Auth: UserAuthConfig[];
  RoleArn: string;
  VpcSubnetIds: string[];
  VpcSecurityGroupIds?: string[] | null;
  RequireTLS?: boolean | null;
  IdleClientTimeout?: number | null;
  DebugLogging?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBSecurityGroupMessage {
  DBSecurityGroupName: string;
  DBSecurityGroupDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBSnapshotMessage {
  DBSnapshotIdentifier: string;
  DBInstanceIdentifier: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBSubnetGroupMessage {
  DBSubnetGroupName: string;
  DBSubnetGroupDescription: string;
  SubnetIds: string[];
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateEventSubscriptionMessage {
  SubscriptionName: string;
  SnsTopicArn: string;
  SourceType?: string | null;
  EventCategories?: string[] | null;
  SourceIds?: string[] | null;
  Enabled?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateGlobalClusterMessage {
  GlobalClusterIdentifier?: string | null;
  SourceDBClusterIdentifier?: string | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  DeletionProtection?: boolean | null;
  DatabaseName?: string | null;
  StorageEncrypted?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateOptionGroupMessage {
  OptionGroupName: string;
  EngineName: string;
  MajorEngineVersion: string;
  OptionGroupDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteCustomAvailabilityZoneMessage {
  CustomAvailabilityZoneId: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBClusterMessage {
  DBClusterIdentifier: string;
  SkipFinalSnapshot?: boolean | null;
  FinalDBSnapshotIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteDBClusterEndpointMessage {
  DBClusterEndpointIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBClusterParameterGroupMessage {
  DBClusterParameterGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBClusterSnapshotMessage {
  DBClusterSnapshotIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBInstanceMessage {
  DBInstanceIdentifier: string;
  SkipFinalSnapshot?: boolean | null;
  FinalDBSnapshotIdentifier?: string | null;
  DeleteAutomatedBackups?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteDBInstanceAutomatedBackupMessage {
  DbiResourceId: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBParameterGroupMessage {
  DBParameterGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBProxyRequest {
  DBProxyName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBSecurityGroupMessage {
  DBSecurityGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBSnapshotMessage {
  DBSnapshotIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBSubnetGroupMessage {
  DBSubnetGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteEventSubscriptionMessage {
  SubscriptionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteGlobalClusterMessage {
  GlobalClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteInstallationMediaMessage {
  InstallationMediaId: string;
}

// refs: 1 - tags: named, input
export interface DeleteOptionGroupMessage {
  OptionGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeregisterDBProxyTargetsRequest {
  DBProxyName: string;
  TargetGroupName?: string | null;
  DBInstanceIdentifiers?: string[] | null;
  DBClusterIdentifiers?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeAccountAttributesMessage {
}

// refs: 1 - tags: named, input
export interface DescribeCertificatesMessage {
  CertificateIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeCustomAvailabilityZonesMessage {
  CustomAvailabilityZoneId?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterBacktracksMessage {
  DBClusterIdentifier: string;
  BacktrackIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterEndpointsMessage {
  DBClusterIdentifier?: string | null;
  DBClusterEndpointIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterParameterGroupsMessage {
  DBClusterParameterGroupName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterParametersMessage {
  DBClusterParameterGroupName: string;
  Source?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterSnapshotAttributesMessage {
  DBClusterSnapshotIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterSnapshotsMessage {
  DBClusterIdentifier?: string | null;
  DBClusterSnapshotIdentifier?: string | null;
  SnapshotType?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  IncludeShared?: boolean | null;
  IncludePublic?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClustersMessage {
  DBClusterIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  IncludeShared?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBEngineVersionsMessage {
  Engine?: string | null;
  EngineVersion?: string | null;
  DBParameterGroupFamily?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  DefaultOnly?: boolean | null;
  ListSupportedCharacterSets?: boolean | null;
  ListSupportedTimezones?: boolean | null;
  IncludeAll?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBInstanceAutomatedBackupsMessage {
  DbiResourceId?: string | null;
  DBInstanceIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBInstancesMessage {
  DBInstanceIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBLogFilesMessage {
  DBInstanceIdentifier: string;
  FilenameContains?: string | null;
  FileLastWritten?: number | null;
  FileSize?: number | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBParameterGroupsMessage {
  DBParameterGroupName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBParametersMessage {
  DBParameterGroupName: string;
  Source?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBProxiesRequest {
  DBProxyName?: string | null;
  Filters?: Filter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBProxyTargetGroupsRequest {
  DBProxyName: string;
  TargetGroupName?: string | null;
  Filters?: Filter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBProxyTargetsRequest {
  DBProxyName: string;
  TargetGroupName?: string | null;
  Filters?: Filter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBSecurityGroupsMessage {
  DBSecurityGroupName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBSnapshotAttributesMessage {
  DBSnapshotIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DescribeDBSnapshotsMessage {
  DBInstanceIdentifier?: string | null;
  DBSnapshotIdentifier?: string | null;
  SnapshotType?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  IncludeShared?: boolean | null;
  IncludePublic?: boolean | null;
  DbiResourceId?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBSubnetGroupsMessage {
  DBSubnetGroupName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEngineDefaultClusterParametersMessage {
  DBParameterGroupFamily: string;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEngineDefaultParametersMessage {
  DBParameterGroupFamily: string;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventCategoriesMessage {
  SourceType?: string | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventSubscriptionsMessage {
  SubscriptionName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventsMessage {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Duration?: number | null;
  EventCategories?: string[] | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeExportTasksMessage {
  ExportTaskIdentifier?: string | null;
  SourceArn?: string | null;
  Filters?: Filter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeGlobalClustersMessage {
  GlobalClusterIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstallationMediaMessage {
  InstallationMediaId?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeOptionGroupOptionsMessage {
  EngineName: string;
  MajorEngineVersion?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeOptionGroupsMessage {
  OptionGroupName?: string | null;
  Filters?: Filter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
  EngineName?: string | null;
  MajorEngineVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeOrderableDBInstanceOptionsMessage {
  Engine: string;
  EngineVersion?: string | null;
  DBInstanceClass?: string | null;
  LicenseModel?: string | null;
  AvailabilityZoneGroup?: string | null;
  Vpc?: boolean | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribePendingMaintenanceActionsMessage {
  ResourceIdentifier?: string | null;
  Filters?: Filter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedDBInstancesMessage {
  ReservedDBInstanceId?: string | null;
  ReservedDBInstancesOfferingId?: string | null;
  DBInstanceClass?: string | null;
  Duration?: string | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MultiAZ?: boolean | null;
  LeaseId?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedDBInstancesOfferingsMessage {
  ReservedDBInstancesOfferingId?: string | null;
  DBInstanceClass?: string | null;
  Duration?: string | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MultiAZ?: boolean | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeSourceRegionsMessage {
  RegionName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeValidDBInstanceModificationsMessage {
  DBInstanceIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DownloadDBLogFilePortionMessage {
  DBInstanceIdentifier: string;
  LogFileName: string;
  Marker?: string | null;
  NumberOfLines?: number | null;
}

// refs: 1 - tags: named, input
export interface FailoverDBClusterMessage {
  DBClusterIdentifier: string;
  TargetDBInstanceIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface ImportInstallationMediaMessage {
  CustomAvailabilityZoneId: string;
  Engine: string;
  EngineVersion: string;
  EngineInstallationMediaPath: string;
  OSInstallationMediaPath: string;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceMessage {
  ResourceName: string;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyCertificatesMessage {
  CertificateIdentifier?: string | null;
  RemoveCustomerOverride?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyCurrentDBClusterCapacityMessage {
  DBClusterIdentifier: string;
  Capacity?: number | null;
  SecondsBeforeTimeout?: number | null;
  TimeoutAction?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBClusterMessage {
  DBClusterIdentifier: string;
  NewDBClusterIdentifier?: string | null;
  ApplyImmediately?: boolean | null;
  BackupRetentionPeriod?: number | null;
  DBClusterParameterGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  Port?: number | null;
  MasterUserPassword?: string | null;
  OptionGroupName?: string | null;
  PreferredBackupWindow?: string | null;
  PreferredMaintenanceWindow?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  BacktrackWindow?: number | null;
  CloudwatchLogsExportConfiguration?: CloudwatchLogsExportConfiguration | null;
  EngineVersion?: string | null;
  AllowMajorVersionUpgrade?: boolean | null;
  DBInstanceParameterGroupName?: string | null;
  Domain?: string | null;
  DomainIAMRoleName?: string | null;
  ScalingConfiguration?: ScalingConfiguration | null;
  DeletionProtection?: boolean | null;
  EnableHttpEndpoint?: boolean | null;
  CopyTagsToSnapshot?: boolean | null;
  EnableGlobalWriteForwarding?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBClusterEndpointMessage {
  DBClusterEndpointIdentifier: string;
  EndpointType?: string | null;
  StaticMembers?: string[] | null;
  ExcludedMembers?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBClusterParameterGroupMessage {
  DBClusterParameterGroupName: string;
  Parameters: Parameter[];
}

// refs: 1 - tags: named, input
export interface ModifyDBClusterSnapshotAttributeMessage {
  DBClusterSnapshotIdentifier: string;
  AttributeName: string;
  ValuesToAdd?: string[] | null;
  ValuesToRemove?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBInstanceMessage {
  DBInstanceIdentifier: string;
  AllocatedStorage?: number | null;
  DBInstanceClass?: string | null;
  DBSubnetGroupName?: string | null;
  DBSecurityGroups?: string[] | null;
  VpcSecurityGroupIds?: string[] | null;
  ApplyImmediately?: boolean | null;
  MasterUserPassword?: string | null;
  DBParameterGroupName?: string | null;
  BackupRetentionPeriod?: number | null;
  PreferredBackupWindow?: string | null;
  PreferredMaintenanceWindow?: string | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AllowMajorVersionUpgrade?: boolean | null;
  AutoMinorVersionUpgrade?: boolean | null;
  LicenseModel?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  NewDBInstanceIdentifier?: string | null;
  StorageType?: string | null;
  TdeCredentialArn?: string | null;
  TdeCredentialPassword?: string | null;
  CACertificateIdentifier?: string | null;
  Domain?: string | null;
  CopyTagsToSnapshot?: boolean | null;
  MonitoringInterval?: number | null;
  DBPortNumber?: number | null;
  PubliclyAccessible?: boolean | null;
  MonitoringRoleArn?: string | null;
  DomainIAMRoleName?: string | null;
  PromotionTier?: number | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  EnablePerformanceInsights?: boolean | null;
  PerformanceInsightsKMSKeyId?: string | null;
  PerformanceInsightsRetentionPeriod?: number | null;
  CloudwatchLogsExportConfiguration?: CloudwatchLogsExportConfiguration | null;
  ProcessorFeatures?: ProcessorFeature[] | null;
  UseDefaultProcessorFeatures?: boolean | null;
  DeletionProtection?: boolean | null;
  MaxAllocatedStorage?: number | null;
  CertificateRotationRestart?: boolean | null;
  ReplicaMode?: ReplicaMode | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBParameterGroupMessage {
  DBParameterGroupName: string;
  Parameters: Parameter[];
}

// refs: 1 - tags: named, input
export interface ModifyDBProxyRequest {
  DBProxyName: string;
  NewDBProxyName?: string | null;
  Auth?: UserAuthConfig[] | null;
  RequireTLS?: boolean | null;
  IdleClientTimeout?: number | null;
  DebugLogging?: boolean | null;
  RoleArn?: string | null;
  SecurityGroups?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBProxyTargetGroupRequest {
  TargetGroupName: string;
  DBProxyName: string;
  ConnectionPoolConfig?: ConnectionPoolConfiguration | null;
  NewName?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBSnapshotMessage {
  DBSnapshotIdentifier: string;
  EngineVersion?: string | null;
  OptionGroupName?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBSnapshotAttributeMessage {
  DBSnapshotIdentifier: string;
  AttributeName: string;
  ValuesToAdd?: string[] | null;
  ValuesToRemove?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBSubnetGroupMessage {
  DBSubnetGroupName: string;
  DBSubnetGroupDescription?: string | null;
  SubnetIds: string[];
}

// refs: 1 - tags: named, input
export interface ModifyEventSubscriptionMessage {
  SubscriptionName: string;
  SnsTopicArn?: string | null;
  SourceType?: string | null;
  EventCategories?: string[] | null;
  Enabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyGlobalClusterMessage {
  GlobalClusterIdentifier?: string | null;
  NewGlobalClusterIdentifier?: string | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyOptionGroupMessage {
  OptionGroupName: string;
  OptionsToInclude?: OptionConfiguration[] | null;
  OptionsToRemove?: string[] | null;
  ApplyImmediately?: boolean | null;
}

// refs: 1 - tags: named, input
export interface PromoteReadReplicaMessage {
  DBInstanceIdentifier: string;
  BackupRetentionPeriod?: number | null;
  PreferredBackupWindow?: string | null;
}

// refs: 1 - tags: named, input
export interface PromoteReadReplicaDBClusterMessage {
  DBClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface PurchaseReservedDBInstancesOfferingMessage {
  ReservedDBInstancesOfferingId: string;
  ReservedDBInstanceId?: string | null;
  DBInstanceCount?: number | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface RebootDBInstanceMessage {
  DBInstanceIdentifier: string;
  ForceFailover?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RegisterDBProxyTargetsRequest {
  DBProxyName: string;
  TargetGroupName?: string | null;
  DBInstanceIdentifiers?: string[] | null;
  DBClusterIdentifiers?: string[] | null;
}

// refs: 1 - tags: named, input
export interface RemoveFromGlobalClusterMessage {
  GlobalClusterIdentifier?: string | null;
  DbClusterIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface RemoveRoleFromDBClusterMessage {
  DBClusterIdentifier: string;
  RoleArn: string;
  FeatureName?: string | null;
}

// refs: 1 - tags: named, input
export interface RemoveRoleFromDBInstanceMessage {
  DBInstanceIdentifier: string;
  RoleArn: string;
  FeatureName: string;
}

// refs: 1 - tags: named, input
export interface RemoveSourceIdentifierFromSubscriptionMessage {
  SubscriptionName: string;
  SourceIdentifier: string;
}

// refs: 1 - tags: named, input
export interface RemoveTagsFromResourceMessage {
  ResourceName: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface ResetDBClusterParameterGroupMessage {
  DBClusterParameterGroupName: string;
  ResetAllParameters?: boolean | null;
  Parameters?: Parameter[] | null;
}

// refs: 1 - tags: named, input
export interface ResetDBParameterGroupMessage {
  DBParameterGroupName: string;
  ResetAllParameters?: boolean | null;
  Parameters?: Parameter[] | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBClusterFromS3Message {
  AvailabilityZones?: string[] | null;
  BackupRetentionPeriod?: number | null;
  CharacterSetName?: string | null;
  DatabaseName?: string | null;
  DBClusterIdentifier: string;
  DBClusterParameterGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  DBSubnetGroupName?: string | null;
  Engine: string;
  EngineVersion?: string | null;
  Port?: number | null;
  MasterUsername: string;
  MasterUserPassword: string;
  OptionGroupName?: string | null;
  PreferredBackupWindow?: string | null;
  PreferredMaintenanceWindow?: string | null;
  Tags?: Tag[] | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  SourceEngine: string;
  SourceEngineVersion: string;
  S3BucketName: string;
  S3Prefix?: string | null;
  S3IngestionRoleArn: string;
  BacktrackWindow?: number | null;
  EnableCloudwatchLogsExports?: string[] | null;
  DeletionProtection?: boolean | null;
  CopyTagsToSnapshot?: boolean | null;
  Domain?: string | null;
  DomainIAMRoleName?: string | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBClusterFromSnapshotMessage {
  AvailabilityZones?: string[] | null;
  DBClusterIdentifier: string;
  SnapshotIdentifier: string;
  Engine: string;
  EngineVersion?: string | null;
  Port?: number | null;
  DBSubnetGroupName?: string | null;
  DatabaseName?: string | null;
  OptionGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  Tags?: Tag[] | null;
  KmsKeyId?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  BacktrackWindow?: number | null;
  EnableCloudwatchLogsExports?: string[] | null;
  EngineMode?: string | null;
  ScalingConfiguration?: ScalingConfiguration | null;
  DBClusterParameterGroupName?: string | null;
  DeletionProtection?: boolean | null;
  CopyTagsToSnapshot?: boolean | null;
  Domain?: string | null;
  DomainIAMRoleName?: string | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBClusterToPointInTimeMessage {
  DBClusterIdentifier: string;
  RestoreType?: string | null;
  SourceDBClusterIdentifier: string;
  RestoreToTime?: Date | number | null;
  UseLatestRestorableTime?: boolean | null;
  Port?: number | null;
  DBSubnetGroupName?: string | null;
  OptionGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  Tags?: Tag[] | null;
  KmsKeyId?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  BacktrackWindow?: number | null;
  EnableCloudwatchLogsExports?: string[] | null;
  DBClusterParameterGroupName?: string | null;
  DeletionProtection?: boolean | null;
  CopyTagsToSnapshot?: boolean | null;
  Domain?: string | null;
  DomainIAMRoleName?: string | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBInstanceFromDBSnapshotMessage {
  DBInstanceIdentifier: string;
  DBSnapshotIdentifier: string;
  DBInstanceClass?: string | null;
  Port?: number | null;
  AvailabilityZone?: string | null;
  DBSubnetGroupName?: string | null;
  MultiAZ?: boolean | null;
  PubliclyAccessible?: boolean | null;
  AutoMinorVersionUpgrade?: boolean | null;
  LicenseModel?: string | null;
  DBName?: string | null;
  Engine?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  Tags?: Tag[] | null;
  StorageType?: string | null;
  TdeCredentialArn?: string | null;
  TdeCredentialPassword?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  Domain?: string | null;
  CopyTagsToSnapshot?: boolean | null;
  DomainIAMRoleName?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  EnableCloudwatchLogsExports?: string[] | null;
  ProcessorFeatures?: ProcessorFeature[] | null;
  UseDefaultProcessorFeatures?: boolean | null;
  DBParameterGroupName?: string | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBInstanceFromS3Message {
  DBName?: string | null;
  DBInstanceIdentifier: string;
  AllocatedStorage?: number | null;
  DBInstanceClass: string;
  Engine: string;
  MasterUsername?: string | null;
  MasterUserPassword?: string | null;
  DBSecurityGroups?: string[] | null;
  VpcSecurityGroupIds?: string[] | null;
  AvailabilityZone?: string | null;
  DBSubnetGroupName?: string | null;
  PreferredMaintenanceWindow?: string | null;
  DBParameterGroupName?: string | null;
  BackupRetentionPeriod?: number | null;
  PreferredBackupWindow?: string | null;
  Port?: number | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  LicenseModel?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  PubliclyAccessible?: boolean | null;
  Tags?: Tag[] | null;
  StorageType?: string | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  CopyTagsToSnapshot?: boolean | null;
  MonitoringInterval?: number | null;
  MonitoringRoleArn?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  SourceEngine: string;
  SourceEngineVersion: string;
  S3BucketName: string;
  S3Prefix?: string | null;
  S3IngestionRoleArn: string;
  EnablePerformanceInsights?: boolean | null;
  PerformanceInsightsKMSKeyId?: string | null;
  PerformanceInsightsRetentionPeriod?: number | null;
  EnableCloudwatchLogsExports?: string[] | null;
  ProcessorFeatures?: ProcessorFeature[] | null;
  UseDefaultProcessorFeatures?: boolean | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBInstanceToPointInTimeMessage {
  SourceDBInstanceIdentifier?: string | null;
  TargetDBInstanceIdentifier: string;
  RestoreTime?: Date | number | null;
  UseLatestRestorableTime?: boolean | null;
  DBInstanceClass?: string | null;
  Port?: number | null;
  AvailabilityZone?: string | null;
  DBSubnetGroupName?: string | null;
  MultiAZ?: boolean | null;
  PubliclyAccessible?: boolean | null;
  AutoMinorVersionUpgrade?: boolean | null;
  LicenseModel?: string | null;
  DBName?: string | null;
  Engine?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  CopyTagsToSnapshot?: boolean | null;
  Tags?: Tag[] | null;
  StorageType?: string | null;
  TdeCredentialArn?: string | null;
  TdeCredentialPassword?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  Domain?: string | null;
  DomainIAMRoleName?: string | null;
  EnableIAMDatabaseAuthentication?: boolean | null;
  EnableCloudwatchLogsExports?: string[] | null;
  ProcessorFeatures?: ProcessorFeature[] | null;
  UseDefaultProcessorFeatures?: boolean | null;
  DBParameterGroupName?: string | null;
  DeletionProtection?: boolean | null;
  SourceDbiResourceId?: string | null;
}

// refs: 1 - tags: named, input
export interface RevokeDBSecurityGroupIngressMessage {
  DBSecurityGroupName: string;
  CIDRIP?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupId?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
}

// refs: 1 - tags: named, input
export interface StartActivityStreamRequest {
  ResourceArn: string;
  Mode: ActivityStreamMode;
  KmsKeyId: string;
  ApplyImmediately?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StartDBClusterMessage {
  DBClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface StartDBInstanceMessage {
  DBInstanceIdentifier: string;
}

// refs: 1 - tags: named, input
export interface StartExportTaskMessage {
  ExportTaskIdentifier: string;
  SourceArn: string;
  S3BucketName: string;
  IamRoleArn: string;
  KmsKeyId: string;
  S3Prefix?: string | null;
  ExportOnly?: string[] | null;
}

// refs: 1 - tags: named, input
export interface StopActivityStreamRequest {
  ResourceArn: string;
  ApplyImmediately?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StopDBClusterMessage {
  DBClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface StopDBInstanceMessage {
  DBInstanceIdentifier: string;
  DBSnapshotIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface AddSourceIdentifierToSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface ApplyPendingMaintenanceActionResult {
  ResourcePendingMaintenanceActions?: ResourcePendingMaintenanceActions | null;
}

// refs: 1 - tags: named, output
export interface AuthorizeDBSecurityGroupIngressResult {
  DBSecurityGroup?: DBSecurityGroup | null;
}

// refs: 2 - tags: named, output, interface
export interface DBClusterBacktrack {
  DBClusterIdentifier?: string | null;
  BacktrackIdentifier?: string | null;
  BacktrackTo?: Date | number | null;
  BacktrackedFrom?: Date | number | null;
  BacktrackRequestCreationTime?: Date | number | null;
  Status?: string | null;
}
function DBClusterBacktrack_Parse(node: XmlNode): DBClusterBacktrack {
  return {
    ...node.strings({
      optional: {"DBClusterIdentifier":true,"BacktrackIdentifier":true,"Status":true},
    }),
    BacktrackTo: node.first("BacktrackTo", false, x => parseTimestamp(x.content)),
    BacktrackedFrom: node.first("BacktrackedFrom", false, x => parseTimestamp(x.content)),
    BacktrackRequestCreationTime: node.first("BacktrackRequestCreationTime", false, x => parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: named, output, interface
export interface ExportTask {
  ExportTaskIdentifier?: string | null;
  SourceArn?: string | null;
  ExportOnly: string[];
  SnapshotTime?: Date | number | null;
  TaskStartTime?: Date | number | null;
  TaskEndTime?: Date | number | null;
  S3Bucket?: string | null;
  S3Prefix?: string | null;
  IamRoleArn?: string | null;
  KmsKeyId?: string | null;
  Status?: string | null;
  PercentProgress?: number | null;
  TotalExtractedDataInGB?: number | null;
  FailureCause?: string | null;
  WarningMessage?: string | null;
}
function ExportTask_Parse(node: XmlNode): ExportTask {
  return {
    ...node.strings({
      optional: {"ExportTaskIdentifier":true,"SourceArn":true,"S3Bucket":true,"S3Prefix":true,"IamRoleArn":true,"KmsKeyId":true,"Status":true,"FailureCause":true,"WarningMessage":true},
    }),
    ExportOnly: node.getList("ExportOnly", "member").map(x => x.content ?? ''),
    SnapshotTime: node.first("SnapshotTime", false, x => parseTimestamp(x.content)),
    TaskStartTime: node.first("TaskStartTime", false, x => parseTimestamp(x.content)),
    TaskEndTime: node.first("TaskEndTime", false, x => parseTimestamp(x.content)),
    PercentProgress: node.first("PercentProgress", false, x => parseInt(x.content ?? '0')),
    TotalExtractedDataInGB: node.first("TotalExtractedDataInGB", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: named, output
export interface CopyDBClusterParameterGroupResult {
  DBClusterParameterGroup?: DBClusterParameterGroup | null;
}

// refs: 1 - tags: named, output
export interface CopyDBClusterSnapshotResult {
  DBClusterSnapshot?: DBClusterSnapshot | null;
}

// refs: 1 - tags: named, output
export interface CopyDBParameterGroupResult {
  DBParameterGroup?: DBParameterGroup | null;
}

// refs: 1 - tags: named, output
export interface CopyDBSnapshotResult {
  DBSnapshot?: DBSnapshot | null;
}

// refs: 1 - tags: named, output
export interface CopyOptionGroupResult {
  OptionGroup?: OptionGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateCustomAvailabilityZoneResult {
  CustomAvailabilityZone?: CustomAvailabilityZone | null;
}

// refs: 1 - tags: named, output
export interface CreateDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 2 - tags: named, output, interface
export interface DBClusterEndpoint {
  DBClusterEndpointIdentifier?: string | null;
  DBClusterIdentifier?: string | null;
  DBClusterEndpointResourceIdentifier?: string | null;
  Endpoint?: string | null;
  Status?: string | null;
  EndpointType?: string | null;
  CustomEndpointType?: string | null;
  StaticMembers: string[];
  ExcludedMembers: string[];
  DBClusterEndpointArn?: string | null;
}
function DBClusterEndpoint_Parse(node: XmlNode): DBClusterEndpoint {
  return {
    ...node.strings({
      optional: {"DBClusterEndpointIdentifier":true,"DBClusterIdentifier":true,"DBClusterEndpointResourceIdentifier":true,"Endpoint":true,"Status":true,"EndpointType":true,"CustomEndpointType":true,"DBClusterEndpointArn":true},
    }),
    StaticMembers: node.getList("StaticMembers", "member").map(x => x.content ?? ''),
    ExcludedMembers: node.getList("ExcludedMembers", "member").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: named, output
export interface CreateDBClusterParameterGroupResult {
  DBClusterParameterGroup?: DBClusterParameterGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateDBClusterSnapshotResult {
  DBClusterSnapshot?: DBClusterSnapshot | null;
}

// refs: 1 - tags: named, output
export interface CreateDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface CreateDBInstanceReadReplicaResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface CreateDBParameterGroupResult {
  DBParameterGroup?: DBParameterGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateDBProxyResponse {
  DBProxy?: DBProxy | null;
}

// refs: 1 - tags: named, output
export interface CreateDBSecurityGroupResult {
  DBSecurityGroup?: DBSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateDBSnapshotResult {
  DBSnapshot?: DBSnapshot | null;
}

// refs: 1 - tags: named, output
export interface CreateDBSubnetGroupResult {
  DBSubnetGroup?: DBSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateEventSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface CreateGlobalClusterResult {
  GlobalCluster?: GlobalCluster | null;
}

// refs: 1 - tags: named, output
export interface CreateOptionGroupResult {
  OptionGroup?: OptionGroup | null;
}

// refs: 1 - tags: named, output
export interface DeleteCustomAvailabilityZoneResult {
  CustomAvailabilityZone?: CustomAvailabilityZone | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBClusterSnapshotResult {
  DBClusterSnapshot?: DBClusterSnapshot | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBInstanceAutomatedBackupResult {
  DBInstanceAutomatedBackup?: DBInstanceAutomatedBackup | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBProxyResponse {
  DBProxy?: DBProxy | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBSnapshotResult {
  DBSnapshot?: DBSnapshot | null;
}

// refs: 1 - tags: named, output
export interface DeleteEventSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface DeleteGlobalClusterResult {
  GlobalCluster?: GlobalCluster | null;
}

// refs: 2 - tags: named, output, interface
export interface InstallationMedia {
  InstallationMediaId?: string | null;
  CustomAvailabilityZoneId?: string | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  EngineInstallationMediaPath?: string | null;
  OSInstallationMediaPath?: string | null;
  Status?: string | null;
  FailureCause?: InstallationMediaFailureCause | null;
}
function InstallationMedia_Parse(node: XmlNode): InstallationMedia {
  return {
    ...node.strings({
      optional: {"InstallationMediaId":true,"CustomAvailabilityZoneId":true,"Engine":true,"EngineVersion":true,"EngineInstallationMediaPath":true,"OSInstallationMediaPath":true,"Status":true},
    }),
    FailureCause: node.first("FailureCause", false, InstallationMediaFailureCause_Parse),
  };
}

// refs: 1 - tags: named, output
export interface DeregisterDBProxyTargetsResponse {
}

// refs: 1 - tags: named, output
export interface AccountAttributesMessage {
  AccountQuotas: AccountQuota[];
}

// refs: 1 - tags: named, output
export interface CertificateMessage {
  Certificates: Certificate[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface CustomAvailabilityZoneMessage {
  Marker?: string | null;
  CustomAvailabilityZones: CustomAvailabilityZone[];
}

// refs: 1 - tags: named, output
export interface DBClusterBacktrackMessage {
  Marker?: string | null;
  DBClusterBacktracks: DBClusterBacktrack[];
}

// refs: 1 - tags: named, output
export interface DBClusterEndpointMessage {
  Marker?: string | null;
  DBClusterEndpoints: DBClusterEndpoint[];
}

// refs: 1 - tags: named, output
export interface DBClusterParameterGroupsMessage {
  Marker?: string | null;
  DBClusterParameterGroups: DBClusterParameterGroup[];
}

// refs: 1 - tags: named, output
export interface DBClusterParameterGroupDetails {
  Parameters: Parameter[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeDBClusterSnapshotAttributesResult {
  DBClusterSnapshotAttributesResult?: DBClusterSnapshotAttributesResult | null;
}

// refs: 1 - tags: named, output
export interface DBClusterSnapshotMessage {
  Marker?: string | null;
  DBClusterSnapshots: DBClusterSnapshot[];
}

// refs: 1 - tags: named, output
export interface DBClusterMessage {
  Marker?: string | null;
  DBClusters: DBCluster[];
}

// refs: 1 - tags: named, output
export interface DBEngineVersionMessage {
  Marker?: string | null;
  DBEngineVersions: DBEngineVersion[];
}

// refs: 1 - tags: named, output
export interface DBInstanceAutomatedBackupMessage {
  Marker?: string | null;
  DBInstanceAutomatedBackups: DBInstanceAutomatedBackup[];
}

// refs: 1 - tags: named, output
export interface DBInstanceMessage {
  Marker?: string | null;
  DBInstances: DBInstance[];
}

// refs: 1 - tags: named, output
export interface DescribeDBLogFilesResponse {
  DescribeDBLogFiles: DescribeDBLogFilesDetails[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DBParameterGroupsMessage {
  Marker?: string | null;
  DBParameterGroups: DBParameterGroup[];
}

// refs: 1 - tags: named, output
export interface DBParameterGroupDetails {
  Parameters: Parameter[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeDBProxiesResponse {
  DBProxies: DBProxy[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeDBProxyTargetGroupsResponse {
  TargetGroups: DBProxyTargetGroup[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeDBProxyTargetsResponse {
  Targets: DBProxyTarget[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DBSecurityGroupMessage {
  Marker?: string | null;
  DBSecurityGroups: DBSecurityGroup[];
}

// refs: 1 - tags: named, output
export interface DescribeDBSnapshotAttributesResult {
  DBSnapshotAttributesResult?: DBSnapshotAttributesResult | null;
}

// refs: 1 - tags: named, output
export interface DBSnapshotMessage {
  Marker?: string | null;
  DBSnapshots: DBSnapshot[];
}

// refs: 1 - tags: named, output
export interface DBSubnetGroupMessage {
  Marker?: string | null;
  DBSubnetGroups: DBSubnetGroup[];
}

// refs: 1 - tags: named, output
export interface DescribeEngineDefaultClusterParametersResult {
  EngineDefaults?: EngineDefaults | null;
}

// refs: 1 - tags: named, output
export interface DescribeEngineDefaultParametersResult {
  EngineDefaults?: EngineDefaults | null;
}

// refs: 1 - tags: named, output
export interface EventCategoriesMessage {
  EventCategoriesMapList: EventCategoriesMap[];
}

// refs: 1 - tags: named, output
export interface EventSubscriptionsMessage {
  Marker?: string | null;
  EventSubscriptionsList: EventSubscription[];
}

// refs: 1 - tags: named, output
export interface EventsMessage {
  Marker?: string | null;
  Events: Event[];
}

// refs: 1 - tags: named, output
export interface ExportTasksMessage {
  Marker?: string | null;
  ExportTasks: ExportTask[];
}

// refs: 1 - tags: named, output
export interface GlobalClustersMessage {
  Marker?: string | null;
  GlobalClusters: GlobalCluster[];
}

// refs: 1 - tags: named, output
export interface InstallationMediaMessage {
  Marker?: string | null;
  InstallationMedia: InstallationMedia[];
}

// refs: 1 - tags: named, output
export interface OptionGroupOptionsMessage {
  OptionGroupOptions: OptionGroupOption[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface OptionGroups {
  OptionGroupsList: OptionGroup[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface OrderableDBInstanceOptionsMessage {
  OrderableDBInstanceOptions: OrderableDBInstanceOption[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface PendingMaintenanceActionsMessage {
  PendingMaintenanceActions: ResourcePendingMaintenanceActions[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ReservedDBInstanceMessage {
  Marker?: string | null;
  ReservedDBInstances: ReservedDBInstance[];
}

// refs: 1 - tags: named, output
export interface ReservedDBInstancesOfferingMessage {
  Marker?: string | null;
  ReservedDBInstancesOfferings: ReservedDBInstancesOffering[];
}

// refs: 1 - tags: named, output
export interface SourceRegionMessage {
  Marker?: string | null;
  SourceRegions: SourceRegion[];
}

// refs: 1 - tags: named, output
export interface DescribeValidDBInstanceModificationsResult {
  ValidDBInstanceModificationsMessage?: ValidDBInstanceModificationsMessage | null;
}

// refs: 1 - tags: named, output
export interface DownloadDBLogFilePortionDetails {
  LogFileData?: string | null;
  Marker?: string | null;
  AdditionalDataPending?: boolean | null;
}

// refs: 1 - tags: named, output
export interface FailoverDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface TagListMessage {
  TagList: Tag[];
}

// refs: 1 - tags: named, output
export interface ModifyCertificatesResult {
  Certificate?: Certificate | null;
}

// refs: 1 - tags: named, output
export interface DBClusterCapacityInfo {
  DBClusterIdentifier?: string | null;
  PendingCapacity?: number | null;
  CurrentCapacity?: number | null;
  SecondsBeforeTimeout?: number | null;
  TimeoutAction?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface DBClusterParameterGroupNameMessage {
  DBClusterParameterGroupName?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBClusterSnapshotAttributeResult {
  DBClusterSnapshotAttributesResult?: DBClusterSnapshotAttributesResult | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface DBParameterGroupNameMessage {
  DBParameterGroupName?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBProxyResponse {
  DBProxy?: DBProxy | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBProxyTargetGroupResponse {
  DBProxyTargetGroup?: DBProxyTargetGroup | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBSnapshotResult {
  DBSnapshot?: DBSnapshot | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBSnapshotAttributeResult {
  DBSnapshotAttributesResult?: DBSnapshotAttributesResult | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBSubnetGroupResult {
  DBSubnetGroup?: DBSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface ModifyEventSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface ModifyGlobalClusterResult {
  GlobalCluster?: GlobalCluster | null;
}

// refs: 1 - tags: named, output
export interface ModifyOptionGroupResult {
  OptionGroup?: OptionGroup | null;
}

// refs: 1 - tags: named, output
export interface PromoteReadReplicaResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface PromoteReadReplicaDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface PurchaseReservedDBInstancesOfferingResult {
  ReservedDBInstance?: ReservedDBInstance | null;
}

// refs: 1 - tags: named, output
export interface RebootDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface RegisterDBProxyTargetsResponse {
  DBProxyTargets: DBProxyTarget[];
}

// refs: 1 - tags: named, output
export interface RemoveFromGlobalClusterResult {
  GlobalCluster?: GlobalCluster | null;
}

// refs: 1 - tags: named, output
export interface RemoveSourceIdentifierFromSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBClusterFromS3Result {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBClusterFromSnapshotResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBClusterToPointInTimeResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBInstanceFromDBSnapshotResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBInstanceFromS3Result {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBInstanceToPointInTimeResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface RevokeDBSecurityGroupIngressResult {
  DBSecurityGroup?: DBSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface StartActivityStreamResponse {
  KmsKeyId?: string | null;
  KinesisStreamName?: string | null;
  Status?: ActivityStreamStatus | null;
  Mode?: ActivityStreamMode | null;
  ApplyImmediately?: boolean | null;
}

// refs: 1 - tags: named, output
export interface StartDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface StartDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface StopActivityStreamResponse {
  KmsKeyId?: string | null;
  KinesisStreamName?: string | null;
  Status?: ActivityStreamStatus | null;
}

// refs: 1 - tags: named, output
export interface StopDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface StopDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 27 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: XmlNode): Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 3 - tags: input, named, interface
export interface ScalingConfiguration {
  MinCapacity?: number | null;
  MaxCapacity?: number | null;
  AutoPause?: boolean | null;
  SecondsUntilAutoPause?: number | null;
  TimeoutAction?: string | null;
}
function ScalingConfiguration_Serialize(body: URLSearchParams, prefix: string, params: ScalingConfiguration) {
    if ("MinCapacity" in params) body.append(prefix+".MinCapacity", (params["MinCapacity"] ?? '').toString());
    if ("MaxCapacity" in params) body.append(prefix+".MaxCapacity", (params["MaxCapacity"] ?? '').toString());
    if ("AutoPause" in params) body.append(prefix+".AutoPause", (params["AutoPause"] ?? '').toString());
    if ("SecondsUntilAutoPause" in params) body.append(prefix+".SecondsUntilAutoPause", (params["SecondsUntilAutoPause"] ?? '').toString());
    if ("TimeoutAction" in params) body.append(prefix+".TimeoutAction", (params["TimeoutAction"] ?? '').toString());
}

// refs: 35 - tags: input, named, interface, output
export interface ProcessorFeature {
  Name?: string | null;
  Value?: string | null;
}
function ProcessorFeature_Serialize(body: URLSearchParams, prefix: string, params: ProcessorFeature) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function ProcessorFeature_Parse(node: XmlNode): ProcessorFeature {
  return node.strings({
    optional: {"Name":true,"Value":true},
  });
}

// refs: 14 - tags: input, named, enum, output
export type ReplicaMode =
| "open-read-only"
| "mounted"
;



// refs: 1 - tags: input, named, enum
export type EngineFamily =
| "MYSQL"
| "POSTGRESQL"
;


// refs: 2 - tags: input, named, interface
export interface UserAuthConfig {
  Description?: string | null;
  UserName?: string | null;
  AuthScheme?: AuthScheme | null;
  SecretArn?: string | null;
  IAMAuth?: IAMAuthMode | null;
}
function UserAuthConfig_Serialize(body: URLSearchParams, prefix: string, params: UserAuthConfig) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("UserName" in params) body.append(prefix+".UserName", (params["UserName"] ?? '').toString());
    if ("AuthScheme" in params) body.append(prefix+".AuthScheme", (params["AuthScheme"] ?? '').toString());
    if ("SecretArn" in params) body.append(prefix+".SecretArn", (params["SecretArn"] ?? '').toString());
    if ("IAMAuth" in params) body.append(prefix+".IAMAuth", (params["IAMAuth"] ?? '').toString());
}

// refs: 6 - tags: input, named, enum, output
export type AuthScheme =
| "SECRETS"
;



// refs: 6 - tags: input, named, enum, output
export type IAMAuthMode =
| "DISABLED"
| "REQUIRED"
;



// refs: 36 - tags: input, named, interface
export interface Filter {
  Name: string;
  Values: string[];
}
function Filter_Serialize(body: URLSearchParams, prefix: string, params: Filter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) prt.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".Value."})
}

// refs: 2 - tags: input, named, enum, output
export type SourceType =
| "db-instance"
| "db-parameter-group"
| "db-security-group"
| "db-snapshot"
| "db-cluster"
| "db-cluster-snapshot"
;



// refs: 2 - tags: input, named, interface
export interface CloudwatchLogsExportConfiguration {
  EnableLogTypes?: string[] | null;
  DisableLogTypes?: string[] | null;
}
function CloudwatchLogsExportConfiguration_Serialize(body: URLSearchParams, prefix: string, params: CloudwatchLogsExportConfiguration) {
    if (params["EnableLogTypes"]) prt.appendList(body, prefix+".EnableLogTypes", params["EnableLogTypes"], {"entryPrefix":".member."})
    if (params["DisableLogTypes"]) prt.appendList(body, prefix+".DisableLogTypes", params["DisableLogTypes"], {"entryPrefix":".member."})
}

// refs: 8 - tags: input, named, interface, output
export interface Parameter {
  ParameterName?: string | null;
  ParameterValue?: string | null;
  Description?: string | null;
  Source?: string | null;
  ApplyType?: string | null;
  DataType?: string | null;
  AllowedValues?: string | null;
  IsModifiable?: boolean | null;
  MinimumEngineVersion?: string | null;
  ApplyMethod?: ApplyMethod | null;
  SupportedEngineModes: string[];
}
function Parameter_Serialize(body: URLSearchParams, prefix: string, params: Parameter) {
    if ("ParameterName" in params) body.append(prefix+".ParameterName", (params["ParameterName"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("Source" in params) body.append(prefix+".Source", (params["Source"] ?? '').toString());
    if ("ApplyType" in params) body.append(prefix+".ApplyType", (params["ApplyType"] ?? '').toString());
    if ("DataType" in params) body.append(prefix+".DataType", (params["DataType"] ?? '').toString());
    if ("AllowedValues" in params) body.append(prefix+".AllowedValues", (params["AllowedValues"] ?? '').toString());
    if ("IsModifiable" in params) body.append(prefix+".IsModifiable", (params["IsModifiable"] ?? '').toString());
    if ("MinimumEngineVersion" in params) body.append(prefix+".MinimumEngineVersion", (params["MinimumEngineVersion"] ?? '').toString());
    if ("ApplyMethod" in params) body.append(prefix+".ApplyMethod", (params["ApplyMethod"] ?? '').toString());
    if (params["SupportedEngineModes"]) prt.appendList(body, prefix+".SupportedEngineModes", params["SupportedEngineModes"], {"entryPrefix":".member."})
}
function Parameter_Parse(node: XmlNode): Parameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"ParameterValue":true,"Description":true,"Source":true,"ApplyType":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    ApplyMethod: node.first("ApplyMethod", false, x => (x.content ?? '') as ApplyMethod),
    SupportedEngineModes: node.getList("SupportedEngineModes", "member").map(x => x.content ?? ''),
  };
}

// refs: 8 - tags: input, named, enum, output
export type ApplyMethod =
| "immediate"
| "pending-reboot"
;



// refs: 1 - tags: input, named, interface
export interface ConnectionPoolConfiguration {
  MaxConnectionsPercent?: number | null;
  MaxIdleConnectionsPercent?: number | null;
  ConnectionBorrowTimeout?: number | null;
  SessionPinningFilters?: string[] | null;
  InitQuery?: string | null;
}
function ConnectionPoolConfiguration_Serialize(body: URLSearchParams, prefix: string, params: ConnectionPoolConfiguration) {
    if ("MaxConnectionsPercent" in params) body.append(prefix+".MaxConnectionsPercent", (params["MaxConnectionsPercent"] ?? '').toString());
    if ("MaxIdleConnectionsPercent" in params) body.append(prefix+".MaxIdleConnectionsPercent", (params["MaxIdleConnectionsPercent"] ?? '').toString());
    if ("ConnectionBorrowTimeout" in params) body.append(prefix+".ConnectionBorrowTimeout", (params["ConnectionBorrowTimeout"] ?? '').toString());
    if (params["SessionPinningFilters"]) prt.appendList(body, prefix+".SessionPinningFilters", params["SessionPinningFilters"], {"entryPrefix":".member."})
    if ("InitQuery" in params) body.append(prefix+".InitQuery", (params["InitQuery"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface OptionConfiguration {
  OptionName: string;
  Port?: number | null;
  OptionVersion?: string | null;
  DBSecurityGroupMemberships?: string[] | null;
  VpcSecurityGroupMemberships?: string[] | null;
  OptionSettings?: OptionSetting[] | null;
}
function OptionConfiguration_Serialize(body: URLSearchParams, prefix: string, params: OptionConfiguration) {
    body.append(prefix+".OptionName", (params["OptionName"] ?? '').toString());
    if ("Port" in params) body.append(prefix+".Port", (params["Port"] ?? '').toString());
    if ("OptionVersion" in params) body.append(prefix+".OptionVersion", (params["OptionVersion"] ?? '').toString());
    if (params["DBSecurityGroupMemberships"]) prt.appendList(body, prefix+".DBSecurityGroupMemberships", params["DBSecurityGroupMemberships"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupMemberships"]) prt.appendList(body, prefix+".VpcSecurityGroupMemberships", params["VpcSecurityGroupMemberships"], {"entryPrefix":".VpcSecurityGroupId."})
    if (params["OptionSettings"]) prt.appendList(body, prefix+".OptionSettings", params["OptionSettings"], {"appender":OptionSetting_Serialize,"entryPrefix":".OptionSetting."})
}

// refs: 5 - tags: input, named, interface, output
export interface OptionSetting {
  Name?: string | null;
  Value?: string | null;
  DefaultValue?: string | null;
  Description?: string | null;
  ApplyType?: string | null;
  DataType?: string | null;
  AllowedValues?: string | null;
  IsModifiable?: boolean | null;
  IsCollection?: boolean | null;
}
function OptionSetting_Serialize(body: URLSearchParams, prefix: string, params: OptionSetting) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("ApplyType" in params) body.append(prefix+".ApplyType", (params["ApplyType"] ?? '').toString());
    if ("DataType" in params) body.append(prefix+".DataType", (params["DataType"] ?? '').toString());
    if ("AllowedValues" in params) body.append(prefix+".AllowedValues", (params["AllowedValues"] ?? '').toString());
    if ("IsModifiable" in params) body.append(prefix+".IsModifiable", (params["IsModifiable"] ?? '').toString());
    if ("IsCollection" in params) body.append(prefix+".IsCollection", (params["IsCollection"] ?? '').toString());
}
function OptionSetting_Parse(node: XmlNode): OptionSetting {
  return {
    ...node.strings({
      optional: {"Name":true,"Value":true,"DefaultValue":true,"Description":true,"ApplyType":true,"DataType":true,"AllowedValues":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    IsCollection: node.first("IsCollection", false, x => x.content === 'true'),
  };
}

// refs: 13 - tags: input, named, enum, output
export type ActivityStreamMode =
| "sync"
| "async"
;



// refs: 6 - tags: output, named, interface
export interface EventSubscription {
  CustomerAwsId?: string | null;
  CustSubscriptionId?: string | null;
  SnsTopicArn?: string | null;
  Status?: string | null;
  SubscriptionCreationTime?: string | null;
  SourceType?: string | null;
  SourceIdsList: string[];
  EventCategoriesList: string[];
  Enabled?: boolean | null;
  EventSubscriptionArn?: string | null;
}
function EventSubscription_Parse(node: XmlNode): EventSubscription {
  return {
    ...node.strings({
      optional: {"CustomerAwsId":true,"CustSubscriptionId":true,"SnsTopicArn":true,"Status":true,"SubscriptionCreationTime":true,"SourceType":true,"EventSubscriptionArn":true},
    }),
    SourceIdsList: node.getList("SourceIdsList", "SourceId").map(x => x.content ?? ''),
    EventCategoriesList: node.getList("EventCategoriesList", "EventCategory").map(x => x.content ?? ''),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface ResourcePendingMaintenanceActions {
  ResourceIdentifier?: string | null;
  PendingMaintenanceActionDetails: PendingMaintenanceAction[];
}
function ResourcePendingMaintenanceActions_Parse(node: XmlNode): ResourcePendingMaintenanceActions {
  return {
    ...node.strings({
      optional: {"ResourceIdentifier":true},
    }),
    PendingMaintenanceActionDetails: node.getList("PendingMaintenanceActionDetails", "PendingMaintenanceAction").map(PendingMaintenanceAction_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface PendingMaintenanceAction {
  Action?: string | null;
  AutoAppliedAfterDate?: Date | number | null;
  ForcedApplyDate?: Date | number | null;
  OptInStatus?: string | null;
  CurrentApplyDate?: Date | number | null;
  Description?: string | null;
}
function PendingMaintenanceAction_Parse(node: XmlNode): PendingMaintenanceAction {
  return {
    ...node.strings({
      optional: {"Action":true,"OptInStatus":true,"Description":true},
    }),
    AutoAppliedAfterDate: node.first("AutoAppliedAfterDate", false, x => parseTimestamp(x.content)),
    ForcedApplyDate: node.first("ForcedApplyDate", false, x => parseTimestamp(x.content)),
    CurrentApplyDate: node.first("CurrentApplyDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 4 - tags: output, named, interface
export interface DBSecurityGroup {
  OwnerId?: string | null;
  DBSecurityGroupName?: string | null;
  DBSecurityGroupDescription?: string | null;
  VpcId?: string | null;
  EC2SecurityGroups: EC2SecurityGroup[];
  IPRanges: IPRange[];
  DBSecurityGroupArn?: string | null;
}
function DBSecurityGroup_Parse(node: XmlNode): DBSecurityGroup {
  return {
    ...node.strings({
      optional: {"OwnerId":true,"DBSecurityGroupName":true,"DBSecurityGroupDescription":true,"VpcId":true,"DBSecurityGroupArn":true},
    }),
    EC2SecurityGroups: node.getList("EC2SecurityGroups", "EC2SecurityGroup").map(EC2SecurityGroup_Parse),
    IPRanges: node.getList("IPRanges", "IPRange").map(IPRange_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface EC2SecurityGroup {
  Status?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupId?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
}
function EC2SecurityGroup_Parse(node: XmlNode): EC2SecurityGroup {
  return node.strings({
    optional: {"Status":true,"EC2SecurityGroupName":true,"EC2SecurityGroupId":true,"EC2SecurityGroupOwnerId":true},
  });
}

// refs: 4 - tags: output, named, interface
export interface IPRange {
  Status?: string | null;
  CIDRIP?: string | null;
}
function IPRange_Parse(node: XmlNode): IPRange {
  return node.strings({
    optional: {"Status":true,"CIDRIP":true},
  });
}

// refs: 3 - tags: output, named, interface
export interface DBClusterParameterGroup {
  DBClusterParameterGroupName?: string | null;
  DBParameterGroupFamily?: string | null;
  Description?: string | null;
  DBClusterParameterGroupArn?: string | null;
}
function DBClusterParameterGroup_Parse(node: XmlNode): DBClusterParameterGroup {
  return node.strings({
    optional: {"DBClusterParameterGroupName":true,"DBParameterGroupFamily":true,"Description":true,"DBClusterParameterGroupArn":true},
  });
}

// refs: 4 - tags: output, named, interface
export interface DBClusterSnapshot {
  AvailabilityZones: string[];
  DBClusterSnapshotIdentifier?: string | null;
  DBClusterIdentifier?: string | null;
  SnapshotCreateTime?: Date | number | null;
  Engine?: string | null;
  AllocatedStorage?: number | null;
  Status?: string | null;
  Port?: number | null;
  VpcId?: string | null;
  ClusterCreateTime?: Date | number | null;
  MasterUsername?: string | null;
  EngineVersion?: string | null;
  LicenseModel?: string | null;
  SnapshotType?: string | null;
  PercentProgress?: number | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  DBClusterSnapshotArn?: string | null;
  SourceDBClusterSnapshotArn?: string | null;
  IAMDatabaseAuthenticationEnabled?: boolean | null;
}
function DBClusterSnapshot_Parse(node: XmlNode): DBClusterSnapshot {
  return {
    ...node.strings({
      optional: {"DBClusterSnapshotIdentifier":true,"DBClusterIdentifier":true,"Engine":true,"Status":true,"VpcId":true,"MasterUsername":true,"EngineVersion":true,"LicenseModel":true,"SnapshotType":true,"KmsKeyId":true,"DBClusterSnapshotArn":true,"SourceDBClusterSnapshotArn":true},
    }),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(x => x.content ?? ''),
    SnapshotCreateTime: node.first("SnapshotCreateTime", false, x => parseTimestamp(x.content)),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    ClusterCreateTime: node.first("ClusterCreateTime", false, x => parseTimestamp(x.content)),
    PercentProgress: node.first("PercentProgress", false, x => parseInt(x.content ?? '0')),
    StorageEncrypted: node.first("StorageEncrypted", false, x => x.content === 'true'),
    IAMDatabaseAuthenticationEnabled: node.first("IAMDatabaseAuthenticationEnabled", false, x => x.content === 'true'),
  };
}

// refs: 3 - tags: output, named, interface
export interface DBParameterGroup {
  DBParameterGroupName?: string | null;
  DBParameterGroupFamily?: string | null;
  Description?: string | null;
  DBParameterGroupArn?: string | null;
}
function DBParameterGroup_Parse(node: XmlNode): DBParameterGroup {
  return node.strings({
    optional: {"DBParameterGroupName":true,"DBParameterGroupFamily":true,"Description":true,"DBParameterGroupArn":true},
  });
}

// refs: 5 - tags: output, named, interface
export interface DBSnapshot {
  DBSnapshotIdentifier?: string | null;
  DBInstanceIdentifier?: string | null;
  SnapshotCreateTime?: Date | number | null;
  Engine?: string | null;
  AllocatedStorage?: number | null;
  Status?: string | null;
  Port?: number | null;
  AvailabilityZone?: string | null;
  VpcId?: string | null;
  InstanceCreateTime?: Date | number | null;
  MasterUsername?: string | null;
  EngineVersion?: string | null;
  LicenseModel?: string | null;
  SnapshotType?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  PercentProgress?: number | null;
  SourceRegion?: string | null;
  SourceDBSnapshotIdentifier?: string | null;
  StorageType?: string | null;
  TdeCredentialArn?: string | null;
  Encrypted?: boolean | null;
  KmsKeyId?: string | null;
  DBSnapshotArn?: string | null;
  Timezone?: string | null;
  IAMDatabaseAuthenticationEnabled?: boolean | null;
  ProcessorFeatures: ProcessorFeature[];
  DbiResourceId?: string | null;
}
function DBSnapshot_Parse(node: XmlNode): DBSnapshot {
  return {
    ...node.strings({
      optional: {"DBSnapshotIdentifier":true,"DBInstanceIdentifier":true,"Engine":true,"Status":true,"AvailabilityZone":true,"VpcId":true,"MasterUsername":true,"EngineVersion":true,"LicenseModel":true,"SnapshotType":true,"OptionGroupName":true,"SourceRegion":true,"SourceDBSnapshotIdentifier":true,"StorageType":true,"TdeCredentialArn":true,"KmsKeyId":true,"DBSnapshotArn":true,"Timezone":true,"DbiResourceId":true},
    }),
    SnapshotCreateTime: node.first("SnapshotCreateTime", false, x => parseTimestamp(x.content)),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    InstanceCreateTime: node.first("InstanceCreateTime", false, x => parseTimestamp(x.content)),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    PercentProgress: node.first("PercentProgress", false, x => parseInt(x.content ?? '0')),
    Encrypted: node.first("Encrypted", false, x => x.content === 'true'),
    IAMDatabaseAuthenticationEnabled: node.first("IAMDatabaseAuthenticationEnabled", false, x => x.content === 'true'),
    ProcessorFeatures: node.getList("ProcessorFeatures", "ProcessorFeature").map(ProcessorFeature_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface OptionGroup {
  OptionGroupName?: string | null;
  OptionGroupDescription?: string | null;
  EngineName?: string | null;
  MajorEngineVersion?: string | null;
  Options: Option[];
  AllowsVpcAndNonVpcInstanceMemberships?: boolean | null;
  VpcId?: string | null;
  OptionGroupArn?: string | null;
}
function OptionGroup_Parse(node: XmlNode): OptionGroup {
  return {
    ...node.strings({
      optional: {"OptionGroupName":true,"OptionGroupDescription":true,"EngineName":true,"MajorEngineVersion":true,"VpcId":true,"OptionGroupArn":true},
    }),
    Options: node.getList("Options", "Option").map(Option_Parse),
    AllowsVpcAndNonVpcInstanceMemberships: node.first("AllowsVpcAndNonVpcInstanceMemberships", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: output, named, interface
export interface Option {
  OptionName?: string | null;
  OptionDescription?: string | null;
  Persistent?: boolean | null;
  Permanent?: boolean | null;
  Port?: number | null;
  OptionVersion?: string | null;
  OptionSettings: OptionSetting[];
  DBSecurityGroupMemberships: DBSecurityGroupMembership[];
  VpcSecurityGroupMemberships: VpcSecurityGroupMembership[];
}
function Option_Parse(node: XmlNode): Option {
  return {
    ...node.strings({
      optional: {"OptionName":true,"OptionDescription":true,"OptionVersion":true},
    }),
    Persistent: node.first("Persistent", false, x => x.content === 'true'),
    Permanent: node.first("Permanent", false, x => x.content === 'true'),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    OptionSettings: node.getList("OptionSettings", "OptionSetting").map(OptionSetting_Parse),
    DBSecurityGroupMemberships: node.getList("DBSecurityGroupMemberships", "DBSecurityGroup").map(DBSecurityGroupMembership_Parse),
    VpcSecurityGroupMemberships: node.getList("VpcSecurityGroupMemberships", "VpcSecurityGroupMembership").map(VpcSecurityGroupMembership_Parse),
  };
}

// refs: 16 - tags: output, named, interface
export interface DBSecurityGroupMembership {
  DBSecurityGroupName?: string | null;
  Status?: string | null;
}
function DBSecurityGroupMembership_Parse(node: XmlNode): DBSecurityGroupMembership {
  return node.strings({
    optional: {"DBSecurityGroupName":true,"Status":true},
  });
}

// refs: 27 - tags: output, named, interface
export interface VpcSecurityGroupMembership {
  VpcSecurityGroupId?: string | null;
  Status?: string | null;
}
function VpcSecurityGroupMembership_Parse(node: XmlNode): VpcSecurityGroupMembership {
  return node.strings({
    optional: {"VpcSecurityGroupId":true,"Status":true},
  });
}

// refs: 3 - tags: output, named, interface
export interface CustomAvailabilityZone {
  CustomAvailabilityZoneId?: string | null;
  CustomAvailabilityZoneName?: string | null;
  CustomAvailabilityZoneStatus?: string | null;
  VpnDetails?: VpnDetails | null;
}
function CustomAvailabilityZone_Parse(node: XmlNode): CustomAvailabilityZone {
  return {
    ...node.strings({
      optional: {"CustomAvailabilityZoneId":true,"CustomAvailabilityZoneName":true,"CustomAvailabilityZoneStatus":true},
    }),
    VpnDetails: node.first("VpnDetails", false, VpnDetails_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface VpnDetails {
  VpnId?: string | null;
  VpnTunnelOriginatorIP?: string | null;
  VpnGatewayIp?: string | null;
  VpnPSK?: string | null;
  VpnName?: string | null;
  VpnState?: string | null;
}
function VpnDetails_Parse(node: XmlNode): VpnDetails {
  return node.strings({
    optional: {"VpnId":true,"VpnTunnelOriginatorIP":true,"VpnGatewayIp":true,"VpnPSK":true,"VpnName":true,"VpnState":true},
  });
}

// refs: 11 - tags: output, named, interface
export interface DBCluster {
  AllocatedStorage?: number | null;
  AvailabilityZones: string[];
  BackupRetentionPeriod?: number | null;
  CharacterSetName?: string | null;
  DatabaseName?: string | null;
  DBClusterIdentifier?: string | null;
  DBClusterParameterGroup?: string | null;
  DBSubnetGroup?: string | null;
  Status?: string | null;
  PercentProgress?: string | null;
  EarliestRestorableTime?: Date | number | null;
  Endpoint?: string | null;
  ReaderEndpoint?: string | null;
  CustomEndpoints: string[];
  MultiAZ?: boolean | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  LatestRestorableTime?: Date | number | null;
  Port?: number | null;
  MasterUsername?: string | null;
  DBClusterOptionGroupMemberships: DBClusterOptionGroupStatus[];
  PreferredBackupWindow?: string | null;
  PreferredMaintenanceWindow?: string | null;
  ReplicationSourceIdentifier?: string | null;
  ReadReplicaIdentifiers: string[];
  DBClusterMembers: DBClusterMember[];
  VpcSecurityGroups: VpcSecurityGroupMembership[];
  HostedZoneId?: string | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  DbClusterResourceId?: string | null;
  DBClusterArn?: string | null;
  AssociatedRoles: DBClusterRole[];
  IAMDatabaseAuthenticationEnabled?: boolean | null;
  CloneGroupId?: string | null;
  ClusterCreateTime?: Date | number | null;
  EarliestBacktrackTime?: Date | number | null;
  BacktrackWindow?: number | null;
  BacktrackConsumedChangeRecords?: number | null;
  EnabledCloudwatchLogsExports: string[];
  Capacity?: number | null;
  EngineMode?: string | null;
  ScalingConfigurationInfo?: ScalingConfigurationInfo | null;
  DeletionProtection?: boolean | null;
  HttpEndpointEnabled?: boolean | null;
  ActivityStreamMode?: ActivityStreamMode | null;
  ActivityStreamStatus?: ActivityStreamStatus | null;
  ActivityStreamKmsKeyId?: string | null;
  ActivityStreamKinesisStreamName?: string | null;
  CopyTagsToSnapshot?: boolean | null;
  CrossAccountClone?: boolean | null;
  DomainMemberships: DomainMembership[];
  GlobalWriteForwardingStatus?: WriteForwardingStatus | null;
  GlobalWriteForwardingRequested?: boolean | null;
}
function DBCluster_Parse(node: XmlNode): DBCluster {
  return {
    ...node.strings({
      optional: {"CharacterSetName":true,"DatabaseName":true,"DBClusterIdentifier":true,"DBClusterParameterGroup":true,"DBSubnetGroup":true,"Status":true,"PercentProgress":true,"Endpoint":true,"ReaderEndpoint":true,"Engine":true,"EngineVersion":true,"MasterUsername":true,"PreferredBackupWindow":true,"PreferredMaintenanceWindow":true,"ReplicationSourceIdentifier":true,"HostedZoneId":true,"KmsKeyId":true,"DbClusterResourceId":true,"DBClusterArn":true,"CloneGroupId":true,"EngineMode":true,"ActivityStreamKmsKeyId":true,"ActivityStreamKinesisStreamName":true},
    }),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(x => x.content ?? ''),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    EarliestRestorableTime: node.first("EarliestRestorableTime", false, x => parseTimestamp(x.content)),
    CustomEndpoints: node.getList("CustomEndpoints", "member").map(x => x.content ?? ''),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    LatestRestorableTime: node.first("LatestRestorableTime", false, x => parseTimestamp(x.content)),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    DBClusterOptionGroupMemberships: node.getList("DBClusterOptionGroupMemberships", "DBClusterOptionGroup").map(DBClusterOptionGroupStatus_Parse),
    ReadReplicaIdentifiers: node.getList("ReadReplicaIdentifiers", "ReadReplicaIdentifier").map(x => x.content ?? ''),
    DBClusterMembers: node.getList("DBClusterMembers", "DBClusterMember").map(DBClusterMember_Parse),
    VpcSecurityGroups: node.getList("VpcSecurityGroups", "VpcSecurityGroupMembership").map(VpcSecurityGroupMembership_Parse),
    StorageEncrypted: node.first("StorageEncrypted", false, x => x.content === 'true'),
    AssociatedRoles: node.getList("AssociatedRoles", "DBClusterRole").map(DBClusterRole_Parse),
    IAMDatabaseAuthenticationEnabled: node.first("IAMDatabaseAuthenticationEnabled", false, x => x.content === 'true'),
    ClusterCreateTime: node.first("ClusterCreateTime", false, x => parseTimestamp(x.content)),
    EarliestBacktrackTime: node.first("EarliestBacktrackTime", false, x => parseTimestamp(x.content)),
    BacktrackWindow: node.first("BacktrackWindow", false, x => parseInt(x.content ?? '0')),
    BacktrackConsumedChangeRecords: node.first("BacktrackConsumedChangeRecords", false, x => parseInt(x.content ?? '0')),
    EnabledCloudwatchLogsExports: node.getList("EnabledCloudwatchLogsExports", "member").map(x => x.content ?? ''),
    Capacity: node.first("Capacity", false, x => parseInt(x.content ?? '0')),
    ScalingConfigurationInfo: node.first("ScalingConfigurationInfo", false, ScalingConfigurationInfo_Parse),
    DeletionProtection: node.first("DeletionProtection", false, x => x.content === 'true'),
    HttpEndpointEnabled: node.first("HttpEndpointEnabled", false, x => x.content === 'true'),
    ActivityStreamMode: node.first("ActivityStreamMode", false, x => (x.content ?? '') as ActivityStreamMode),
    ActivityStreamStatus: node.first("ActivityStreamStatus", false, x => (x.content ?? '') as ActivityStreamStatus),
    CopyTagsToSnapshot: node.first("CopyTagsToSnapshot", false, x => x.content === 'true'),
    CrossAccountClone: node.first("CrossAccountClone", false, x => x.content === 'true'),
    DomainMemberships: node.getList("DomainMemberships", "DomainMembership").map(DomainMembership_Parse),
    GlobalWriteForwardingStatus: node.first("GlobalWriteForwardingStatus", false, x => (x.content ?? '') as WriteForwardingStatus),
    GlobalWriteForwardingRequested: node.first("GlobalWriteForwardingRequested", false, x => x.content === 'true'),
  };
}

// refs: 11 - tags: output, named, interface
export interface DBClusterOptionGroupStatus {
  DBClusterOptionGroupName?: string | null;
  Status?: string | null;
}
function DBClusterOptionGroupStatus_Parse(node: XmlNode): DBClusterOptionGroupStatus {
  return node.strings({
    optional: {"DBClusterOptionGroupName":true,"Status":true},
  });
}

// refs: 11 - tags: output, named, interface
export interface DBClusterMember {
  DBInstanceIdentifier?: string | null;
  IsClusterWriter?: boolean | null;
  DBClusterParameterGroupStatus?: string | null;
  PromotionTier?: number | null;
}
function DBClusterMember_Parse(node: XmlNode): DBClusterMember {
  return {
    ...node.strings({
      optional: {"DBInstanceIdentifier":true,"DBClusterParameterGroupStatus":true},
    }),
    IsClusterWriter: node.first("IsClusterWriter", false, x => x.content === 'true'),
    PromotionTier: node.first("PromotionTier", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 11 - tags: output, named, interface
export interface DBClusterRole {
  RoleArn?: string | null;
  Status?: string | null;
  FeatureName?: string | null;
}
function DBClusterRole_Parse(node: XmlNode): DBClusterRole {
  return node.strings({
    optional: {"RoleArn":true,"Status":true,"FeatureName":true},
  });
}

// refs: 11 - tags: output, named, interface
export interface ScalingConfigurationInfo {
  MinCapacity?: number | null;
  MaxCapacity?: number | null;
  AutoPause?: boolean | null;
  SecondsUntilAutoPause?: number | null;
  TimeoutAction?: string | null;
}
function ScalingConfigurationInfo_Parse(node: XmlNode): ScalingConfigurationInfo {
  return {
    ...node.strings({
      optional: {"TimeoutAction":true},
    }),
    MinCapacity: node.first("MinCapacity", false, x => parseInt(x.content ?? '0')),
    MaxCapacity: node.first("MaxCapacity", false, x => parseInt(x.content ?? '0')),
    AutoPause: node.first("AutoPause", false, x => x.content === 'true'),
    SecondsUntilAutoPause: node.first("SecondsUntilAutoPause", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 13 - tags: output, named, enum
export type ActivityStreamStatus =
| "stopped"
| "starting"
| "started"
| "stopping"
;


// refs: 23 - tags: output, named, interface
export interface DomainMembership {
  Domain?: string | null;
  Status?: string | null;
  FQDN?: string | null;
  IAMRoleName?: string | null;
}
function DomainMembership_Parse(node: XmlNode): DomainMembership {
  return node.strings({
    optional: {"Domain":true,"Status":true,"FQDN":true,"IAMRoleName":true},
  });
}

// refs: 16 - tags: output, named, enum
export type WriteForwardingStatus =
| "enabled"
| "disabled"
| "enabling"
| "disabling"
| "unknown"
;


// refs: 12 - tags: output, named, interface
export interface DBInstance {
  DBInstanceIdentifier?: string | null;
  DBInstanceClass?: string | null;
  Engine?: string | null;
  DBInstanceStatus?: string | null;
  MasterUsername?: string | null;
  DBName?: string | null;
  Endpoint?: Endpoint | null;
  AllocatedStorage?: number | null;
  InstanceCreateTime?: Date | number | null;
  PreferredBackupWindow?: string | null;
  BackupRetentionPeriod?: number | null;
  DBSecurityGroups: DBSecurityGroupMembership[];
  VpcSecurityGroups: VpcSecurityGroupMembership[];
  DBParameterGroups: DBParameterGroupStatus[];
  AvailabilityZone?: string | null;
  DBSubnetGroup?: DBSubnetGroup | null;
  PreferredMaintenanceWindow?: string | null;
  PendingModifiedValues?: PendingModifiedValues | null;
  LatestRestorableTime?: Date | number | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  ReadReplicaSourceDBInstanceIdentifier?: string | null;
  ReadReplicaDBInstanceIdentifiers: string[];
  ReadReplicaDBClusterIdentifiers: string[];
  ReplicaMode?: ReplicaMode | null;
  LicenseModel?: string | null;
  Iops?: number | null;
  OptionGroupMemberships: OptionGroupMembership[];
  CharacterSetName?: string | null;
  NcharCharacterSetName?: string | null;
  SecondaryAvailabilityZone?: string | null;
  PubliclyAccessible?: boolean | null;
  StatusInfos: DBInstanceStatusInfo[];
  StorageType?: string | null;
  TdeCredentialArn?: string | null;
  DbInstancePort?: number | null;
  DBClusterIdentifier?: string | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  DbiResourceId?: string | null;
  CACertificateIdentifier?: string | null;
  DomainMemberships: DomainMembership[];
  CopyTagsToSnapshot?: boolean | null;
  MonitoringInterval?: number | null;
  EnhancedMonitoringResourceArn?: string | null;
  MonitoringRoleArn?: string | null;
  PromotionTier?: number | null;
  DBInstanceArn?: string | null;
  Timezone?: string | null;
  IAMDatabaseAuthenticationEnabled?: boolean | null;
  PerformanceInsightsEnabled?: boolean | null;
  PerformanceInsightsKMSKeyId?: string | null;
  PerformanceInsightsRetentionPeriod?: number | null;
  EnabledCloudwatchLogsExports: string[];
  ProcessorFeatures: ProcessorFeature[];
  DeletionProtection?: boolean | null;
  AssociatedRoles: DBInstanceRole[];
  ListenerEndpoint?: Endpoint | null;
  MaxAllocatedStorage?: number | null;
}
function DBInstance_Parse(node: XmlNode): DBInstance {
  return {
    ...node.strings({
      optional: {"DBInstanceIdentifier":true,"DBInstanceClass":true,"Engine":true,"DBInstanceStatus":true,"MasterUsername":true,"DBName":true,"PreferredBackupWindow":true,"AvailabilityZone":true,"PreferredMaintenanceWindow":true,"EngineVersion":true,"ReadReplicaSourceDBInstanceIdentifier":true,"LicenseModel":true,"CharacterSetName":true,"NcharCharacterSetName":true,"SecondaryAvailabilityZone":true,"StorageType":true,"TdeCredentialArn":true,"DBClusterIdentifier":true,"KmsKeyId":true,"DbiResourceId":true,"CACertificateIdentifier":true,"EnhancedMonitoringResourceArn":true,"MonitoringRoleArn":true,"DBInstanceArn":true,"Timezone":true,"PerformanceInsightsKMSKeyId":true},
    }),
    Endpoint: node.first("Endpoint", false, Endpoint_Parse),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    InstanceCreateTime: node.first("InstanceCreateTime", false, x => parseTimestamp(x.content)),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    DBSecurityGroups: node.getList("DBSecurityGroups", "DBSecurityGroup").map(DBSecurityGroupMembership_Parse),
    VpcSecurityGroups: node.getList("VpcSecurityGroups", "VpcSecurityGroupMembership").map(VpcSecurityGroupMembership_Parse),
    DBParameterGroups: node.getList("DBParameterGroups", "DBParameterGroup").map(DBParameterGroupStatus_Parse),
    DBSubnetGroup: node.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    PendingModifiedValues: node.first("PendingModifiedValues", false, PendingModifiedValues_Parse),
    LatestRestorableTime: node.first("LatestRestorableTime", false, x => parseTimestamp(x.content)),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    AutoMinorVersionUpgrade: node.first("AutoMinorVersionUpgrade", false, x => x.content === 'true'),
    ReadReplicaDBInstanceIdentifiers: node.getList("ReadReplicaDBInstanceIdentifiers", "ReadReplicaDBInstanceIdentifier").map(x => x.content ?? ''),
    ReadReplicaDBClusterIdentifiers: node.getList("ReadReplicaDBClusterIdentifiers", "ReadReplicaDBClusterIdentifier").map(x => x.content ?? ''),
    ReplicaMode: node.first("ReplicaMode", false, x => (x.content ?? '') as ReplicaMode),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    OptionGroupMemberships: node.getList("OptionGroupMemberships", "OptionGroupMembership").map(OptionGroupMembership_Parse),
    PubliclyAccessible: node.first("PubliclyAccessible", false, x => x.content === 'true'),
    StatusInfos: node.getList("StatusInfos", "DBInstanceStatusInfo").map(DBInstanceStatusInfo_Parse),
    DbInstancePort: node.first("DbInstancePort", false, x => parseInt(x.content ?? '0')),
    StorageEncrypted: node.first("StorageEncrypted", false, x => x.content === 'true'),
    DomainMemberships: node.getList("DomainMemberships", "DomainMembership").map(DomainMembership_Parse),
    CopyTagsToSnapshot: node.first("CopyTagsToSnapshot", false, x => x.content === 'true'),
    MonitoringInterval: node.first("MonitoringInterval", false, x => parseInt(x.content ?? '0')),
    PromotionTier: node.first("PromotionTier", false, x => parseInt(x.content ?? '0')),
    IAMDatabaseAuthenticationEnabled: node.first("IAMDatabaseAuthenticationEnabled", false, x => x.content === 'true'),
    PerformanceInsightsEnabled: node.first("PerformanceInsightsEnabled", false, x => x.content === 'true'),
    PerformanceInsightsRetentionPeriod: node.first("PerformanceInsightsRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    EnabledCloudwatchLogsExports: node.getList("EnabledCloudwatchLogsExports", "member").map(x => x.content ?? ''),
    ProcessorFeatures: node.getList("ProcessorFeatures", "ProcessorFeature").map(ProcessorFeature_Parse),
    DeletionProtection: node.first("DeletionProtection", false, x => x.content === 'true'),
    AssociatedRoles: node.getList("AssociatedRoles", "DBInstanceRole").map(DBInstanceRole_Parse),
    ListenerEndpoint: node.first("ListenerEndpoint", false, Endpoint_Parse),
    MaxAllocatedStorage: node.first("MaxAllocatedStorage", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 24 - tags: output, named, interface
export interface Endpoint {
  Address?: string | null;
  Port?: number | null;
  HostedZoneId?: string | null;
}
function Endpoint_Parse(node: XmlNode): Endpoint {
  return {
    ...node.strings({
      optional: {"Address":true,"HostedZoneId":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 12 - tags: output, named, interface
export interface DBParameterGroupStatus {
  DBParameterGroupName?: string | null;
  ParameterApplyStatus?: string | null;
}
function DBParameterGroupStatus_Parse(node: XmlNode): DBParameterGroupStatus {
  return node.strings({
    optional: {"DBParameterGroupName":true,"ParameterApplyStatus":true},
  });
}

// refs: 15 - tags: output, named, interface
export interface DBSubnetGroup {
  DBSubnetGroupName?: string | null;
  DBSubnetGroupDescription?: string | null;
  VpcId?: string | null;
  SubnetGroupStatus?: string | null;
  Subnets: Subnet[];
  DBSubnetGroupArn?: string | null;
}
function DBSubnetGroup_Parse(node: XmlNode): DBSubnetGroup {
  return {
    ...node.strings({
      optional: {"DBSubnetGroupName":true,"DBSubnetGroupDescription":true,"VpcId":true,"SubnetGroupStatus":true,"DBSubnetGroupArn":true},
    }),
    Subnets: node.getList("Subnets", "Subnet").map(Subnet_Parse),
  };
}

// refs: 15 - tags: output, named, interface
export interface Subnet {
  SubnetIdentifier?: string | null;
  SubnetAvailabilityZone?: AvailabilityZone | null;
  SubnetOutpost?: Outpost | null;
  SubnetStatus?: string | null;
}
function Subnet_Parse(node: XmlNode): Subnet {
  return {
    ...node.strings({
      optional: {"SubnetIdentifier":true,"SubnetStatus":true},
    }),
    SubnetAvailabilityZone: node.first("SubnetAvailabilityZone", false, AvailabilityZone_Parse),
    SubnetOutpost: node.first("SubnetOutpost", false, Outpost_Parse),
  };
}

// refs: 16 - tags: output, named, interface
export interface AvailabilityZone {
  Name?: string | null;
}
function AvailabilityZone_Parse(node: XmlNode): AvailabilityZone {
  return node.strings({
    optional: {"Name":true},
  });
}

// refs: 15 - tags: output, named, interface
export interface Outpost {
  Arn?: string | null;
}
function Outpost_Parse(node: XmlNode): Outpost {
  return node.strings({
    optional: {"Arn":true},
  });
}

// refs: 12 - tags: output, named, interface
export interface PendingModifiedValues {
  DBInstanceClass?: string | null;
  AllocatedStorage?: number | null;
  MasterUserPassword?: string | null;
  Port?: number | null;
  BackupRetentionPeriod?: number | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  LicenseModel?: string | null;
  Iops?: number | null;
  DBInstanceIdentifier?: string | null;
  StorageType?: string | null;
  CACertificateIdentifier?: string | null;
  DBSubnetGroupName?: string | null;
  PendingCloudwatchLogsExports?: PendingCloudwatchLogsExports | null;
  ProcessorFeatures: ProcessorFeature[];
}
function PendingModifiedValues_Parse(node: XmlNode): PendingModifiedValues {
  return {
    ...node.strings({
      optional: {"DBInstanceClass":true,"MasterUserPassword":true,"EngineVersion":true,"LicenseModel":true,"DBInstanceIdentifier":true,"StorageType":true,"CACertificateIdentifier":true,"DBSubnetGroupName":true},
    }),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    PendingCloudwatchLogsExports: node.first("PendingCloudwatchLogsExports", false, PendingCloudwatchLogsExports_Parse),
    ProcessorFeatures: node.getList("ProcessorFeatures", "ProcessorFeature").map(ProcessorFeature_Parse),
  };
}

// refs: 12 - tags: output, named, interface
export interface PendingCloudwatchLogsExports {
  LogTypesToEnable: string[];
  LogTypesToDisable: string[];
}
function PendingCloudwatchLogsExports_Parse(node: XmlNode): PendingCloudwatchLogsExports {
  return {
    LogTypesToEnable: node.getList("LogTypesToEnable", "member").map(x => x.content ?? ''),
    LogTypesToDisable: node.getList("LogTypesToDisable", "member").map(x => x.content ?? ''),
  };
}

// refs: 12 - tags: output, named, interface
export interface OptionGroupMembership {
  OptionGroupName?: string | null;
  Status?: string | null;
}
function OptionGroupMembership_Parse(node: XmlNode): OptionGroupMembership {
  return node.strings({
    optional: {"OptionGroupName":true,"Status":true},
  });
}

// refs: 12 - tags: output, named, interface
export interface DBInstanceStatusInfo {
  StatusType?: string | null;
  Normal?: boolean | null;
  Status?: string | null;
  Message?: string | null;
}
function DBInstanceStatusInfo_Parse(node: XmlNode): DBInstanceStatusInfo {
  return {
    ...node.strings({
      optional: {"StatusType":true,"Status":true,"Message":true},
    }),
    Normal: node.first("Normal", false, x => x.content === 'true'),
  };
}

// refs: 12 - tags: output, named, interface
export interface DBInstanceRole {
  RoleArn?: string | null;
  FeatureName?: string | null;
  Status?: string | null;
}
function DBInstanceRole_Parse(node: XmlNode): DBInstanceRole {
  return node.strings({
    optional: {"RoleArn":true,"FeatureName":true,"Status":true},
  });
}

// refs: 4 - tags: output, named, interface
export interface DBProxy {
  DBProxyName?: string | null;
  DBProxyArn?: string | null;
  Status?: DBProxyStatus | null;
  EngineFamily?: string | null;
  VpcSecurityGroupIds: string[];
  VpcSubnetIds: string[];
  Auth: UserAuthConfigInfo[];
  RoleArn?: string | null;
  Endpoint?: string | null;
  RequireTLS?: boolean | null;
  IdleClientTimeout?: number | null;
  DebugLogging?: boolean | null;
  CreatedDate?: Date | number | null;
  UpdatedDate?: Date | number | null;
}
function DBProxy_Parse(node: XmlNode): DBProxy {
  return {
    ...node.strings({
      optional: {"DBProxyName":true,"DBProxyArn":true,"EngineFamily":true,"RoleArn":true,"Endpoint":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as DBProxyStatus),
    VpcSecurityGroupIds: node.getList("VpcSecurityGroupIds", "member").map(x => x.content ?? ''),
    VpcSubnetIds: node.getList("VpcSubnetIds", "member").map(x => x.content ?? ''),
    Auth: node.getList("Auth", "member").map(UserAuthConfigInfo_Parse),
    RequireTLS: node.first("RequireTLS", false, x => x.content === 'true'),
    IdleClientTimeout: node.first("IdleClientTimeout", false, x => parseInt(x.content ?? '0')),
    DebugLogging: node.first("DebugLogging", false, x => x.content === 'true'),
    CreatedDate: node.first("CreatedDate", false, x => parseTimestamp(x.content)),
    UpdatedDate: node.first("UpdatedDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 4 - tags: output, named, enum
export type DBProxyStatus =
| "available"
| "modifying"
| "incompatible-network"
| "insufficient-resource-limits"
| "creating"
| "deleting"
| "suspended"
| "suspending"
| "reactivating"
;


// refs: 4 - tags: output, named, interface
export interface UserAuthConfigInfo {
  Description?: string | null;
  UserName?: string | null;
  AuthScheme?: AuthScheme | null;
  SecretArn?: string | null;
  IAMAuth?: IAMAuthMode | null;
}
function UserAuthConfigInfo_Parse(node: XmlNode): UserAuthConfigInfo {
  return {
    ...node.strings({
      optional: {"Description":true,"UserName":true,"SecretArn":true},
    }),
    AuthScheme: node.first("AuthScheme", false, x => (x.content ?? '') as AuthScheme),
    IAMAuth: node.first("IAMAuth", false, x => (x.content ?? '') as IAMAuthMode),
  };
}

// refs: 5 - tags: output, named, interface
export interface GlobalCluster {
  GlobalClusterIdentifier?: string | null;
  GlobalClusterResourceId?: string | null;
  GlobalClusterArn?: string | null;
  Status?: string | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  DatabaseName?: string | null;
  StorageEncrypted?: boolean | null;
  DeletionProtection?: boolean | null;
  GlobalClusterMembers: GlobalClusterMember[];
}
function GlobalCluster_Parse(node: XmlNode): GlobalCluster {
  return {
    ...node.strings({
      optional: {"GlobalClusterIdentifier":true,"GlobalClusterResourceId":true,"GlobalClusterArn":true,"Status":true,"Engine":true,"EngineVersion":true,"DatabaseName":true},
    }),
    StorageEncrypted: node.first("StorageEncrypted", false, x => x.content === 'true'),
    DeletionProtection: node.first("DeletionProtection", false, x => x.content === 'true'),
    GlobalClusterMembers: node.getList("GlobalClusterMembers", "GlobalClusterMember").map(GlobalClusterMember_Parse),
  };
}

// refs: 5 - tags: output, named, interface
export interface GlobalClusterMember {
  DBClusterArn?: string | null;
  Readers: string[];
  IsWriter?: boolean | null;
  GlobalWriteForwardingStatus?: WriteForwardingStatus | null;
}
function GlobalClusterMember_Parse(node: XmlNode): GlobalClusterMember {
  return {
    ...node.strings({
      optional: {"DBClusterArn":true},
    }),
    Readers: node.getList("Readers", "member").map(x => x.content ?? ''),
    IsWriter: node.first("IsWriter", false, x => x.content === 'true'),
    GlobalWriteForwardingStatus: node.first("GlobalWriteForwardingStatus", false, x => (x.content ?? '') as WriteForwardingStatus),
  };
}

// refs: 2 - tags: output, named, interface
export interface DBInstanceAutomatedBackup {
  DBInstanceArn?: string | null;
  DbiResourceId?: string | null;
  Region?: string | null;
  DBInstanceIdentifier?: string | null;
  RestoreWindow?: RestoreWindow | null;
  AllocatedStorage?: number | null;
  Status?: string | null;
  Port?: number | null;
  AvailabilityZone?: string | null;
  VpcId?: string | null;
  InstanceCreateTime?: Date | number | null;
  MasterUsername?: string | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  LicenseModel?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  TdeCredentialArn?: string | null;
  Encrypted?: boolean | null;
  StorageType?: string | null;
  KmsKeyId?: string | null;
  Timezone?: string | null;
  IAMDatabaseAuthenticationEnabled?: boolean | null;
}
function DBInstanceAutomatedBackup_Parse(node: XmlNode): DBInstanceAutomatedBackup {
  return {
    ...node.strings({
      optional: {"DBInstanceArn":true,"DbiResourceId":true,"Region":true,"DBInstanceIdentifier":true,"Status":true,"AvailabilityZone":true,"VpcId":true,"MasterUsername":true,"Engine":true,"EngineVersion":true,"LicenseModel":true,"OptionGroupName":true,"TdeCredentialArn":true,"StorageType":true,"KmsKeyId":true,"Timezone":true},
    }),
    RestoreWindow: node.first("RestoreWindow", false, RestoreWindow_Parse),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    InstanceCreateTime: node.first("InstanceCreateTime", false, x => parseTimestamp(x.content)),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    Encrypted: node.first("Encrypted", false, x => x.content === 'true'),
    IAMDatabaseAuthenticationEnabled: node.first("IAMDatabaseAuthenticationEnabled", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface RestoreWindow {
  EarliestTime?: Date | number | null;
  LatestTime?: Date | number | null;
}
function RestoreWindow_Parse(node: XmlNode): RestoreWindow {
  return {
    EarliestTime: node.first("EarliestTime", false, x => parseTimestamp(x.content)),
    LatestTime: node.first("LatestTime", false, x => parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface InstallationMediaFailureCause {
  Message?: string | null;
}
function InstallationMediaFailureCause_Parse(node: XmlNode): InstallationMediaFailureCause {
  return node.strings({
    optional: {"Message":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface AccountQuota {
  AccountQuotaName?: string | null;
  Used?: number | null;
  Max?: number | null;
}
function AccountQuota_Parse(node: XmlNode): AccountQuota {
  return {
    ...node.strings({
      optional: {"AccountQuotaName":true},
    }),
    Used: node.first("Used", false, x => parseInt(x.content ?? '0')),
    Max: node.first("Max", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: output, named, interface
export interface Certificate {
  CertificateIdentifier?: string | null;
  CertificateType?: string | null;
  Thumbprint?: string | null;
  ValidFrom?: Date | number | null;
  ValidTill?: Date | number | null;
  CertificateArn?: string | null;
  CustomerOverride?: boolean | null;
  CustomerOverrideValidTill?: Date | number | null;
}
function Certificate_Parse(node: XmlNode): Certificate {
  return {
    ...node.strings({
      optional: {"CertificateIdentifier":true,"CertificateType":true,"Thumbprint":true,"CertificateArn":true},
    }),
    ValidFrom: node.first("ValidFrom", false, x => parseTimestamp(x.content)),
    ValidTill: node.first("ValidTill", false, x => parseTimestamp(x.content)),
    CustomerOverride: node.first("CustomerOverride", false, x => x.content === 'true'),
    CustomerOverrideValidTill: node.first("CustomerOverrideValidTill", false, x => parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface DBClusterSnapshotAttributesResult {
  DBClusterSnapshotIdentifier?: string | null;
  DBClusterSnapshotAttributes: DBClusterSnapshotAttribute[];
}
function DBClusterSnapshotAttributesResult_Parse(node: XmlNode): DBClusterSnapshotAttributesResult {
  return {
    ...node.strings({
      optional: {"DBClusterSnapshotIdentifier":true},
    }),
    DBClusterSnapshotAttributes: node.getList("DBClusterSnapshotAttributes", "DBClusterSnapshotAttribute").map(DBClusterSnapshotAttribute_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface DBClusterSnapshotAttribute {
  AttributeName?: string | null;
  AttributeValues: string[];
}
function DBClusterSnapshotAttribute_Parse(node: XmlNode): DBClusterSnapshotAttribute {
  return {
    ...node.strings({
      optional: {"AttributeName":true},
    }),
    AttributeValues: node.getList("AttributeValues", "AttributeValue").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface DBEngineVersion {
  Engine?: string | null;
  EngineVersion?: string | null;
  DBParameterGroupFamily?: string | null;
  DBEngineDescription?: string | null;
  DBEngineVersionDescription?: string | null;
  DefaultCharacterSet?: CharacterSet | null;
  SupportedCharacterSets: CharacterSet[];
  SupportedNcharCharacterSets: CharacterSet[];
  ValidUpgradeTarget: UpgradeTarget[];
  SupportedTimezones: Timezone[];
  ExportableLogTypes: string[];
  SupportsLogExportsToCloudwatchLogs?: boolean | null;
  SupportsReadReplica?: boolean | null;
  SupportedEngineModes: string[];
  SupportedFeatureNames: string[];
  Status?: string | null;
  SupportsParallelQuery?: boolean | null;
  SupportsGlobalDatabases?: boolean | null;
}
function DBEngineVersion_Parse(node: XmlNode): DBEngineVersion {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"DBParameterGroupFamily":true,"DBEngineDescription":true,"DBEngineVersionDescription":true,"Status":true},
    }),
    DefaultCharacterSet: node.first("DefaultCharacterSet", false, CharacterSet_Parse),
    SupportedCharacterSets: node.getList("SupportedCharacterSets", "CharacterSet").map(CharacterSet_Parse),
    SupportedNcharCharacterSets: node.getList("SupportedNcharCharacterSets", "CharacterSet").map(CharacterSet_Parse),
    ValidUpgradeTarget: node.getList("ValidUpgradeTarget", "UpgradeTarget").map(UpgradeTarget_Parse),
    SupportedTimezones: node.getList("SupportedTimezones", "Timezone").map(Timezone_Parse),
    ExportableLogTypes: node.getList("ExportableLogTypes", "member").map(x => x.content ?? ''),
    SupportsLogExportsToCloudwatchLogs: node.first("SupportsLogExportsToCloudwatchLogs", false, x => x.content === 'true'),
    SupportsReadReplica: node.first("SupportsReadReplica", false, x => x.content === 'true'),
    SupportedEngineModes: node.getList("SupportedEngineModes", "member").map(x => x.content ?? ''),
    SupportedFeatureNames: node.getList("SupportedFeatureNames", "member").map(x => x.content ?? ''),
    SupportsParallelQuery: node.first("SupportsParallelQuery", false, x => x.content === 'true'),
    SupportsGlobalDatabases: node.first("SupportsGlobalDatabases", false, x => x.content === 'true'),
  };
}

// refs: 3 - tags: output, named, interface
export interface CharacterSet {
  CharacterSetName?: string | null;
  CharacterSetDescription?: string | null;
}
function CharacterSet_Parse(node: XmlNode): CharacterSet {
  return node.strings({
    optional: {"CharacterSetName":true,"CharacterSetDescription":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface UpgradeTarget {
  Engine?: string | null;
  EngineVersion?: string | null;
  Description?: string | null;
  AutoUpgrade?: boolean | null;
  IsMajorVersionUpgrade?: boolean | null;
}
function UpgradeTarget_Parse(node: XmlNode): UpgradeTarget {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"Description":true},
    }),
    AutoUpgrade: node.first("AutoUpgrade", false, x => x.content === 'true'),
    IsMajorVersionUpgrade: node.first("IsMajorVersionUpgrade", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface Timezone {
  TimezoneName?: string | null;
}
function Timezone_Parse(node: XmlNode): Timezone {
  return node.strings({
    optional: {"TimezoneName":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface DescribeDBLogFilesDetails {
  LogFileName?: string | null;
  LastWritten?: number | null;
  Size?: number | null;
}
function DescribeDBLogFilesDetails_Parse(node: XmlNode): DescribeDBLogFilesDetails {
  return {
    ...node.strings({
      optional: {"LogFileName":true},
    }),
    LastWritten: node.first("LastWritten", false, x => parseInt(x.content ?? '0')),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: output, named, interface
export interface DBProxyTargetGroup {
  DBProxyName?: string | null;
  TargetGroupName?: string | null;
  TargetGroupArn?: string | null;
  IsDefault?: boolean | null;
  Status?: string | null;
  ConnectionPoolConfig?: ConnectionPoolConfigurationInfo | null;
  CreatedDate?: Date | number | null;
  UpdatedDate?: Date | number | null;
}
function DBProxyTargetGroup_Parse(node: XmlNode): DBProxyTargetGroup {
  return {
    ...node.strings({
      optional: {"DBProxyName":true,"TargetGroupName":true,"TargetGroupArn":true,"Status":true},
    }),
    IsDefault: node.first("IsDefault", false, x => x.content === 'true'),
    ConnectionPoolConfig: node.first("ConnectionPoolConfig", false, ConnectionPoolConfigurationInfo_Parse),
    CreatedDate: node.first("CreatedDate", false, x => parseTimestamp(x.content)),
    UpdatedDate: node.first("UpdatedDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface ConnectionPoolConfigurationInfo {
  MaxConnectionsPercent?: number | null;
  MaxIdleConnectionsPercent?: number | null;
  ConnectionBorrowTimeout?: number | null;
  SessionPinningFilters: string[];
  InitQuery?: string | null;
}
function ConnectionPoolConfigurationInfo_Parse(node: XmlNode): ConnectionPoolConfigurationInfo {
  return {
    ...node.strings({
      optional: {"InitQuery":true},
    }),
    MaxConnectionsPercent: node.first("MaxConnectionsPercent", false, x => parseInt(x.content ?? '0')),
    MaxIdleConnectionsPercent: node.first("MaxIdleConnectionsPercent", false, x => parseInt(x.content ?? '0')),
    ConnectionBorrowTimeout: node.first("ConnectionBorrowTimeout", false, x => parseInt(x.content ?? '0')),
    SessionPinningFilters: node.getList("SessionPinningFilters", "member").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface DBProxyTarget {
  TargetArn?: string | null;
  Endpoint?: string | null;
  TrackedClusterId?: string | null;
  RdsResourceId?: string | null;
  Port?: number | null;
  Type?: TargetType | null;
  TargetHealth?: TargetHealth | null;
}
function DBProxyTarget_Parse(node: XmlNode): DBProxyTarget {
  return {
    ...node.strings({
      optional: {"TargetArn":true,"Endpoint":true,"TrackedClusterId":true,"RdsResourceId":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    Type: node.first("Type", false, x => (x.content ?? '') as TargetType),
    TargetHealth: node.first("TargetHealth", false, TargetHealth_Parse),
  };
}

// refs: 2 - tags: output, named, enum
export type TargetType =
| "RDS_INSTANCE"
| "RDS_SERVERLESS_ENDPOINT"
| "TRACKED_CLUSTER"
;


// refs: 2 - tags: output, named, interface
export interface TargetHealth {
  State?: TargetState | null;
  Reason?: TargetHealthReason | null;
  Description?: string | null;
}
function TargetHealth_Parse(node: XmlNode): TargetHealth {
  return {
    ...node.strings({
      optional: {"Description":true},
    }),
    State: node.first("State", false, x => (x.content ?? '') as TargetState),
    Reason: node.first("Reason", false, x => (x.content ?? '') as TargetHealthReason),
  };
}

// refs: 2 - tags: output, named, enum
export type TargetState =
| "REGISTERING"
| "AVAILABLE"
| "UNAVAILABLE"
;


// refs: 2 - tags: output, named, enum
export type TargetHealthReason =
| "UNREACHABLE"
| "CONNECTION_FAILED"
| "AUTH_FAILURE"
| "PENDING_PROXY_CAPACITY"
;


// refs: 2 - tags: output, named, interface
export interface DBSnapshotAttributesResult {
  DBSnapshotIdentifier?: string | null;
  DBSnapshotAttributes: DBSnapshotAttribute[];
}
function DBSnapshotAttributesResult_Parse(node: XmlNode): DBSnapshotAttributesResult {
  return {
    ...node.strings({
      optional: {"DBSnapshotIdentifier":true},
    }),
    DBSnapshotAttributes: node.getList("DBSnapshotAttributes", "DBSnapshotAttribute").map(DBSnapshotAttribute_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface DBSnapshotAttribute {
  AttributeName?: string | null;
  AttributeValues: string[];
}
function DBSnapshotAttribute_Parse(node: XmlNode): DBSnapshotAttribute {
  return {
    ...node.strings({
      optional: {"AttributeName":true},
    }),
    AttributeValues: node.getList("AttributeValues", "AttributeValue").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface EngineDefaults {
  DBParameterGroupFamily?: string | null;
  Marker?: string | null;
  Parameters: Parameter[];
}
function EngineDefaults_Parse(node: XmlNode): EngineDefaults {
  return {
    ...node.strings({
      optional: {"DBParameterGroupFamily":true,"Marker":true},
    }),
    Parameters: node.getList("Parameters", "Parameter").map(Parameter_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface EventCategoriesMap {
  SourceType?: string | null;
  EventCategories: string[];
}
function EventCategoriesMap_Parse(node: XmlNode): EventCategoriesMap {
  return {
    ...node.strings({
      optional: {"SourceType":true},
    }),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface Event {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  Message?: string | null;
  EventCategories: string[];
  Date?: Date | number | null;
  SourceArn?: string | null;
}
function Event_Parse(node: XmlNode): Event {
  return {
    ...node.strings({
      optional: {"SourceIdentifier":true,"Message":true,"SourceArn":true},
    }),
    SourceType: node.first("SourceType", false, x => (x.content ?? '') as SourceType),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
    Date: node.first("Date", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface OptionGroupOption {
  Name?: string | null;
  Description?: string | null;
  EngineName?: string | null;
  MajorEngineVersion?: string | null;
  MinimumRequiredMinorEngineVersion?: string | null;
  PortRequired?: boolean | null;
  DefaultPort?: number | null;
  OptionsDependedOn: string[];
  OptionsConflictsWith: string[];
  Persistent?: boolean | null;
  Permanent?: boolean | null;
  RequiresAutoMinorEngineVersionUpgrade?: boolean | null;
  VpcOnly?: boolean | null;
  SupportsOptionVersionDowngrade?: boolean | null;
  OptionGroupOptionSettings: OptionGroupOptionSetting[];
  OptionGroupOptionVersions: OptionVersion[];
}
function OptionGroupOption_Parse(node: XmlNode): OptionGroupOption {
  return {
    ...node.strings({
      optional: {"Name":true,"Description":true,"EngineName":true,"MajorEngineVersion":true,"MinimumRequiredMinorEngineVersion":true},
    }),
    PortRequired: node.first("PortRequired", false, x => x.content === 'true'),
    DefaultPort: node.first("DefaultPort", false, x => parseInt(x.content ?? '0')),
    OptionsDependedOn: node.getList("OptionsDependedOn", "OptionName").map(x => x.content ?? ''),
    OptionsConflictsWith: node.getList("OptionsConflictsWith", "OptionConflictName").map(x => x.content ?? ''),
    Persistent: node.first("Persistent", false, x => x.content === 'true'),
    Permanent: node.first("Permanent", false, x => x.content === 'true'),
    RequiresAutoMinorEngineVersionUpgrade: node.first("RequiresAutoMinorEngineVersionUpgrade", false, x => x.content === 'true'),
    VpcOnly: node.first("VpcOnly", false, x => x.content === 'true'),
    SupportsOptionVersionDowngrade: node.first("SupportsOptionVersionDowngrade", false, x => x.content === 'true'),
    OptionGroupOptionSettings: node.getList("OptionGroupOptionSettings", "OptionGroupOptionSetting").map(OptionGroupOptionSetting_Parse),
    OptionGroupOptionVersions: node.getList("OptionGroupOptionVersions", "OptionVersion").map(OptionVersion_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface OptionGroupOptionSetting {
  SettingName?: string | null;
  SettingDescription?: string | null;
  DefaultValue?: string | null;
  ApplyType?: string | null;
  AllowedValues?: string | null;
  IsModifiable?: boolean | null;
  IsRequired?: boolean | null;
  MinimumEngineVersionPerAllowedValue: MinimumEngineVersionPerAllowedValue[];
}
function OptionGroupOptionSetting_Parse(node: XmlNode): OptionGroupOptionSetting {
  return {
    ...node.strings({
      optional: {"SettingName":true,"SettingDescription":true,"DefaultValue":true,"ApplyType":true,"AllowedValues":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    IsRequired: node.first("IsRequired", false, x => x.content === 'true'),
    MinimumEngineVersionPerAllowedValue: node.getList("MinimumEngineVersionPerAllowedValue", "MinimumEngineVersionPerAllowedValue").map(MinimumEngineVersionPerAllowedValue_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface MinimumEngineVersionPerAllowedValue {
  AllowedValue?: string | null;
  MinimumEngineVersion?: string | null;
}
function MinimumEngineVersionPerAllowedValue_Parse(node: XmlNode): MinimumEngineVersionPerAllowedValue {
  return node.strings({
    optional: {"AllowedValue":true,"MinimumEngineVersion":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface OptionVersion {
  Version?: string | null;
  IsDefault?: boolean | null;
}
function OptionVersion_Parse(node: XmlNode): OptionVersion {
  return {
    ...node.strings({
      optional: {"Version":true},
    }),
    IsDefault: node.first("IsDefault", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface OrderableDBInstanceOption {
  Engine?: string | null;
  EngineVersion?: string | null;
  DBInstanceClass?: string | null;
  LicenseModel?: string | null;
  AvailabilityZoneGroup?: string | null;
  AvailabilityZones: AvailabilityZone[];
  MultiAZCapable?: boolean | null;
  ReadReplicaCapable?: boolean | null;
  Vpc?: boolean | null;
  SupportsStorageEncryption?: boolean | null;
  StorageType?: string | null;
  SupportsIops?: boolean | null;
  SupportsEnhancedMonitoring?: boolean | null;
  SupportsIAMDatabaseAuthentication?: boolean | null;
  SupportsPerformanceInsights?: boolean | null;
  MinStorageSize?: number | null;
  MaxStorageSize?: number | null;
  MinIopsPerDbInstance?: number | null;
  MaxIopsPerDbInstance?: number | null;
  MinIopsPerGib?: number | null;
  MaxIopsPerGib?: number | null;
  AvailableProcessorFeatures: AvailableProcessorFeature[];
  SupportedEngineModes: string[];
  SupportsStorageAutoscaling?: boolean | null;
  SupportsKerberosAuthentication?: boolean | null;
  OutpostCapable?: boolean | null;
  SupportsGlobalDatabases?: boolean | null;
}
function OrderableDBInstanceOption_Parse(node: XmlNode): OrderableDBInstanceOption {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"DBInstanceClass":true,"LicenseModel":true,"AvailabilityZoneGroup":true,"StorageType":true},
    }),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(AvailabilityZone_Parse),
    MultiAZCapable: node.first("MultiAZCapable", false, x => x.content === 'true'),
    ReadReplicaCapable: node.first("ReadReplicaCapable", false, x => x.content === 'true'),
    Vpc: node.first("Vpc", false, x => x.content === 'true'),
    SupportsStorageEncryption: node.first("SupportsStorageEncryption", false, x => x.content === 'true'),
    SupportsIops: node.first("SupportsIops", false, x => x.content === 'true'),
    SupportsEnhancedMonitoring: node.first("SupportsEnhancedMonitoring", false, x => x.content === 'true'),
    SupportsIAMDatabaseAuthentication: node.first("SupportsIAMDatabaseAuthentication", false, x => x.content === 'true'),
    SupportsPerformanceInsights: node.first("SupportsPerformanceInsights", false, x => x.content === 'true'),
    MinStorageSize: node.first("MinStorageSize", false, x => parseInt(x.content ?? '0')),
    MaxStorageSize: node.first("MaxStorageSize", false, x => parseInt(x.content ?? '0')),
    MinIopsPerDbInstance: node.first("MinIopsPerDbInstance", false, x => parseInt(x.content ?? '0')),
    MaxIopsPerDbInstance: node.first("MaxIopsPerDbInstance", false, x => parseInt(x.content ?? '0')),
    MinIopsPerGib: node.first("MinIopsPerGib", false, x => parseFloat(x.content ?? '0')),
    MaxIopsPerGib: node.first("MaxIopsPerGib", false, x => parseFloat(x.content ?? '0')),
    AvailableProcessorFeatures: node.getList("AvailableProcessorFeatures", "AvailableProcessorFeature").map(AvailableProcessorFeature_Parse),
    SupportedEngineModes: node.getList("SupportedEngineModes", "member").map(x => x.content ?? ''),
    SupportsStorageAutoscaling: node.first("SupportsStorageAutoscaling", false, x => x.content === 'true'),
    SupportsKerberosAuthentication: node.first("SupportsKerberosAuthentication", false, x => x.content === 'true'),
    OutpostCapable: node.first("OutpostCapable", false, x => x.content === 'true'),
    SupportsGlobalDatabases: node.first("SupportsGlobalDatabases", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface AvailableProcessorFeature {
  Name?: string | null;
  DefaultValue?: string | null;
  AllowedValues?: string | null;
}
function AvailableProcessorFeature_Parse(node: XmlNode): AvailableProcessorFeature {
  return node.strings({
    optional: {"Name":true,"DefaultValue":true,"AllowedValues":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface ReservedDBInstance {
  ReservedDBInstanceId?: string | null;
  ReservedDBInstancesOfferingId?: string | null;
  DBInstanceClass?: string | null;
  StartTime?: Date | number | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  CurrencyCode?: string | null;
  DBInstanceCount?: number | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MultiAZ?: boolean | null;
  State?: string | null;
  RecurringCharges: RecurringCharge[];
  ReservedDBInstanceArn?: string | null;
  LeaseId?: string | null;
}
function ReservedDBInstance_Parse(node: XmlNode): ReservedDBInstance {
  return {
    ...node.strings({
      optional: {"ReservedDBInstanceId":true,"ReservedDBInstancesOfferingId":true,"DBInstanceClass":true,"CurrencyCode":true,"ProductDescription":true,"OfferingType":true,"State":true,"ReservedDBInstanceArn":true,"LeaseId":true},
    }),
    StartTime: node.first("StartTime", false, x => parseTimestamp(x.content)),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    DBInstanceCount: node.first("DBInstanceCount", false, x => parseInt(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface RecurringCharge {
  RecurringChargeAmount?: number | null;
  RecurringChargeFrequency?: string | null;
}
function RecurringCharge_Parse(node: XmlNode): RecurringCharge {
  return {
    ...node.strings({
      optional: {"RecurringChargeFrequency":true},
    }),
    RecurringChargeAmount: node.first("RecurringChargeAmount", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReservedDBInstancesOffering {
  ReservedDBInstancesOfferingId?: string | null;
  DBInstanceClass?: string | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  CurrencyCode?: string | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MultiAZ?: boolean | null;
  RecurringCharges: RecurringCharge[];
}
function ReservedDBInstancesOffering_Parse(node: XmlNode): ReservedDBInstancesOffering {
  return {
    ...node.strings({
      optional: {"ReservedDBInstancesOfferingId":true,"DBInstanceClass":true,"CurrencyCode":true,"ProductDescription":true,"OfferingType":true},
    }),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface SourceRegion {
  RegionName?: string | null;
  Endpoint?: string | null;
  Status?: string | null;
}
function SourceRegion_Parse(node: XmlNode): SourceRegion {
  return node.strings({
    optional: {"RegionName":true,"Endpoint":true,"Status":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface ValidDBInstanceModificationsMessage {
  Storage: ValidStorageOptions[];
  ValidProcessorFeatures: AvailableProcessorFeature[];
}
function ValidDBInstanceModificationsMessage_Parse(node: XmlNode): ValidDBInstanceModificationsMessage {
  return {
    Storage: node.getList("Storage", "ValidStorageOptions").map(ValidStorageOptions_Parse),
    ValidProcessorFeatures: node.getList("ValidProcessorFeatures", "AvailableProcessorFeature").map(AvailableProcessorFeature_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface ValidStorageOptions {
  StorageType?: string | null;
  StorageSize: Range[];
  ProvisionedIops: Range[];
  IopsToStorageRatio: DoubleRange[];
  SupportsStorageAutoscaling?: boolean | null;
}
function ValidStorageOptions_Parse(node: XmlNode): ValidStorageOptions {
  return {
    ...node.strings({
      optional: {"StorageType":true},
    }),
    StorageSize: node.getList("StorageSize", "Range").map(Range_Parse),
    ProvisionedIops: node.getList("ProvisionedIops", "Range").map(Range_Parse),
    IopsToStorageRatio: node.getList("IopsToStorageRatio", "DoubleRange").map(DoubleRange_Parse),
    SupportsStorageAutoscaling: node.first("SupportsStorageAutoscaling", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface Range {
  From?: number | null;
  To?: number | null;
  Step?: number | null;
}
function Range_Parse(node: XmlNode): Range {
  return {
    From: node.first("From", false, x => parseInt(x.content ?? '0')),
    To: node.first("To", false, x => parseInt(x.content ?? '0')),
    Step: node.first("Step", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface DoubleRange {
  From?: number | null;
  To?: number | null;
}
function DoubleRange_Parse(node: XmlNode): DoubleRange {
  return {
    From: node.first("From", false, x => parseFloat(x.content ?? '0')),
    To: node.first("To", false, x => parseFloat(x.content ?? '0')),
  };
}
