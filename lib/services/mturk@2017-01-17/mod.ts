// Autogenerated API client for: Amazon Mechanical Turk

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class MTurk {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MTurk.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-01-17",
    "endpointPrefix": "mturk-requester",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon MTurk",
    "serviceFullName": "Amazon Mechanical Turk",
    "serviceId": "MTurk",
    "signatureVersion": "v4",
    "targetPrefix": "MTurkRequesterServiceV20170117",
    "uid": "mturk-requester-2017-01-17"
  };

  async acceptQualificationRequest(
    {abortSignal, ...params}: RequestConfig & AcceptQualificationRequestRequest,
  ): Promise<AcceptQualificationRequestResponse> {
    const body: jsonP.JSONObject = {
      QualificationRequestId: params["QualificationRequestId"],
      IntegerValue: params["IntegerValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptQualificationRequest",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async approveAssignment(
    {abortSignal, ...params}: RequestConfig & ApproveAssignmentRequest,
  ): Promise<ApproveAssignmentResponse> {
    const body: jsonP.JSONObject = {
      AssignmentId: params["AssignmentId"],
      RequesterFeedback: params["RequesterFeedback"],
      OverrideRejection: params["OverrideRejection"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApproveAssignment",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async associateQualificationWithWorker(
    {abortSignal, ...params}: RequestConfig & AssociateQualificationWithWorkerRequest,
  ): Promise<AssociateQualificationWithWorkerResponse> {
    const body: jsonP.JSONObject = {
      QualificationTypeId: params["QualificationTypeId"],
      WorkerId: params["WorkerId"],
      IntegerValue: params["IntegerValue"],
      SendNotification: params["SendNotification"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateQualificationWithWorker",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createAdditionalAssignmentsForHIT(
    {abortSignal, ...params}: RequestConfig & CreateAdditionalAssignmentsForHITRequest,
  ): Promise<CreateAdditionalAssignmentsForHITResponse> {
    const body: jsonP.JSONObject = {
      HITId: params["HITId"],
      NumberOfAdditionalAssignments: params["NumberOfAdditionalAssignments"],
      UniqueRequestToken: params["UniqueRequestToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAdditionalAssignmentsForHIT",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createHIT(
    {abortSignal, ...params}: RequestConfig & CreateHITRequest,
  ): Promise<CreateHITResponse> {
    const body: jsonP.JSONObject = {
      MaxAssignments: params["MaxAssignments"],
      AutoApprovalDelayInSeconds: params["AutoApprovalDelayInSeconds"],
      LifetimeInSeconds: params["LifetimeInSeconds"],
      AssignmentDurationInSeconds: params["AssignmentDurationInSeconds"],
      Reward: params["Reward"],
      Title: params["Title"],
      Keywords: params["Keywords"],
      Description: params["Description"],
      Question: params["Question"],
      RequesterAnnotation: params["RequesterAnnotation"],
      QualificationRequirements: params["QualificationRequirements"]?.map(x => fromQualificationRequirement(x)),
      UniqueRequestToken: params["UniqueRequestToken"],
      AssignmentReviewPolicy: fromReviewPolicy(params["AssignmentReviewPolicy"]),
      HITReviewPolicy: fromReviewPolicy(params["HITReviewPolicy"]),
      HITLayoutId: params["HITLayoutId"],
      HITLayoutParameters: params["HITLayoutParameters"]?.map(x => fromHITLayoutParameter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHIT",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HIT": toHIT,
      },
    }, await resp.json());
  }

  async createHITType(
    {abortSignal, ...params}: RequestConfig & CreateHITTypeRequest,
  ): Promise<CreateHITTypeResponse> {
    const body: jsonP.JSONObject = {
      AutoApprovalDelayInSeconds: params["AutoApprovalDelayInSeconds"],
      AssignmentDurationInSeconds: params["AssignmentDurationInSeconds"],
      Reward: params["Reward"],
      Title: params["Title"],
      Keywords: params["Keywords"],
      Description: params["Description"],
      QualificationRequirements: params["QualificationRequirements"]?.map(x => fromQualificationRequirement(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHITType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HITTypeId": "s",
      },
    }, await resp.json());
  }

  async createHITWithHITType(
    {abortSignal, ...params}: RequestConfig & CreateHITWithHITTypeRequest,
  ): Promise<CreateHITWithHITTypeResponse> {
    const body: jsonP.JSONObject = {
      HITTypeId: params["HITTypeId"],
      MaxAssignments: params["MaxAssignments"],
      LifetimeInSeconds: params["LifetimeInSeconds"],
      Question: params["Question"],
      RequesterAnnotation: params["RequesterAnnotation"],
      UniqueRequestToken: params["UniqueRequestToken"],
      AssignmentReviewPolicy: fromReviewPolicy(params["AssignmentReviewPolicy"]),
      HITReviewPolicy: fromReviewPolicy(params["HITReviewPolicy"]),
      HITLayoutId: params["HITLayoutId"],
      HITLayoutParameters: params["HITLayoutParameters"]?.map(x => fromHITLayoutParameter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHITWithHITType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HIT": toHIT,
      },
    }, await resp.json());
  }

  async createQualificationType(
    {abortSignal, ...params}: RequestConfig & CreateQualificationTypeRequest,
  ): Promise<CreateQualificationTypeResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Keywords: params["Keywords"],
      Description: params["Description"],
      QualificationTypeStatus: params["QualificationTypeStatus"],
      RetryDelayInSeconds: params["RetryDelayInSeconds"],
      Test: params["Test"],
      AnswerKey: params["AnswerKey"],
      TestDurationInSeconds: params["TestDurationInSeconds"],
      AutoGranted: params["AutoGranted"],
      AutoGrantedValue: params["AutoGrantedValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateQualificationType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "QualificationType": toQualificationType,
      },
    }, await resp.json());
  }

  async createWorkerBlock(
    {abortSignal, ...params}: RequestConfig & CreateWorkerBlockRequest,
  ): Promise<CreateWorkerBlockResponse> {
    const body: jsonP.JSONObject = {
      WorkerId: params["WorkerId"],
      Reason: params["Reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorkerBlock",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteHIT(
    {abortSignal, ...params}: RequestConfig & DeleteHITRequest,
  ): Promise<DeleteHITResponse> {
    const body: jsonP.JSONObject = {
      HITId: params["HITId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteHIT",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteQualificationType(
    {abortSignal, ...params}: RequestConfig & DeleteQualificationTypeRequest,
  ): Promise<DeleteQualificationTypeResponse> {
    const body: jsonP.JSONObject = {
      QualificationTypeId: params["QualificationTypeId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteQualificationType",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteWorkerBlock(
    {abortSignal, ...params}: RequestConfig & DeleteWorkerBlockRequest,
  ): Promise<DeleteWorkerBlockResponse> {
    const body: jsonP.JSONObject = {
      WorkerId: params["WorkerId"],
      Reason: params["Reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWorkerBlock",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async disassociateQualificationFromWorker(
    {abortSignal, ...params}: RequestConfig & DisassociateQualificationFromWorkerRequest,
  ): Promise<DisassociateQualificationFromWorkerResponse> {
    const body: jsonP.JSONObject = {
      WorkerId: params["WorkerId"],
      QualificationTypeId: params["QualificationTypeId"],
      Reason: params["Reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateQualificationFromWorker",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async getAccountBalance(
    {abortSignal, ...params}: RequestConfig & GetAccountBalanceRequest = {},
  ): Promise<GetAccountBalanceResponse> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAccountBalance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AvailableBalance": "s",
        "OnHoldBalance": "s",
      },
    }, await resp.json());
  }

  async getAssignment(
    {abortSignal, ...params}: RequestConfig & GetAssignmentRequest,
  ): Promise<GetAssignmentResponse> {
    const body: jsonP.JSONObject = {
      AssignmentId: params["AssignmentId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAssignment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Assignment": toAssignment,
        "HIT": toHIT,
      },
    }, await resp.json());
  }

  async getFileUploadURL(
    {abortSignal, ...params}: RequestConfig & GetFileUploadURLRequest,
  ): Promise<GetFileUploadURLResponse> {
    const body: jsonP.JSONObject = {
      AssignmentId: params["AssignmentId"],
      QuestionIdentifier: params["QuestionIdentifier"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFileUploadURL",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FileUploadURL": "s",
      },
    }, await resp.json());
  }

  async getHIT(
    {abortSignal, ...params}: RequestConfig & GetHITRequest,
  ): Promise<GetHITResponse> {
    const body: jsonP.JSONObject = {
      HITId: params["HITId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetHIT",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HIT": toHIT,
      },
    }, await resp.json());
  }

  async getQualificationScore(
    {abortSignal, ...params}: RequestConfig & GetQualificationScoreRequest,
  ): Promise<GetQualificationScoreResponse> {
    const body: jsonP.JSONObject = {
      QualificationTypeId: params["QualificationTypeId"],
      WorkerId: params["WorkerId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetQualificationScore",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Qualification": toQualification,
      },
    }, await resp.json());
  }

  async getQualificationType(
    {abortSignal, ...params}: RequestConfig & GetQualificationTypeRequest,
  ): Promise<GetQualificationTypeResponse> {
    const body: jsonP.JSONObject = {
      QualificationTypeId: params["QualificationTypeId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetQualificationType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "QualificationType": toQualificationType,
      },
    }, await resp.json());
  }

  async listAssignmentsForHIT(
    {abortSignal, ...params}: RequestConfig & ListAssignmentsForHITRequest,
  ): Promise<ListAssignmentsForHITResponse> {
    const body: jsonP.JSONObject = {
      HITId: params["HITId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      AssignmentStatuses: params["AssignmentStatuses"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAssignmentsForHIT",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NumResults": "n",
        "Assignments": [toAssignment],
      },
    }, await resp.json());
  }

  async listBonusPayments(
    {abortSignal, ...params}: RequestConfig & ListBonusPaymentsRequest = {},
  ): Promise<ListBonusPaymentsResponse> {
    const body: jsonP.JSONObject = {
      HITId: params["HITId"],
      AssignmentId: params["AssignmentId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBonusPayments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NumResults": "n",
        "NextToken": "s",
        "BonusPayments": [toBonusPayment],
      },
    }, await resp.json());
  }

  async listHITs(
    {abortSignal, ...params}: RequestConfig & ListHITsRequest = {},
  ): Promise<ListHITsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListHITs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NumResults": "n",
        "HITs": [toHIT],
      },
    }, await resp.json());
  }

  async listHITsForQualificationType(
    {abortSignal, ...params}: RequestConfig & ListHITsForQualificationTypeRequest,
  ): Promise<ListHITsForQualificationTypeResponse> {
    const body: jsonP.JSONObject = {
      QualificationTypeId: params["QualificationTypeId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListHITsForQualificationType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NumResults": "n",
        "HITs": [toHIT],
      },
    }, await resp.json());
  }

  async listQualificationRequests(
    {abortSignal, ...params}: RequestConfig & ListQualificationRequestsRequest = {},
  ): Promise<ListQualificationRequestsResponse> {
    const body: jsonP.JSONObject = {
      QualificationTypeId: params["QualificationTypeId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListQualificationRequests",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NumResults": "n",
        "NextToken": "s",
        "QualificationRequests": [toQualificationRequest],
      },
    }, await resp.json());
  }

  async listQualificationTypes(
    {abortSignal, ...params}: RequestConfig & ListQualificationTypesRequest,
  ): Promise<ListQualificationTypesResponse> {
    const body: jsonP.JSONObject = {
      Query: params["Query"],
      MustBeRequestable: params["MustBeRequestable"],
      MustBeOwnedByCaller: params["MustBeOwnedByCaller"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListQualificationTypes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NumResults": "n",
        "NextToken": "s",
        "QualificationTypes": [toQualificationType],
      },
    }, await resp.json());
  }

  async listReviewPolicyResultsForHIT(
    {abortSignal, ...params}: RequestConfig & ListReviewPolicyResultsForHITRequest,
  ): Promise<ListReviewPolicyResultsForHITResponse> {
    const body: jsonP.JSONObject = {
      HITId: params["HITId"],
      PolicyLevels: params["PolicyLevels"],
      RetrieveActions: params["RetrieveActions"],
      RetrieveResults: params["RetrieveResults"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReviewPolicyResultsForHIT",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HITId": "s",
        "AssignmentReviewPolicy": toReviewPolicy,
        "HITReviewPolicy": toReviewPolicy,
        "AssignmentReviewReport": toReviewReport,
        "HITReviewReport": toReviewReport,
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listReviewableHITs(
    {abortSignal, ...params}: RequestConfig & ListReviewableHITsRequest = {},
  ): Promise<ListReviewableHITsResponse> {
    const body: jsonP.JSONObject = {
      HITTypeId: params["HITTypeId"],
      Status: params["Status"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReviewableHITs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NumResults": "n",
        "HITs": [toHIT],
      },
    }, await resp.json());
  }

  async listWorkerBlocks(
    {abortSignal, ...params}: RequestConfig & ListWorkerBlocksRequest = {},
  ): Promise<ListWorkerBlocksResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorkerBlocks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NumResults": "n",
        "WorkerBlocks": [toWorkerBlock],
      },
    }, await resp.json());
  }

  async listWorkersWithQualificationType(
    {abortSignal, ...params}: RequestConfig & ListWorkersWithQualificationTypeRequest,
  ): Promise<ListWorkersWithQualificationTypeResponse> {
    const body: jsonP.JSONObject = {
      QualificationTypeId: params["QualificationTypeId"],
      Status: params["Status"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorkersWithQualificationType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NumResults": "n",
        "Qualifications": [toQualification],
      },
    }, await resp.json());
  }

  async notifyWorkers(
    {abortSignal, ...params}: RequestConfig & NotifyWorkersRequest,
  ): Promise<NotifyWorkersResponse> {
    const body: jsonP.JSONObject = {
      Subject: params["Subject"],
      MessageText: params["MessageText"],
      WorkerIds: params["WorkerIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "NotifyWorkers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotifyWorkersFailureStatuses": [toNotifyWorkersFailureStatus],
      },
    }, await resp.json());
  }

  async rejectAssignment(
    {abortSignal, ...params}: RequestConfig & RejectAssignmentRequest,
  ): Promise<RejectAssignmentResponse> {
    const body: jsonP.JSONObject = {
      AssignmentId: params["AssignmentId"],
      RequesterFeedback: params["RequesterFeedback"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectAssignment",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async rejectQualificationRequest(
    {abortSignal, ...params}: RequestConfig & RejectQualificationRequestRequest,
  ): Promise<RejectQualificationRequestResponse> {
    const body: jsonP.JSONObject = {
      QualificationRequestId: params["QualificationRequestId"],
      Reason: params["Reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectQualificationRequest",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async sendBonus(
    {abortSignal, ...params}: RequestConfig & SendBonusRequest,
  ): Promise<SendBonusResponse> {
    const body: jsonP.JSONObject = {
      WorkerId: params["WorkerId"],
      BonusAmount: params["BonusAmount"],
      AssignmentId: params["AssignmentId"],
      Reason: params["Reason"],
      UniqueRequestToken: params["UniqueRequestToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendBonus",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async sendTestEventNotification(
    {abortSignal, ...params}: RequestConfig & SendTestEventNotificationRequest,
  ): Promise<SendTestEventNotificationResponse> {
    const body: jsonP.JSONObject = {
      Notification: fromNotificationSpecification(params["Notification"]),
      TestEventType: params["TestEventType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendTestEventNotification",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateExpirationForHIT(
    {abortSignal, ...params}: RequestConfig & UpdateExpirationForHITRequest,
  ): Promise<UpdateExpirationForHITResponse> {
    const body: jsonP.JSONObject = {
      HITId: params["HITId"],
      ExpireAt: jsonP.serializeDate_unixTimestamp(params["ExpireAt"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateExpirationForHIT",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateHITReviewStatus(
    {abortSignal, ...params}: RequestConfig & UpdateHITReviewStatusRequest,
  ): Promise<UpdateHITReviewStatusResponse> {
    const body: jsonP.JSONObject = {
      HITId: params["HITId"],
      Revert: params["Revert"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateHITReviewStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateHITTypeOfHIT(
    {abortSignal, ...params}: RequestConfig & UpdateHITTypeOfHITRequest,
  ): Promise<UpdateHITTypeOfHITResponse> {
    const body: jsonP.JSONObject = {
      HITId: params["HITId"],
      HITTypeId: params["HITTypeId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateHITTypeOfHIT",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateNotificationSettings(
    {abortSignal, ...params}: RequestConfig & UpdateNotificationSettingsRequest,
  ): Promise<UpdateNotificationSettingsResponse> {
    const body: jsonP.JSONObject = {
      HITTypeId: params["HITTypeId"],
      Notification: fromNotificationSpecification(params["Notification"]),
      Active: params["Active"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNotificationSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateQualificationType(
    {abortSignal, ...params}: RequestConfig & UpdateQualificationTypeRequest,
  ): Promise<UpdateQualificationTypeResponse> {
    const body: jsonP.JSONObject = {
      QualificationTypeId: params["QualificationTypeId"],
      Description: params["Description"],
      QualificationTypeStatus: params["QualificationTypeStatus"],
      Test: params["Test"],
      AnswerKey: params["AnswerKey"],
      TestDurationInSeconds: params["TestDurationInSeconds"],
      RetryDelayInSeconds: params["RetryDelayInSeconds"],
      AutoGranted: params["AutoGranted"],
      AutoGrantedValue: params["AutoGrantedValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateQualificationType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "QualificationType": toQualificationType,
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface AcceptQualificationRequestRequest {
  QualificationRequestId: string;
  IntegerValue?: number | null;
}

// refs: 1 - tags: named, input
export interface ApproveAssignmentRequest {
  AssignmentId: string;
  RequesterFeedback?: string | null;
  OverrideRejection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AssociateQualificationWithWorkerRequest {
  QualificationTypeId: string;
  WorkerId: string;
  IntegerValue?: number | null;
  SendNotification?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateAdditionalAssignmentsForHITRequest {
  HITId: string;
  NumberOfAdditionalAssignments: number;
  UniqueRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateHITRequest {
  MaxAssignments?: number | null;
  AutoApprovalDelayInSeconds?: number | null;
  LifetimeInSeconds: number;
  AssignmentDurationInSeconds: number;
  Reward: string;
  Title: string;
  Keywords?: string | null;
  Description: string;
  Question?: string | null;
  RequesterAnnotation?: string | null;
  QualificationRequirements?: QualificationRequirement[] | null;
  UniqueRequestToken?: string | null;
  AssignmentReviewPolicy?: ReviewPolicy | null;
  HITReviewPolicy?: ReviewPolicy | null;
  HITLayoutId?: string | null;
  HITLayoutParameters?: HITLayoutParameter[] | null;
}

// refs: 1 - tags: named, input
export interface CreateHITTypeRequest {
  AutoApprovalDelayInSeconds?: number | null;
  AssignmentDurationInSeconds: number;
  Reward: string;
  Title: string;
  Keywords?: string | null;
  Description: string;
  QualificationRequirements?: QualificationRequirement[] | null;
}

// refs: 1 - tags: named, input
export interface CreateHITWithHITTypeRequest {
  HITTypeId: string;
  MaxAssignments?: number | null;
  LifetimeInSeconds: number;
  Question?: string | null;
  RequesterAnnotation?: string | null;
  UniqueRequestToken?: string | null;
  AssignmentReviewPolicy?: ReviewPolicy | null;
  HITReviewPolicy?: ReviewPolicy | null;
  HITLayoutId?: string | null;
  HITLayoutParameters?: HITLayoutParameter[] | null;
}

// refs: 1 - tags: named, input
export interface CreateQualificationTypeRequest {
  Name: string;
  Keywords?: string | null;
  Description: string;
  QualificationTypeStatus: QualificationTypeStatus;
  RetryDelayInSeconds?: number | null;
  Test?: string | null;
  AnswerKey?: string | null;
  TestDurationInSeconds?: number | null;
  AutoGranted?: boolean | null;
  AutoGrantedValue?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateWorkerBlockRequest {
  WorkerId: string;
  Reason: string;
}

// refs: 1 - tags: named, input
export interface DeleteHITRequest {
  HITId: string;
}

// refs: 1 - tags: named, input
export interface DeleteQualificationTypeRequest {
  QualificationTypeId: string;
}

// refs: 1 - tags: named, input
export interface DeleteWorkerBlockRequest {
  WorkerId: string;
  Reason?: string | null;
}

// refs: 1 - tags: named, input
export interface DisassociateQualificationFromWorkerRequest {
  WorkerId: string;
  QualificationTypeId: string;
  Reason?: string | null;
}

// refs: 1 - tags: named, input
export interface GetAccountBalanceRequest {
}

// refs: 1 - tags: named, input
export interface GetAssignmentRequest {
  AssignmentId: string;
}

// refs: 1 - tags: named, input
export interface GetFileUploadURLRequest {
  AssignmentId: string;
  QuestionIdentifier: string;
}

// refs: 1 - tags: named, input
export interface GetHITRequest {
  HITId: string;
}

// refs: 1 - tags: named, input
export interface GetQualificationScoreRequest {
  QualificationTypeId: string;
  WorkerId: string;
}

// refs: 1 - tags: named, input
export interface GetQualificationTypeRequest {
  QualificationTypeId: string;
}

// refs: 1 - tags: named, input
export interface ListAssignmentsForHITRequest {
  HITId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  AssignmentStatuses?: AssignmentStatus[] | null;
}

// refs: 1 - tags: named, input
export interface ListBonusPaymentsRequest {
  HITId?: string | null;
  AssignmentId?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListHITsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListHITsForQualificationTypeRequest {
  QualificationTypeId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListQualificationRequestsRequest {
  QualificationTypeId?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListQualificationTypesRequest {
  Query?: string | null;
  MustBeRequestable: boolean;
  MustBeOwnedByCaller?: boolean | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListReviewPolicyResultsForHITRequest {
  HITId: string;
  PolicyLevels?: ReviewPolicyLevel[] | null;
  RetrieveActions?: boolean | null;
  RetrieveResults?: boolean | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListReviewableHITsRequest {
  HITTypeId?: string | null;
  Status?: ReviewableHITStatus | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListWorkerBlocksRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListWorkersWithQualificationTypeRequest {
  QualificationTypeId: string;
  Status?: QualificationStatus | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface NotifyWorkersRequest {
  Subject: string;
  MessageText: string;
  WorkerIds: string[];
}

// refs: 1 - tags: named, input
export interface RejectAssignmentRequest {
  AssignmentId: string;
  RequesterFeedback: string;
}

// refs: 1 - tags: named, input
export interface RejectQualificationRequestRequest {
  QualificationRequestId: string;
  Reason?: string | null;
}

// refs: 1 - tags: named, input
export interface SendBonusRequest {
  WorkerId: string;
  BonusAmount: string;
  AssignmentId: string;
  Reason: string;
  UniqueRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface SendTestEventNotificationRequest {
  Notification: NotificationSpecification;
  TestEventType: EventType;
}

// refs: 1 - tags: named, input
export interface UpdateExpirationForHITRequest {
  HITId: string;
  ExpireAt: Date | number;
}

// refs: 1 - tags: named, input
export interface UpdateHITReviewStatusRequest {
  HITId: string;
  Revert?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UpdateHITTypeOfHITRequest {
  HITId: string;
  HITTypeId: string;
}

// refs: 1 - tags: named, input
export interface UpdateNotificationSettingsRequest {
  HITTypeId: string;
  Notification?: NotificationSpecification | null;
  Active?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UpdateQualificationTypeRequest {
  QualificationTypeId: string;
  Description?: string | null;
  QualificationTypeStatus?: QualificationTypeStatus | null;
  Test?: string | null;
  AnswerKey?: string | null;
  TestDurationInSeconds?: number | null;
  RetryDelayInSeconds?: number | null;
  AutoGranted?: boolean | null;
  AutoGrantedValue?: number | null;
}

// refs: 1 - tags: named, output
export interface AcceptQualificationRequestResponse {
}

// refs: 1 - tags: named, output
export interface ApproveAssignmentResponse {
}

// refs: 1 - tags: named, output
export interface AssociateQualificationWithWorkerResponse {
}

// refs: 1 - tags: named, output
export interface CreateAdditionalAssignmentsForHITResponse {
}

// refs: 1 - tags: named, output
export interface CreateHITResponse {
  HIT?: HIT | null;
}

// refs: 1 - tags: named, output
export interface CreateHITTypeResponse {
  HITTypeId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateHITWithHITTypeResponse {
  HIT?: HIT | null;
}

// refs: 1 - tags: named, output
export interface CreateQualificationTypeResponse {
  QualificationType?: QualificationType | null;
}

// refs: 1 - tags: named, output
export interface CreateWorkerBlockResponse {
}

// refs: 1 - tags: named, output
export interface DeleteHITResponse {
}

// refs: 1 - tags: named, output
export interface DeleteQualificationTypeResponse {
}

// refs: 1 - tags: named, output
export interface DeleteWorkerBlockResponse {
}

// refs: 1 - tags: named, output
export interface DisassociateQualificationFromWorkerResponse {
}

// refs: 1 - tags: named, output
export interface GetAccountBalanceResponse {
  AvailableBalance?: string | null;
  OnHoldBalance?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAssignmentResponse {
  Assignment?: Assignment | null;
  HIT?: HIT | null;
}

// refs: 1 - tags: named, output
export interface GetFileUploadURLResponse {
  FileUploadURL?: string | null;
}

// refs: 1 - tags: named, output
export interface GetHITResponse {
  HIT?: HIT | null;
}

// refs: 1 - tags: named, output
export interface GetQualificationScoreResponse {
  Qualification?: Qualification | null;
}

// refs: 1 - tags: named, output
export interface GetQualificationTypeResponse {
  QualificationType?: QualificationType | null;
}

// refs: 1 - tags: named, output
export interface ListAssignmentsForHITResponse {
  NextToken?: string | null;
  NumResults?: number | null;
  Assignments?: Assignment[] | null;
}

// refs: 1 - tags: named, output
export interface ListBonusPaymentsResponse {
  NumResults?: number | null;
  NextToken?: string | null;
  BonusPayments?: BonusPayment[] | null;
}

// refs: 1 - tags: named, output
export interface ListHITsResponse {
  NextToken?: string | null;
  NumResults?: number | null;
  HITs?: HIT[] | null;
}

// refs: 1 - tags: named, output
export interface ListHITsForQualificationTypeResponse {
  NextToken?: string | null;
  NumResults?: number | null;
  HITs?: HIT[] | null;
}

// refs: 1 - tags: named, output
export interface ListQualificationRequestsResponse {
  NumResults?: number | null;
  NextToken?: string | null;
  QualificationRequests?: QualificationRequest[] | null;
}

// refs: 1 - tags: named, output
export interface ListQualificationTypesResponse {
  NumResults?: number | null;
  NextToken?: string | null;
  QualificationTypes?: QualificationType[] | null;
}

// refs: 1 - tags: named, output
export interface ListReviewPolicyResultsForHITResponse {
  HITId?: string | null;
  AssignmentReviewPolicy?: ReviewPolicy | null;
  HITReviewPolicy?: ReviewPolicy | null;
  AssignmentReviewReport?: ReviewReport | null;
  HITReviewReport?: ReviewReport | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListReviewableHITsResponse {
  NextToken?: string | null;
  NumResults?: number | null;
  HITs?: HIT[] | null;
}

// refs: 1 - tags: named, output
export interface ListWorkerBlocksResponse {
  NextToken?: string | null;
  NumResults?: number | null;
  WorkerBlocks?: WorkerBlock[] | null;
}

// refs: 1 - tags: named, output
export interface ListWorkersWithQualificationTypeResponse {
  NextToken?: string | null;
  NumResults?: number | null;
  Qualifications?: Qualification[] | null;
}

// refs: 1 - tags: named, output
export interface NotifyWorkersResponse {
  NotifyWorkersFailureStatuses?: NotifyWorkersFailureStatus[] | null;
}

// refs: 1 - tags: named, output
export interface RejectAssignmentResponse {
}

// refs: 1 - tags: named, output
export interface RejectQualificationRequestResponse {
}

// refs: 1 - tags: named, output
export interface SendBonusResponse {
}

// refs: 1 - tags: named, output
export interface SendTestEventNotificationResponse {
}

// refs: 1 - tags: named, output
export interface UpdateExpirationForHITResponse {
}

// refs: 1 - tags: named, output
export interface UpdateHITReviewStatusResponse {
}

// refs: 1 - tags: named, output
export interface UpdateHITTypeOfHITResponse {
}

// refs: 1 - tags: named, output
export interface UpdateNotificationSettingsResponse {
}

// refs: 1 - tags: named, output
export interface UpdateQualificationTypeResponse {
  QualificationType?: QualificationType | null;
}

// refs: 9 - tags: input, named, interface, output
export interface QualificationRequirement {
  QualificationTypeId: string;
  Comparator: Comparator;
  IntegerValues?: number[] | null;
  LocaleValues?: Locale[] | null;
  RequiredToPreview?: boolean | null;
  ActionsGuarded?: HITAccessActions | null;
}
function fromQualificationRequirement(input?: QualificationRequirement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    QualificationTypeId: input["QualificationTypeId"],
    Comparator: input["Comparator"],
    IntegerValues: input["IntegerValues"],
    LocaleValues: input["LocaleValues"]?.map(x => fromLocale(x)),
    RequiredToPreview: input["RequiredToPreview"],
    ActionsGuarded: input["ActionsGuarded"],
  }
}
function toQualificationRequirement(root: jsonP.JSONValue): QualificationRequirement {
  return jsonP.readObj({
    required: {
      "QualificationTypeId": "s",
      "Comparator": (x: jsonP.JSONValue) => cmnP.readEnum<Comparator>(x),
    },
    optional: {
      "IntegerValues": ["n"],
      "LocaleValues": [toLocale],
      "RequiredToPreview": "b",
      "ActionsGuarded": (x: jsonP.JSONValue) => cmnP.readEnum<HITAccessActions>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type Comparator =
| "LessThan"
| "LessThanOrEqualTo"
| "GreaterThan"
| "GreaterThanOrEqualTo"
| "EqualTo"
| "NotEqualTo"
| "Exists"
| "DoesNotExist"
| "In"
| "NotIn"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, interface, output
export interface Locale {
  Country: string;
  Subdivision?: string | null;
}
function fromLocale(input?: Locale | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Country: input["Country"],
    Subdivision: input["Subdivision"],
  }
}
function toLocale(root: jsonP.JSONValue): Locale {
  return jsonP.readObj({
    required: {
      "Country": "s",
    },
    optional: {
      "Subdivision": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type HITAccessActions =
| "Accept"
| "PreviewAndAccept"
| "DiscoverPreviewAndAccept"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface ReviewPolicy {
  PolicyName: string;
  Parameters?: PolicyParameter[] | null;
}
function fromReviewPolicy(input?: ReviewPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyName: input["PolicyName"],
    Parameters: input["Parameters"]?.map(x => fromPolicyParameter(x)),
  }
}
function toReviewPolicy(root: jsonP.JSONValue): ReviewPolicy {
  return jsonP.readObj({
    required: {
      "PolicyName": "s",
    },
    optional: {
      "Parameters": [toPolicyParameter],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface PolicyParameter {
  Key?: string | null;
  Values?: string[] | null;
  MapEntries?: ParameterMapEntry[] | null;
}
function fromPolicyParameter(input?: PolicyParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    MapEntries: input["MapEntries"]?.map(x => fromParameterMapEntry(x)),
  }
}
function toPolicyParameter(root: jsonP.JSONValue): PolicyParameter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Values": ["s"],
      "MapEntries": [toParameterMapEntry],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ParameterMapEntry {
  Key?: string | null;
  Values?: string[] | null;
}
function fromParameterMapEntry(input?: ParameterMapEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}
function toParameterMapEntry(root: jsonP.JSONValue): ParameterMapEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Values": ["s"],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface HITLayoutParameter {
  Name: string;
  Value: string;
}
function fromHITLayoutParameter(input?: HITLayoutParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}

// refs: 6 - tags: input, named, enum, output
export type QualificationTypeStatus =
| "Active"
| "Inactive"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type AssignmentStatus =
| "Submitted"
| "Approved"
| "Rejected"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ReviewPolicyLevel =
| "Assignment"
| "HIT"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ReviewableHITStatus =
| "Reviewable"
| "Reviewing"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type QualificationStatus =
| "Granted"
| "Revoked"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface NotificationSpecification {
  Destination: string;
  Transport: NotificationTransport;
  Version: string;
  EventTypes: EventType[];
}
function fromNotificationSpecification(input?: NotificationSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Destination: input["Destination"],
    Transport: input["Transport"],
    Version: input["Version"],
    EventTypes: input["EventTypes"],
  }
}

// refs: 2 - tags: input, named, enum
export type NotificationTransport =
| "Email"
| "SQS"
| "SNS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum
export type EventType =
| "AssignmentAccepted"
| "AssignmentAbandoned"
| "AssignmentReturned"
| "AssignmentSubmitted"
| "AssignmentRejected"
| "AssignmentApproved"
| "HITCreated"
| "HITExpired"
| "HITReviewable"
| "HITExtended"
| "HITDisposed"
| "Ping"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, interface
export interface HIT {
  HITId?: string | null;
  HITTypeId?: string | null;
  HITGroupId?: string | null;
  HITLayoutId?: string | null;
  CreationTime?: Date | number | null;
  Title?: string | null;
  Description?: string | null;
  Question?: string | null;
  Keywords?: string | null;
  HITStatus?: HITStatus | null;
  MaxAssignments?: number | null;
  Reward?: string | null;
  AutoApprovalDelayInSeconds?: number | null;
  Expiration?: Date | number | null;
  AssignmentDurationInSeconds?: number | null;
  RequesterAnnotation?: string | null;
  QualificationRequirements?: QualificationRequirement[] | null;
  HITReviewStatus?: HITReviewStatus | null;
  NumberOfAssignmentsPending?: number | null;
  NumberOfAssignmentsAvailable?: number | null;
  NumberOfAssignmentsCompleted?: number | null;
}
function toHIT(root: jsonP.JSONValue): HIT {
  return jsonP.readObj({
    required: {},
    optional: {
      "HITId": "s",
      "HITTypeId": "s",
      "HITGroupId": "s",
      "HITLayoutId": "s",
      "CreationTime": "d",
      "Title": "s",
      "Description": "s",
      "Question": "s",
      "Keywords": "s",
      "HITStatus": (x: jsonP.JSONValue) => cmnP.readEnum<HITStatus>(x),
      "MaxAssignments": "n",
      "Reward": "s",
      "AutoApprovalDelayInSeconds": "n",
      "Expiration": "d",
      "AssignmentDurationInSeconds": "n",
      "RequesterAnnotation": "s",
      "QualificationRequirements": [toQualificationRequirement],
      "HITReviewStatus": (x: jsonP.JSONValue) => cmnP.readEnum<HITReviewStatus>(x),
      "NumberOfAssignmentsPending": "n",
      "NumberOfAssignmentsAvailable": "n",
      "NumberOfAssignmentsCompleted": "n",
    },
  }, root);
}

// refs: 7 - tags: output, named, enum
export type HITStatus =
| "Assignable"
| "Unassignable"
| "Reviewable"
| "Reviewing"
| "Disposed"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, enum
export type HITReviewStatus =
| "NotReviewed"
| "MarkedForReview"
| "ReviewedAppropriate"
| "ReviewedInappropriate"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface QualificationType {
  QualificationTypeId?: string | null;
  CreationTime?: Date | number | null;
  Name?: string | null;
  Description?: string | null;
  Keywords?: string | null;
  QualificationTypeStatus?: QualificationTypeStatus | null;
  Test?: string | null;
  TestDurationInSeconds?: number | null;
  AnswerKey?: string | null;
  RetryDelayInSeconds?: number | null;
  IsRequestable?: boolean | null;
  AutoGranted?: boolean | null;
  AutoGrantedValue?: number | null;
}
function toQualificationType(root: jsonP.JSONValue): QualificationType {
  return jsonP.readObj({
    required: {},
    optional: {
      "QualificationTypeId": "s",
      "CreationTime": "d",
      "Name": "s",
      "Description": "s",
      "Keywords": "s",
      "QualificationTypeStatus": (x: jsonP.JSONValue) => cmnP.readEnum<QualificationTypeStatus>(x),
      "Test": "s",
      "TestDurationInSeconds": "n",
      "AnswerKey": "s",
      "RetryDelayInSeconds": "n",
      "IsRequestable": "b",
      "AutoGranted": "b",
      "AutoGrantedValue": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Assignment {
  AssignmentId?: string | null;
  WorkerId?: string | null;
  HITId?: string | null;
  AssignmentStatus?: AssignmentStatus | null;
  AutoApprovalTime?: Date | number | null;
  AcceptTime?: Date | number | null;
  SubmitTime?: Date | number | null;
  ApprovalTime?: Date | number | null;
  RejectionTime?: Date | number | null;
  Deadline?: Date | number | null;
  Answer?: string | null;
  RequesterFeedback?: string | null;
}
function toAssignment(root: jsonP.JSONValue): Assignment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssignmentId": "s",
      "WorkerId": "s",
      "HITId": "s",
      "AssignmentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AssignmentStatus>(x),
      "AutoApprovalTime": "d",
      "AcceptTime": "d",
      "SubmitTime": "d",
      "ApprovalTime": "d",
      "RejectionTime": "d",
      "Deadline": "d",
      "Answer": "s",
      "RequesterFeedback": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Qualification {
  QualificationTypeId?: string | null;
  WorkerId?: string | null;
  GrantTime?: Date | number | null;
  IntegerValue?: number | null;
  LocaleValue?: Locale | null;
  Status?: QualificationStatus | null;
}
function toQualification(root: jsonP.JSONValue): Qualification {
  return jsonP.readObj({
    required: {},
    optional: {
      "QualificationTypeId": "s",
      "WorkerId": "s",
      "GrantTime": "d",
      "IntegerValue": "n",
      "LocaleValue": toLocale,
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<QualificationStatus>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BonusPayment {
  WorkerId?: string | null;
  BonusAmount?: string | null;
  AssignmentId?: string | null;
  Reason?: string | null;
  GrantTime?: Date | number | null;
}
function toBonusPayment(root: jsonP.JSONValue): BonusPayment {
  return jsonP.readObj({
    required: {},
    optional: {
      "WorkerId": "s",
      "BonusAmount": "s",
      "AssignmentId": "s",
      "Reason": "s",
      "GrantTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface QualificationRequest {
  QualificationRequestId?: string | null;
  QualificationTypeId?: string | null;
  WorkerId?: string | null;
  Test?: string | null;
  Answer?: string | null;
  SubmitTime?: Date | number | null;
}
function toQualificationRequest(root: jsonP.JSONValue): QualificationRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "QualificationRequestId": "s",
      "QualificationTypeId": "s",
      "WorkerId": "s",
      "Test": "s",
      "Answer": "s",
      "SubmitTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ReviewReport {
  ReviewResults?: ReviewResultDetail[] | null;
  ReviewActions?: ReviewActionDetail[] | null;
}
function toReviewReport(root: jsonP.JSONValue): ReviewReport {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReviewResults": [toReviewResultDetail],
      "ReviewActions": [toReviewActionDetail],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ReviewResultDetail {
  ActionId?: string | null;
  SubjectId?: string | null;
  SubjectType?: string | null;
  QuestionId?: string | null;
  Key?: string | null;
  Value?: string | null;
}
function toReviewResultDetail(root: jsonP.JSONValue): ReviewResultDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActionId": "s",
      "SubjectId": "s",
      "SubjectType": "s",
      "QuestionId": "s",
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ReviewActionDetail {
  ActionId?: string | null;
  ActionName?: string | null;
  TargetId?: string | null;
  TargetType?: string | null;
  Status?: ReviewActionStatus | null;
  CompleteTime?: Date | number | null;
  Result?: string | null;
  ErrorCode?: string | null;
}
function toReviewActionDetail(root: jsonP.JSONValue): ReviewActionDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActionId": "s",
      "ActionName": "s",
      "TargetId": "s",
      "TargetType": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ReviewActionStatus>(x),
      "CompleteTime": "d",
      "Result": "s",
      "ErrorCode": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ReviewActionStatus =
| "Intended"
| "Succeeded"
| "Failed"
| "Cancelled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface WorkerBlock {
  WorkerId?: string | null;
  Reason?: string | null;
}
function toWorkerBlock(root: jsonP.JSONValue): WorkerBlock {
  return jsonP.readObj({
    required: {},
    optional: {
      "WorkerId": "s",
      "Reason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NotifyWorkersFailureStatus {
  NotifyWorkersFailureCode?: NotifyWorkersFailureCode | null;
  NotifyWorkersFailureMessage?: string | null;
  WorkerId?: string | null;
}
function toNotifyWorkersFailureStatus(root: jsonP.JSONValue): NotifyWorkersFailureStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotifyWorkersFailureCode": (x: jsonP.JSONValue) => cmnP.readEnum<NotifyWorkersFailureCode>(x),
      "NotifyWorkersFailureMessage": "s",
      "WorkerId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type NotifyWorkersFailureCode =
| "SoftFailure"
| "HardFailure"
| cmnP.UnexpectedEnumValue;
