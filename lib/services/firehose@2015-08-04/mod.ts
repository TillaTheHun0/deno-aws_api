// Autogenerated API client for: Amazon Kinesis Firehose

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Firehose {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Firehose.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2015-08-04",
    "endpointPrefix": "firehose",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Firehose",
    "serviceFullName": "Amazon Kinesis Firehose",
    "serviceId": "Firehose",
    "signatureVersion": "v4",
    "targetPrefix": "Firehose_20150804",
    "uid": "firehose-2015-08-04"
  };

  async createDeliveryStream(
    {abortSignal, ...params}: RequestConfig & CreateDeliveryStreamInput,
  ): Promise<CreateDeliveryStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      DeliveryStreamType: params["DeliveryStreamType"],
      KinesisStreamSourceConfiguration: fromKinesisStreamSourceConfiguration(params["KinesisStreamSourceConfiguration"]),
      DeliveryStreamEncryptionConfigurationInput: fromDeliveryStreamEncryptionConfigurationInput(params["DeliveryStreamEncryptionConfigurationInput"]),
      S3DestinationConfiguration: fromS3DestinationConfiguration(params["S3DestinationConfiguration"]),
      ExtendedS3DestinationConfiguration: fromExtendedS3DestinationConfiguration(params["ExtendedS3DestinationConfiguration"]),
      RedshiftDestinationConfiguration: fromRedshiftDestinationConfiguration(params["RedshiftDestinationConfiguration"]),
      ElasticsearchDestinationConfiguration: fromElasticsearchDestinationConfiguration(params["ElasticsearchDestinationConfiguration"]),
      SplunkDestinationConfiguration: fromSplunkDestinationConfiguration(params["SplunkDestinationConfiguration"]),
      HttpEndpointDestinationConfiguration: fromHttpEndpointDestinationConfiguration(params["HttpEndpointDestinationConfiguration"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeliveryStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DeliveryStreamARN": "s",
      },
    }, await resp.json());
  }

  async deleteDeliveryStream(
    {abortSignal, ...params}: RequestConfig & DeleteDeliveryStreamInput,
  ): Promise<DeleteDeliveryStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      AllowForceDelete: params["AllowForceDelete"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDeliveryStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeDeliveryStream(
    {abortSignal, ...params}: RequestConfig & DescribeDeliveryStreamInput,
  ): Promise<DescribeDeliveryStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      Limit: params["Limit"],
      ExclusiveStartDestinationId: params["ExclusiveStartDestinationId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDeliveryStream",
    });
    return jsonP.readObj({
      required: {
        "DeliveryStreamDescription": toDeliveryStreamDescription,
      },
      optional: {},
    }, await resp.json());
  }

  async listDeliveryStreams(
    {abortSignal, ...params}: RequestConfig & ListDeliveryStreamsInput = {},
  ): Promise<ListDeliveryStreamsOutput> {
    const body: jsonP.JSONObject = params ? {
      Limit: params["Limit"],
      DeliveryStreamType: params["DeliveryStreamType"],
      ExclusiveStartDeliveryStreamName: params["ExclusiveStartDeliveryStreamName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeliveryStreams",
    });
    return jsonP.readObj({
      required: {
        "DeliveryStreamNames": ["s"],
        "HasMoreDeliveryStreams": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async listTagsForDeliveryStream(
    {abortSignal, ...params}: RequestConfig & ListTagsForDeliveryStreamInput,
  ): Promise<ListTagsForDeliveryStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      ExclusiveStartTagKey: params["ExclusiveStartTagKey"],
      Limit: params["Limit"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForDeliveryStream",
    });
    return jsonP.readObj({
      required: {
        "Tags": [toTag],
        "HasMoreTags": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async putRecord(
    {abortSignal, ...params}: RequestConfig & PutRecordInput,
  ): Promise<PutRecordOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      Record: fromRecord(params["Record"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRecord",
    });
    return jsonP.readObj({
      required: {
        "RecordId": "s",
      },
      optional: {
        "Encrypted": "b",
      },
    }, await resp.json());
  }

  async putRecordBatch(
    {abortSignal, ...params}: RequestConfig & PutRecordBatchInput,
  ): Promise<PutRecordBatchOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      Records: params["Records"]?.map(x => fromRecord(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRecordBatch",
    });
    return jsonP.readObj({
      required: {
        "FailedPutCount": "n",
        "RequestResponses": [toPutRecordBatchResponseEntry],
      },
      optional: {
        "Encrypted": "b",
      },
    }, await resp.json());
  }

  async startDeliveryStreamEncryption(
    {abortSignal, ...params}: RequestConfig & StartDeliveryStreamEncryptionInput,
  ): Promise<StartDeliveryStreamEncryptionOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      DeliveryStreamEncryptionConfigurationInput: fromDeliveryStreamEncryptionConfigurationInput(params["DeliveryStreamEncryptionConfigurationInput"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDeliveryStreamEncryption",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async stopDeliveryStreamEncryption(
    {abortSignal, ...params}: RequestConfig & StopDeliveryStreamEncryptionInput,
  ): Promise<StopDeliveryStreamEncryptionOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopDeliveryStreamEncryption",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagDeliveryStream(
    {abortSignal, ...params}: RequestConfig & TagDeliveryStreamInput,
  ): Promise<TagDeliveryStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagDeliveryStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagDeliveryStream(
    {abortSignal, ...params}: RequestConfig & UntagDeliveryStreamInput,
  ): Promise<UntagDeliveryStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      TagKeys: params["TagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagDeliveryStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDestination(
    {abortSignal, ...params}: RequestConfig & UpdateDestinationInput,
  ): Promise<UpdateDestinationOutput> {
    const body: jsonP.JSONObject = params ? {
      DeliveryStreamName: params["DeliveryStreamName"],
      CurrentDeliveryStreamVersionId: params["CurrentDeliveryStreamVersionId"],
      DestinationId: params["DestinationId"],
      S3DestinationUpdate: fromS3DestinationUpdate(params["S3DestinationUpdate"]),
      ExtendedS3DestinationUpdate: fromExtendedS3DestinationUpdate(params["ExtendedS3DestinationUpdate"]),
      RedshiftDestinationUpdate: fromRedshiftDestinationUpdate(params["RedshiftDestinationUpdate"]),
      ElasticsearchDestinationUpdate: fromElasticsearchDestinationUpdate(params["ElasticsearchDestinationUpdate"]),
      SplunkDestinationUpdate: fromSplunkDestinationUpdate(params["SplunkDestinationUpdate"]),
      HttpEndpointDestinationUpdate: fromHttpEndpointDestinationUpdate(params["HttpEndpointDestinationUpdate"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDestination",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CreateDeliveryStreamInput {
  DeliveryStreamName: string;
  DeliveryStreamType?: DeliveryStreamType | null;
  KinesisStreamSourceConfiguration?: KinesisStreamSourceConfiguration | null;
  DeliveryStreamEncryptionConfigurationInput?: DeliveryStreamEncryptionConfigurationInput | null;
  S3DestinationConfiguration?: S3DestinationConfiguration | null;
  ExtendedS3DestinationConfiguration?: ExtendedS3DestinationConfiguration | null;
  RedshiftDestinationConfiguration?: RedshiftDestinationConfiguration | null;
  ElasticsearchDestinationConfiguration?: ElasticsearchDestinationConfiguration | null;
  SplunkDestinationConfiguration?: SplunkDestinationConfiguration | null;
  HttpEndpointDestinationConfiguration?: HttpEndpointDestinationConfiguration | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteDeliveryStreamInput {
  DeliveryStreamName: string;
  AllowForceDelete?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDeliveryStreamInput {
  DeliveryStreamName: string;
  Limit?: number | null;
  ExclusiveStartDestinationId?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDeliveryStreamsInput {
  Limit?: number | null;
  DeliveryStreamType?: DeliveryStreamType | null;
  ExclusiveStartDeliveryStreamName?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForDeliveryStreamInput {
  DeliveryStreamName: string;
  ExclusiveStartTagKey?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface PutRecordInput {
  DeliveryStreamName: string;
  Record: Record;
}

// refs: 1 - tags: named, input
export interface PutRecordBatchInput {
  DeliveryStreamName: string;
  Records: Record[];
}

// refs: 1 - tags: named, input
export interface StartDeliveryStreamEncryptionInput {
  DeliveryStreamName: string;
  DeliveryStreamEncryptionConfigurationInput?: DeliveryStreamEncryptionConfigurationInput | null;
}

// refs: 1 - tags: named, input
export interface StopDeliveryStreamEncryptionInput {
  DeliveryStreamName: string;
}

// refs: 1 - tags: named, input
export interface TagDeliveryStreamInput {
  DeliveryStreamName: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagDeliveryStreamInput {
  DeliveryStreamName: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateDestinationInput {
  DeliveryStreamName: string;
  CurrentDeliveryStreamVersionId: string;
  DestinationId: string;
  S3DestinationUpdate?: S3DestinationUpdate | null;
  ExtendedS3DestinationUpdate?: ExtendedS3DestinationUpdate | null;
  RedshiftDestinationUpdate?: RedshiftDestinationUpdate | null;
  ElasticsearchDestinationUpdate?: ElasticsearchDestinationUpdate | null;
  SplunkDestinationUpdate?: SplunkDestinationUpdate | null;
  HttpEndpointDestinationUpdate?: HttpEndpointDestinationUpdate | null;
}

// refs: 1 - tags: named, output
export interface CreateDeliveryStreamOutput {
  DeliveryStreamARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteDeliveryStreamOutput {
}

// refs: 1 - tags: named, output
export interface DescribeDeliveryStreamOutput {
  DeliveryStreamDescription: DeliveryStreamDescription;
}

// refs: 1 - tags: named, output
export interface ListDeliveryStreamsOutput {
  DeliveryStreamNames: string[];
  HasMoreDeliveryStreams: boolean;
}

// refs: 1 - tags: named, output
export interface ListTagsForDeliveryStreamOutput {
  Tags: Tag[];
  HasMoreTags: boolean;
}

// refs: 1 - tags: named, output
export interface PutRecordOutput {
  RecordId: string;
  Encrypted?: boolean | null;
}

// refs: 1 - tags: named, output
export interface PutRecordBatchOutput {
  FailedPutCount: number;
  Encrypted?: boolean | null;
  RequestResponses: PutRecordBatchResponseEntry[];
}

// refs: 1 - tags: named, output
export interface StartDeliveryStreamEncryptionOutput {
}

// refs: 1 - tags: named, output
export interface StopDeliveryStreamEncryptionOutput {
}

// refs: 1 - tags: named, output
export interface TagDeliveryStreamOutput {
}

// refs: 1 - tags: named, output
export interface UntagDeliveryStreamOutput {
}

// refs: 1 - tags: named, output
export interface UpdateDestinationOutput {
}

// refs: 3 - tags: input, named, enum, output
export type DeliveryStreamType =
| "DirectPut"
| "KinesisStreamAsSource"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface KinesisStreamSourceConfiguration {
  KinesisStreamARN: string;
  RoleARN: string;
}
function fromKinesisStreamSourceConfiguration(input?: KinesisStreamSourceConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KinesisStreamARN: input["KinesisStreamARN"],
    RoleARN: input["RoleARN"],
  }
}

// refs: 2 - tags: input, named, interface
export interface DeliveryStreamEncryptionConfigurationInput {
  KeyARN?: string | null;
  KeyType: KeyType;
}
function fromDeliveryStreamEncryptionConfigurationInput(input?: DeliveryStreamEncryptionConfigurationInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KeyARN: input["KeyARN"],
    KeyType: input["KeyType"],
  }
}

// refs: 3 - tags: input, named, enum, output
export type KeyType =
| "AWS_OWNED_CMK"
| "CUSTOMER_MANAGED_CMK"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface
export interface S3DestinationConfiguration {
  RoleARN: string;
  BucketARN: string;
  Prefix?: string | null;
  ErrorOutputPrefix?: string | null;
  BufferingHints?: BufferingHints | null;
  CompressionFormat?: CompressionFormat | null;
  EncryptionConfiguration?: EncryptionConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function fromS3DestinationConfiguration(input?: S3DestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    BucketARN: input["BucketARN"],
    Prefix: input["Prefix"],
    ErrorOutputPrefix: input["ErrorOutputPrefix"],
    BufferingHints: fromBufferingHints(input["BufferingHints"]),
    CompressionFormat: input["CompressionFormat"],
    EncryptionConfiguration: fromEncryptionConfiguration(input["EncryptionConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

// refs: 24 - tags: input, named, interface, output
export interface BufferingHints {
  SizeInMBs?: number | null;
  IntervalInSeconds?: number | null;
}
function fromBufferingHints(input?: BufferingHints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SizeInMBs: input["SizeInMBs"],
    IntervalInSeconds: input["IntervalInSeconds"],
  }
}
function toBufferingHints(root: jsonP.JSONValue): BufferingHints {
  return jsonP.readObj({
    required: {},
    optional: {
      "SizeInMBs": "n",
      "IntervalInSeconds": "n",
    },
  }, root);
}

// refs: 24 - tags: input, named, enum, output
export type CompressionFormat =
| "UNCOMPRESSED"
| "GZIP"
| "ZIP"
| "Snappy"
| "HADOOP_SNAPPY"
| cmnP.UnexpectedEnumValue;

// refs: 24 - tags: input, named, interface, output
export interface EncryptionConfiguration {
  NoEncryptionConfig?: NoEncryptionConfig | null;
  KMSEncryptionConfig?: KMSEncryptionConfig | null;
}
function fromEncryptionConfiguration(input?: EncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NoEncryptionConfig: input["NoEncryptionConfig"],
    KMSEncryptionConfig: fromKMSEncryptionConfig(input["KMSEncryptionConfig"]),
  }
}
function toEncryptionConfiguration(root: jsonP.JSONValue): EncryptionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "NoEncryptionConfig": (x: jsonP.JSONValue) => cmnP.readEnum<NoEncryptionConfig>(x),
      "KMSEncryptionConfig": toKMSEncryptionConfig,
    },
  }, root);
}

// refs: 24 - tags: input, named, enum, output
export type NoEncryptionConfig =
| "NoEncryption"
| cmnP.UnexpectedEnumValue;

// refs: 24 - tags: input, named, interface, output
export interface KMSEncryptionConfig {
  AWSKMSKeyARN: string;
}
function fromKMSEncryptionConfig(input?: KMSEncryptionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AWSKMSKeyARN: input["AWSKMSKeyARN"],
  }
}
function toKMSEncryptionConfig(root: jsonP.JSONValue): KMSEncryptionConfig {
  return jsonP.readObj({
    required: {
      "AWSKMSKeyARN": "s",
    },
    optional: {},
  }, root);
}

// refs: 36 - tags: input, named, interface, output
export interface CloudWatchLoggingOptions {
  Enabled?: boolean | null;
  LogGroupName?: string | null;
  LogStreamName?: string | null;
}
function fromCloudWatchLoggingOptions(input?: CloudWatchLoggingOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    LogGroupName: input["LogGroupName"],
    LogStreamName: input["LogStreamName"],
  }
}
function toCloudWatchLoggingOptions(root: jsonP.JSONValue): CloudWatchLoggingOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "LogGroupName": "s",
      "LogStreamName": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface ExtendedS3DestinationConfiguration {
  RoleARN: string;
  BucketARN: string;
  Prefix?: string | null;
  ErrorOutputPrefix?: string | null;
  BufferingHints?: BufferingHints | null;
  CompressionFormat?: CompressionFormat | null;
  EncryptionConfiguration?: EncryptionConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  S3BackupMode?: S3BackupMode | null;
  S3BackupConfiguration?: S3DestinationConfiguration | null;
  DataFormatConversionConfiguration?: DataFormatConversionConfiguration | null;
}
function fromExtendedS3DestinationConfiguration(input?: ExtendedS3DestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    BucketARN: input["BucketARN"],
    Prefix: input["Prefix"],
    ErrorOutputPrefix: input["ErrorOutputPrefix"],
    BufferingHints: fromBufferingHints(input["BufferingHints"]),
    CompressionFormat: input["CompressionFormat"],
    EncryptionConfiguration: fromEncryptionConfiguration(input["EncryptionConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    S3BackupMode: input["S3BackupMode"],
    S3BackupConfiguration: fromS3DestinationConfiguration(input["S3BackupConfiguration"]),
    DataFormatConversionConfiguration: fromDataFormatConversionConfiguration(input["DataFormatConversionConfiguration"]),
  }
}

// refs: 15 - tags: input, named, interface, output
export interface ProcessingConfiguration {
  Enabled?: boolean | null;
  Processors?: Processor[] | null;
}
function fromProcessingConfiguration(input?: ProcessingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    Processors: input["Processors"]?.map(x => fromProcessor(x)),
  }
}
function toProcessingConfiguration(root: jsonP.JSONValue): ProcessingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "Processors": [toProcessor],
    },
  }, root);
}

// refs: 15 - tags: input, named, interface, output
export interface Processor {
  Type: ProcessorType;
  Parameters?: ProcessorParameter[] | null;
}
function fromProcessor(input?: Processor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Parameters: input["Parameters"]?.map(x => fromProcessorParameter(x)),
  }
}
function toProcessor(root: jsonP.JSONValue): Processor {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessorType>(x),
    },
    optional: {
      "Parameters": [toProcessorParameter],
    },
  }, root);
}

// refs: 15 - tags: input, named, enum, output
export type ProcessorType =
| "Lambda"
| cmnP.UnexpectedEnumValue;

// refs: 15 - tags: input, named, interface, output
export interface ProcessorParameter {
  ParameterName: ProcessorParameterName;
  ParameterValue: string;
}
function fromProcessorParameter(input?: ProcessorParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParameterName: input["ParameterName"],
    ParameterValue: input["ParameterValue"],
  }
}
function toProcessorParameter(root: jsonP.JSONValue): ProcessorParameter {
  return jsonP.readObj({
    required: {
      "ParameterName": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessorParameterName>(x),
      "ParameterValue": "s",
    },
    optional: {},
  }, root);
}

// refs: 15 - tags: input, named, enum, output
export type ProcessorParameterName =
| "LambdaArn"
| "NumberOfRetries"
| "RoleArn"
| "BufferSizeInMBs"
| "BufferIntervalInSeconds"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type S3BackupMode =
| "Disabled"
| "Enabled"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface DataFormatConversionConfiguration {
  SchemaConfiguration?: SchemaConfiguration | null;
  InputFormatConfiguration?: InputFormatConfiguration | null;
  OutputFormatConfiguration?: OutputFormatConfiguration | null;
  Enabled?: boolean | null;
}
function fromDataFormatConversionConfiguration(input?: DataFormatConversionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaConfiguration: fromSchemaConfiguration(input["SchemaConfiguration"]),
    InputFormatConfiguration: fromInputFormatConfiguration(input["InputFormatConfiguration"]),
    OutputFormatConfiguration: fromOutputFormatConfiguration(input["OutputFormatConfiguration"]),
    Enabled: input["Enabled"],
  }
}
function toDataFormatConversionConfiguration(root: jsonP.JSONValue): DataFormatConversionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaConfiguration": toSchemaConfiguration,
      "InputFormatConfiguration": toInputFormatConfiguration,
      "OutputFormatConfiguration": toOutputFormatConfiguration,
      "Enabled": "b",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface SchemaConfiguration {
  RoleARN?: string | null;
  CatalogId?: string | null;
  DatabaseName?: string | null;
  TableName?: string | null;
  Region?: string | null;
  VersionId?: string | null;
}
function fromSchemaConfiguration(input?: SchemaConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
    TableName: input["TableName"],
    Region: input["Region"],
    VersionId: input["VersionId"],
  }
}
function toSchemaConfiguration(root: jsonP.JSONValue): SchemaConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "RoleARN": "s",
      "CatalogId": "s",
      "DatabaseName": "s",
      "TableName": "s",
      "Region": "s",
      "VersionId": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface InputFormatConfiguration {
  Deserializer?: Deserializer | null;
}
function fromInputFormatConfiguration(input?: InputFormatConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Deserializer: fromDeserializer(input["Deserializer"]),
  }
}
function toInputFormatConfiguration(root: jsonP.JSONValue): InputFormatConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Deserializer": toDeserializer,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Deserializer {
  OpenXJsonSerDe?: OpenXJsonSerDe | null;
  HiveJsonSerDe?: HiveJsonSerDe | null;
}
function fromDeserializer(input?: Deserializer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OpenXJsonSerDe: fromOpenXJsonSerDe(input["OpenXJsonSerDe"]),
    HiveJsonSerDe: fromHiveJsonSerDe(input["HiveJsonSerDe"]),
  }
}
function toDeserializer(root: jsonP.JSONValue): Deserializer {
  return jsonP.readObj({
    required: {},
    optional: {
      "OpenXJsonSerDe": toOpenXJsonSerDe,
      "HiveJsonSerDe": toHiveJsonSerDe,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface OpenXJsonSerDe {
  ConvertDotsInJsonKeysToUnderscores?: boolean | null;
  CaseInsensitive?: boolean | null;
  ColumnToJsonKeyMappings?: { [key: string]: string | null | undefined } | null;
}
function fromOpenXJsonSerDe(input?: OpenXJsonSerDe | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConvertDotsInJsonKeysToUnderscores: input["ConvertDotsInJsonKeysToUnderscores"],
    CaseInsensitive: input["CaseInsensitive"],
    ColumnToJsonKeyMappings: input["ColumnToJsonKeyMappings"],
  }
}
function toOpenXJsonSerDe(root: jsonP.JSONValue): OpenXJsonSerDe {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConvertDotsInJsonKeysToUnderscores": "b",
      "CaseInsensitive": "b",
      "ColumnToJsonKeyMappings": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface HiveJsonSerDe {
  TimestampFormats?: string[] | null;
}
function fromHiveJsonSerDe(input?: HiveJsonSerDe | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TimestampFormats: input["TimestampFormats"],
  }
}
function toHiveJsonSerDe(root: jsonP.JSONValue): HiveJsonSerDe {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimestampFormats": ["s"],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface OutputFormatConfiguration {
  Serializer?: Serializer | null;
}
function fromOutputFormatConfiguration(input?: OutputFormatConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Serializer: fromSerializer(input["Serializer"]),
  }
}
function toOutputFormatConfiguration(root: jsonP.JSONValue): OutputFormatConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Serializer": toSerializer,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Serializer {
  ParquetSerDe?: ParquetSerDe | null;
  OrcSerDe?: OrcSerDe | null;
}
function fromSerializer(input?: Serializer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParquetSerDe: fromParquetSerDe(input["ParquetSerDe"]),
    OrcSerDe: fromOrcSerDe(input["OrcSerDe"]),
  }
}
function toSerializer(root: jsonP.JSONValue): Serializer {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParquetSerDe": toParquetSerDe,
      "OrcSerDe": toOrcSerDe,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ParquetSerDe {
  BlockSizeBytes?: number | null;
  PageSizeBytes?: number | null;
  Compression?: ParquetCompression | null;
  EnableDictionaryCompression?: boolean | null;
  MaxPaddingBytes?: number | null;
  WriterVersion?: ParquetWriterVersion | null;
}
function fromParquetSerDe(input?: ParquetSerDe | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BlockSizeBytes: input["BlockSizeBytes"],
    PageSizeBytes: input["PageSizeBytes"],
    Compression: input["Compression"],
    EnableDictionaryCompression: input["EnableDictionaryCompression"],
    MaxPaddingBytes: input["MaxPaddingBytes"],
    WriterVersion: input["WriterVersion"],
  }
}
function toParquetSerDe(root: jsonP.JSONValue): ParquetSerDe {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlockSizeBytes": "n",
      "PageSizeBytes": "n",
      "Compression": (x: jsonP.JSONValue) => cmnP.readEnum<ParquetCompression>(x),
      "EnableDictionaryCompression": "b",
      "MaxPaddingBytes": "n",
      "WriterVersion": (x: jsonP.JSONValue) => cmnP.readEnum<ParquetWriterVersion>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ParquetCompression =
| "UNCOMPRESSED"
| "GZIP"
| "SNAPPY"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ParquetWriterVersion =
| "V1"
| "V2"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface OrcSerDe {
  StripeSizeBytes?: number | null;
  BlockSizeBytes?: number | null;
  RowIndexStride?: number | null;
  EnablePadding?: boolean | null;
  PaddingTolerance?: number | null;
  Compression?: OrcCompression | null;
  BloomFilterColumns?: string[] | null;
  BloomFilterFalsePositiveProbability?: number | null;
  DictionaryKeyThreshold?: number | null;
  FormatVersion?: OrcFormatVersion | null;
}
function fromOrcSerDe(input?: OrcSerDe | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StripeSizeBytes: input["StripeSizeBytes"],
    BlockSizeBytes: input["BlockSizeBytes"],
    RowIndexStride: input["RowIndexStride"],
    EnablePadding: input["EnablePadding"],
    PaddingTolerance: input["PaddingTolerance"],
    Compression: input["Compression"],
    BloomFilterColumns: input["BloomFilterColumns"],
    BloomFilterFalsePositiveProbability: input["BloomFilterFalsePositiveProbability"],
    DictionaryKeyThreshold: input["DictionaryKeyThreshold"],
    FormatVersion: input["FormatVersion"],
  }
}
function toOrcSerDe(root: jsonP.JSONValue): OrcSerDe {
  return jsonP.readObj({
    required: {},
    optional: {
      "StripeSizeBytes": "n",
      "BlockSizeBytes": "n",
      "RowIndexStride": "n",
      "EnablePadding": "b",
      "PaddingTolerance": "n",
      "Compression": (x: jsonP.JSONValue) => cmnP.readEnum<OrcCompression>(x),
      "BloomFilterColumns": ["s"],
      "BloomFilterFalsePositiveProbability": "n",
      "DictionaryKeyThreshold": "n",
      "FormatVersion": (x: jsonP.JSONValue) => cmnP.readEnum<OrcFormatVersion>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type OrcCompression =
| "NONE"
| "ZLIB"
| "SNAPPY"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type OrcFormatVersion =
| "V0_11"
| "V0_12"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface RedshiftDestinationConfiguration {
  RoleARN: string;
  ClusterJDBCURL: string;
  CopyCommand: CopyCommand;
  Username: string;
  Password: string;
  RetryOptions?: RedshiftRetryOptions | null;
  S3Configuration: S3DestinationConfiguration;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  S3BackupMode?: RedshiftS3BackupMode | null;
  S3BackupConfiguration?: S3DestinationConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function fromRedshiftDestinationConfiguration(input?: RedshiftDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    ClusterJDBCURL: input["ClusterJDBCURL"],
    CopyCommand: fromCopyCommand(input["CopyCommand"]),
    Username: input["Username"],
    Password: input["Password"],
    RetryOptions: fromRedshiftRetryOptions(input["RetryOptions"]),
    S3Configuration: fromS3DestinationConfiguration(input["S3Configuration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    S3BackupMode: input["S3BackupMode"],
    S3BackupConfiguration: fromS3DestinationConfiguration(input["S3BackupConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

// refs: 3 - tags: input, named, interface, output
export interface CopyCommand {
  DataTableName: string;
  DataTableColumns?: string | null;
  CopyOptions?: string | null;
}
function fromCopyCommand(input?: CopyCommand | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataTableName: input["DataTableName"],
    DataTableColumns: input["DataTableColumns"],
    CopyOptions: input["CopyOptions"],
  }
}
function toCopyCommand(root: jsonP.JSONValue): CopyCommand {
  return jsonP.readObj({
    required: {
      "DataTableName": "s",
    },
    optional: {
      "DataTableColumns": "s",
      "CopyOptions": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface RedshiftRetryOptions {
  DurationInSeconds?: number | null;
}
function fromRedshiftRetryOptions(input?: RedshiftRetryOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DurationInSeconds: input["DurationInSeconds"],
  }
}
function toRedshiftRetryOptions(root: jsonP.JSONValue): RedshiftRetryOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInSeconds": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type RedshiftS3BackupMode =
| "Disabled"
| "Enabled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ElasticsearchDestinationConfiguration {
  RoleARN: string;
  DomainARN?: string | null;
  ClusterEndpoint?: string | null;
  IndexName: string;
  TypeName?: string | null;
  IndexRotationPeriod?: ElasticsearchIndexRotationPeriod | null;
  BufferingHints?: ElasticsearchBufferingHints | null;
  RetryOptions?: ElasticsearchRetryOptions | null;
  S3BackupMode?: ElasticsearchS3BackupMode | null;
  S3Configuration: S3DestinationConfiguration;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
  VpcConfiguration?: VpcConfiguration | null;
}
function fromElasticsearchDestinationConfiguration(input?: ElasticsearchDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    DomainARN: input["DomainARN"],
    ClusterEndpoint: input["ClusterEndpoint"],
    IndexName: input["IndexName"],
    TypeName: input["TypeName"],
    IndexRotationPeriod: input["IndexRotationPeriod"],
    BufferingHints: fromElasticsearchBufferingHints(input["BufferingHints"]),
    RetryOptions: fromElasticsearchRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Configuration: fromS3DestinationConfiguration(input["S3Configuration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    VpcConfiguration: fromVpcConfiguration(input["VpcConfiguration"]),
  }
}

// refs: 3 - tags: input, named, enum, output
export type ElasticsearchIndexRotationPeriod =
| "NoRotation"
| "OneHour"
| "OneDay"
| "OneWeek"
| "OneMonth"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface ElasticsearchBufferingHints {
  IntervalInSeconds?: number | null;
  SizeInMBs?: number | null;
}
function fromElasticsearchBufferingHints(input?: ElasticsearchBufferingHints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IntervalInSeconds: input["IntervalInSeconds"],
    SizeInMBs: input["SizeInMBs"],
  }
}
function toElasticsearchBufferingHints(root: jsonP.JSONValue): ElasticsearchBufferingHints {
  return jsonP.readObj({
    required: {},
    optional: {
      "IntervalInSeconds": "n",
      "SizeInMBs": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ElasticsearchRetryOptions {
  DurationInSeconds?: number | null;
}
function fromElasticsearchRetryOptions(input?: ElasticsearchRetryOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DurationInSeconds: input["DurationInSeconds"],
  }
}
function toElasticsearchRetryOptions(root: jsonP.JSONValue): ElasticsearchRetryOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInSeconds": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type ElasticsearchS3BackupMode =
| "FailedDocumentsOnly"
| "AllDocuments"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface VpcConfiguration {
  SubnetIds: string[];
  RoleARN: string;
  SecurityGroupIds: string[];
}
function fromVpcConfiguration(input?: VpcConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetIds: input["SubnetIds"],
    RoleARN: input["RoleARN"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}

// refs: 1 - tags: input, named, interface
export interface SplunkDestinationConfiguration {
  HECEndpoint: string;
  HECEndpointType: HECEndpointType;
  HECToken: string;
  HECAcknowledgmentTimeoutInSeconds?: number | null;
  RetryOptions?: SplunkRetryOptions | null;
  S3BackupMode?: SplunkS3BackupMode | null;
  S3Configuration: S3DestinationConfiguration;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function fromSplunkDestinationConfiguration(input?: SplunkDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HECEndpoint: input["HECEndpoint"],
    HECEndpointType: input["HECEndpointType"],
    HECToken: input["HECToken"],
    HECAcknowledgmentTimeoutInSeconds: input["HECAcknowledgmentTimeoutInSeconds"],
    RetryOptions: fromSplunkRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Configuration: fromS3DestinationConfiguration(input["S3Configuration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

// refs: 3 - tags: input, named, enum, output
export type HECEndpointType =
| "Raw"
| "Event"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface SplunkRetryOptions {
  DurationInSeconds?: number | null;
}
function fromSplunkRetryOptions(input?: SplunkRetryOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DurationInSeconds: input["DurationInSeconds"],
  }
}
function toSplunkRetryOptions(root: jsonP.JSONValue): SplunkRetryOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInSeconds": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type SplunkS3BackupMode =
| "FailedEventsOnly"
| "AllEvents"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface HttpEndpointDestinationConfiguration {
  EndpointConfiguration: HttpEndpointConfiguration;
  BufferingHints?: HttpEndpointBufferingHints | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
  RequestConfiguration?: HttpEndpointRequestConfiguration | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  RoleARN?: string | null;
  RetryOptions?: HttpEndpointRetryOptions | null;
  S3BackupMode?: HttpEndpointS3BackupMode | null;
  S3Configuration: S3DestinationConfiguration;
}
function fromHttpEndpointDestinationConfiguration(input?: HttpEndpointDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointConfiguration: fromHttpEndpointConfiguration(input["EndpointConfiguration"]),
    BufferingHints: fromHttpEndpointBufferingHints(input["BufferingHints"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    RequestConfiguration: fromHttpEndpointRequestConfiguration(input["RequestConfiguration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    RoleARN: input["RoleARN"],
    RetryOptions: fromHttpEndpointRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Configuration: fromS3DestinationConfiguration(input["S3Configuration"]),
  }
}

// refs: 2 - tags: input, named, interface
export interface HttpEndpointConfiguration {
  Url: string;
  Name?: string | null;
  AccessKey?: string | null;
}
function fromHttpEndpointConfiguration(input?: HttpEndpointConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Url: input["Url"],
    Name: input["Name"],
    AccessKey: input["AccessKey"],
  }
}

// refs: 3 - tags: input, named, interface, output
export interface HttpEndpointBufferingHints {
  SizeInMBs?: number | null;
  IntervalInSeconds?: number | null;
}
function fromHttpEndpointBufferingHints(input?: HttpEndpointBufferingHints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SizeInMBs: input["SizeInMBs"],
    IntervalInSeconds: input["IntervalInSeconds"],
  }
}
function toHttpEndpointBufferingHints(root: jsonP.JSONValue): HttpEndpointBufferingHints {
  return jsonP.readObj({
    required: {},
    optional: {
      "SizeInMBs": "n",
      "IntervalInSeconds": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface HttpEndpointRequestConfiguration {
  ContentEncoding?: ContentEncoding | null;
  CommonAttributes?: HttpEndpointCommonAttribute[] | null;
}
function fromHttpEndpointRequestConfiguration(input?: HttpEndpointRequestConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContentEncoding: input["ContentEncoding"],
    CommonAttributes: input["CommonAttributes"]?.map(x => fromHttpEndpointCommonAttribute(x)),
  }
}
function toHttpEndpointRequestConfiguration(root: jsonP.JSONValue): HttpEndpointRequestConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ContentEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<ContentEncoding>(x),
      "CommonAttributes": [toHttpEndpointCommonAttribute],
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ContentEncoding =
| "NONE"
| "GZIP"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface HttpEndpointCommonAttribute {
  AttributeName: string;
  AttributeValue: string;
}
function fromHttpEndpointCommonAttribute(input?: HttpEndpointCommonAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    AttributeValue: input["AttributeValue"],
  }
}
function toHttpEndpointCommonAttribute(root: jsonP.JSONValue): HttpEndpointCommonAttribute {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "AttributeValue": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface HttpEndpointRetryOptions {
  DurationInSeconds?: number | null;
}
function fromHttpEndpointRetryOptions(input?: HttpEndpointRetryOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DurationInSeconds: input["DurationInSeconds"],
  }
}
function toHttpEndpointRetryOptions(root: jsonP.JSONValue): HttpEndpointRetryOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInSeconds": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type HttpEndpointS3BackupMode =
| "FailedDataOnly"
| "AllData"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface Record {
  Data: Uint8Array | string;
}
function fromRecord(input?: Record | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Data: jsonP.serializeBlob(input["Data"]),
  }
}

// refs: 7 - tags: input, named, interface
export interface S3DestinationUpdate {
  RoleARN?: string | null;
  BucketARN?: string | null;
  Prefix?: string | null;
  ErrorOutputPrefix?: string | null;
  BufferingHints?: BufferingHints | null;
  CompressionFormat?: CompressionFormat | null;
  EncryptionConfiguration?: EncryptionConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function fromS3DestinationUpdate(input?: S3DestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    BucketARN: input["BucketARN"],
    Prefix: input["Prefix"],
    ErrorOutputPrefix: input["ErrorOutputPrefix"],
    BufferingHints: fromBufferingHints(input["BufferingHints"]),
    CompressionFormat: input["CompressionFormat"],
    EncryptionConfiguration: fromEncryptionConfiguration(input["EncryptionConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface ExtendedS3DestinationUpdate {
  RoleARN?: string | null;
  BucketARN?: string | null;
  Prefix?: string | null;
  ErrorOutputPrefix?: string | null;
  BufferingHints?: BufferingHints | null;
  CompressionFormat?: CompressionFormat | null;
  EncryptionConfiguration?: EncryptionConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  S3BackupMode?: S3BackupMode | null;
  S3BackupUpdate?: S3DestinationUpdate | null;
  DataFormatConversionConfiguration?: DataFormatConversionConfiguration | null;
}
function fromExtendedS3DestinationUpdate(input?: ExtendedS3DestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    BucketARN: input["BucketARN"],
    Prefix: input["Prefix"],
    ErrorOutputPrefix: input["ErrorOutputPrefix"],
    BufferingHints: fromBufferingHints(input["BufferingHints"]),
    CompressionFormat: input["CompressionFormat"],
    EncryptionConfiguration: fromEncryptionConfiguration(input["EncryptionConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    S3BackupMode: input["S3BackupMode"],
    S3BackupUpdate: fromS3DestinationUpdate(input["S3BackupUpdate"]),
    DataFormatConversionConfiguration: fromDataFormatConversionConfiguration(input["DataFormatConversionConfiguration"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface RedshiftDestinationUpdate {
  RoleARN?: string | null;
  ClusterJDBCURL?: string | null;
  CopyCommand?: CopyCommand | null;
  Username?: string | null;
  Password?: string | null;
  RetryOptions?: RedshiftRetryOptions | null;
  S3Update?: S3DestinationUpdate | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  S3BackupMode?: RedshiftS3BackupMode | null;
  S3BackupUpdate?: S3DestinationUpdate | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function fromRedshiftDestinationUpdate(input?: RedshiftDestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    ClusterJDBCURL: input["ClusterJDBCURL"],
    CopyCommand: fromCopyCommand(input["CopyCommand"]),
    Username: input["Username"],
    Password: input["Password"],
    RetryOptions: fromRedshiftRetryOptions(input["RetryOptions"]),
    S3Update: fromS3DestinationUpdate(input["S3Update"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    S3BackupMode: input["S3BackupMode"],
    S3BackupUpdate: fromS3DestinationUpdate(input["S3BackupUpdate"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface ElasticsearchDestinationUpdate {
  RoleARN?: string | null;
  DomainARN?: string | null;
  ClusterEndpoint?: string | null;
  IndexName?: string | null;
  TypeName?: string | null;
  IndexRotationPeriod?: ElasticsearchIndexRotationPeriod | null;
  BufferingHints?: ElasticsearchBufferingHints | null;
  RetryOptions?: ElasticsearchRetryOptions | null;
  S3Update?: S3DestinationUpdate | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function fromElasticsearchDestinationUpdate(input?: ElasticsearchDestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    DomainARN: input["DomainARN"],
    ClusterEndpoint: input["ClusterEndpoint"],
    IndexName: input["IndexName"],
    TypeName: input["TypeName"],
    IndexRotationPeriod: input["IndexRotationPeriod"],
    BufferingHints: fromElasticsearchBufferingHints(input["BufferingHints"]),
    RetryOptions: fromElasticsearchRetryOptions(input["RetryOptions"]),
    S3Update: fromS3DestinationUpdate(input["S3Update"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface SplunkDestinationUpdate {
  HECEndpoint?: string | null;
  HECEndpointType?: HECEndpointType | null;
  HECToken?: string | null;
  HECAcknowledgmentTimeoutInSeconds?: number | null;
  RetryOptions?: SplunkRetryOptions | null;
  S3BackupMode?: SplunkS3BackupMode | null;
  S3Update?: S3DestinationUpdate | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function fromSplunkDestinationUpdate(input?: SplunkDestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HECEndpoint: input["HECEndpoint"],
    HECEndpointType: input["HECEndpointType"],
    HECToken: input["HECToken"],
    HECAcknowledgmentTimeoutInSeconds: input["HECAcknowledgmentTimeoutInSeconds"],
    RetryOptions: fromSplunkRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Update: fromS3DestinationUpdate(input["S3Update"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface HttpEndpointDestinationUpdate {
  EndpointConfiguration?: HttpEndpointConfiguration | null;
  BufferingHints?: HttpEndpointBufferingHints | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
  RequestConfiguration?: HttpEndpointRequestConfiguration | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  RoleARN?: string | null;
  RetryOptions?: HttpEndpointRetryOptions | null;
  S3BackupMode?: HttpEndpointS3BackupMode | null;
  S3Update?: S3DestinationUpdate | null;
}
function fromHttpEndpointDestinationUpdate(input?: HttpEndpointDestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointConfiguration: fromHttpEndpointConfiguration(input["EndpointConfiguration"]),
    BufferingHints: fromHttpEndpointBufferingHints(input["BufferingHints"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    RequestConfiguration: fromHttpEndpointRequestConfiguration(input["RequestConfiguration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    RoleARN: input["RoleARN"],
    RetryOptions: fromHttpEndpointRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Update: fromS3DestinationUpdate(input["S3Update"]),
  }
}

// refs: 1 - tags: output, named, interface
export interface DeliveryStreamDescription {
  DeliveryStreamName: string;
  DeliveryStreamARN: string;
  DeliveryStreamStatus: DeliveryStreamStatus;
  FailureDescription?: FailureDescription | null;
  DeliveryStreamEncryptionConfiguration?: DeliveryStreamEncryptionConfiguration | null;
  DeliveryStreamType: DeliveryStreamType;
  VersionId: string;
  CreateTimestamp?: Date | number | null;
  LastUpdateTimestamp?: Date | number | null;
  Source?: SourceDescription | null;
  Destinations: DestinationDescription[];
  HasMoreDestinations: boolean;
}
function toDeliveryStreamDescription(root: jsonP.JSONValue): DeliveryStreamDescription {
  return jsonP.readObj({
    required: {
      "DeliveryStreamName": "s",
      "DeliveryStreamARN": "s",
      "DeliveryStreamStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DeliveryStreamStatus>(x),
      "DeliveryStreamType": (x: jsonP.JSONValue) => cmnP.readEnum<DeliveryStreamType>(x),
      "VersionId": "s",
      "Destinations": [toDestinationDescription],
      "HasMoreDestinations": "b",
    },
    optional: {
      "FailureDescription": toFailureDescription,
      "DeliveryStreamEncryptionConfiguration": toDeliveryStreamEncryptionConfiguration,
      "CreateTimestamp": "d",
      "LastUpdateTimestamp": "d",
      "Source": toSourceDescription,
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type DeliveryStreamStatus =
| "CREATING"
| "CREATING_FAILED"
| "DELETING"
| "DELETING_FAILED"
| "ACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface FailureDescription {
  Type: DeliveryStreamFailureType;
  Details: string;
}
function toFailureDescription(root: jsonP.JSONValue): FailureDescription {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<DeliveryStreamFailureType>(x),
      "Details": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DeliveryStreamFailureType =
| "RETIRE_KMS_GRANT_FAILED"
| "CREATE_KMS_GRANT_FAILED"
| "KMS_ACCESS_DENIED"
| "DISABLED_KMS_KEY"
| "INVALID_KMS_KEY"
| "KMS_KEY_NOT_FOUND"
| "KMS_OPT_IN_REQUIRED"
| "CREATE_ENI_FAILED"
| "DELETE_ENI_FAILED"
| "SUBNET_NOT_FOUND"
| "SECURITY_GROUP_NOT_FOUND"
| "ENI_ACCESS_DENIED"
| "SUBNET_ACCESS_DENIED"
| "SECURITY_GROUP_ACCESS_DENIED"
| "UNKNOWN_ERROR"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DeliveryStreamEncryptionConfiguration {
  KeyARN?: string | null;
  KeyType?: KeyType | null;
  Status?: DeliveryStreamEncryptionStatus | null;
  FailureDescription?: FailureDescription | null;
}
function toDeliveryStreamEncryptionConfiguration(root: jsonP.JSONValue): DeliveryStreamEncryptionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyARN": "s",
      "KeyType": (x: jsonP.JSONValue) => cmnP.readEnum<KeyType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<DeliveryStreamEncryptionStatus>(x),
      "FailureDescription": toFailureDescription,
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type DeliveryStreamEncryptionStatus =
| "ENABLED"
| "ENABLING"
| "ENABLING_FAILED"
| "DISABLED"
| "DISABLING"
| "DISABLING_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface SourceDescription {
  KinesisStreamSourceDescription?: KinesisStreamSourceDescription | null;
}
function toSourceDescription(root: jsonP.JSONValue): SourceDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "KinesisStreamSourceDescription": toKinesisStreamSourceDescription,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface KinesisStreamSourceDescription {
  KinesisStreamARN?: string | null;
  RoleARN?: string | null;
  DeliveryStartTimestamp?: Date | number | null;
}
function toKinesisStreamSourceDescription(root: jsonP.JSONValue): KinesisStreamSourceDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "KinesisStreamARN": "s",
      "RoleARN": "s",
      "DeliveryStartTimestamp": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DestinationDescription {
  DestinationId: string;
  S3DestinationDescription?: S3DestinationDescription | null;
  ExtendedS3DestinationDescription?: ExtendedS3DestinationDescription | null;
  RedshiftDestinationDescription?: RedshiftDestinationDescription | null;
  ElasticsearchDestinationDescription?: ElasticsearchDestinationDescription | null;
  SplunkDestinationDescription?: SplunkDestinationDescription | null;
  HttpEndpointDestinationDescription?: HttpEndpointDestinationDescription | null;
}
function toDestinationDescription(root: jsonP.JSONValue): DestinationDescription {
  return jsonP.readObj({
    required: {
      "DestinationId": "s",
    },
    optional: {
      "S3DestinationDescription": toS3DestinationDescription,
      "ExtendedS3DestinationDescription": toExtendedS3DestinationDescription,
      "RedshiftDestinationDescription": toRedshiftDestinationDescription,
      "ElasticsearchDestinationDescription": toElasticsearchDestinationDescription,
      "SplunkDestinationDescription": toSplunkDestinationDescription,
      "HttpEndpointDestinationDescription": toHttpEndpointDestinationDescription,
    },
  }, root);
}

// refs: 7 - tags: output, named, interface
export interface S3DestinationDescription {
  RoleARN: string;
  BucketARN: string;
  Prefix?: string | null;
  ErrorOutputPrefix?: string | null;
  BufferingHints: BufferingHints;
  CompressionFormat: CompressionFormat;
  EncryptionConfiguration: EncryptionConfiguration;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function toS3DestinationDescription(root: jsonP.JSONValue): S3DestinationDescription {
  return jsonP.readObj({
    required: {
      "RoleARN": "s",
      "BucketARN": "s",
      "BufferingHints": toBufferingHints,
      "CompressionFormat": (x: jsonP.JSONValue) => cmnP.readEnum<CompressionFormat>(x),
      "EncryptionConfiguration": toEncryptionConfiguration,
    },
    optional: {
      "Prefix": "s",
      "ErrorOutputPrefix": "s",
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ExtendedS3DestinationDescription {
  RoleARN: string;
  BucketARN: string;
  Prefix?: string | null;
  ErrorOutputPrefix?: string | null;
  BufferingHints: BufferingHints;
  CompressionFormat: CompressionFormat;
  EncryptionConfiguration: EncryptionConfiguration;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  S3BackupMode?: S3BackupMode | null;
  S3BackupDescription?: S3DestinationDescription | null;
  DataFormatConversionConfiguration?: DataFormatConversionConfiguration | null;
}
function toExtendedS3DestinationDescription(root: jsonP.JSONValue): ExtendedS3DestinationDescription {
  return jsonP.readObj({
    required: {
      "RoleARN": "s",
      "BucketARN": "s",
      "BufferingHints": toBufferingHints,
      "CompressionFormat": (x: jsonP.JSONValue) => cmnP.readEnum<CompressionFormat>(x),
      "EncryptionConfiguration": toEncryptionConfiguration,
    },
    optional: {
      "Prefix": "s",
      "ErrorOutputPrefix": "s",
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
      "ProcessingConfiguration": toProcessingConfiguration,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<S3BackupMode>(x),
      "S3BackupDescription": toS3DestinationDescription,
      "DataFormatConversionConfiguration": toDataFormatConversionConfiguration,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RedshiftDestinationDescription {
  RoleARN: string;
  ClusterJDBCURL: string;
  CopyCommand: CopyCommand;
  Username: string;
  RetryOptions?: RedshiftRetryOptions | null;
  S3DestinationDescription: S3DestinationDescription;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  S3BackupMode?: RedshiftS3BackupMode | null;
  S3BackupDescription?: S3DestinationDescription | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function toRedshiftDestinationDescription(root: jsonP.JSONValue): RedshiftDestinationDescription {
  return jsonP.readObj({
    required: {
      "RoleARN": "s",
      "ClusterJDBCURL": "s",
      "CopyCommand": toCopyCommand,
      "Username": "s",
      "S3DestinationDescription": toS3DestinationDescription,
    },
    optional: {
      "RetryOptions": toRedshiftRetryOptions,
      "ProcessingConfiguration": toProcessingConfiguration,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<RedshiftS3BackupMode>(x),
      "S3BackupDescription": toS3DestinationDescription,
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ElasticsearchDestinationDescription {
  RoleARN?: string | null;
  DomainARN?: string | null;
  ClusterEndpoint?: string | null;
  IndexName?: string | null;
  TypeName?: string | null;
  IndexRotationPeriod?: ElasticsearchIndexRotationPeriod | null;
  BufferingHints?: ElasticsearchBufferingHints | null;
  RetryOptions?: ElasticsearchRetryOptions | null;
  S3BackupMode?: ElasticsearchS3BackupMode | null;
  S3DestinationDescription?: S3DestinationDescription | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
  VpcConfigurationDescription?: VpcConfigurationDescription | null;
}
function toElasticsearchDestinationDescription(root: jsonP.JSONValue): ElasticsearchDestinationDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "RoleARN": "s",
      "DomainARN": "s",
      "ClusterEndpoint": "s",
      "IndexName": "s",
      "TypeName": "s",
      "IndexRotationPeriod": (x: jsonP.JSONValue) => cmnP.readEnum<ElasticsearchIndexRotationPeriod>(x),
      "BufferingHints": toElasticsearchBufferingHints,
      "RetryOptions": toElasticsearchRetryOptions,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<ElasticsearchS3BackupMode>(x),
      "S3DestinationDescription": toS3DestinationDescription,
      "ProcessingConfiguration": toProcessingConfiguration,
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
      "VpcConfigurationDescription": toVpcConfigurationDescription,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VpcConfigurationDescription {
  SubnetIds: string[];
  RoleARN: string;
  SecurityGroupIds: string[];
  VpcId: string;
}
function toVpcConfigurationDescription(root: jsonP.JSONValue): VpcConfigurationDescription {
  return jsonP.readObj({
    required: {
      "SubnetIds": ["s"],
      "RoleARN": "s",
      "SecurityGroupIds": ["s"],
      "VpcId": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SplunkDestinationDescription {
  HECEndpoint?: string | null;
  HECEndpointType?: HECEndpointType | null;
  HECToken?: string | null;
  HECAcknowledgmentTimeoutInSeconds?: number | null;
  RetryOptions?: SplunkRetryOptions | null;
  S3BackupMode?: SplunkS3BackupMode | null;
  S3DestinationDescription?: S3DestinationDescription | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
}
function toSplunkDestinationDescription(root: jsonP.JSONValue): SplunkDestinationDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "HECEndpoint": "s",
      "HECEndpointType": (x: jsonP.JSONValue) => cmnP.readEnum<HECEndpointType>(x),
      "HECToken": "s",
      "HECAcknowledgmentTimeoutInSeconds": "n",
      "RetryOptions": toSplunkRetryOptions,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<SplunkS3BackupMode>(x),
      "S3DestinationDescription": toS3DestinationDescription,
      "ProcessingConfiguration": toProcessingConfiguration,
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface HttpEndpointDestinationDescription {
  EndpointConfiguration?: HttpEndpointDescription | null;
  BufferingHints?: HttpEndpointBufferingHints | null;
  CloudWatchLoggingOptions?: CloudWatchLoggingOptions | null;
  RequestConfiguration?: HttpEndpointRequestConfiguration | null;
  ProcessingConfiguration?: ProcessingConfiguration | null;
  RoleARN?: string | null;
  RetryOptions?: HttpEndpointRetryOptions | null;
  S3BackupMode?: HttpEndpointS3BackupMode | null;
  S3DestinationDescription?: S3DestinationDescription | null;
}
function toHttpEndpointDestinationDescription(root: jsonP.JSONValue): HttpEndpointDestinationDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointConfiguration": toHttpEndpointDescription,
      "BufferingHints": toHttpEndpointBufferingHints,
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
      "RequestConfiguration": toHttpEndpointRequestConfiguration,
      "ProcessingConfiguration": toProcessingConfiguration,
      "RoleARN": "s",
      "RetryOptions": toHttpEndpointRetryOptions,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<HttpEndpointS3BackupMode>(x),
      "S3DestinationDescription": toS3DestinationDescription,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface HttpEndpointDescription {
  Url?: string | null;
  Name?: string | null;
}
function toHttpEndpointDescription(root: jsonP.JSONValue): HttpEndpointDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Url": "s",
      "Name": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PutRecordBatchResponseEntry {
  RecordId?: string | null;
  ErrorCode?: string | null;
  ErrorMessage?: string | null;
}
function toPutRecordBatchResponseEntry(root: jsonP.JSONValue): PutRecordBatchResponseEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecordId": "s",
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}
