// Autogenerated API client for: Amazon Kinesis Firehose

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Firehose {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Firehose.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-08-04",
    "endpointPrefix": "firehose",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Firehose",
    "serviceFullName": "Amazon Kinesis Firehose",
    "serviceId": "Firehose",
    "signatureVersion": "v4",
    "targetPrefix": "Firehose_20150804",
    "uid": "firehose-2015-08-04"
  };

  async createDeliveryStream(
    {abortSignal, ...params}: RequestConfig & s.CreateDeliveryStreamInput,
  ): Promise<s.CreateDeliveryStreamOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      DeliveryStreamType: params["DeliveryStreamType"],
      KinesisStreamSourceConfiguration: fromKinesisStreamSourceConfiguration(params["KinesisStreamSourceConfiguration"]),
      DeliveryStreamEncryptionConfigurationInput: fromDeliveryStreamEncryptionConfigurationInput(params["DeliveryStreamEncryptionConfigurationInput"]),
      S3DestinationConfiguration: fromS3DestinationConfiguration(params["S3DestinationConfiguration"]),
      ExtendedS3DestinationConfiguration: fromExtendedS3DestinationConfiguration(params["ExtendedS3DestinationConfiguration"]),
      RedshiftDestinationConfiguration: fromRedshiftDestinationConfiguration(params["RedshiftDestinationConfiguration"]),
      ElasticsearchDestinationConfiguration: fromElasticsearchDestinationConfiguration(params["ElasticsearchDestinationConfiguration"]),
      SplunkDestinationConfiguration: fromSplunkDestinationConfiguration(params["SplunkDestinationConfiguration"]),
      HttpEndpointDestinationConfiguration: fromHttpEndpointDestinationConfiguration(params["HttpEndpointDestinationConfiguration"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeliveryStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DeliveryStreamARN": "s",
      },
    }, await resp.json());
  }

  async deleteDeliveryStream(
    {abortSignal, ...params}: RequestConfig & s.DeleteDeliveryStreamInput,
  ): Promise<s.DeleteDeliveryStreamOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      AllowForceDelete: params["AllowForceDelete"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDeliveryStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeDeliveryStream(
    {abortSignal, ...params}: RequestConfig & s.DescribeDeliveryStreamInput,
  ): Promise<s.DescribeDeliveryStreamOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      Limit: params["Limit"],
      ExclusiveStartDestinationId: params["ExclusiveStartDestinationId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDeliveryStream",
    });
    return jsonP.readObj({
      required: {
        "DeliveryStreamDescription": toDeliveryStreamDescription,
      },
      optional: {},
    }, await resp.json());
  }

  async listDeliveryStreams(
    {abortSignal, ...params}: RequestConfig & s.ListDeliveryStreamsInput = {},
  ): Promise<s.ListDeliveryStreamsOutput> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      DeliveryStreamType: params["DeliveryStreamType"],
      ExclusiveStartDeliveryStreamName: params["ExclusiveStartDeliveryStreamName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeliveryStreams",
    });
    return jsonP.readObj({
      required: {
        "DeliveryStreamNames": ["s"],
        "HasMoreDeliveryStreams": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async listTagsForDeliveryStream(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForDeliveryStreamInput,
  ): Promise<s.ListTagsForDeliveryStreamOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      ExclusiveStartTagKey: params["ExclusiveStartTagKey"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForDeliveryStream",
    });
    return jsonP.readObj({
      required: {
        "Tags": [toTag],
        "HasMoreTags": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async putRecord(
    {abortSignal, ...params}: RequestConfig & s.PutRecordInput,
  ): Promise<s.PutRecordOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      Record: fromRecord(params["Record"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRecord",
    });
    return jsonP.readObj({
      required: {
        "RecordId": "s",
      },
      optional: {
        "Encrypted": "b",
      },
    }, await resp.json());
  }

  async putRecordBatch(
    {abortSignal, ...params}: RequestConfig & s.PutRecordBatchInput,
  ): Promise<s.PutRecordBatchOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      Records: params["Records"]?.map(x => fromRecord(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRecordBatch",
    });
    return jsonP.readObj({
      required: {
        "FailedPutCount": "n",
        "RequestResponses": [toPutRecordBatchResponseEntry],
      },
      optional: {
        "Encrypted": "b",
      },
    }, await resp.json());
  }

  async startDeliveryStreamEncryption(
    {abortSignal, ...params}: RequestConfig & s.StartDeliveryStreamEncryptionInput,
  ): Promise<s.StartDeliveryStreamEncryptionOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      DeliveryStreamEncryptionConfigurationInput: fromDeliveryStreamEncryptionConfigurationInput(params["DeliveryStreamEncryptionConfigurationInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDeliveryStreamEncryption",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async stopDeliveryStreamEncryption(
    {abortSignal, ...params}: RequestConfig & s.StopDeliveryStreamEncryptionInput,
  ): Promise<s.StopDeliveryStreamEncryptionOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopDeliveryStreamEncryption",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagDeliveryStream(
    {abortSignal, ...params}: RequestConfig & s.TagDeliveryStreamInput,
  ): Promise<s.TagDeliveryStreamOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagDeliveryStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagDeliveryStream(
    {abortSignal, ...params}: RequestConfig & s.UntagDeliveryStreamInput,
  ): Promise<s.UntagDeliveryStreamOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagDeliveryStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDestination(
    {abortSignal, ...params}: RequestConfig & s.UpdateDestinationInput,
  ): Promise<s.UpdateDestinationOutput> {
    const body: jsonP.JSONObject = {
      DeliveryStreamName: params["DeliveryStreamName"],
      CurrentDeliveryStreamVersionId: params["CurrentDeliveryStreamVersionId"],
      DestinationId: params["DestinationId"],
      S3DestinationUpdate: fromS3DestinationUpdate(params["S3DestinationUpdate"]),
      ExtendedS3DestinationUpdate: fromExtendedS3DestinationUpdate(params["ExtendedS3DestinationUpdate"]),
      RedshiftDestinationUpdate: fromRedshiftDestinationUpdate(params["RedshiftDestinationUpdate"]),
      ElasticsearchDestinationUpdate: fromElasticsearchDestinationUpdate(params["ElasticsearchDestinationUpdate"]),
      SplunkDestinationUpdate: fromSplunkDestinationUpdate(params["SplunkDestinationUpdate"]),
      HttpEndpointDestinationUpdate: fromHttpEndpointDestinationUpdate(params["HttpEndpointDestinationUpdate"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDestination",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromKinesisStreamSourceConfiguration(input?: s.KinesisStreamSourceConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KinesisStreamARN: input["KinesisStreamARN"],
    RoleARN: input["RoleARN"],
  }
}

function fromDeliveryStreamEncryptionConfigurationInput(input?: s.DeliveryStreamEncryptionConfigurationInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KeyARN: input["KeyARN"],
    KeyType: input["KeyType"],
  }
}

function fromS3DestinationConfiguration(input?: s.S3DestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    BucketARN: input["BucketARN"],
    Prefix: input["Prefix"],
    ErrorOutputPrefix: input["ErrorOutputPrefix"],
    BufferingHints: fromBufferingHints(input["BufferingHints"]),
    CompressionFormat: input["CompressionFormat"],
    EncryptionConfiguration: fromEncryptionConfiguration(input["EncryptionConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

function fromBufferingHints(input?: s.BufferingHints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SizeInMBs: input["SizeInMBs"],
    IntervalInSeconds: input["IntervalInSeconds"],
  }
}
function toBufferingHints(root: jsonP.JSONValue): s.BufferingHints {
  return jsonP.readObj({
    required: {},
    optional: {
      "SizeInMBs": "n",
      "IntervalInSeconds": "n",
    },
  }, root);
}

function fromEncryptionConfiguration(input?: s.EncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NoEncryptionConfig: input["NoEncryptionConfig"],
    KMSEncryptionConfig: fromKMSEncryptionConfig(input["KMSEncryptionConfig"]),
  }
}
function toEncryptionConfiguration(root: jsonP.JSONValue): s.EncryptionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "NoEncryptionConfig": (x: jsonP.JSONValue) => cmnP.readEnum<s.NoEncryptionConfig>(x),
      "KMSEncryptionConfig": toKMSEncryptionConfig,
    },
  }, root);
}

function fromKMSEncryptionConfig(input?: s.KMSEncryptionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AWSKMSKeyARN: input["AWSKMSKeyARN"],
  }
}
function toKMSEncryptionConfig(root: jsonP.JSONValue): s.KMSEncryptionConfig {
  return jsonP.readObj({
    required: {
      "AWSKMSKeyARN": "s",
    },
    optional: {},
  }, root);
}

function fromCloudWatchLoggingOptions(input?: s.CloudWatchLoggingOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    LogGroupName: input["LogGroupName"],
    LogStreamName: input["LogStreamName"],
  }
}
function toCloudWatchLoggingOptions(root: jsonP.JSONValue): s.CloudWatchLoggingOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "LogGroupName": "s",
      "LogStreamName": "s",
    },
  }, root);
}

function fromExtendedS3DestinationConfiguration(input?: s.ExtendedS3DestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    BucketARN: input["BucketARN"],
    Prefix: input["Prefix"],
    ErrorOutputPrefix: input["ErrorOutputPrefix"],
    BufferingHints: fromBufferingHints(input["BufferingHints"]),
    CompressionFormat: input["CompressionFormat"],
    EncryptionConfiguration: fromEncryptionConfiguration(input["EncryptionConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    S3BackupMode: input["S3BackupMode"],
    S3BackupConfiguration: fromS3DestinationConfiguration(input["S3BackupConfiguration"]),
    DataFormatConversionConfiguration: fromDataFormatConversionConfiguration(input["DataFormatConversionConfiguration"]),
  }
}

function fromProcessingConfiguration(input?: s.ProcessingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    Processors: input["Processors"]?.map(x => fromProcessor(x)),
  }
}
function toProcessingConfiguration(root: jsonP.JSONValue): s.ProcessingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "Processors": [toProcessor],
    },
  }, root);
}

function fromProcessor(input?: s.Processor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Parameters: input["Parameters"]?.map(x => fromProcessorParameter(x)),
  }
}
function toProcessor(root: jsonP.JSONValue): s.Processor {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessorType>(x),
    },
    optional: {
      "Parameters": [toProcessorParameter],
    },
  }, root);
}

function fromProcessorParameter(input?: s.ProcessorParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParameterName: input["ParameterName"],
    ParameterValue: input["ParameterValue"],
  }
}
function toProcessorParameter(root: jsonP.JSONValue): s.ProcessorParameter {
  return jsonP.readObj({
    required: {
      "ParameterName": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessorParameterName>(x),
      "ParameterValue": "s",
    },
    optional: {},
  }, root);
}

function fromDataFormatConversionConfiguration(input?: s.DataFormatConversionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaConfiguration: fromSchemaConfiguration(input["SchemaConfiguration"]),
    InputFormatConfiguration: fromInputFormatConfiguration(input["InputFormatConfiguration"]),
    OutputFormatConfiguration: fromOutputFormatConfiguration(input["OutputFormatConfiguration"]),
    Enabled: input["Enabled"],
  }
}
function toDataFormatConversionConfiguration(root: jsonP.JSONValue): s.DataFormatConversionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaConfiguration": toSchemaConfiguration,
      "InputFormatConfiguration": toInputFormatConfiguration,
      "OutputFormatConfiguration": toOutputFormatConfiguration,
      "Enabled": "b",
    },
  }, root);
}

function fromSchemaConfiguration(input?: s.SchemaConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
    TableName: input["TableName"],
    Region: input["Region"],
    VersionId: input["VersionId"],
  }
}
function toSchemaConfiguration(root: jsonP.JSONValue): s.SchemaConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "RoleARN": "s",
      "CatalogId": "s",
      "DatabaseName": "s",
      "TableName": "s",
      "Region": "s",
      "VersionId": "s",
    },
  }, root);
}

function fromInputFormatConfiguration(input?: s.InputFormatConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Deserializer: fromDeserializer(input["Deserializer"]),
  }
}
function toInputFormatConfiguration(root: jsonP.JSONValue): s.InputFormatConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Deserializer": toDeserializer,
    },
  }, root);
}

function fromDeserializer(input?: s.Deserializer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OpenXJsonSerDe: fromOpenXJsonSerDe(input["OpenXJsonSerDe"]),
    HiveJsonSerDe: fromHiveJsonSerDe(input["HiveJsonSerDe"]),
  }
}
function toDeserializer(root: jsonP.JSONValue): s.Deserializer {
  return jsonP.readObj({
    required: {},
    optional: {
      "OpenXJsonSerDe": toOpenXJsonSerDe,
      "HiveJsonSerDe": toHiveJsonSerDe,
    },
  }, root);
}

function fromOpenXJsonSerDe(input?: s.OpenXJsonSerDe | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConvertDotsInJsonKeysToUnderscores: input["ConvertDotsInJsonKeysToUnderscores"],
    CaseInsensitive: input["CaseInsensitive"],
    ColumnToJsonKeyMappings: input["ColumnToJsonKeyMappings"],
  }
}
function toOpenXJsonSerDe(root: jsonP.JSONValue): s.OpenXJsonSerDe {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConvertDotsInJsonKeysToUnderscores": "b",
      "CaseInsensitive": "b",
      "ColumnToJsonKeyMappings": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromHiveJsonSerDe(input?: s.HiveJsonSerDe | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TimestampFormats: input["TimestampFormats"],
  }
}
function toHiveJsonSerDe(root: jsonP.JSONValue): s.HiveJsonSerDe {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimestampFormats": ["s"],
    },
  }, root);
}

function fromOutputFormatConfiguration(input?: s.OutputFormatConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Serializer: fromSerializer(input["Serializer"]),
  }
}
function toOutputFormatConfiguration(root: jsonP.JSONValue): s.OutputFormatConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Serializer": toSerializer,
    },
  }, root);
}

function fromSerializer(input?: s.Serializer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParquetSerDe: fromParquetSerDe(input["ParquetSerDe"]),
    OrcSerDe: fromOrcSerDe(input["OrcSerDe"]),
  }
}
function toSerializer(root: jsonP.JSONValue): s.Serializer {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParquetSerDe": toParquetSerDe,
      "OrcSerDe": toOrcSerDe,
    },
  }, root);
}

function fromParquetSerDe(input?: s.ParquetSerDe | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BlockSizeBytes: input["BlockSizeBytes"],
    PageSizeBytes: input["PageSizeBytes"],
    Compression: input["Compression"],
    EnableDictionaryCompression: input["EnableDictionaryCompression"],
    MaxPaddingBytes: input["MaxPaddingBytes"],
    WriterVersion: input["WriterVersion"],
  }
}
function toParquetSerDe(root: jsonP.JSONValue): s.ParquetSerDe {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlockSizeBytes": "n",
      "PageSizeBytes": "n",
      "Compression": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParquetCompression>(x),
      "EnableDictionaryCompression": "b",
      "MaxPaddingBytes": "n",
      "WriterVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParquetWriterVersion>(x),
    },
  }, root);
}

function fromOrcSerDe(input?: s.OrcSerDe | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StripeSizeBytes: input["StripeSizeBytes"],
    BlockSizeBytes: input["BlockSizeBytes"],
    RowIndexStride: input["RowIndexStride"],
    EnablePadding: input["EnablePadding"],
    PaddingTolerance: input["PaddingTolerance"],
    Compression: input["Compression"],
    BloomFilterColumns: input["BloomFilterColumns"],
    BloomFilterFalsePositiveProbability: input["BloomFilterFalsePositiveProbability"],
    DictionaryKeyThreshold: input["DictionaryKeyThreshold"],
    FormatVersion: input["FormatVersion"],
  }
}
function toOrcSerDe(root: jsonP.JSONValue): s.OrcSerDe {
  return jsonP.readObj({
    required: {},
    optional: {
      "StripeSizeBytes": "n",
      "BlockSizeBytes": "n",
      "RowIndexStride": "n",
      "EnablePadding": "b",
      "PaddingTolerance": "n",
      "Compression": (x: jsonP.JSONValue) => cmnP.readEnum<s.OrcCompression>(x),
      "BloomFilterColumns": ["s"],
      "BloomFilterFalsePositiveProbability": "n",
      "DictionaryKeyThreshold": "n",
      "FormatVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.OrcFormatVersion>(x),
    },
  }, root);
}

function fromRedshiftDestinationConfiguration(input?: s.RedshiftDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    ClusterJDBCURL: input["ClusterJDBCURL"],
    CopyCommand: fromCopyCommand(input["CopyCommand"]),
    Username: input["Username"],
    Password: input["Password"],
    RetryOptions: fromRedshiftRetryOptions(input["RetryOptions"]),
    S3Configuration: fromS3DestinationConfiguration(input["S3Configuration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    S3BackupMode: input["S3BackupMode"],
    S3BackupConfiguration: fromS3DestinationConfiguration(input["S3BackupConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

function fromCopyCommand(input?: s.CopyCommand | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataTableName: input["DataTableName"],
    DataTableColumns: input["DataTableColumns"],
    CopyOptions: input["CopyOptions"],
  }
}
function toCopyCommand(root: jsonP.JSONValue): s.CopyCommand {
  return jsonP.readObj({
    required: {
      "DataTableName": "s",
    },
    optional: {
      "DataTableColumns": "s",
      "CopyOptions": "s",
    },
  }, root);
}

function fromRedshiftRetryOptions(input?: s.RedshiftRetryOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DurationInSeconds: input["DurationInSeconds"],
  }
}
function toRedshiftRetryOptions(root: jsonP.JSONValue): s.RedshiftRetryOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInSeconds": "n",
    },
  }, root);
}

function fromElasticsearchDestinationConfiguration(input?: s.ElasticsearchDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    DomainARN: input["DomainARN"],
    ClusterEndpoint: input["ClusterEndpoint"],
    IndexName: input["IndexName"],
    TypeName: input["TypeName"],
    IndexRotationPeriod: input["IndexRotationPeriod"],
    BufferingHints: fromElasticsearchBufferingHints(input["BufferingHints"]),
    RetryOptions: fromElasticsearchRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Configuration: fromS3DestinationConfiguration(input["S3Configuration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    VpcConfiguration: fromVpcConfiguration(input["VpcConfiguration"]),
  }
}

function fromElasticsearchBufferingHints(input?: s.ElasticsearchBufferingHints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IntervalInSeconds: input["IntervalInSeconds"],
    SizeInMBs: input["SizeInMBs"],
  }
}
function toElasticsearchBufferingHints(root: jsonP.JSONValue): s.ElasticsearchBufferingHints {
  return jsonP.readObj({
    required: {},
    optional: {
      "IntervalInSeconds": "n",
      "SizeInMBs": "n",
    },
  }, root);
}

function fromElasticsearchRetryOptions(input?: s.ElasticsearchRetryOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DurationInSeconds: input["DurationInSeconds"],
  }
}
function toElasticsearchRetryOptions(root: jsonP.JSONValue): s.ElasticsearchRetryOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInSeconds": "n",
    },
  }, root);
}

function fromVpcConfiguration(input?: s.VpcConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetIds: input["SubnetIds"],
    RoleARN: input["RoleARN"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}

function fromSplunkDestinationConfiguration(input?: s.SplunkDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HECEndpoint: input["HECEndpoint"],
    HECEndpointType: input["HECEndpointType"],
    HECToken: input["HECToken"],
    HECAcknowledgmentTimeoutInSeconds: input["HECAcknowledgmentTimeoutInSeconds"],
    RetryOptions: fromSplunkRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Configuration: fromS3DestinationConfiguration(input["S3Configuration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

function fromSplunkRetryOptions(input?: s.SplunkRetryOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DurationInSeconds: input["DurationInSeconds"],
  }
}
function toSplunkRetryOptions(root: jsonP.JSONValue): s.SplunkRetryOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInSeconds": "n",
    },
  }, root);
}

function fromHttpEndpointDestinationConfiguration(input?: s.HttpEndpointDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointConfiguration: fromHttpEndpointConfiguration(input["EndpointConfiguration"]),
    BufferingHints: fromHttpEndpointBufferingHints(input["BufferingHints"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    RequestConfiguration: fromHttpEndpointRequestConfiguration(input["RequestConfiguration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    RoleARN: input["RoleARN"],
    RetryOptions: fromHttpEndpointRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Configuration: fromS3DestinationConfiguration(input["S3Configuration"]),
  }
}

function fromHttpEndpointConfiguration(input?: s.HttpEndpointConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Url: input["Url"],
    Name: input["Name"],
    AccessKey: input["AccessKey"],
  }
}

function fromHttpEndpointBufferingHints(input?: s.HttpEndpointBufferingHints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SizeInMBs: input["SizeInMBs"],
    IntervalInSeconds: input["IntervalInSeconds"],
  }
}
function toHttpEndpointBufferingHints(root: jsonP.JSONValue): s.HttpEndpointBufferingHints {
  return jsonP.readObj({
    required: {},
    optional: {
      "SizeInMBs": "n",
      "IntervalInSeconds": "n",
    },
  }, root);
}

function fromHttpEndpointRequestConfiguration(input?: s.HttpEndpointRequestConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContentEncoding: input["ContentEncoding"],
    CommonAttributes: input["CommonAttributes"]?.map(x => fromHttpEndpointCommonAttribute(x)),
  }
}
function toHttpEndpointRequestConfiguration(root: jsonP.JSONValue): s.HttpEndpointRequestConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ContentEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentEncoding>(x),
      "CommonAttributes": [toHttpEndpointCommonAttribute],
    },
  }, root);
}

function fromHttpEndpointCommonAttribute(input?: s.HttpEndpointCommonAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    AttributeValue: input["AttributeValue"],
  }
}
function toHttpEndpointCommonAttribute(root: jsonP.JSONValue): s.HttpEndpointCommonAttribute {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "AttributeValue": "s",
    },
    optional: {},
  }, root);
}

function fromHttpEndpointRetryOptions(input?: s.HttpEndpointRetryOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DurationInSeconds: input["DurationInSeconds"],
  }
}
function toHttpEndpointRetryOptions(root: jsonP.JSONValue): s.HttpEndpointRetryOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "DurationInSeconds": "n",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

function fromRecord(input?: s.Record | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Data: jsonP.serializeBlob(input["Data"]),
  }
}

function fromS3DestinationUpdate(input?: s.S3DestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    BucketARN: input["BucketARN"],
    Prefix: input["Prefix"],
    ErrorOutputPrefix: input["ErrorOutputPrefix"],
    BufferingHints: fromBufferingHints(input["BufferingHints"]),
    CompressionFormat: input["CompressionFormat"],
    EncryptionConfiguration: fromEncryptionConfiguration(input["EncryptionConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

function fromExtendedS3DestinationUpdate(input?: s.ExtendedS3DestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    BucketARN: input["BucketARN"],
    Prefix: input["Prefix"],
    ErrorOutputPrefix: input["ErrorOutputPrefix"],
    BufferingHints: fromBufferingHints(input["BufferingHints"]),
    CompressionFormat: input["CompressionFormat"],
    EncryptionConfiguration: fromEncryptionConfiguration(input["EncryptionConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    S3BackupMode: input["S3BackupMode"],
    S3BackupUpdate: fromS3DestinationUpdate(input["S3BackupUpdate"]),
    DataFormatConversionConfiguration: fromDataFormatConversionConfiguration(input["DataFormatConversionConfiguration"]),
  }
}

function fromRedshiftDestinationUpdate(input?: s.RedshiftDestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    ClusterJDBCURL: input["ClusterJDBCURL"],
    CopyCommand: fromCopyCommand(input["CopyCommand"]),
    Username: input["Username"],
    Password: input["Password"],
    RetryOptions: fromRedshiftRetryOptions(input["RetryOptions"]),
    S3Update: fromS3DestinationUpdate(input["S3Update"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    S3BackupMode: input["S3BackupMode"],
    S3BackupUpdate: fromS3DestinationUpdate(input["S3BackupUpdate"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

function fromElasticsearchDestinationUpdate(input?: s.ElasticsearchDestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    DomainARN: input["DomainARN"],
    ClusterEndpoint: input["ClusterEndpoint"],
    IndexName: input["IndexName"],
    TypeName: input["TypeName"],
    IndexRotationPeriod: input["IndexRotationPeriod"],
    BufferingHints: fromElasticsearchBufferingHints(input["BufferingHints"]),
    RetryOptions: fromElasticsearchRetryOptions(input["RetryOptions"]),
    S3Update: fromS3DestinationUpdate(input["S3Update"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

function fromSplunkDestinationUpdate(input?: s.SplunkDestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HECEndpoint: input["HECEndpoint"],
    HECEndpointType: input["HECEndpointType"],
    HECToken: input["HECToken"],
    HECAcknowledgmentTimeoutInSeconds: input["HECAcknowledgmentTimeoutInSeconds"],
    RetryOptions: fromSplunkRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Update: fromS3DestinationUpdate(input["S3Update"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
  }
}

function fromHttpEndpointDestinationUpdate(input?: s.HttpEndpointDestinationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointConfiguration: fromHttpEndpointConfiguration(input["EndpointConfiguration"]),
    BufferingHints: fromHttpEndpointBufferingHints(input["BufferingHints"]),
    CloudWatchLoggingOptions: fromCloudWatchLoggingOptions(input["CloudWatchLoggingOptions"]),
    RequestConfiguration: fromHttpEndpointRequestConfiguration(input["RequestConfiguration"]),
    ProcessingConfiguration: fromProcessingConfiguration(input["ProcessingConfiguration"]),
    RoleARN: input["RoleARN"],
    RetryOptions: fromHttpEndpointRetryOptions(input["RetryOptions"]),
    S3BackupMode: input["S3BackupMode"],
    S3Update: fromS3DestinationUpdate(input["S3Update"]),
  }
}

function toDeliveryStreamDescription(root: jsonP.JSONValue): s.DeliveryStreamDescription {
  return jsonP.readObj({
    required: {
      "DeliveryStreamName": "s",
      "DeliveryStreamARN": "s",
      "DeliveryStreamStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeliveryStreamStatus>(x),
      "DeliveryStreamType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeliveryStreamType>(x),
      "VersionId": "s",
      "Destinations": [toDestinationDescription],
      "HasMoreDestinations": "b",
    },
    optional: {
      "FailureDescription": toFailureDescription,
      "DeliveryStreamEncryptionConfiguration": toDeliveryStreamEncryptionConfiguration,
      "CreateTimestamp": "d",
      "LastUpdateTimestamp": "d",
      "Source": toSourceDescription,
    },
  }, root);
}

function toFailureDescription(root: jsonP.JSONValue): s.FailureDescription {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeliveryStreamFailureType>(x),
      "Details": "s",
    },
    optional: {},
  }, root);
}

function toDeliveryStreamEncryptionConfiguration(root: jsonP.JSONValue): s.DeliveryStreamEncryptionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyARN": "s",
      "KeyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeliveryStreamEncryptionStatus>(x),
      "FailureDescription": toFailureDescription,
    },
  }, root);
}

function toSourceDescription(root: jsonP.JSONValue): s.SourceDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "KinesisStreamSourceDescription": toKinesisStreamSourceDescription,
    },
  }, root);
}

function toKinesisStreamSourceDescription(root: jsonP.JSONValue): s.KinesisStreamSourceDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "KinesisStreamARN": "s",
      "RoleARN": "s",
      "DeliveryStartTimestamp": "d",
    },
  }, root);
}

function toDestinationDescription(root: jsonP.JSONValue): s.DestinationDescription {
  return jsonP.readObj({
    required: {
      "DestinationId": "s",
    },
    optional: {
      "S3DestinationDescription": toS3DestinationDescription,
      "ExtendedS3DestinationDescription": toExtendedS3DestinationDescription,
      "RedshiftDestinationDescription": toRedshiftDestinationDescription,
      "ElasticsearchDestinationDescription": toElasticsearchDestinationDescription,
      "SplunkDestinationDescription": toSplunkDestinationDescription,
      "HttpEndpointDestinationDescription": toHttpEndpointDestinationDescription,
    },
  }, root);
}

function toS3DestinationDescription(root: jsonP.JSONValue): s.S3DestinationDescription {
  return jsonP.readObj({
    required: {
      "RoleARN": "s",
      "BucketARN": "s",
      "BufferingHints": toBufferingHints,
      "CompressionFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompressionFormat>(x),
      "EncryptionConfiguration": toEncryptionConfiguration,
    },
    optional: {
      "Prefix": "s",
      "ErrorOutputPrefix": "s",
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
    },
  }, root);
}

function toExtendedS3DestinationDescription(root: jsonP.JSONValue): s.ExtendedS3DestinationDescription {
  return jsonP.readObj({
    required: {
      "RoleARN": "s",
      "BucketARN": "s",
      "BufferingHints": toBufferingHints,
      "CompressionFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompressionFormat>(x),
      "EncryptionConfiguration": toEncryptionConfiguration,
    },
    optional: {
      "Prefix": "s",
      "ErrorOutputPrefix": "s",
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
      "ProcessingConfiguration": toProcessingConfiguration,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.S3BackupMode>(x),
      "S3BackupDescription": toS3DestinationDescription,
      "DataFormatConversionConfiguration": toDataFormatConversionConfiguration,
    },
  }, root);
}

function toRedshiftDestinationDescription(root: jsonP.JSONValue): s.RedshiftDestinationDescription {
  return jsonP.readObj({
    required: {
      "RoleARN": "s",
      "ClusterJDBCURL": "s",
      "CopyCommand": toCopyCommand,
      "Username": "s",
      "S3DestinationDescription": toS3DestinationDescription,
    },
    optional: {
      "RetryOptions": toRedshiftRetryOptions,
      "ProcessingConfiguration": toProcessingConfiguration,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.RedshiftS3BackupMode>(x),
      "S3BackupDescription": toS3DestinationDescription,
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
    },
  }, root);
}

function toElasticsearchDestinationDescription(root: jsonP.JSONValue): s.ElasticsearchDestinationDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "RoleARN": "s",
      "DomainARN": "s",
      "ClusterEndpoint": "s",
      "IndexName": "s",
      "TypeName": "s",
      "IndexRotationPeriod": (x: jsonP.JSONValue) => cmnP.readEnum<s.ElasticsearchIndexRotationPeriod>(x),
      "BufferingHints": toElasticsearchBufferingHints,
      "RetryOptions": toElasticsearchRetryOptions,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ElasticsearchS3BackupMode>(x),
      "S3DestinationDescription": toS3DestinationDescription,
      "ProcessingConfiguration": toProcessingConfiguration,
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
      "VpcConfigurationDescription": toVpcConfigurationDescription,
    },
  }, root);
}

function toVpcConfigurationDescription(root: jsonP.JSONValue): s.VpcConfigurationDescription {
  return jsonP.readObj({
    required: {
      "SubnetIds": ["s"],
      "RoleARN": "s",
      "SecurityGroupIds": ["s"],
      "VpcId": "s",
    },
    optional: {},
  }, root);
}

function toSplunkDestinationDescription(root: jsonP.JSONValue): s.SplunkDestinationDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "HECEndpoint": "s",
      "HECEndpointType": (x: jsonP.JSONValue) => cmnP.readEnum<s.HECEndpointType>(x),
      "HECToken": "s",
      "HECAcknowledgmentTimeoutInSeconds": "n",
      "RetryOptions": toSplunkRetryOptions,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SplunkS3BackupMode>(x),
      "S3DestinationDescription": toS3DestinationDescription,
      "ProcessingConfiguration": toProcessingConfiguration,
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
    },
  }, root);
}

function toHttpEndpointDestinationDescription(root: jsonP.JSONValue): s.HttpEndpointDestinationDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointConfiguration": toHttpEndpointDescription,
      "BufferingHints": toHttpEndpointBufferingHints,
      "CloudWatchLoggingOptions": toCloudWatchLoggingOptions,
      "RequestConfiguration": toHttpEndpointRequestConfiguration,
      "ProcessingConfiguration": toProcessingConfiguration,
      "RoleARN": "s",
      "RetryOptions": toHttpEndpointRetryOptions,
      "S3BackupMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.HttpEndpointS3BackupMode>(x),
      "S3DestinationDescription": toS3DestinationDescription,
    },
  }, root);
}

function toHttpEndpointDescription(root: jsonP.JSONValue): s.HttpEndpointDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Url": "s",
      "Name": "s",
    },
  }, root);
}

function toPutRecordBatchResponseEntry(root: jsonP.JSONValue): s.PutRecordBatchResponseEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecordId": "s",
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}
