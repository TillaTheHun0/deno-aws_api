// Autogenerated API client for: Amazon Augmented AI Runtime

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class AugmentedAIRuntime {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AugmentedAIRuntime.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2019-11-07",
    "endpointPrefix": "a2i-runtime.sagemaker",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Augmented AI Runtime",
    "serviceId": "SageMaker A2I Runtime",
    "signatureVersion": "v4",
    "signingName": "sagemaker",
    "uid": "sagemaker-a2i-runtime-2019-11-07"
  };

  async deleteHumanLoop(
    {abortSignal, ...params}: RequestConfig & DeleteHumanLoopRequest,
  ): Promise<DeleteHumanLoopResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteHumanLoop",
      method: "DELETE",
      requestUri: cmnP.encodePath`/human-loops/${params["HumanLoopName"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async describeHumanLoop(
    {abortSignal, ...params}: RequestConfig & DescribeHumanLoopRequest,
  ): Promise<DescribeHumanLoopResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeHumanLoop",
      method: "GET",
      requestUri: cmnP.encodePath`/human-loops/${params["HumanLoopName"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {
          "CreationTime": "d",
          "HumanLoopStatus": (x: jsonP.JSONValue) => cmnP.readEnum<HumanLoopStatus>(x),
          "HumanLoopName": "s",
          "HumanLoopArn": "s",
          "FlowDefinitionArn": "s",
        },
        optional: {
          "FailureReason": "s",
          "FailureCode": "s",
          "HumanLoopOutput": toHumanLoopOutput,
        },
      }, await resp.json()),
  };
  }

  async listHumanLoops(
    {abortSignal, ...params}: RequestConfig & ListHumanLoopsRequest,
  ): Promise<ListHumanLoopsResponse> {
    const query = new URLSearchParams;
    if (params["CreationTimeAfter"] != null) query.set("CreationTimeAfter", cmnP.serializeDate_iso8601(params["CreationTimeAfter"]) ?? "");
    if (params["CreationTimeBefore"] != null) query.set("CreationTimeBefore", cmnP.serializeDate_iso8601(params["CreationTimeBefore"]) ?? "");
    query.set("FlowDefinitionArn", params["FlowDefinitionArn"]?.toString() ?? "");
    if (params["SortOrder"] != null) query.set("SortOrder", params["SortOrder"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListHumanLoops",
      method: "GET",
      requestUri: "/human-loops",
    });
  return {
    ...jsonP.readObj({
        required: {
          "HumanLoopSummaries": [toHumanLoopSummary],
        },
        optional: {
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async startHumanLoop(
    {abortSignal, ...params}: RequestConfig & StartHumanLoopRequest,
  ): Promise<StartHumanLoopResponse> {
    const body: jsonP.JSONObject = params ? {
      HumanLoopName: params["HumanLoopName"],
      FlowDefinitionArn: params["FlowDefinitionArn"],
      HumanLoopInput: fromHumanLoopInput(params["HumanLoopInput"]),
      DataAttributes: fromHumanLoopDataAttributes(params["DataAttributes"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartHumanLoop",
      requestUri: "/human-loops",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "HumanLoopArn": "s",
        },
      }, await resp.json()),
  };
  }

  async stopHumanLoop(
    {abortSignal, ...params}: RequestConfig & StopHumanLoopRequest,
  ): Promise<StopHumanLoopResponse> {
    const body: jsonP.JSONObject = params ? {
      HumanLoopName: params["HumanLoopName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopHumanLoop",
      requestUri: "/human-loops/stop",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface DeleteHumanLoopRequest {
  HumanLoopName: string;
}

// refs: 1 - tags: named, input
export interface DescribeHumanLoopRequest {
  HumanLoopName: string;
}

// refs: 1 - tags: named, input
export interface ListHumanLoopsRequest {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  FlowDefinitionArn: string;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface StartHumanLoopRequest {
  HumanLoopName: string;
  FlowDefinitionArn: string;
  HumanLoopInput: HumanLoopInput;
  DataAttributes?: HumanLoopDataAttributes | null;
}

// refs: 1 - tags: named, input
export interface StopHumanLoopRequest {
  HumanLoopName: string;
}

// refs: 1 - tags: named, output
export interface DeleteHumanLoopResponse {
}

// refs: 1 - tags: named, output
export interface DescribeHumanLoopResponse {
  CreationTime: Date | number;
  FailureReason?: string | null;
  FailureCode?: string | null;
  HumanLoopStatus: HumanLoopStatus;
  HumanLoopName: string;
  HumanLoopArn: string;
  FlowDefinitionArn: string;
  HumanLoopOutput?: HumanLoopOutput | null;
}

// refs: 1 - tags: named, output
export interface ListHumanLoopsResponse {
  HumanLoopSummaries: HumanLoopSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface StartHumanLoopResponse {
  HumanLoopArn?: string | null;
}

// refs: 1 - tags: named, output
export interface StopHumanLoopResponse {
}

// refs: 1 - tags: input, named, enum
export type SortOrder =
| "Ascending"
| "Descending"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface HumanLoopInput {
  InputContent: string;
}
function fromHumanLoopInput(input?: HumanLoopInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputContent: input["InputContent"],
  }
}

// refs: 1 - tags: input, named, interface
export interface HumanLoopDataAttributes {
  ContentClassifiers: ContentClassifier[];
}
function fromHumanLoopDataAttributes(input?: HumanLoopDataAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContentClassifiers: input["ContentClassifiers"],
  }
}

// refs: 1 - tags: input, named, enum
export type ContentClassifier =
| "FreeOfPersonallyIdentifiableInformation"
| "FreeOfAdultContent"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type HumanLoopStatus =
| "InProgress"
| "Failed"
| "Completed"
| "Stopped"
| "Stopping"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface HumanLoopOutput {
  OutputS3Uri: string;
}
function toHumanLoopOutput(root: jsonP.JSONValue): HumanLoopOutput {
  return jsonP.readObj({
    required: {
      "OutputS3Uri": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface HumanLoopSummary {
  HumanLoopName?: string | null;
  HumanLoopStatus?: HumanLoopStatus | null;
  CreationTime?: Date | number | null;
  FailureReason?: string | null;
  FlowDefinitionArn?: string | null;
}
function toHumanLoopSummary(root: jsonP.JSONValue): HumanLoopSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "HumanLoopName": "s",
      "HumanLoopStatus": (x: jsonP.JSONValue) => cmnP.readEnum<HumanLoopStatus>(x),
      "CreationTime": "d",
      "FailureReason": "s",
      "FlowDefinitionArn": "s",
    },
  }, root);
}
