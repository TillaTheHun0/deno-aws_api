// Autogenerated API client for: AWS MediaConnect

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class MediaConnect {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaConnect.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-11-14",
    "endpointPrefix": "mediaconnect",
    "signingName": "mediaconnect",
    "serviceFullName": "AWS MediaConnect",
    "serviceId": "MediaConnect",
    "protocol": "rest-json",
    "jsonVersion": "1.1",
    "uid": "mediaconnect-2018-11-14",
    "signatureVersion": "v4"
  };

  async addFlowOutputs(
    {abortSignal, ...params}: RequestConfig & s.AddFlowOutputsRequest,
  ): Promise<s.AddFlowOutputsResponse> {
    const body: jsonP.JSONObject = {
      outputs: params["Outputs"]?.map(x => fromAddOutputRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddFlowOutputs",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/outputs`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "Outputs": [toOutput],
      },
    }, await resp.json());
  }

  async addFlowSources(
    {abortSignal, ...params}: RequestConfig & s.AddFlowSourcesRequest,
  ): Promise<s.AddFlowSourcesResponse> {
    const body: jsonP.JSONObject = {
      sources: params["Sources"]?.map(x => fromSetSourceRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddFlowSources",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/source`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "Sources": [toSource],
      },
    }, await resp.json());
  }

  async addFlowVpcInterfaces(
    {abortSignal, ...params}: RequestConfig & s.AddFlowVpcInterfacesRequest,
  ): Promise<s.AddFlowVpcInterfacesResponse> {
    const body: jsonP.JSONObject = {
      vpcInterfaces: params["VpcInterfaces"]?.map(x => fromVpcInterfaceRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddFlowVpcInterfaces",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/vpcInterfaces`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "VpcInterfaces": [toVpcInterface],
      },
    }, await resp.json());
  }

  async createFlow(
    {abortSignal, ...params}: RequestConfig & s.CreateFlowRequest,
  ): Promise<s.CreateFlowResponse> {
    const body: jsonP.JSONObject = {
      availabilityZone: params["AvailabilityZone"],
      entitlements: params["Entitlements"]?.map(x => fromGrantEntitlementRequest(x)),
      name: params["Name"],
      outputs: params["Outputs"]?.map(x => fromAddOutputRequest(x)),
      source: fromSetSourceRequest(params["Source"]),
      sourceFailoverConfig: fromFailoverConfig(params["SourceFailoverConfig"]),
      sources: params["Sources"]?.map(x => fromSetSourceRequest(x)),
      vpcInterfaces: params["VpcInterfaces"]?.map(x => fromVpcInterfaceRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFlow",
      requestUri: "/v1/flows",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Flow": toFlow,
      },
    }, await resp.json());
  }

  async deleteFlow(
    {abortSignal, ...params}: RequestConfig & s.DeleteFlowRequest,
  ): Promise<s.DeleteFlowResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteFlow",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
      },
    }, await resp.json());
  }

  async describeFlow(
    {abortSignal, ...params}: RequestConfig & s.DescribeFlowRequest,
  ): Promise<s.DescribeFlowResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeFlow",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Flow": toFlow,
        "Messages": toMessages,
      },
    }, await resp.json());
  }

  async describeOffering(
    {abortSignal, ...params}: RequestConfig & s.DescribeOfferingRequest,
  ): Promise<s.DescribeOfferingResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeOffering",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/offerings/${params["OfferingArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Offering": toOffering,
      },
    }, await resp.json());
  }

  async describeReservation(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservationRequest,
  ): Promise<s.DescribeReservationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeReservation",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/reservations/${params["ReservationArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Reservation": toReservation,
      },
    }, await resp.json());
  }

  async grantFlowEntitlements(
    {abortSignal, ...params}: RequestConfig & s.GrantFlowEntitlementsRequest,
  ): Promise<s.GrantFlowEntitlementsResponse> {
    const body: jsonP.JSONObject = {
      entitlements: params["Entitlements"]?.map(x => fromGrantEntitlementRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GrantFlowEntitlements",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/entitlements`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Entitlements": [toEntitlement],
        "FlowArn": "s",
      },
    }, await resp.json());
  }

  async listEntitlements(
    {abortSignal, ...params}: RequestConfig & s.ListEntitlementsRequest = {},
  ): Promise<s.ListEntitlementsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListEntitlements",
      method: "GET",
      requestUri: "/v1/entitlements",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Entitlements": [toListedEntitlement],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listFlows(
    {abortSignal, ...params}: RequestConfig & s.ListFlowsRequest = {},
  ): Promise<s.ListFlowsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFlows",
      method: "GET",
      requestUri: "/v1/flows",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Flows": [toListedFlow],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listOfferings(
    {abortSignal, ...params}: RequestConfig & s.ListOfferingsRequest = {},
  ): Promise<s.ListOfferingsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOfferings",
      method: "GET",
      requestUri: "/v1/offerings",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Offerings": [toOffering],
      },
    }, await resp.json());
  }

  async listReservations(
    {abortSignal, ...params}: RequestConfig & s.ListReservationsRequest = {},
  ): Promise<s.ListReservationsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListReservations",
      method: "GET",
      requestUri: "/v1/reservations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Reservations": [toReservation],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async purchaseOffering(
    {abortSignal, ...params}: RequestConfig & s.PurchaseOfferingRequest,
  ): Promise<s.PurchaseOfferingResponse> {
    const body: jsonP.JSONObject = {
      reservationName: params["ReservationName"],
      start: params["Start"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseOffering",
      requestUri: cmnP.encodePath`/v1/offerings/${params["OfferingArn"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Reservation": toReservation,
      },
    }, await resp.json());
  }

  async removeFlowOutput(
    {abortSignal, ...params}: RequestConfig & s.RemoveFlowOutputRequest,
  ): Promise<s.RemoveFlowOutputResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RemoveFlowOutput",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/outputs/${params["OutputArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "OutputArn": "s",
      },
    }, await resp.json());
  }

  async removeFlowSource(
    {abortSignal, ...params}: RequestConfig & s.RemoveFlowSourceRequest,
  ): Promise<s.RemoveFlowSourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RemoveFlowSource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/source/${params["SourceArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "SourceArn": "s",
      },
    }, await resp.json());
  }

  async removeFlowVpcInterface(
    {abortSignal, ...params}: RequestConfig & s.RemoveFlowVpcInterfaceRequest,
  ): Promise<s.RemoveFlowVpcInterfaceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RemoveFlowVpcInterface",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/vpcInterfaces/${params["VpcInterfaceName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "NonDeletedNetworkInterfaceIds": ["s"],
        "VpcInterfaceName": "s",
      },
    }, await resp.json());
  }

  async revokeFlowEntitlement(
    {abortSignal, ...params}: RequestConfig & s.RevokeFlowEntitlementRequest,
  ): Promise<s.RevokeFlowEntitlementResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RevokeFlowEntitlement",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/entitlements/${params["EntitlementArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EntitlementArn": "s",
        "FlowArn": "s",
      },
    }, await resp.json());
  }

  async startFlow(
    {abortSignal, ...params}: RequestConfig & s.StartFlowRequest,
  ): Promise<s.StartFlowResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StartFlow",
      requestUri: cmnP.encodePath`/v1/flows/start/${params["FlowArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
      },
    }, await resp.json());
  }

  async stopFlow(
    {abortSignal, ...params}: RequestConfig & s.StopFlowRequest,
  ): Promise<s.StopFlowResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StopFlow",
      requestUri: cmnP.encodePath`/v1/flows/stop/${params["FlowArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
    await resp.text();
  }

  async updateFlow(
    {abortSignal, ...params}: RequestConfig & s.UpdateFlowRequest,
  ): Promise<s.UpdateFlowResponse> {
    const body: jsonP.JSONObject = {
      sourceFailoverConfig: fromUpdateFailoverConfig(params["SourceFailoverConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFlow",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Flow": toFlow,
      },
    }, await resp.json());
  }

  async updateFlowEntitlement(
    {abortSignal, ...params}: RequestConfig & s.UpdateFlowEntitlementRequest,
  ): Promise<s.UpdateFlowEntitlementResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      encryption: fromUpdateEncryption(params["Encryption"]),
      entitlementStatus: params["EntitlementStatus"],
      subscribers: params["Subscribers"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFlowEntitlement",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/entitlements/${params["EntitlementArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Entitlement": toEntitlement,
        "FlowArn": "s",
      },
    }, await resp.json());
  }

  async updateFlowOutput(
    {abortSignal, ...params}: RequestConfig & s.UpdateFlowOutputRequest,
  ): Promise<s.UpdateFlowOutputResponse> {
    const body: jsonP.JSONObject = {
      cidrAllowList: params["CidrAllowList"],
      description: params["Description"],
      destination: params["Destination"],
      encryption: fromUpdateEncryption(params["Encryption"]),
      maxLatency: params["MaxLatency"],
      minLatency: params["MinLatency"],
      port: params["Port"],
      protocol: params["Protocol"],
      remoteId: params["RemoteId"],
      smoothingLatency: params["SmoothingLatency"],
      streamId: params["StreamId"],
      vpcInterfaceAttachment: fromVpcInterfaceAttachment(params["VpcInterfaceAttachment"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFlowOutput",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/outputs/${params["OutputArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "Output": toOutput,
      },
    }, await resp.json());
  }

  async updateFlowSource(
    {abortSignal, ...params}: RequestConfig & s.UpdateFlowSourceRequest,
  ): Promise<s.UpdateFlowSourceResponse> {
    const body: jsonP.JSONObject = {
      decryption: fromUpdateEncryption(params["Decryption"]),
      description: params["Description"],
      entitlementArn: params["EntitlementArn"],
      ingestPort: params["IngestPort"],
      maxBitrate: params["MaxBitrate"],
      maxLatency: params["MaxLatency"],
      minLatency: params["MinLatency"],
      protocol: params["Protocol"],
      streamId: params["StreamId"],
      vpcInterfaceName: params["VpcInterfaceName"],
      whitelistCidr: params["WhitelistCidr"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFlowSource",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/flows/${params["FlowArn"]}/source/${params["SourceArn"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FlowArn": "s",
        "Source": toSource,
      },
    }, await resp.json());
  }

}

function fromAddOutputRequest(input?: s.AddOutputRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cidrAllowList: input["CidrAllowList"],
    description: input["Description"],
    destination: input["Destination"],
    encryption: fromEncryption(input["Encryption"]),
    maxLatency: input["MaxLatency"],
    minLatency: input["MinLatency"],
    name: input["Name"],
    port: input["Port"],
    protocol: input["Protocol"],
    remoteId: input["RemoteId"],
    smoothingLatency: input["SmoothingLatency"],
    streamId: input["StreamId"],
    vpcInterfaceAttachment: fromVpcInterfaceAttachment(input["VpcInterfaceAttachment"]),
  }
}

function fromEncryption(input?: s.Encryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    algorithm: input["Algorithm"],
    constantInitializationVector: input["ConstantInitializationVector"],
    deviceId: input["DeviceId"],
    keyType: input["KeyType"],
    region: input["Region"],
    resourceId: input["ResourceId"],
    roleArn: input["RoleArn"],
    secretArn: input["SecretArn"],
    url: input["Url"],
  }
}
function toEncryption(root: jsonP.JSONValue): s.Encryption {
  return jsonP.readObj({
    required: {
      "RoleArn": "s",
    },
    optional: {
      "Algorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.Algorithm>(x),
      "ConstantInitializationVector": "s",
      "DeviceId": "s",
      "KeyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyType>(x),
      "Region": "s",
      "ResourceId": "s",
      "SecretArn": "s",
      "Url": "s",
    },
  }, root);
}

function fromVpcInterfaceAttachment(input?: s.VpcInterfaceAttachment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    vpcInterfaceName: input["VpcInterfaceName"],
  }
}
function toVpcInterfaceAttachment(root: jsonP.JSONValue): s.VpcInterfaceAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "VpcInterfaceName": "s",
    },
  }, root);
}

function fromSetSourceRequest(input?: s.SetSourceRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    decryption: fromEncryption(input["Decryption"]),
    description: input["Description"],
    entitlementArn: input["EntitlementArn"],
    ingestPort: input["IngestPort"],
    maxBitrate: input["MaxBitrate"],
    maxLatency: input["MaxLatency"],
    minLatency: input["MinLatency"],
    name: input["Name"],
    protocol: input["Protocol"],
    streamId: input["StreamId"],
    vpcInterfaceName: input["VpcInterfaceName"],
    whitelistCidr: input["WhitelistCidr"],
  }
}

function fromVpcInterfaceRequest(input?: s.VpcInterfaceRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["Name"],
    roleArn: input["RoleArn"],
    securityGroupIds: input["SecurityGroupIds"],
    subnetId: input["SubnetId"],
  }
}

function fromGrantEntitlementRequest(input?: s.GrantEntitlementRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dataTransferSubscriberFeePercent: input["DataTransferSubscriberFeePercent"],
    description: input["Description"],
    encryption: fromEncryption(input["Encryption"]),
    entitlementStatus: input["EntitlementStatus"],
    name: input["Name"],
    subscribers: input["Subscribers"],
  }
}

function fromFailoverConfig(input?: s.FailoverConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    recoveryWindow: input["RecoveryWindow"],
    state: input["State"],
  }
}
function toFailoverConfig(root: jsonP.JSONValue): s.FailoverConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecoveryWindow": "n",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.State>(x),
    },
  }, root);
}

function fromUpdateFailoverConfig(input?: s.UpdateFailoverConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    recoveryWindow: input["RecoveryWindow"],
    state: input["State"],
  }
}

function fromUpdateEncryption(input?: s.UpdateEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    algorithm: input["Algorithm"],
    constantInitializationVector: input["ConstantInitializationVector"],
    deviceId: input["DeviceId"],
    keyType: input["KeyType"],
    region: input["Region"],
    resourceId: input["ResourceId"],
    roleArn: input["RoleArn"],
    secretArn: input["SecretArn"],
    url: input["Url"],
  }
}

function toOutput(root: jsonP.JSONValue): s.Output {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "OutputArn": "s",
    },
    optional: {
      "DataTransferSubscriberFeePercent": "n",
      "Description": "s",
      "Destination": "s",
      "Encryption": toEncryption,
      "EntitlementArn": "s",
      "MediaLiveInputArn": "s",
      "Port": "n",
      "Transport": toTransport,
      "VpcInterfaceAttachment": toVpcInterfaceAttachment,
    },
  }, root);
}

function toTransport(root: jsonP.JSONValue): s.Transport {
  return jsonP.readObj({
    required: {
      "Protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.Protocol>(x),
    },
    optional: {
      "CidrAllowList": ["s"],
      "MaxBitrate": "n",
      "MaxLatency": "n",
      "MinLatency": "n",
      "RemoteId": "s",
      "SmoothingLatency": "n",
      "StreamId": "s",
    },
  }, root);
}

function toSource(root: jsonP.JSONValue): s.Source {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "SourceArn": "s",
    },
    optional: {
      "DataTransferSubscriberFeePercent": "n",
      "Decryption": toEncryption,
      "Description": "s",
      "EntitlementArn": "s",
      "IngestIp": "s",
      "IngestPort": "n",
      "Transport": toTransport,
      "VpcInterfaceName": "s",
      "WhitelistCidr": "s",
    },
  }, root);
}

function toVpcInterface(root: jsonP.JSONValue): s.VpcInterface {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "NetworkInterfaceIds": ["s"],
      "RoleArn": "s",
      "SecurityGroupIds": ["s"],
      "SubnetId": "s",
    },
    optional: {},
  }, root);
}

function toFlow(root: jsonP.JSONValue): s.Flow {
  return jsonP.readObj({
    required: {
      "AvailabilityZone": "s",
      "Entitlements": [toEntitlement],
      "FlowArn": "s",
      "Name": "s",
      "Outputs": [toOutput],
      "Source": toSource,
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
    },
    optional: {
      "Description": "s",
      "EgressIp": "s",
      "SourceFailoverConfig": toFailoverConfig,
      "Sources": [toSource],
      "VpcInterfaces": [toVpcInterface],
    },
  }, root);
}

function toEntitlement(root: jsonP.JSONValue): s.Entitlement {
  return jsonP.readObj({
    required: {
      "EntitlementArn": "s",
      "Name": "s",
      "Subscribers": ["s"],
    },
    optional: {
      "DataTransferSubscriberFeePercent": "n",
      "Description": "s",
      "Encryption": toEncryption,
      "EntitlementStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntitlementStatus>(x),
    },
  }, root);
}

function toMessages(root: jsonP.JSONValue): s.Messages {
  return jsonP.readObj({
    required: {
      "Errors": ["s"],
    },
    optional: {},
  }, root);
}

function toOffering(root: jsonP.JSONValue): s.Offering {
  return jsonP.readObj({
    required: {
      "CurrencyCode": "s",
      "Duration": "n",
      "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.DurationUnits>(x),
      "OfferingArn": "s",
      "OfferingDescription": "s",
      "PricePerUnit": "s",
      "PriceUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.PriceUnits>(x),
      "ResourceSpecification": toResourceSpecification,
    },
    optional: {},
  }, root);
}

function toResourceSpecification(root: jsonP.JSONValue): s.ResourceSpecification {
  return jsonP.readObj({
    required: {
      "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
    },
    optional: {
      "ReservedBitrate": "n",
    },
  }, root);
}

function toReservation(root: jsonP.JSONValue): s.Reservation {
  return jsonP.readObj({
    required: {
      "CurrencyCode": "s",
      "Duration": "n",
      "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.DurationUnits>(x),
      "End": "s",
      "OfferingArn": "s",
      "OfferingDescription": "s",
      "PricePerUnit": "s",
      "PriceUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.PriceUnits>(x),
      "ReservationArn": "s",
      "ReservationName": "s",
      "ReservationState": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationState>(x),
      "ResourceSpecification": toResourceSpecification,
      "Start": "s",
    },
    optional: {},
  }, root);
}

function toListedEntitlement(root: jsonP.JSONValue): s.ListedEntitlement {
  return jsonP.readObj({
    required: {
      "EntitlementArn": "s",
      "EntitlementName": "s",
    },
    optional: {
      "DataTransferSubscriberFeePercent": "n",
    },
  }, root);
}

function toListedFlow(root: jsonP.JSONValue): s.ListedFlow {
  return jsonP.readObj({
    required: {
      "AvailabilityZone": "s",
      "Description": "s",
      "FlowArn": "s",
      "Name": "s",
      "SourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SourceType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
    },
    optional: {},
  }, root);
}
