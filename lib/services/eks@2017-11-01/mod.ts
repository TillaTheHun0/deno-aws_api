// Autogenerated API client for: Amazon Elastic Kubernetes Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class EKS {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EKS.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-11-01",
    "endpointPrefix": "eks",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "Amazon EKS",
    "serviceFullName": "Amazon Elastic Kubernetes Service",
    "serviceId": "EKS",
    "signatureVersion": "v4",
    "signingName": "eks",
    "uid": "eks-2017-11-01"
  };

  async createAddon(
    {abortSignal, ...params}: RequestConfig & s.CreateAddonRequest,
  ): Promise<s.CreateAddonResponse> {
    const body: jsonP.JSONObject = {
      addonName: params["addonName"],
      addonVersion: params["addonVersion"],
      serviceAccountRoleArn: params["serviceAccountRoleArn"],
      resolveConflicts: params["resolveConflicts"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAddon",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addon": toAddon,
      },
    }, await resp.json());
  }

  async createCluster(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterRequest,
  ): Promise<s.CreateClusterResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      version: params["version"],
      roleArn: params["roleArn"],
      resourcesVpcConfig: fromVpcConfigRequest(params["resourcesVpcConfig"]),
      kubernetesNetworkConfig: fromKubernetesNetworkConfigRequest(params["kubernetesNetworkConfig"]),
      logging: fromLogging(params["logging"]),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      tags: params["tags"],
      encryptionConfig: params["encryptionConfig"]?.map(x => fromEncryptionConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
      requestUri: "/clusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async createFargateProfile(
    {abortSignal, ...params}: RequestConfig & s.CreateFargateProfileRequest,
  ): Promise<s.CreateFargateProfileResponse> {
    const body: jsonP.JSONObject = {
      fargateProfileName: params["fargateProfileName"],
      podExecutionRoleArn: params["podExecutionRoleArn"],
      subnets: params["subnets"],
      selectors: params["selectors"]?.map(x => fromFargateProfileSelector(x)),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFargateProfile",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/fargate-profiles`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fargateProfile": toFargateProfile,
      },
    }, await resp.json());
  }

  async createNodegroup(
    {abortSignal, ...params}: RequestConfig & s.CreateNodegroupRequest,
  ): Promise<s.CreateNodegroupResponse> {
    const body: jsonP.JSONObject = {
      nodegroupName: params["nodegroupName"],
      scalingConfig: fromNodegroupScalingConfig(params["scalingConfig"]),
      diskSize: params["diskSize"],
      subnets: params["subnets"],
      instanceTypes: params["instanceTypes"],
      amiType: params["amiType"],
      remoteAccess: fromRemoteAccessConfig(params["remoteAccess"]),
      nodeRole: params["nodeRole"],
      labels: params["labels"],
      tags: params["tags"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      launchTemplate: fromLaunchTemplateSpecification(params["launchTemplate"]),
      capacityType: params["capacityType"],
      version: params["version"],
      releaseVersion: params["releaseVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNodegroup",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nodegroup": toNodegroup,
      },
    }, await resp.json());
  }

  async deleteAddon(
    {abortSignal, ...params}: RequestConfig & s.DeleteAddonRequest,
  ): Promise<s.DeleteAddonResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAddon",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons/${params["addonName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addon": toAddon,
      },
    }, await resp.json());
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterRequest,
  ): Promise<s.DeleteClusterResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteCluster",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async deleteFargateProfile(
    {abortSignal, ...params}: RequestConfig & s.DeleteFargateProfileRequest,
  ): Promise<s.DeleteFargateProfileResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteFargateProfile",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/fargate-profiles/${params["fargateProfileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fargateProfile": toFargateProfile,
      },
    }, await resp.json());
  }

  async deleteNodegroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteNodegroupRequest,
  ): Promise<s.DeleteNodegroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteNodegroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups/${params["nodegroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nodegroup": toNodegroup,
      },
    }, await resp.json());
  }

  async describeAddon(
    {abortSignal, ...params}: RequestConfig & s.DescribeAddonRequest,
  ): Promise<s.DescribeAddonResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAddon",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons/${params["addonName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addon": toAddon,
      },
    }, await resp.json());
  }

  async describeAddonVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeAddonVersionsRequest = {},
  ): Promise<s.DescribeAddonVersionsResponse> {
    const query = new URLSearchParams;
    if (params["kubernetesVersion"] != null) query.set("kubernetesVersion", params["kubernetesVersion"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["addonName"] != null) query.set("addonName", params["addonName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeAddonVersions",
      method: "GET",
      requestUri: "/addons/supported-versions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addons": [toAddonInfo],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeCluster(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterRequest,
  ): Promise<s.DescribeClusterResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeCluster",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async describeFargateProfile(
    {abortSignal, ...params}: RequestConfig & s.DescribeFargateProfileRequest,
  ): Promise<s.DescribeFargateProfileResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeFargateProfile",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/fargate-profiles/${params["fargateProfileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fargateProfile": toFargateProfile,
      },
    }, await resp.json());
  }

  async describeNodegroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeNodegroupRequest,
  ): Promise<s.DescribeNodegroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeNodegroup",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups/${params["nodegroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nodegroup": toNodegroup,
      },
    }, await resp.json());
  }

  async describeUpdate(
    {abortSignal, ...params}: RequestConfig & s.DescribeUpdateRequest,
  ): Promise<s.DescribeUpdateResponse> {
    const query = new URLSearchParams;
    if (params["nodegroupName"] != null) query.set("nodegroupName", params["nodegroupName"]?.toString() ?? "");
    if (params["addonName"] != null) query.set("addonName", params["addonName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeUpdate",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}/updates/${params["updateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async listAddons(
    {abortSignal, ...params}: RequestConfig & s.ListAddonsRequest,
  ): Promise<s.ListAddonsResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAddons",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addons": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listClusters(
    {abortSignal, ...params}: RequestConfig & s.ListClustersRequest = {},
  ): Promise<s.ListClustersResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListClusters",
      method: "GET",
      requestUri: "/clusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clusters": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFargateProfiles(
    {abortSignal, ...params}: RequestConfig & s.ListFargateProfilesRequest,
  ): Promise<s.ListFargateProfilesResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFargateProfiles",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/fargate-profiles`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fargateProfileNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listNodegroups(
    {abortSignal, ...params}: RequestConfig & s.ListNodegroupsRequest,
  ): Promise<s.ListNodegroupsResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListNodegroups",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nodegroups": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listUpdates(
    {abortSignal, ...params}: RequestConfig & s.ListUpdatesRequest,
  ): Promise<s.ListUpdatesResponse> {
    const query = new URLSearchParams;
    if (params["nodegroupName"] != null) query.set("nodegroupName", params["nodegroupName"]?.toString() ?? "");
    if (params["addonName"] != null) query.set("addonName", params["addonName"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListUpdates",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}/updates`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "updateIds": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateAddon(
    {abortSignal, ...params}: RequestConfig & s.UpdateAddonRequest,
  ): Promise<s.UpdateAddonResponse> {
    const body: jsonP.JSONObject = {
      addonVersion: params["addonVersion"],
      serviceAccountRoleArn: params["serviceAccountRoleArn"],
      resolveConflicts: params["resolveConflicts"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAddon",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons/${params["addonName"]}/update`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async updateClusterConfig(
    {abortSignal, ...params}: RequestConfig & s.UpdateClusterConfigRequest,
  ): Promise<s.UpdateClusterConfigResponse> {
    const body: jsonP.JSONObject = {
      resourcesVpcConfig: fromVpcConfigRequest(params["resourcesVpcConfig"]),
      logging: fromLogging(params["logging"]),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterConfig",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}/update-config`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async updateClusterVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateClusterVersionRequest,
  ): Promise<s.UpdateClusterVersionResponse> {
    const body: jsonP.JSONObject = {
      version: params["version"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterVersion",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}/updates`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async updateNodegroupConfig(
    {abortSignal, ...params}: RequestConfig & s.UpdateNodegroupConfigRequest,
  ): Promise<s.UpdateNodegroupConfigResponse> {
    const body: jsonP.JSONObject = {
      labels: fromUpdateLabelsPayload(params["labels"]),
      scalingConfig: fromNodegroupScalingConfig(params["scalingConfig"]),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNodegroupConfig",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups/${params["nodegroupName"]}/update-config`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async updateNodegroupVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateNodegroupVersionRequest,
  ): Promise<s.UpdateNodegroupVersionResponse> {
    const body: jsonP.JSONObject = {
      version: params["version"],
      releaseVersion: params["releaseVersion"],
      launchTemplate: fromLaunchTemplateSpecification(params["launchTemplate"]),
      force: params["force"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNodegroupVersion",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups/${params["nodegroupName"]}/update-version`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 30 seconds apart (about 20 minutes max wait time). */
  async waitForClusterActive(
    params: RequestConfig & s.DescribeClusterRequest,
  ): Promise<s.DescribeClusterResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterActive';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeCluster(params);
      const field = resp?.cluster?.status;
      if (field === "DELETING") throw new Error(errMessage);
      if (field === "FAILED") throw new Error(errMessage);
      if (field === "ACTIVE") return resp;
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 30 seconds apart (about 20 minutes max wait time). */
  async waitForClusterDeleted(
    params: RequestConfig & s.DescribeClusterRequest,
  ): Promise<Error | s.DescribeClusterResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeCluster(params);
        const field = resp?.cluster?.status;
        if (field === "ACTIVE") throw new Error(errMessage);
        if (field === "CREATING") throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 80 times, 30 seconds apart (about 40 minutes max wait time). */
  async waitForNodegroupActive(
    params: RequestConfig & s.DescribeNodegroupRequest,
  ): Promise<s.DescribeNodegroupResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NodegroupActive';
    for (let i = 0; i < 80; i++) {
      const resp = await this.describeNodegroup(params);
      const field = resp?.nodegroup?.status;
      if (field === "CREATE_FAILED") throw new Error(errMessage);
      if (field === "ACTIVE") return resp;
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 30 seconds apart (about 20 minutes max wait time). */
  async waitForNodegroupDeleted(
    params: RequestConfig & s.DescribeNodegroupRequest,
  ): Promise<Error | s.DescribeNodegroupResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NodegroupDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeNodegroup(params);
        if (resp?.nodegroup?.status === "DELETE_FAILED") throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 10 seconds apart (about 10 minutes max wait time). */
  async waitForAddonActive(
    params: RequestConfig & s.DescribeAddonRequest,
  ): Promise<s.DescribeAddonResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AddonActive';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeAddon(params);
      const field = resp?.addon?.status;
      if (field === "CREATE_FAILED") throw new Error(errMessage);
      if (field === "ACTIVE") return resp;
      await new Promise(r => setTimeout(r, 10000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 10 seconds apart (about 10 minutes max wait time). */
  async waitForAddonDeleted(
    params: RequestConfig & s.DescribeAddonRequest,
  ): Promise<Error | s.DescribeAddonResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AddonDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeAddon(params);
        if (resp?.addon?.status === "DELETE_FAILED") throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 10000));
    }
    throw new Error(errMessage);
  }

}

function fromVpcConfigRequest(input?: s.VpcConfigRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subnetIds: input["subnetIds"],
    securityGroupIds: input["securityGroupIds"],
    endpointPublicAccess: input["endpointPublicAccess"],
    endpointPrivateAccess: input["endpointPrivateAccess"],
    publicAccessCidrs: input["publicAccessCidrs"],
  }
}

function fromKubernetesNetworkConfigRequest(input?: s.KubernetesNetworkConfigRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceIpv4Cidr: input["serviceIpv4Cidr"],
  }
}

function fromLogging(input?: s.Logging | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clusterLogging: input["clusterLogging"]?.map(x => fromLogSetup(x)),
  }
}
function toLogging(root: jsonP.JSONValue): s.Logging {
  return jsonP.readObj({
    required: {},
    optional: {
      "clusterLogging": [toLogSetup],
    },
  }, root);
}

function fromLogSetup(input?: s.LogSetup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    types: input["types"],
    enabled: input["enabled"],
  }
}
function toLogSetup(root: jsonP.JSONValue): s.LogSetup {
  return jsonP.readObj({
    required: {},
    optional: {
      "types": [(x: jsonP.JSONValue) => cmnP.readEnum<s.LogType>(x)],
      "enabled": "b",
    },
  }, root);
}

function fromEncryptionConfig(input?: s.EncryptionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    resources: input["resources"],
    provider: fromProvider(input["provider"]),
  }
}
function toEncryptionConfig(root: jsonP.JSONValue): s.EncryptionConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "resources": ["s"],
      "provider": toProvider,
    },
  }, root);
}

function fromProvider(input?: s.Provider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyArn: input["keyArn"],
  }
}
function toProvider(root: jsonP.JSONValue): s.Provider {
  return jsonP.readObj({
    required: {},
    optional: {
      "keyArn": "s",
    },
  }, root);
}

function fromFargateProfileSelector(input?: s.FargateProfileSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    namespace: input["namespace"],
    labels: input["labels"],
  }
}
function toFargateProfileSelector(root: jsonP.JSONValue): s.FargateProfileSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "namespace": "s",
      "labels": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromNodegroupScalingConfig(input?: s.NodegroupScalingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    minSize: input["minSize"],
    maxSize: input["maxSize"],
    desiredSize: input["desiredSize"],
  }
}
function toNodegroupScalingConfig(root: jsonP.JSONValue): s.NodegroupScalingConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "minSize": "n",
      "maxSize": "n",
      "desiredSize": "n",
    },
  }, root);
}

function fromRemoteAccessConfig(input?: s.RemoteAccessConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ec2SshKey: input["ec2SshKey"],
    sourceSecurityGroups: input["sourceSecurityGroups"],
  }
}
function toRemoteAccessConfig(root: jsonP.JSONValue): s.RemoteAccessConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ec2SshKey": "s",
      "sourceSecurityGroups": ["s"],
    },
  }, root);
}

function fromLaunchTemplateSpecification(input?: s.LaunchTemplateSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    version: input["version"],
    id: input["id"],
  }
}
function toLaunchTemplateSpecification(root: jsonP.JSONValue): s.LaunchTemplateSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "version": "s",
      "id": "s",
    },
  }, root);
}

function fromUpdateLabelsPayload(input?: s.UpdateLabelsPayload | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    addOrUpdateLabels: input["addOrUpdateLabels"],
    removeLabels: input["removeLabels"],
  }
}

function toAddon(root: jsonP.JSONValue): s.Addon {
  return jsonP.readObj({
    required: {},
    optional: {
      "addonName": "s",
      "clusterName": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AddonStatus>(x),
      "addonVersion": "s",
      "health": toAddonHealth,
      "addonArn": "s",
      "createdAt": "d",
      "modifiedAt": "d",
      "serviceAccountRoleArn": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toAddonHealth(root: jsonP.JSONValue): s.AddonHealth {
  return jsonP.readObj({
    required: {},
    optional: {
      "issues": [toAddonIssue],
    },
  }, root);
}

function toAddonIssue(root: jsonP.JSONValue): s.AddonIssue {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<s.AddonIssueCode>(x),
      "message": "s",
      "resourceIds": ["s"],
    },
  }, root);
}

function toCluster(root: jsonP.JSONValue): s.Cluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "createdAt": "d",
      "version": "s",
      "endpoint": "s",
      "roleArn": "s",
      "resourcesVpcConfig": toVpcConfigResponse,
      "kubernetesNetworkConfig": toKubernetesNetworkConfigResponse,
      "logging": toLogging,
      "identity": toIdentity,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClusterStatus>(x),
      "certificateAuthority": toCertificate,
      "clientRequestToken": "s",
      "platformVersion": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "encryptionConfig": [toEncryptionConfig],
    },
  }, root);
}

function toVpcConfigResponse(root: jsonP.JSONValue): s.VpcConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "subnetIds": ["s"],
      "securityGroupIds": ["s"],
      "clusterSecurityGroupId": "s",
      "vpcId": "s",
      "endpointPublicAccess": "b",
      "endpointPrivateAccess": "b",
      "publicAccessCidrs": ["s"],
    },
  }, root);
}

function toKubernetesNetworkConfigResponse(root: jsonP.JSONValue): s.KubernetesNetworkConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceIpv4Cidr": "s",
    },
  }, root);
}

function toIdentity(root: jsonP.JSONValue): s.Identity {
  return jsonP.readObj({
    required: {},
    optional: {
      "oidc": toOIDC,
    },
  }, root);
}

function toOIDC(root: jsonP.JSONValue): s.OIDC {
  return jsonP.readObj({
    required: {},
    optional: {
      "issuer": "s",
    },
  }, root);
}

function toCertificate(root: jsonP.JSONValue): s.Certificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "data": "s",
    },
  }, root);
}

function toFargateProfile(root: jsonP.JSONValue): s.FargateProfile {
  return jsonP.readObj({
    required: {},
    optional: {
      "fargateProfileName": "s",
      "fargateProfileArn": "s",
      "clusterName": "s",
      "createdAt": "d",
      "podExecutionRoleArn": "s",
      "subnets": ["s"],
      "selectors": [toFargateProfileSelector],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.FargateProfileStatus>(x),
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toNodegroup(root: jsonP.JSONValue): s.Nodegroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "nodegroupName": "s",
      "nodegroupArn": "s",
      "clusterName": "s",
      "version": "s",
      "releaseVersion": "s",
      "createdAt": "d",
      "modifiedAt": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.NodegroupStatus>(x),
      "capacityType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CapacityTypes>(x),
      "scalingConfig": toNodegroupScalingConfig,
      "instanceTypes": ["s"],
      "subnets": ["s"],
      "remoteAccess": toRemoteAccessConfig,
      "amiType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AMITypes>(x),
      "nodeRole": "s",
      "labels": x => jsonP.readMap(String, String, x),
      "resources": toNodegroupResources,
      "diskSize": "n",
      "health": toNodegroupHealth,
      "launchTemplate": toLaunchTemplateSpecification,
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toNodegroupResources(root: jsonP.JSONValue): s.NodegroupResources {
  return jsonP.readObj({
    required: {},
    optional: {
      "autoScalingGroups": [toAutoScalingGroup],
      "remoteAccessSecurityGroup": "s",
    },
  }, root);
}

function toAutoScalingGroup(root: jsonP.JSONValue): s.AutoScalingGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

function toNodegroupHealth(root: jsonP.JSONValue): s.NodegroupHealth {
  return jsonP.readObj({
    required: {},
    optional: {
      "issues": [toIssue],
    },
  }, root);
}

function toIssue(root: jsonP.JSONValue): s.Issue {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<s.NodegroupIssueCode>(x),
      "message": "s",
      "resourceIds": ["s"],
    },
  }, root);
}

function toAddonInfo(root: jsonP.JSONValue): s.AddonInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "addonName": "s",
      "type": "s",
      "addonVersions": [toAddonVersionInfo],
    },
  }, root);
}

function toAddonVersionInfo(root: jsonP.JSONValue): s.AddonVersionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "addonVersion": "s",
      "architecture": ["s"],
      "compatibilities": [toCompatibility],
    },
  }, root);
}

function toCompatibility(root: jsonP.JSONValue): s.Compatibility {
  return jsonP.readObj({
    required: {},
    optional: {
      "clusterVersion": "s",
      "platformVersions": ["s"],
      "defaultVersion": "b",
    },
  }, root);
}

function toUpdate(root: jsonP.JSONValue): s.Update {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpdateStatus>(x),
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpdateType>(x),
      "params": [toUpdateParam],
      "createdAt": "d",
      "errors": [toErrorDetail],
    },
  }, root);
}

function toUpdateParam(root: jsonP.JSONValue): s.UpdateParam {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpdateParamType>(x),
      "value": "s",
    },
  }, root);
}

function toErrorDetail(root: jsonP.JSONValue): s.ErrorDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ErrorCode>(x),
      "errorMessage": "s",
      "resourceIds": ["s"],
    },
  }, root);
}
