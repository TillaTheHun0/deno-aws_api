// Autogenerated API client for: Amazon Elastic Kubernetes Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class EKS {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EKS.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-11-01",
    "endpointPrefix": "eks",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "Amazon EKS",
    "serviceFullName": "Amazon Elastic Kubernetes Service",
    "serviceId": "EKS",
    "signatureVersion": "v4",
    "signingName": "eks",
    "uid": "eks-2017-11-01"
  };

  async createAddon(
    {abortSignal, ...params}: RequestConfig & CreateAddonRequest,
  ): Promise<CreateAddonResponse> {
    const body: jsonP.JSONObject = {
      addonName: params["addonName"],
      addonVersion: params["addonVersion"],
      serviceAccountRoleArn: params["serviceAccountRoleArn"],
      resolveConflicts: params["resolveConflicts"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAddon",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addon": toAddon,
      },
    }, await resp.json());
  }

  async createCluster(
    {abortSignal, ...params}: RequestConfig & CreateClusterRequest,
  ): Promise<CreateClusterResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      version: params["version"],
      roleArn: params["roleArn"],
      resourcesVpcConfig: fromVpcConfigRequest(params["resourcesVpcConfig"]),
      kubernetesNetworkConfig: fromKubernetesNetworkConfigRequest(params["kubernetesNetworkConfig"]),
      logging: fromLogging(params["logging"]),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      tags: params["tags"],
      encryptionConfig: params["encryptionConfig"]?.map(x => fromEncryptionConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
      requestUri: "/clusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async createFargateProfile(
    {abortSignal, ...params}: RequestConfig & CreateFargateProfileRequest,
  ): Promise<CreateFargateProfileResponse> {
    const body: jsonP.JSONObject = {
      fargateProfileName: params["fargateProfileName"],
      podExecutionRoleArn: params["podExecutionRoleArn"],
      subnets: params["subnets"],
      selectors: params["selectors"]?.map(x => fromFargateProfileSelector(x)),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFargateProfile",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/fargate-profiles`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fargateProfile": toFargateProfile,
      },
    }, await resp.json());
  }

  async createNodegroup(
    {abortSignal, ...params}: RequestConfig & CreateNodegroupRequest,
  ): Promise<CreateNodegroupResponse> {
    const body: jsonP.JSONObject = {
      nodegroupName: params["nodegroupName"],
      scalingConfig: fromNodegroupScalingConfig(params["scalingConfig"]),
      diskSize: params["diskSize"],
      subnets: params["subnets"],
      instanceTypes: params["instanceTypes"],
      amiType: params["amiType"],
      remoteAccess: fromRemoteAccessConfig(params["remoteAccess"]),
      nodeRole: params["nodeRole"],
      labels: params["labels"],
      tags: params["tags"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      launchTemplate: fromLaunchTemplateSpecification(params["launchTemplate"]),
      capacityType: params["capacityType"],
      version: params["version"],
      releaseVersion: params["releaseVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNodegroup",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nodegroup": toNodegroup,
      },
    }, await resp.json());
  }

  async deleteAddon(
    {abortSignal, ...params}: RequestConfig & DeleteAddonRequest,
  ): Promise<DeleteAddonResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAddon",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons/${params["addonName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addon": toAddon,
      },
    }, await resp.json());
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & DeleteClusterRequest,
  ): Promise<DeleteClusterResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteCluster",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async deleteFargateProfile(
    {abortSignal, ...params}: RequestConfig & DeleteFargateProfileRequest,
  ): Promise<DeleteFargateProfileResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteFargateProfile",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/fargate-profiles/${params["fargateProfileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fargateProfile": toFargateProfile,
      },
    }, await resp.json());
  }

  async deleteNodegroup(
    {abortSignal, ...params}: RequestConfig & DeleteNodegroupRequest,
  ): Promise<DeleteNodegroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteNodegroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups/${params["nodegroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nodegroup": toNodegroup,
      },
    }, await resp.json());
  }

  async describeAddon(
    {abortSignal, ...params}: RequestConfig & DescribeAddonRequest,
  ): Promise<DescribeAddonResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAddon",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons/${params["addonName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addon": toAddon,
      },
    }, await resp.json());
  }

  async describeAddonVersions(
    {abortSignal, ...params}: RequestConfig & DescribeAddonVersionsRequest = {},
  ): Promise<DescribeAddonVersionsResponse> {
    const query = new URLSearchParams;
    if (params["kubernetesVersion"] != null) query.set("kubernetesVersion", params["kubernetesVersion"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["addonName"] != null) query.set("addonName", params["addonName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeAddonVersions",
      method: "GET",
      requestUri: "/addons/supported-versions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addons": [toAddonInfo],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeCluster(
    {abortSignal, ...params}: RequestConfig & DescribeClusterRequest,
  ): Promise<DescribeClusterResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeCluster",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async describeFargateProfile(
    {abortSignal, ...params}: RequestConfig & DescribeFargateProfileRequest,
  ): Promise<DescribeFargateProfileResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeFargateProfile",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/fargate-profiles/${params["fargateProfileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fargateProfile": toFargateProfile,
      },
    }, await resp.json());
  }

  async describeNodegroup(
    {abortSignal, ...params}: RequestConfig & DescribeNodegroupRequest,
  ): Promise<DescribeNodegroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeNodegroup",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups/${params["nodegroupName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nodegroup": toNodegroup,
      },
    }, await resp.json());
  }

  async describeUpdate(
    {abortSignal, ...params}: RequestConfig & DescribeUpdateRequest,
  ): Promise<DescribeUpdateResponse> {
    const query = new URLSearchParams;
    if (params["nodegroupName"] != null) query.set("nodegroupName", params["nodegroupName"]?.toString() ?? "");
    if (params["addonName"] != null) query.set("addonName", params["addonName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeUpdate",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}/updates/${params["updateId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async listAddons(
    {abortSignal, ...params}: RequestConfig & ListAddonsRequest,
  ): Promise<ListAddonsResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAddons",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "addons": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listClusters(
    {abortSignal, ...params}: RequestConfig & ListClustersRequest = {},
  ): Promise<ListClustersResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListClusters",
      method: "GET",
      requestUri: "/clusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clusters": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFargateProfiles(
    {abortSignal, ...params}: RequestConfig & ListFargateProfilesRequest,
  ): Promise<ListFargateProfilesResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFargateProfiles",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/fargate-profiles`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "fargateProfileNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listNodegroups(
    {abortSignal, ...params}: RequestConfig & ListNodegroupsRequest,
  ): Promise<ListNodegroupsResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListNodegroups",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nodegroups": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listUpdates(
    {abortSignal, ...params}: RequestConfig & ListUpdatesRequest,
  ): Promise<ListUpdatesResponse> {
    const query = new URLSearchParams;
    if (params["nodegroupName"] != null) query.set("nodegroupName", params["nodegroupName"]?.toString() ?? "");
    if (params["addonName"] != null) query.set("addonName", params["addonName"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListUpdates",
      method: "GET",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}/updates`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "updateIds": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateAddon(
    {abortSignal, ...params}: RequestConfig & UpdateAddonRequest,
  ): Promise<UpdateAddonResponse> {
    const body: jsonP.JSONObject = {
      addonVersion: params["addonVersion"],
      serviceAccountRoleArn: params["serviceAccountRoleArn"],
      resolveConflicts: params["resolveConflicts"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAddon",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/addons/${params["addonName"]}/update`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async updateClusterConfig(
    {abortSignal, ...params}: RequestConfig & UpdateClusterConfigRequest,
  ): Promise<UpdateClusterConfigResponse> {
    const body: jsonP.JSONObject = {
      resourcesVpcConfig: fromVpcConfigRequest(params["resourcesVpcConfig"]),
      logging: fromLogging(params["logging"]),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterConfig",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}/update-config`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async updateClusterVersion(
    {abortSignal, ...params}: RequestConfig & UpdateClusterVersionRequest,
  ): Promise<UpdateClusterVersionResponse> {
    const body: jsonP.JSONObject = {
      version: params["version"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterVersion",
      requestUri: cmnP.encodePath`/clusters/${params["name"]}/updates`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async updateNodegroupConfig(
    {abortSignal, ...params}: RequestConfig & UpdateNodegroupConfigRequest,
  ): Promise<UpdateNodegroupConfigResponse> {
    const body: jsonP.JSONObject = {
      labels: fromUpdateLabelsPayload(params["labels"]),
      scalingConfig: fromNodegroupScalingConfig(params["scalingConfig"]),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNodegroupConfig",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups/${params["nodegroupName"]}/update-config`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  async updateNodegroupVersion(
    {abortSignal, ...params}: RequestConfig & UpdateNodegroupVersionRequest,
  ): Promise<UpdateNodegroupVersionResponse> {
    const body: jsonP.JSONObject = {
      version: params["version"],
      releaseVersion: params["releaseVersion"],
      launchTemplate: fromLaunchTemplateSpecification(params["launchTemplate"]),
      force: params["force"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNodegroupVersion",
      requestUri: cmnP.encodePath`/clusters/${params["clusterName"]}/node-groups/${params["nodegroupName"]}/update-version`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "update": toUpdate,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 30 seconds apart (about 20 minutes max wait time). */
  async waitForClusterActive(
    params: RequestConfig & DescribeClusterRequest,
  ): Promise<DescribeClusterResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterActive';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeCluster(params);
      const field = resp?.cluster?.status;
      if (field === "DELETING") throw new Error(errMessage);
      if (field === "FAILED") throw new Error(errMessage);
      if (field === "ACTIVE") return resp;
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 30 seconds apart (about 20 minutes max wait time). */
  async waitForClusterDeleted(
    params: RequestConfig & DescribeClusterRequest,
  ): Promise<Error | DescribeClusterResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeCluster(params);
        const field = resp?.cluster?.status;
        if (field === "ACTIVE") throw new Error(errMessage);
        if (field === "CREATING") throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 80 times, 30 seconds apart (about 40 minutes max wait time). */
  async waitForNodegroupActive(
    params: RequestConfig & DescribeNodegroupRequest,
  ): Promise<DescribeNodegroupResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NodegroupActive';
    for (let i = 0; i < 80; i++) {
      const resp = await this.describeNodegroup(params);
      const field = resp?.nodegroup?.status;
      if (field === "CREATE_FAILED") throw new Error(errMessage);
      if (field === "ACTIVE") return resp;
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 30 seconds apart (about 20 minutes max wait time). */
  async waitForNodegroupDeleted(
    params: RequestConfig & DescribeNodegroupRequest,
  ): Promise<Error | DescribeNodegroupResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NodegroupDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeNodegroup(params);
        if (resp?.nodegroup?.status === "DELETE_FAILED") throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 10 seconds apart (about 10 minutes max wait time). */
  async waitForAddonActive(
    params: RequestConfig & DescribeAddonRequest,
  ): Promise<DescribeAddonResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AddonActive';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeAddon(params);
      const field = resp?.addon?.status;
      if (field === "CREATE_FAILED") throw new Error(errMessage);
      if (field === "ACTIVE") return resp;
      await new Promise(r => setTimeout(r, 10000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 10 seconds apart (about 10 minutes max wait time). */
  async waitForAddonDeleted(
    params: RequestConfig & DescribeAddonRequest,
  ): Promise<Error | DescribeAddonResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AddonDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeAddon(params);
        if (resp?.addon?.status === "DELETE_FAILED") throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 10000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface CreateAddonRequest {
  clusterName: string;
  addonName: string;
  addonVersion?: string | null;
  serviceAccountRoleArn?: string | null;
  resolveConflicts?: ResolveConflicts | null;
  clientRequestToken?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateClusterRequest {
  name: string;
  version?: string | null;
  roleArn: string;
  resourcesVpcConfig: VpcConfigRequest;
  kubernetesNetworkConfig?: KubernetesNetworkConfigRequest | null;
  logging?: Logging | null;
  clientRequestToken?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
  encryptionConfig?: EncryptionConfig[] | null;
}

// refs: 1 - tags: named, input
export interface CreateFargateProfileRequest {
  fargateProfileName: string;
  clusterName: string;
  podExecutionRoleArn: string;
  subnets?: string[] | null;
  selectors?: FargateProfileSelector[] | null;
  clientRequestToken?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateNodegroupRequest {
  clusterName: string;
  nodegroupName: string;
  scalingConfig?: NodegroupScalingConfig | null;
  diskSize?: number | null;
  subnets: string[];
  instanceTypes?: string[] | null;
  amiType?: AMITypes | null;
  remoteAccess?: RemoteAccessConfig | null;
  nodeRole: string;
  labels?: { [key: string]: string | null | undefined } | null;
  tags?: { [key: string]: string | null | undefined } | null;
  clientRequestToken?: string | null;
  launchTemplate?: LaunchTemplateSpecification | null;
  capacityType?: CapacityTypes | null;
  version?: string | null;
  releaseVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteAddonRequest {
  clusterName: string;
  addonName: string;
}

// refs: 1 - tags: named, input
export interface DeleteClusterRequest {
  name: string;
}

// refs: 1 - tags: named, input
export interface DeleteFargateProfileRequest {
  clusterName: string;
  fargateProfileName: string;
}

// refs: 1 - tags: named, input
export interface DeleteNodegroupRequest {
  clusterName: string;
  nodegroupName: string;
}

// refs: 1 - tags: named, input
export interface DescribeAddonRequest {
  clusterName: string;
  addonName: string;
}

// refs: 1 - tags: named, input
export interface DescribeAddonVersionsRequest {
  kubernetesVersion?: string | null;
  maxResults?: number | null;
  nextToken?: string | null;
  addonName?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeClusterRequest {
  name: string;
}

// refs: 1 - tags: named, input
export interface DescribeFargateProfileRequest {
  clusterName: string;
  fargateProfileName: string;
}

// refs: 1 - tags: named, input
export interface DescribeNodegroupRequest {
  clusterName: string;
  nodegroupName: string;
}

// refs: 1 - tags: named, input
export interface DescribeUpdateRequest {
  name: string;
  updateId: string;
  nodegroupName?: string | null;
  addonName?: string | null;
}

// refs: 1 - tags: named, input
export interface ListAddonsRequest {
  clusterName: string;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListClustersRequest {
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListFargateProfilesRequest {
  clusterName: string;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListNodegroupsRequest {
  clusterName: string;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface ListUpdatesRequest {
  name: string;
  nodegroupName?: string | null;
  addonName?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateAddonRequest {
  clusterName: string;
  addonName: string;
  addonVersion?: string | null;
  serviceAccountRoleArn?: string | null;
  resolveConflicts?: ResolveConflicts | null;
  clientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateClusterConfigRequest {
  name: string;
  resourcesVpcConfig?: VpcConfigRequest | null;
  logging?: Logging | null;
  clientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateClusterVersionRequest {
  name: string;
  version: string;
  clientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateNodegroupConfigRequest {
  clusterName: string;
  nodegroupName: string;
  labels?: UpdateLabelsPayload | null;
  scalingConfig?: NodegroupScalingConfig | null;
  clientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateNodegroupVersionRequest {
  clusterName: string;
  nodegroupName: string;
  version?: string | null;
  releaseVersion?: string | null;
  launchTemplate?: LaunchTemplateSpecification | null;
  force?: boolean | null;
  clientRequestToken?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateAddonResponse {
  addon?: Addon | null;
}

// refs: 1 - tags: named, output
export interface CreateClusterResponse {
  cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface CreateFargateProfileResponse {
  fargateProfile?: FargateProfile | null;
}

// refs: 1 - tags: named, output
export interface CreateNodegroupResponse {
  nodegroup?: Nodegroup | null;
}

// refs: 1 - tags: named, output
export interface DeleteAddonResponse {
  addon?: Addon | null;
}

// refs: 1 - tags: named, output
export interface DeleteClusterResponse {
  cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface DeleteFargateProfileResponse {
  fargateProfile?: FargateProfile | null;
}

// refs: 1 - tags: named, output
export interface DeleteNodegroupResponse {
  nodegroup?: Nodegroup | null;
}

// refs: 1 - tags: named, output
export interface DescribeAddonResponse {
  addon?: Addon | null;
}

// refs: 1 - tags: named, output
export interface DescribeAddonVersionsResponse {
  addons?: AddonInfo[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeClusterResponse {
  cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface DescribeFargateProfileResponse {
  fargateProfile?: FargateProfile | null;
}

// refs: 1 - tags: named, output
export interface DescribeNodegroupResponse {
  nodegroup?: Nodegroup | null;
}

// refs: 1 - tags: named, output
export interface DescribeUpdateResponse {
  update?: Update | null;
}

// refs: 1 - tags: named, output
export interface ListAddonsResponse {
  addons?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListClustersResponse {
  clusters?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListFargateProfilesResponse {
  fargateProfileNames?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListNodegroupsResponse {
  nodegroups?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface ListUpdatesResponse {
  updateIds?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateAddonResponse {
  update?: Update | null;
}

// refs: 1 - tags: named, output
export interface UpdateClusterConfigResponse {
  update?: Update | null;
}

// refs: 1 - tags: named, output
export interface UpdateClusterVersionResponse {
  update?: Update | null;
}

// refs: 1 - tags: named, output
export interface UpdateNodegroupConfigResponse {
  update?: Update | null;
}

// refs: 1 - tags: named, output
export interface UpdateNodegroupVersionResponse {
  update?: Update | null;
}

// refs: 2 - tags: input, named, enum
export type ResolveConflicts =
| "OVERWRITE"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface VpcConfigRequest {
  subnetIds?: string[] | null;
  securityGroupIds?: string[] | null;
  endpointPublicAccess?: boolean | null;
  endpointPrivateAccess?: boolean | null;
  publicAccessCidrs?: string[] | null;
}
function fromVpcConfigRequest(input?: VpcConfigRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subnetIds: input["subnetIds"],
    securityGroupIds: input["securityGroupIds"],
    endpointPublicAccess: input["endpointPublicAccess"],
    endpointPrivateAccess: input["endpointPrivateAccess"],
    publicAccessCidrs: input["publicAccessCidrs"],
  }
}

// refs: 1 - tags: input, named, interface
export interface KubernetesNetworkConfigRequest {
  serviceIpv4Cidr?: string | null;
}
function fromKubernetesNetworkConfigRequest(input?: KubernetesNetworkConfigRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceIpv4Cidr: input["serviceIpv4Cidr"],
  }
}

// refs: 5 - tags: input, named, interface, output
export interface Logging {
  clusterLogging?: LogSetup[] | null;
}
function fromLogging(input?: Logging | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clusterLogging: input["clusterLogging"]?.map(x => fromLogSetup(x)),
  }
}
function toLogging(root: jsonP.JSONValue): Logging {
  return jsonP.readObj({
    required: {},
    optional: {
      "clusterLogging": [toLogSetup],
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface LogSetup {
  types?: LogType[] | null;
  enabled?: boolean | null;
}
function fromLogSetup(input?: LogSetup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    types: input["types"],
    enabled: input["enabled"],
  }
}
function toLogSetup(root: jsonP.JSONValue): LogSetup {
  return jsonP.readObj({
    required: {},
    optional: {
      "types": [(x: jsonP.JSONValue) => cmnP.readEnum<LogType>(x)],
      "enabled": "b",
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type LogType =
| "api"
| "audit"
| "authenticator"
| "controllerManager"
| "scheduler"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface EncryptionConfig {
  resources?: string[] | null;
  provider?: Provider | null;
}
function fromEncryptionConfig(input?: EncryptionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    resources: input["resources"],
    provider: fromProvider(input["provider"]),
  }
}
function toEncryptionConfig(root: jsonP.JSONValue): EncryptionConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "resources": ["s"],
      "provider": toProvider,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Provider {
  keyArn?: string | null;
}
function fromProvider(input?: Provider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyArn: input["keyArn"],
  }
}
function toProvider(root: jsonP.JSONValue): Provider {
  return jsonP.readObj({
    required: {},
    optional: {
      "keyArn": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface FargateProfileSelector {
  namespace?: string | null;
  labels?: { [key: string]: string | null | undefined } | null;
}
function fromFargateProfileSelector(input?: FargateProfileSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    namespace: input["namespace"],
    labels: input["labels"],
  }
}
function toFargateProfileSelector(root: jsonP.JSONValue): FargateProfileSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "namespace": "s",
      "labels": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface NodegroupScalingConfig {
  minSize?: number | null;
  maxSize?: number | null;
  desiredSize?: number | null;
}
function fromNodegroupScalingConfig(input?: NodegroupScalingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    minSize: input["minSize"],
    maxSize: input["maxSize"],
    desiredSize: input["desiredSize"],
  }
}
function toNodegroupScalingConfig(root: jsonP.JSONValue): NodegroupScalingConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "minSize": "n",
      "maxSize": "n",
      "desiredSize": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type AMITypes =
| "AL2_x86_64"
| "AL2_x86_64_GPU"
| "AL2_ARM_64"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface RemoteAccessConfig {
  ec2SshKey?: string | null;
  sourceSecurityGroups?: string[] | null;
}
function fromRemoteAccessConfig(input?: RemoteAccessConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ec2SshKey: input["ec2SshKey"],
    sourceSecurityGroups: input["sourceSecurityGroups"],
  }
}
function toRemoteAccessConfig(root: jsonP.JSONValue): RemoteAccessConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ec2SshKey": "s",
      "sourceSecurityGroups": ["s"],
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface LaunchTemplateSpecification {
  name?: string | null;
  version?: string | null;
  id?: string | null;
}
function fromLaunchTemplateSpecification(input?: LaunchTemplateSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    version: input["version"],
    id: input["id"],
  }
}
function toLaunchTemplateSpecification(root: jsonP.JSONValue): LaunchTemplateSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "version": "s",
      "id": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type CapacityTypes =
| "ON_DEMAND"
| "SPOT"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface UpdateLabelsPayload {
  addOrUpdateLabels?: { [key: string]: string | null | undefined } | null;
  removeLabels?: string[] | null;
}
function fromUpdateLabelsPayload(input?: UpdateLabelsPayload | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    addOrUpdateLabels: input["addOrUpdateLabels"],
    removeLabels: input["removeLabels"],
  }
}

// refs: 3 - tags: output, named, interface
export interface Addon {
  addonName?: string | null;
  clusterName?: string | null;
  status?: AddonStatus | null;
  addonVersion?: string | null;
  health?: AddonHealth | null;
  addonArn?: string | null;
  createdAt?: Date | number | null;
  modifiedAt?: Date | number | null;
  serviceAccountRoleArn?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toAddon(root: jsonP.JSONValue): Addon {
  return jsonP.readObj({
    required: {},
    optional: {
      "addonName": "s",
      "clusterName": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<AddonStatus>(x),
      "addonVersion": "s",
      "health": toAddonHealth,
      "addonArn": "s",
      "createdAt": "d",
      "modifiedAt": "d",
      "serviceAccountRoleArn": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type AddonStatus =
| "CREATING"
| "ACTIVE"
| "CREATE_FAILED"
| "UPDATING"
| "DELETING"
| "DELETE_FAILED"
| "DEGRADED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface AddonHealth {
  issues?: AddonIssue[] | null;
}
function toAddonHealth(root: jsonP.JSONValue): AddonHealth {
  return jsonP.readObj({
    required: {},
    optional: {
      "issues": [toAddonIssue],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface AddonIssue {
  code?: AddonIssueCode | null;
  message?: string | null;
  resourceIds?: string[] | null;
}
function toAddonIssue(root: jsonP.JSONValue): AddonIssue {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<AddonIssueCode>(x),
      "message": "s",
      "resourceIds": ["s"],
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type AddonIssueCode =
| "AccessDenied"
| "InternalFailure"
| "ClusterUnreachable"
| "InsufficientNumberOfReplicas"
| "ConfigurationConflict"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface Cluster {
  name?: string | null;
  arn?: string | null;
  createdAt?: Date | number | null;
  version?: string | null;
  endpoint?: string | null;
  roleArn?: string | null;
  resourcesVpcConfig?: VpcConfigResponse | null;
  kubernetesNetworkConfig?: KubernetesNetworkConfigResponse | null;
  logging?: Logging | null;
  identity?: Identity | null;
  status?: ClusterStatus | null;
  certificateAuthority?: Certificate | null;
  clientRequestToken?: string | null;
  platformVersion?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
  encryptionConfig?: EncryptionConfig[] | null;
}
function toCluster(root: jsonP.JSONValue): Cluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "createdAt": "d",
      "version": "s",
      "endpoint": "s",
      "roleArn": "s",
      "resourcesVpcConfig": toVpcConfigResponse,
      "kubernetesNetworkConfig": toKubernetesNetworkConfigResponse,
      "logging": toLogging,
      "identity": toIdentity,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ClusterStatus>(x),
      "certificateAuthority": toCertificate,
      "clientRequestToken": "s",
      "platformVersion": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "encryptionConfig": [toEncryptionConfig],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface VpcConfigResponse {
  subnetIds?: string[] | null;
  securityGroupIds?: string[] | null;
  clusterSecurityGroupId?: string | null;
  vpcId?: string | null;
  endpointPublicAccess?: boolean | null;
  endpointPrivateAccess?: boolean | null;
  publicAccessCidrs?: string[] | null;
}
function toVpcConfigResponse(root: jsonP.JSONValue): VpcConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "subnetIds": ["s"],
      "securityGroupIds": ["s"],
      "clusterSecurityGroupId": "s",
      "vpcId": "s",
      "endpointPublicAccess": "b",
      "endpointPrivateAccess": "b",
      "publicAccessCidrs": ["s"],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface KubernetesNetworkConfigResponse {
  serviceIpv4Cidr?: string | null;
}
function toKubernetesNetworkConfigResponse(root: jsonP.JSONValue): KubernetesNetworkConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceIpv4Cidr": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Identity {
  oidc?: OIDC | null;
}
function toIdentity(root: jsonP.JSONValue): Identity {
  return jsonP.readObj({
    required: {},
    optional: {
      "oidc": toOIDC,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface OIDC {
  issuer?: string | null;
}
function toOIDC(root: jsonP.JSONValue): OIDC {
  return jsonP.readObj({
    required: {},
    optional: {
      "issuer": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type ClusterStatus =
| "CREATING"
| "ACTIVE"
| "DELETING"
| "FAILED"
| "UPDATING"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface Certificate {
  data?: string | null;
}
function toCertificate(root: jsonP.JSONValue): Certificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "data": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface FargateProfile {
  fargateProfileName?: string | null;
  fargateProfileArn?: string | null;
  clusterName?: string | null;
  createdAt?: Date | number | null;
  podExecutionRoleArn?: string | null;
  subnets?: string[] | null;
  selectors?: FargateProfileSelector[] | null;
  status?: FargateProfileStatus | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toFargateProfile(root: jsonP.JSONValue): FargateProfile {
  return jsonP.readObj({
    required: {},
    optional: {
      "fargateProfileName": "s",
      "fargateProfileArn": "s",
      "clusterName": "s",
      "createdAt": "d",
      "podExecutionRoleArn": "s",
      "subnets": ["s"],
      "selectors": [toFargateProfileSelector],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<FargateProfileStatus>(x),
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type FargateProfileStatus =
| "CREATING"
| "ACTIVE"
| "DELETING"
| "CREATE_FAILED"
| "DELETE_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface Nodegroup {
  nodegroupName?: string | null;
  nodegroupArn?: string | null;
  clusterName?: string | null;
  version?: string | null;
  releaseVersion?: string | null;
  createdAt?: Date | number | null;
  modifiedAt?: Date | number | null;
  status?: NodegroupStatus | null;
  capacityType?: CapacityTypes | null;
  scalingConfig?: NodegroupScalingConfig | null;
  instanceTypes?: string[] | null;
  subnets?: string[] | null;
  remoteAccess?: RemoteAccessConfig | null;
  amiType?: AMITypes | null;
  nodeRole?: string | null;
  labels?: { [key: string]: string | null | undefined } | null;
  resources?: NodegroupResources | null;
  diskSize?: number | null;
  health?: NodegroupHealth | null;
  launchTemplate?: LaunchTemplateSpecification | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toNodegroup(root: jsonP.JSONValue): Nodegroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "nodegroupName": "s",
      "nodegroupArn": "s",
      "clusterName": "s",
      "version": "s",
      "releaseVersion": "s",
      "createdAt": "d",
      "modifiedAt": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<NodegroupStatus>(x),
      "capacityType": (x: jsonP.JSONValue) => cmnP.readEnum<CapacityTypes>(x),
      "scalingConfig": toNodegroupScalingConfig,
      "instanceTypes": ["s"],
      "subnets": ["s"],
      "remoteAccess": toRemoteAccessConfig,
      "amiType": (x: jsonP.JSONValue) => cmnP.readEnum<AMITypes>(x),
      "nodeRole": "s",
      "labels": x => jsonP.readMap(String, String, x),
      "resources": toNodegroupResources,
      "diskSize": "n",
      "health": toNodegroupHealth,
      "launchTemplate": toLaunchTemplateSpecification,
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type NodegroupStatus =
| "CREATING"
| "ACTIVE"
| "UPDATING"
| "DELETING"
| "CREATE_FAILED"
| "DELETE_FAILED"
| "DEGRADED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface NodegroupResources {
  autoScalingGroups?: AutoScalingGroup[] | null;
  remoteAccessSecurityGroup?: string | null;
}
function toNodegroupResources(root: jsonP.JSONValue): NodegroupResources {
  return jsonP.readObj({
    required: {},
    optional: {
      "autoScalingGroups": [toAutoScalingGroup],
      "remoteAccessSecurityGroup": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface AutoScalingGroup {
  name?: string | null;
}
function toAutoScalingGroup(root: jsonP.JSONValue): AutoScalingGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface NodegroupHealth {
  issues?: Issue[] | null;
}
function toNodegroupHealth(root: jsonP.JSONValue): NodegroupHealth {
  return jsonP.readObj({
    required: {},
    optional: {
      "issues": [toIssue],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Issue {
  code?: NodegroupIssueCode | null;
  message?: string | null;
  resourceIds?: string[] | null;
}
function toIssue(root: jsonP.JSONValue): Issue {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<NodegroupIssueCode>(x),
      "message": "s",
      "resourceIds": ["s"],
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type NodegroupIssueCode =
| "AutoScalingGroupNotFound"
| "AutoScalingGroupInvalidConfiguration"
| "Ec2SecurityGroupNotFound"
| "Ec2SecurityGroupDeletionFailure"
| "Ec2LaunchTemplateNotFound"
| "Ec2LaunchTemplateVersionMismatch"
| "Ec2SubnetNotFound"
| "Ec2SubnetInvalidConfiguration"
| "IamInstanceProfileNotFound"
| "IamLimitExceeded"
| "IamNodeRoleNotFound"
| "NodeCreationFailure"
| "AsgInstanceLaunchFailures"
| "InstanceLimitExceeded"
| "InsufficientFreeAddresses"
| "AccessDenied"
| "InternalFailure"
| "ClusterUnreachable"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AddonInfo {
  addonName?: string | null;
  type?: string | null;
  addonVersions?: AddonVersionInfo[] | null;
}
function toAddonInfo(root: jsonP.JSONValue): AddonInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "addonName": "s",
      "type": "s",
      "addonVersions": [toAddonVersionInfo],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AddonVersionInfo {
  addonVersion?: string | null;
  architecture?: string[] | null;
  compatibilities?: Compatibility[] | null;
}
function toAddonVersionInfo(root: jsonP.JSONValue): AddonVersionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "addonVersion": "s",
      "architecture": ["s"],
      "compatibilities": [toCompatibility],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Compatibility {
  clusterVersion?: string | null;
  platformVersions?: string[] | null;
  defaultVersion?: boolean | null;
}
function toCompatibility(root: jsonP.JSONValue): Compatibility {
  return jsonP.readObj({
    required: {},
    optional: {
      "clusterVersion": "s",
      "platformVersions": ["s"],
      "defaultVersion": "b",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface Update {
  id?: string | null;
  status?: UpdateStatus | null;
  type?: UpdateType | null;
  params?: UpdateParam[] | null;
  createdAt?: Date | number | null;
  errors?: ErrorDetail[] | null;
}
function toUpdate(root: jsonP.JSONValue): Update {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<UpdateStatus>(x),
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<UpdateType>(x),
      "params": [toUpdateParam],
      "createdAt": "d",
      "errors": [toErrorDetail],
    },
  }, root);
}

// refs: 6 - tags: output, named, enum
export type UpdateStatus =
| "InProgress"
| "Failed"
| "Cancelled"
| "Successful"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, enum
export type UpdateType =
| "VersionUpdate"
| "EndpointAccessUpdate"
| "LoggingUpdate"
| "ConfigUpdate"
| "AddonUpdate"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface UpdateParam {
  type?: UpdateParamType | null;
  value?: string | null;
}
function toUpdateParam(root: jsonP.JSONValue): UpdateParam {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<UpdateParamType>(x),
      "value": "s",
    },
  }, root);
}

// refs: 6 - tags: output, named, enum
export type UpdateParamType =
| "Version"
| "PlatformVersion"
| "EndpointPrivateAccess"
| "EndpointPublicAccess"
| "ClusterLogging"
| "DesiredSize"
| "LabelsToAdd"
| "LabelsToRemove"
| "MaxSize"
| "MinSize"
| "ReleaseVersion"
| "PublicAccessCidrs"
| "AddonVersion"
| "ServiceAccountRoleArn"
| "ResolveConflicts"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface ErrorDetail {
  errorCode?: ErrorCode | null;
  errorMessage?: string | null;
  resourceIds?: string[] | null;
}
function toErrorDetail(root: jsonP.JSONValue): ErrorDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<ErrorCode>(x),
      "errorMessage": "s",
      "resourceIds": ["s"],
    },
  }, root);
}

// refs: 6 - tags: output, named, enum
export type ErrorCode =
| "SubnetNotFound"
| "SecurityGroupNotFound"
| "EniLimitReached"
| "IpNotAvailable"
| "AccessDenied"
| "OperationNotPermitted"
| "VpcIdNotFound"
| "Unknown"
| "NodeCreationFailure"
| "PodEvictionFailure"
| "InsufficientFreeAddresses"
| "ClusterUnreachable"
| "InsufficientNumberOfReplicas"
| "ConfigurationConflict"
| cmnP.UnexpectedEnumValue;
