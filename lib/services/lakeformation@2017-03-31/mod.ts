// Autogenerated API client for: AWS Lake Formation

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class LakeFormation {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(LakeFormation.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-03-31",
    "endpointPrefix": "lakeformation",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Lake Formation",
    "serviceId": "LakeFormation",
    "signatureVersion": "v4",
    "signingName": "lakeformation",
    "targetPrefix": "AWSLakeFormation",
    "uid": "lakeformation-2017-03-31"
  };

  async batchGrantPermissions(
    {abortSignal, ...params}: RequestConfig & s.BatchGrantPermissionsRequest,
  ): Promise<s.BatchGrantPermissionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Entries: params["Entries"]?.map(x => fromBatchPermissionsRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGrantPermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Failures": [toBatchPermissionsFailureEntry],
      },
    }, await resp.json());
  }

  async batchRevokePermissions(
    {abortSignal, ...params}: RequestConfig & s.BatchRevokePermissionsRequest,
  ): Promise<s.BatchRevokePermissionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Entries: params["Entries"]?.map(x => fromBatchPermissionsRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchRevokePermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Failures": [toBatchPermissionsFailureEntry],
      },
    }, await resp.json());
  }

  async deregisterResource(
    {abortSignal, ...params}: RequestConfig & s.DeregisterResourceRequest,
  ): Promise<s.DeregisterResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeResource(
    {abortSignal, ...params}: RequestConfig & s.DescribeResourceRequest,
  ): Promise<s.DescribeResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceInfo": toResourceInfo,
      },
    }, await resp.json());
  }

  async getDataLakeSettings(
    {abortSignal, ...params}: RequestConfig & s.GetDataLakeSettingsRequest = {},
  ): Promise<s.GetDataLakeSettingsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDataLakeSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataLakeSettings": toDataLakeSettings,
      },
    }, await resp.json());
  }

  async getEffectivePermissionsForPath(
    {abortSignal, ...params}: RequestConfig & s.GetEffectivePermissionsForPathRequest,
  ): Promise<s.GetEffectivePermissionsForPathResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEffectivePermissionsForPath",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Permissions": [toPrincipalResourcePermissions],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async grantPermissions(
    {abortSignal, ...params}: RequestConfig & s.GrantPermissionsRequest,
  ): Promise<s.GrantPermissionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Principal: fromDataLakePrincipal(params["Principal"]),
      Resource: fromResource(params["Resource"]),
      Permissions: params["Permissions"],
      PermissionsWithGrantOption: params["PermissionsWithGrantOption"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GrantPermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async listPermissions(
    {abortSignal, ...params}: RequestConfig & s.ListPermissionsRequest = {},
  ): Promise<s.ListPermissionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Principal: fromDataLakePrincipal(params["Principal"]),
      ResourceType: params["ResourceType"],
      Resource: fromResource(params["Resource"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PrincipalResourcePermissions": [toPrincipalResourcePermissions],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listResources(
    {abortSignal, ...params}: RequestConfig & s.ListResourcesRequest = {},
  ): Promise<s.ListResourcesResponse> {
    const body: jsonP.JSONObject = {
      FilterConditionList: params["FilterConditionList"]?.map(x => fromFilterCondition(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListResources",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceInfoList": [toResourceInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putDataLakeSettings(
    {abortSignal, ...params}: RequestConfig & s.PutDataLakeSettingsRequest,
  ): Promise<s.PutDataLakeSettingsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DataLakeSettings: fromDataLakeSettings(params["DataLakeSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDataLakeSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async registerResource(
    {abortSignal, ...params}: RequestConfig & s.RegisterResourceRequest,
  ): Promise<s.RegisterResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      UseServiceLinkedRole: params["UseServiceLinkedRole"],
      RoleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async revokePermissions(
    {abortSignal, ...params}: RequestConfig & s.RevokePermissionsRequest,
  ): Promise<s.RevokePermissionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Principal: fromDataLakePrincipal(params["Principal"]),
      Resource: fromResource(params["Resource"]),
      Permissions: params["Permissions"],
      PermissionsWithGrantOption: params["PermissionsWithGrantOption"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokePermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateResource(
    {abortSignal, ...params}: RequestConfig & s.UpdateResourceRequest,
  ): Promise<s.UpdateResourceResponse> {
    const body: jsonP.JSONObject = {
      RoleArn: params["RoleArn"],
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromBatchPermissionsRequestEntry(input?: s.BatchPermissionsRequestEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Principal: fromDataLakePrincipal(input["Principal"]),
    Resource: fromResource(input["Resource"]),
    Permissions: input["Permissions"],
    PermissionsWithGrantOption: input["PermissionsWithGrantOption"],
  }
}
function toBatchPermissionsRequestEntry(root: jsonP.JSONValue): s.BatchPermissionsRequestEntry {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {
      "Principal": toDataLakePrincipal,
      "Resource": toResource,
      "Permissions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Permission>(x)],
      "PermissionsWithGrantOption": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Permission>(x)],
    },
  }, root);
}

function fromDataLakePrincipal(input?: s.DataLakePrincipal | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataLakePrincipalIdentifier: input["DataLakePrincipalIdentifier"],
  }
}
function toDataLakePrincipal(root: jsonP.JSONValue): s.DataLakePrincipal {
  return jsonP.readObj({
    required: {},
    optional: {
      "DataLakePrincipalIdentifier": "s",
    },
  }, root);
}

function fromResource(input?: s.Resource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Catalog: fromCatalogResource(input["Catalog"]),
    Database: fromDatabaseResource(input["Database"]),
    Table: fromTableResource(input["Table"]),
    TableWithColumns: fromTableWithColumnsResource(input["TableWithColumns"]),
    DataLocation: fromDataLocationResource(input["DataLocation"]),
  }
}
function toResource(root: jsonP.JSONValue): s.Resource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Catalog": toCatalogResource,
      "Database": toDatabaseResource,
      "Table": toTableResource,
      "TableWithColumns": toTableWithColumnsResource,
      "DataLocation": toDataLocationResource,
    },
  }, root);
}

function fromCatalogResource(input?: s.CatalogResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toCatalogResource(root: jsonP.JSONValue): s.CatalogResource {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromDatabaseResource(input?: s.DatabaseResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    Name: input["Name"],
  }
}
function toDatabaseResource(root: jsonP.JSONValue): s.DatabaseResource {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "CatalogId": "s",
    },
  }, root);
}

function fromTableResource(input?: s.TableResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
    Name: input["Name"],
    TableWildcard: fromTableWildcard(input["TableWildcard"]),
  }
}
function toTableResource(root: jsonP.JSONValue): s.TableResource {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
    },
    optional: {
      "CatalogId": "s",
      "Name": "s",
      "TableWildcard": toTableWildcard,
    },
  }, root);
}

function fromTableWildcard(input?: s.TableWildcard | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toTableWildcard(root: jsonP.JSONValue): s.TableWildcard {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromTableWithColumnsResource(input?: s.TableWithColumnsResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
    Name: input["Name"],
    ColumnNames: input["ColumnNames"],
    ColumnWildcard: fromColumnWildcard(input["ColumnWildcard"]),
  }
}
function toTableWithColumnsResource(root: jsonP.JSONValue): s.TableWithColumnsResource {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
      "Name": "s",
    },
    optional: {
      "CatalogId": "s",
      "ColumnNames": ["s"],
      "ColumnWildcard": toColumnWildcard,
    },
  }, root);
}

function fromColumnWildcard(input?: s.ColumnWildcard | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExcludedColumnNames: input["ExcludedColumnNames"],
  }
}
function toColumnWildcard(root: jsonP.JSONValue): s.ColumnWildcard {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExcludedColumnNames": ["s"],
    },
  }, root);
}

function fromDataLocationResource(input?: s.DataLocationResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    ResourceArn: input["ResourceArn"],
  }
}
function toDataLocationResource(root: jsonP.JSONValue): s.DataLocationResource {
  return jsonP.readObj({
    required: {
      "ResourceArn": "s",
    },
    optional: {
      "CatalogId": "s",
    },
  }, root);
}

function fromFilterCondition(input?: s.FilterCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Field: input["Field"],
    ComparisonOperator: input["ComparisonOperator"],
    StringValueList: input["StringValueList"],
  }
}

function fromDataLakeSettings(input?: s.DataLakeSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataLakeAdmins: input["DataLakeAdmins"]?.map(x => fromDataLakePrincipal(x)),
    CreateDatabaseDefaultPermissions: input["CreateDatabaseDefaultPermissions"]?.map(x => fromPrincipalPermissions(x)),
    CreateTableDefaultPermissions: input["CreateTableDefaultPermissions"]?.map(x => fromPrincipalPermissions(x)),
    TrustedResourceOwners: input["TrustedResourceOwners"],
  }
}
function toDataLakeSettings(root: jsonP.JSONValue): s.DataLakeSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DataLakeAdmins": [toDataLakePrincipal],
      "CreateDatabaseDefaultPermissions": [toPrincipalPermissions],
      "CreateTableDefaultPermissions": [toPrincipalPermissions],
      "TrustedResourceOwners": ["s"],
    },
  }, root);
}

function fromPrincipalPermissions(input?: s.PrincipalPermissions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Principal: fromDataLakePrincipal(input["Principal"]),
    Permissions: input["Permissions"],
  }
}
function toPrincipalPermissions(root: jsonP.JSONValue): s.PrincipalPermissions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Principal": toDataLakePrincipal,
      "Permissions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Permission>(x)],
    },
  }, root);
}

function toBatchPermissionsFailureEntry(root: jsonP.JSONValue): s.BatchPermissionsFailureEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "RequestEntry": toBatchPermissionsRequestEntry,
      "Error": toErrorDetail,
    },
  }, root);
}

function toErrorDetail(root: jsonP.JSONValue): s.ErrorDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

function toResourceInfo(root: jsonP.JSONValue): s.ResourceInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceArn": "s",
      "RoleArn": "s",
      "LastModified": "d",
    },
  }, root);
}

function toPrincipalResourcePermissions(root: jsonP.JSONValue): s.PrincipalResourcePermissions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Principal": toDataLakePrincipal,
      "Resource": toResource,
      "Permissions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Permission>(x)],
      "PermissionsWithGrantOption": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Permission>(x)],
      "AdditionalDetails": toDetailsMap,
    },
  }, root);
}

function toDetailsMap(root: jsonP.JSONValue): s.DetailsMap {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceShare": ["s"],
    },
  }, root);
}
