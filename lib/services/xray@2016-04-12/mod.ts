// Autogenerated API client for: AWS X-Ray

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class XRay {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(XRay.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2016-04-12",
    "endpointPrefix": "xray",
    "protocol": "rest-json",
    "serviceFullName": "AWS X-Ray",
    "serviceId": "XRay",
    "signatureVersion": "v4",
    "uid": "xray-2016-04-12"
  };

  async batchGetTraces(
    {abortSignal, ...params}: RequestConfig & BatchGetTracesRequest,
  ): Promise<BatchGetTracesResult> {
    const body: jsonP.JSONObject = params ? {
      TraceIds: params["TraceIds"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetTraces",
      requestUri: "/Traces",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Traces": [toTrace],
          "UnprocessedTraceIds": ["s"],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async createGroup(
    {abortSignal, ...params}: RequestConfig & CreateGroupRequest,
  ): Promise<CreateGroupResult> {
    const body: jsonP.JSONObject = params ? {
      GroupName: params["GroupName"],
      FilterExpression: params["FilterExpression"],
      InsightsConfiguration: fromInsightsConfiguration(params["InsightsConfiguration"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGroup",
      requestUri: "/CreateGroup",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Group": toGroup,
        },
      }, await resp.json()),
  };
  }

  async createSamplingRule(
    {abortSignal, ...params}: RequestConfig & CreateSamplingRuleRequest,
  ): Promise<CreateSamplingRuleResult> {
    const body: jsonP.JSONObject = params ? {
      SamplingRule: fromSamplingRule(params["SamplingRule"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSamplingRule",
      requestUri: "/CreateSamplingRule",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SamplingRuleRecord": toSamplingRuleRecord,
        },
      }, await resp.json()),
  };
  }

  async deleteGroup(
    {abortSignal, ...params}: RequestConfig & DeleteGroupRequest = {},
  ): Promise<DeleteGroupResult> {
    const body: jsonP.JSONObject = params ? {
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGroup",
      requestUri: "/DeleteGroup",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async deleteSamplingRule(
    {abortSignal, ...params}: RequestConfig & DeleteSamplingRuleRequest = {},
  ): Promise<DeleteSamplingRuleResult> {
    const body: jsonP.JSONObject = params ? {
      RuleName: params["RuleName"],
      RuleARN: params["RuleARN"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSamplingRule",
      requestUri: "/DeleteSamplingRule",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SamplingRuleRecord": toSamplingRuleRecord,
        },
      }, await resp.json()),
  };
  }

  async getEncryptionConfig(
    {abortSignal, ...params}: RequestConfig & GetEncryptionConfigRequest = {},
  ): Promise<GetEncryptionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetEncryptionConfig",
      requestUri: "/EncryptionConfig",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "EncryptionConfig": toEncryptionConfig,
        },
      }, await resp.json()),
  };
  }

  async getGroup(
    {abortSignal, ...params}: RequestConfig & GetGroupRequest = {},
  ): Promise<GetGroupResult> {
    const body: jsonP.JSONObject = params ? {
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroup",
      requestUri: "/GetGroup",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Group": toGroup,
        },
      }, await resp.json()),
  };
  }

  async getGroups(
    {abortSignal, ...params}: RequestConfig & GetGroupsRequest = {},
  ): Promise<GetGroupsResult> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroups",
      requestUri: "/Groups",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Groups": [toGroupSummary],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getSamplingRules(
    {abortSignal, ...params}: RequestConfig & GetSamplingRulesRequest = {},
  ): Promise<GetSamplingRulesResult> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSamplingRules",
      requestUri: "/GetSamplingRules",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SamplingRuleRecords": [toSamplingRuleRecord],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getSamplingStatisticSummaries(
    {abortSignal, ...params}: RequestConfig & GetSamplingStatisticSummariesRequest = {},
  ): Promise<GetSamplingStatisticSummariesResult> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSamplingStatisticSummaries",
      requestUri: "/SamplingStatisticSummaries",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SamplingStatisticSummaries": [toSamplingStatisticSummary],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getSamplingTargets(
    {abortSignal, ...params}: RequestConfig & GetSamplingTargetsRequest,
  ): Promise<GetSamplingTargetsResult> {
    const body: jsonP.JSONObject = params ? {
      SamplingStatisticsDocuments: params["SamplingStatisticsDocuments"]?.map(x => fromSamplingStatisticsDocument(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSamplingTargets",
      requestUri: "/SamplingTargets",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SamplingTargetDocuments": [toSamplingTargetDocument],
          "LastRuleModification": "d",
          "UnprocessedStatistics": [toUnprocessedStatistics],
        },
      }, await resp.json()),
  };
  }

  async getServiceGraph(
    {abortSignal, ...params}: RequestConfig & GetServiceGraphRequest,
  ): Promise<GetServiceGraphResult> {
    const body: jsonP.JSONObject = params ? {
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServiceGraph",
      requestUri: "/ServiceGraph",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "StartTime": "d",
          "EndTime": "d",
          "Services": [toService],
          "ContainsOldGroupVersions": "b",
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getTimeSeriesServiceStatistics(
    {abortSignal, ...params}: RequestConfig & GetTimeSeriesServiceStatisticsRequest,
  ): Promise<GetTimeSeriesServiceStatisticsResult> {
    const body: jsonP.JSONObject = params ? {
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
      EntitySelectorExpression: params["EntitySelectorExpression"],
      Period: params["Period"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTimeSeriesServiceStatistics",
      requestUri: "/TimeSeriesServiceStatistics",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "TimeSeriesServiceStatistics": [toTimeSeriesServiceStatistics],
          "ContainsOldGroupVersions": "b",
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getTraceGraph(
    {abortSignal, ...params}: RequestConfig & GetTraceGraphRequest,
  ): Promise<GetTraceGraphResult> {
    const body: jsonP.JSONObject = params ? {
      TraceIds: params["TraceIds"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTraceGraph",
      requestUri: "/TraceGraph",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Services": [toService],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getTraceSummaries(
    {abortSignal, ...params}: RequestConfig & GetTraceSummariesRequest,
  ): Promise<GetTraceSummariesResult> {
    const body: jsonP.JSONObject = params ? {
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      TimeRangeType: params["TimeRangeType"],
      Sampling: params["Sampling"],
      SamplingStrategy: fromSamplingStrategy(params["SamplingStrategy"]),
      FilterExpression: params["FilterExpression"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTraceSummaries",
      requestUri: "/TraceSummaries",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "TraceSummaries": [toTraceSummary],
          "ApproximateTime": "d",
          "TracesProcessedCount": "n",
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceARN: params["ResourceARN"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
      requestUri: "/ListTagsForResource",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Tags": [toTag],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async putEncryptionConfig(
    {abortSignal, ...params}: RequestConfig & PutEncryptionConfigRequest,
  ): Promise<PutEncryptionConfigResult> {
    const body: jsonP.JSONObject = params ? {
      KeyId: params["KeyId"],
      Type: params["Type"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutEncryptionConfig",
      requestUri: "/PutEncryptionConfig",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "EncryptionConfig": toEncryptionConfig,
        },
      }, await resp.json()),
  };
  }

  async putTelemetryRecords(
    {abortSignal, ...params}: RequestConfig & PutTelemetryRecordsRequest,
  ): Promise<PutTelemetryRecordsResult> {
    const body: jsonP.JSONObject = params ? {
      TelemetryRecords: params["TelemetryRecords"]?.map(x => fromTelemetryRecord(x)),
      EC2InstanceId: params["EC2InstanceId"],
      Hostname: params["Hostname"],
      ResourceARN: params["ResourceARN"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutTelemetryRecords",
      requestUri: "/TelemetryRecords",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async putTraceSegments(
    {abortSignal, ...params}: RequestConfig & PutTraceSegmentsRequest,
  ): Promise<PutTraceSegmentsResult> {
    const body: jsonP.JSONObject = params ? {
      TraceSegmentDocuments: params["TraceSegmentDocuments"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutTraceSegments",
      requestUri: "/TraceSegments",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "UnprocessedTraceSegments": [toUnprocessedTraceSegment],
        },
      }, await resp.json()),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: "/TagResource",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
      requestUri: "/UntagResource",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async updateGroup(
    {abortSignal, ...params}: RequestConfig & UpdateGroupRequest = {},
  ): Promise<UpdateGroupResult> {
    const body: jsonP.JSONObject = params ? {
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
      FilterExpression: params["FilterExpression"],
      InsightsConfiguration: fromInsightsConfiguration(params["InsightsConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGroup",
      requestUri: "/UpdateGroup",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Group": toGroup,
        },
      }, await resp.json()),
  };
  }

  async updateSamplingRule(
    {abortSignal, ...params}: RequestConfig & UpdateSamplingRuleRequest,
  ): Promise<UpdateSamplingRuleResult> {
    const body: jsonP.JSONObject = params ? {
      SamplingRuleUpdate: fromSamplingRuleUpdate(params["SamplingRuleUpdate"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSamplingRule",
      requestUri: "/UpdateSamplingRule",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SamplingRuleRecord": toSamplingRuleRecord,
        },
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface BatchGetTracesRequest {
  TraceIds: string[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateGroupRequest {
  GroupName: string;
  FilterExpression?: string | null;
  InsightsConfiguration?: InsightsConfiguration | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateSamplingRuleRequest {
  SamplingRule: SamplingRule;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteGroupRequest {
  GroupName?: string | null;
  GroupARN?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteSamplingRuleRequest {
  RuleName?: string | null;
  RuleARN?: string | null;
}

// refs: 1 - tags: named, input
export interface GetEncryptionConfigRequest {
}

// refs: 1 - tags: named, input
export interface GetGroupRequest {
  GroupName?: string | null;
  GroupARN?: string | null;
}

// refs: 1 - tags: named, input
export interface GetGroupsRequest {
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetSamplingRulesRequest {
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetSamplingStatisticSummariesRequest {
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetSamplingTargetsRequest {
  SamplingStatisticsDocuments: SamplingStatisticsDocument[];
}

// refs: 1 - tags: named, input
export interface GetServiceGraphRequest {
  StartTime: Date | number;
  EndTime: Date | number;
  GroupName?: string | null;
  GroupARN?: string | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetTimeSeriesServiceStatisticsRequest {
  StartTime: Date | number;
  EndTime: Date | number;
  GroupName?: string | null;
  GroupARN?: string | null;
  EntitySelectorExpression?: string | null;
  Period?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetTraceGraphRequest {
  TraceIds: string[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetTraceSummariesRequest {
  StartTime: Date | number;
  EndTime: Date | number;
  TimeRangeType?: TimeRangeType | null;
  Sampling?: boolean | null;
  SamplingStrategy?: SamplingStrategy | null;
  FilterExpression?: string | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceARN: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PutEncryptionConfigRequest {
  KeyId?: string | null;
  Type: EncryptionType;
}

// refs: 1 - tags: named, input
export interface PutTelemetryRecordsRequest {
  TelemetryRecords: TelemetryRecord[];
  EC2InstanceId?: string | null;
  Hostname?: string | null;
  ResourceARN?: string | null;
}

// refs: 1 - tags: named, input
export interface PutTraceSegmentsRequest {
  TraceSegmentDocuments: string[];
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceARN: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceARN: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateGroupRequest {
  GroupName?: string | null;
  GroupARN?: string | null;
  FilterExpression?: string | null;
  InsightsConfiguration?: InsightsConfiguration | null;
}

// refs: 1 - tags: named, input
export interface UpdateSamplingRuleRequest {
  SamplingRuleUpdate: SamplingRuleUpdate;
}

// refs: 1 - tags: named, output
export interface BatchGetTracesResult {
  Traces?: Trace[] | null;
  UnprocessedTraceIds?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateGroupResult {
  Group?: Group | null;
}

// refs: 1 - tags: named, output
export interface CreateSamplingRuleResult {
  SamplingRuleRecord?: SamplingRuleRecord | null;
}

// refs: 1 - tags: named, output
export interface DeleteGroupResult {
}

// refs: 1 - tags: named, output
export interface DeleteSamplingRuleResult {
  SamplingRuleRecord?: SamplingRuleRecord | null;
}

// refs: 1 - tags: named, output
export interface GetEncryptionConfigResult {
  EncryptionConfig?: EncryptionConfig | null;
}

// refs: 1 - tags: named, output
export interface GetGroupResult {
  Group?: Group | null;
}

// refs: 1 - tags: named, output
export interface GetGroupsResult {
  Groups?: GroupSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSamplingRulesResult {
  SamplingRuleRecords?: SamplingRuleRecord[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSamplingStatisticSummariesResult {
  SamplingStatisticSummaries?: SamplingStatisticSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSamplingTargetsResult {
  SamplingTargetDocuments?: SamplingTargetDocument[] | null;
  LastRuleModification?: Date | number | null;
  UnprocessedStatistics?: UnprocessedStatistics[] | null;
}

// refs: 1 - tags: named, output
export interface GetServiceGraphResult {
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Services?: Service[] | null;
  ContainsOldGroupVersions?: boolean | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTimeSeriesServiceStatisticsResult {
  TimeSeriesServiceStatistics?: TimeSeriesServiceStatistics[] | null;
  ContainsOldGroupVersions?: boolean | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTraceGraphResult {
  Services?: Service[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTraceSummariesResult {
  TraceSummaries?: TraceSummary[] | null;
  ApproximateTime?: Date | number | null;
  TracesProcessedCount?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: Tag[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutEncryptionConfigResult {
  EncryptionConfig?: EncryptionConfig | null;
}

// refs: 1 - tags: named, output
export interface PutTelemetryRecordsResult {
}

// refs: 1 - tags: named, output
export interface PutTraceSegmentsResult {
  UnprocessedTraceSegments?: UnprocessedTraceSegment[] | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateGroupResult {
  Group?: Group | null;
}

// refs: 1 - tags: named, output
export interface UpdateSamplingRuleResult {
  SamplingRuleRecord?: SamplingRuleRecord | null;
}

// refs: 6 - tags: input, named, interface, output
export interface InsightsConfiguration {
  InsightsEnabled?: boolean | null;
  NotificationsEnabled?: boolean | null;
}
function fromInsightsConfiguration(input?: InsightsConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InsightsEnabled: input["InsightsEnabled"],
    NotificationsEnabled: input["NotificationsEnabled"],
  }
}
function toInsightsConfiguration(root: jsonP.JSONValue): InsightsConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "InsightsEnabled": "b",
      "NotificationsEnabled": "b",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface SamplingRule {
  RuleName?: string | null;
  RuleARN?: string | null;
  ResourceARN: string;
  Priority: number;
  FixedRate: number;
  ReservoirSize: number;
  ServiceName: string;
  ServiceType: string;
  Host: string;
  HTTPMethod: string;
  URLPath: string;
  Version: number;
  Attributes?: { [key: string]: string | null | undefined } | null;
}
function fromSamplingRule(input?: SamplingRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleName: input["RuleName"],
    RuleARN: input["RuleARN"],
    ResourceARN: input["ResourceARN"],
    Priority: input["Priority"],
    FixedRate: input["FixedRate"],
    ReservoirSize: input["ReservoirSize"],
    ServiceName: input["ServiceName"],
    ServiceType: input["ServiceType"],
    Host: input["Host"],
    HTTPMethod: input["HTTPMethod"],
    URLPath: input["URLPath"],
    Version: input["Version"],
    Attributes: input["Attributes"],
  }
}
function toSamplingRule(root: jsonP.JSONValue): SamplingRule {
  return jsonP.readObj({
    required: {
      "ResourceARN": "s",
      "Priority": "n",
      "FixedRate": "n",
      "ReservoirSize": "n",
      "ServiceName": "s",
      "ServiceType": "s",
      "Host": "s",
      "HTTPMethod": "s",
      "URLPath": "s",
      "Version": "n",
    },
    optional: {
      "RuleName": "s",
      "RuleARN": "s",
      "Attributes": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface SamplingStatisticsDocument {
  RuleName: string;
  ClientID: string;
  Timestamp: Date | number;
  RequestCount: number;
  SampledCount: number;
  BorrowCount?: number | null;
}
function fromSamplingStatisticsDocument(input?: SamplingStatisticsDocument | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleName: input["RuleName"],
    ClientID: input["ClientID"],
    Timestamp: jsonP.serializeDate_unixTimestamp(input["Timestamp"]),
    RequestCount: input["RequestCount"],
    SampledCount: input["SampledCount"],
    BorrowCount: input["BorrowCount"],
  }
}

// refs: 1 - tags: input, named, enum
export type TimeRangeType =
| "TraceId"
| "Event"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SamplingStrategy {
  Name?: SamplingStrategyName | null;
  Value?: number | null;
}
function fromSamplingStrategy(input?: SamplingStrategy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}

// refs: 1 - tags: input, named, enum
export type SamplingStrategyName =
| "PartialScan"
| "FixedRate"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type EncryptionType =
| "NONE"
| "KMS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TelemetryRecord {
  Timestamp: Date | number;
  SegmentsReceivedCount?: number | null;
  SegmentsSentCount?: number | null;
  SegmentsSpilloverCount?: number | null;
  SegmentsRejectedCount?: number | null;
  BackendConnectionErrors?: BackendConnectionErrors | null;
}
function fromTelemetryRecord(input?: TelemetryRecord | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Timestamp: jsonP.serializeDate_unixTimestamp(input["Timestamp"]),
    SegmentsReceivedCount: input["SegmentsReceivedCount"],
    SegmentsSentCount: input["SegmentsSentCount"],
    SegmentsSpilloverCount: input["SegmentsSpilloverCount"],
    SegmentsRejectedCount: input["SegmentsRejectedCount"],
    BackendConnectionErrors: fromBackendConnectionErrors(input["BackendConnectionErrors"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BackendConnectionErrors {
  TimeoutCount?: number | null;
  ConnectionRefusedCount?: number | null;
  HTTPCode4XXCount?: number | null;
  HTTPCode5XXCount?: number | null;
  UnknownHostCount?: number | null;
  OtherCount?: number | null;
}
function fromBackendConnectionErrors(input?: BackendConnectionErrors | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TimeoutCount: input["TimeoutCount"],
    ConnectionRefusedCount: input["ConnectionRefusedCount"],
    HTTPCode4XXCount: input["HTTPCode4XXCount"],
    HTTPCode5XXCount: input["HTTPCode5XXCount"],
    UnknownHostCount: input["UnknownHostCount"],
    OtherCount: input["OtherCount"],
  }
}

// refs: 1 - tags: input, named, interface
export interface SamplingRuleUpdate {
  RuleName?: string | null;
  RuleARN?: string | null;
  ResourceARN?: string | null;
  Priority?: number | null;
  FixedRate?: number | null;
  ReservoirSize?: number | null;
  Host?: string | null;
  ServiceName?: string | null;
  ServiceType?: string | null;
  HTTPMethod?: string | null;
  URLPath?: string | null;
  Attributes?: { [key: string]: string | null | undefined } | null;
}
function fromSamplingRuleUpdate(input?: SamplingRuleUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleName: input["RuleName"],
    RuleARN: input["RuleARN"],
    ResourceARN: input["ResourceARN"],
    Priority: input["Priority"],
    FixedRate: input["FixedRate"],
    ReservoirSize: input["ReservoirSize"],
    Host: input["Host"],
    ServiceName: input["ServiceName"],
    ServiceType: input["ServiceType"],
    HTTPMethod: input["HTTPMethod"],
    URLPath: input["URLPath"],
    Attributes: input["Attributes"],
  }
}

// refs: 1 - tags: output, named, interface
export interface Trace {
  Id?: string | null;
  Duration?: number | null;
  LimitExceeded?: boolean | null;
  Segments?: Segment[] | null;
}
function toTrace(root: jsonP.JSONValue): Trace {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Duration": "n",
      "LimitExceeded": "b",
      "Segments": [toSegment],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Segment {
  Id?: string | null;
  Document?: string | null;
}
function toSegment(root: jsonP.JSONValue): Segment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Document": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Group {
  GroupName?: string | null;
  GroupARN?: string | null;
  FilterExpression?: string | null;
  InsightsConfiguration?: InsightsConfiguration | null;
}
function toGroup(root: jsonP.JSONValue): Group {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroupName": "s",
      "GroupARN": "s",
      "FilterExpression": "s",
      "InsightsConfiguration": toInsightsConfiguration,
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface SamplingRuleRecord {
  SamplingRule?: SamplingRule | null;
  CreatedAt?: Date | number | null;
  ModifiedAt?: Date | number | null;
}
function toSamplingRuleRecord(root: jsonP.JSONValue): SamplingRuleRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "SamplingRule": toSamplingRule,
      "CreatedAt": "d",
      "ModifiedAt": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EncryptionConfig {
  KeyId?: string | null;
  Status?: EncryptionStatus | null;
  Type?: EncryptionType | null;
}
function toEncryptionConfig(root: jsonP.JSONValue): EncryptionConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionStatus>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionType>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type EncryptionStatus =
| "UPDATING"
| "ACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface GroupSummary {
  GroupName?: string | null;
  GroupARN?: string | null;
  FilterExpression?: string | null;
  InsightsConfiguration?: InsightsConfiguration | null;
}
function toGroupSummary(root: jsonP.JSONValue): GroupSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroupName": "s",
      "GroupARN": "s",
      "FilterExpression": "s",
      "InsightsConfiguration": toInsightsConfiguration,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SamplingStatisticSummary {
  RuleName?: string | null;
  Timestamp?: Date | number | null;
  RequestCount?: number | null;
  BorrowCount?: number | null;
  SampledCount?: number | null;
}
function toSamplingStatisticSummary(root: jsonP.JSONValue): SamplingStatisticSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleName": "s",
      "Timestamp": "d",
      "RequestCount": "n",
      "BorrowCount": "n",
      "SampledCount": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SamplingTargetDocument {
  RuleName?: string | null;
  FixedRate?: number | null;
  ReservoirQuota?: number | null;
  ReservoirQuotaTTL?: Date | number | null;
  Interval?: number | null;
}
function toSamplingTargetDocument(root: jsonP.JSONValue): SamplingTargetDocument {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleName": "s",
      "FixedRate": "n",
      "ReservoirQuota": "n",
      "ReservoirQuotaTTL": "d",
      "Interval": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UnprocessedStatistics {
  RuleName?: string | null;
  ErrorCode?: string | null;
  Message?: string | null;
}
function toUnprocessedStatistics(root: jsonP.JSONValue): UnprocessedStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleName": "s",
      "ErrorCode": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Service {
  ReferenceId?: number | null;
  Name?: string | null;
  Names?: string[] | null;
  Root?: boolean | null;
  AccountId?: string | null;
  Type?: string | null;
  State?: string | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Edges?: Edge[] | null;
  SummaryStatistics?: ServiceStatistics | null;
  DurationHistogram?: HistogramEntry[] | null;
  ResponseTimeHistogram?: HistogramEntry[] | null;
}
function toService(root: jsonP.JSONValue): Service {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReferenceId": "n",
      "Name": "s",
      "Names": ["s"],
      "Root": "b",
      "AccountId": "s",
      "Type": "s",
      "State": "s",
      "StartTime": "d",
      "EndTime": "d",
      "Edges": [toEdge],
      "SummaryStatistics": toServiceStatistics,
      "DurationHistogram": [toHistogramEntry],
      "ResponseTimeHistogram": [toHistogramEntry],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Edge {
  ReferenceId?: number | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  SummaryStatistics?: EdgeStatistics | null;
  ResponseTimeHistogram?: HistogramEntry[] | null;
  Aliases?: Alias[] | null;
}
function toEdge(root: jsonP.JSONValue): Edge {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReferenceId": "n",
      "StartTime": "d",
      "EndTime": "d",
      "SummaryStatistics": toEdgeStatistics,
      "ResponseTimeHistogram": [toHistogramEntry],
      "Aliases": [toAlias],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface EdgeStatistics {
  OkCount?: number | null;
  ErrorStatistics?: ErrorStatistics | null;
  FaultStatistics?: FaultStatistics | null;
  TotalCount?: number | null;
  TotalResponseTime?: number | null;
}
function toEdgeStatistics(root: jsonP.JSONValue): EdgeStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "OkCount": "n",
      "ErrorStatistics": toErrorStatistics,
      "FaultStatistics": toFaultStatistics,
      "TotalCount": "n",
      "TotalResponseTime": "n",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface ErrorStatistics {
  ThrottleCount?: number | null;
  OtherCount?: number | null;
  TotalCount?: number | null;
}
function toErrorStatistics(root: jsonP.JSONValue): ErrorStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "ThrottleCount": "n",
      "OtherCount": "n",
      "TotalCount": "n",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface FaultStatistics {
  OtherCount?: number | null;
  TotalCount?: number | null;
}
function toFaultStatistics(root: jsonP.JSONValue): FaultStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "OtherCount": "n",
      "TotalCount": "n",
    },
  }, root);
}

// refs: 7 - tags: output, named, interface
export interface HistogramEntry {
  Value?: number | null;
  Count?: number | null;
}
function toHistogramEntry(root: jsonP.JSONValue): HistogramEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "n",
      "Count": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Alias {
  Name?: string | null;
  Names?: string[] | null;
  Type?: string | null;
}
function toAlias(root: jsonP.JSONValue): Alias {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "Type": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface ServiceStatistics {
  OkCount?: number | null;
  ErrorStatistics?: ErrorStatistics | null;
  FaultStatistics?: FaultStatistics | null;
  TotalCount?: number | null;
  TotalResponseTime?: number | null;
}
function toServiceStatistics(root: jsonP.JSONValue): ServiceStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "OkCount": "n",
      "ErrorStatistics": toErrorStatistics,
      "FaultStatistics": toFaultStatistics,
      "TotalCount": "n",
      "TotalResponseTime": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TimeSeriesServiceStatistics {
  Timestamp?: Date | number | null;
  EdgeSummaryStatistics?: EdgeStatistics | null;
  ServiceSummaryStatistics?: ServiceStatistics | null;
  ResponseTimeHistogram?: HistogramEntry[] | null;
}
function toTimeSeriesServiceStatistics(root: jsonP.JSONValue): TimeSeriesServiceStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timestamp": "d",
      "EdgeSummaryStatistics": toEdgeStatistics,
      "ServiceSummaryStatistics": toServiceStatistics,
      "ResponseTimeHistogram": [toHistogramEntry],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TraceSummary {
  Id?: string | null;
  Duration?: number | null;
  ResponseTime?: number | null;
  HasFault?: boolean | null;
  HasError?: boolean | null;
  HasThrottle?: boolean | null;
  IsPartial?: boolean | null;
  Http?: Http | null;
  Annotations?: { [key: string]: ValueWithServiceIds[] | null | undefined } | null;
  Users?: TraceUser[] | null;
  ServiceIds?: ServiceId[] | null;
  ResourceARNs?: ResourceARNDetail[] | null;
  InstanceIds?: InstanceIdDetail[] | null;
  AvailabilityZones?: AvailabilityZoneDetail[] | null;
  EntryPoint?: ServiceId | null;
  FaultRootCauses?: FaultRootCause[] | null;
  ErrorRootCauses?: ErrorRootCause[] | null;
  ResponseTimeRootCauses?: ResponseTimeRootCause[] | null;
  Revision?: number | null;
  MatchedEventTime?: Date | number | null;
}
function toTraceSummary(root: jsonP.JSONValue): TraceSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Duration": "n",
      "ResponseTime": "n",
      "HasFault": "b",
      "HasError": "b",
      "HasThrottle": "b",
      "IsPartial": "b",
      "Http": toHttp,
      "Annotations": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toValueWithServiceIds) : [], x),
      "Users": [toTraceUser],
      "ServiceIds": [toServiceId],
      "ResourceARNs": [toResourceARNDetail],
      "InstanceIds": [toInstanceIdDetail],
      "AvailabilityZones": [toAvailabilityZoneDetail],
      "EntryPoint": toServiceId,
      "FaultRootCauses": [toFaultRootCause],
      "ErrorRootCauses": [toErrorRootCause],
      "ResponseTimeRootCauses": [toResponseTimeRootCause],
      "Revision": "n",
      "MatchedEventTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Http {
  HttpURL?: string | null;
  HttpStatus?: number | null;
  HttpMethod?: string | null;
  UserAgent?: string | null;
  ClientIp?: string | null;
}
function toHttp(root: jsonP.JSONValue): Http {
  return jsonP.readObj({
    required: {},
    optional: {
      "HttpURL": "s",
      "HttpStatus": "n",
      "HttpMethod": "s",
      "UserAgent": "s",
      "ClientIp": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ValueWithServiceIds {
  AnnotationValue?: AnnotationValue | null;
  ServiceIds?: ServiceId[] | null;
}
function toValueWithServiceIds(root: jsonP.JSONValue): ValueWithServiceIds {
  return jsonP.readObj({
    required: {},
    optional: {
      "AnnotationValue": toAnnotationValue,
      "ServiceIds": [toServiceId],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AnnotationValue {
  NumberValue?: number | null;
  BooleanValue?: boolean | null;
  StringValue?: string | null;
}
function toAnnotationValue(root: jsonP.JSONValue): AnnotationValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "NumberValue": "n",
      "BooleanValue": "b",
      "StringValue": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface ServiceId {
  Name?: string | null;
  Names?: string[] | null;
  AccountId?: string | null;
  Type?: string | null;
}
function toServiceId(root: jsonP.JSONValue): ServiceId {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "AccountId": "s",
      "Type": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TraceUser {
  UserName?: string | null;
  ServiceIds?: ServiceId[] | null;
}
function toTraceUser(root: jsonP.JSONValue): TraceUser {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserName": "s",
      "ServiceIds": [toServiceId],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResourceARNDetail {
  ARN?: string | null;
}
function toResourceARNDetail(root: jsonP.JSONValue): ResourceARNDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ARN": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceIdDetail {
  Id?: string | null;
}
function toInstanceIdDetail(root: jsonP.JSONValue): InstanceIdDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AvailabilityZoneDetail {
  Name?: string | null;
}
function toAvailabilityZoneDetail(root: jsonP.JSONValue): AvailabilityZoneDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FaultRootCause {
  Services?: FaultRootCauseService[] | null;
  ClientImpacting?: boolean | null;
}
function toFaultRootCause(root: jsonP.JSONValue): FaultRootCause {
  return jsonP.readObj({
    required: {},
    optional: {
      "Services": [toFaultRootCauseService],
      "ClientImpacting": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FaultRootCauseService {
  Name?: string | null;
  Names?: string[] | null;
  Type?: string | null;
  AccountId?: string | null;
  EntityPath?: FaultRootCauseEntity[] | null;
  Inferred?: boolean | null;
}
function toFaultRootCauseService(root: jsonP.JSONValue): FaultRootCauseService {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "Type": "s",
      "AccountId": "s",
      "EntityPath": [toFaultRootCauseEntity],
      "Inferred": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FaultRootCauseEntity {
  Name?: string | null;
  Exceptions?: RootCauseException[] | null;
  Remote?: boolean | null;
}
function toFaultRootCauseEntity(root: jsonP.JSONValue): FaultRootCauseEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Exceptions": [toRootCauseException],
      "Remote": "b",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface RootCauseException {
  Name?: string | null;
  Message?: string | null;
}
function toRootCauseException(root: jsonP.JSONValue): RootCauseException {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ErrorRootCause {
  Services?: ErrorRootCauseService[] | null;
  ClientImpacting?: boolean | null;
}
function toErrorRootCause(root: jsonP.JSONValue): ErrorRootCause {
  return jsonP.readObj({
    required: {},
    optional: {
      "Services": [toErrorRootCauseService],
      "ClientImpacting": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ErrorRootCauseService {
  Name?: string | null;
  Names?: string[] | null;
  Type?: string | null;
  AccountId?: string | null;
  EntityPath?: ErrorRootCauseEntity[] | null;
  Inferred?: boolean | null;
}
function toErrorRootCauseService(root: jsonP.JSONValue): ErrorRootCauseService {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "Type": "s",
      "AccountId": "s",
      "EntityPath": [toErrorRootCauseEntity],
      "Inferred": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ErrorRootCauseEntity {
  Name?: string | null;
  Exceptions?: RootCauseException[] | null;
  Remote?: boolean | null;
}
function toErrorRootCauseEntity(root: jsonP.JSONValue): ErrorRootCauseEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Exceptions": [toRootCauseException],
      "Remote": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResponseTimeRootCause {
  Services?: ResponseTimeRootCauseService[] | null;
  ClientImpacting?: boolean | null;
}
function toResponseTimeRootCause(root: jsonP.JSONValue): ResponseTimeRootCause {
  return jsonP.readObj({
    required: {},
    optional: {
      "Services": [toResponseTimeRootCauseService],
      "ClientImpacting": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResponseTimeRootCauseService {
  Name?: string | null;
  Names?: string[] | null;
  Type?: string | null;
  AccountId?: string | null;
  EntityPath?: ResponseTimeRootCauseEntity[] | null;
  Inferred?: boolean | null;
}
function toResponseTimeRootCauseService(root: jsonP.JSONValue): ResponseTimeRootCauseService {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "Type": "s",
      "AccountId": "s",
      "EntityPath": [toResponseTimeRootCauseEntity],
      "Inferred": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResponseTimeRootCauseEntity {
  Name?: string | null;
  Coverage?: number | null;
  Remote?: boolean | null;
}
function toResponseTimeRootCauseEntity(root: jsonP.JSONValue): ResponseTimeRootCauseEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Coverage": "n",
      "Remote": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UnprocessedTraceSegment {
  Id?: string | null;
  ErrorCode?: string | null;
  Message?: string | null;
}
function toUnprocessedTraceSegment(root: jsonP.JSONValue): UnprocessedTraceSegment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "ErrorCode": "s",
      "Message": "s",
    },
  }, root);
}
