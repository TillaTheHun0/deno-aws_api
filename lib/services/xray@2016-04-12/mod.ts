// Autogenerated API client for: AWS X-Ray

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class XRay {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(XRay.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-04-12",
    "endpointPrefix": "xray",
    "protocol": "rest-json",
    "serviceFullName": "AWS X-Ray",
    "serviceId": "XRay",
    "signatureVersion": "v4",
    "uid": "xray-2016-04-12"
  };

  async batchGetTraces(
    {abortSignal, ...params}: RequestConfig & s.BatchGetTracesRequest,
  ): Promise<s.BatchGetTracesResult> {
    const body: jsonP.JSONObject = {
      TraceIds: params["TraceIds"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetTraces",
      requestUri: "/Traces",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Traces": [toTrace],
        "UnprocessedTraceIds": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async createGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateGroupRequest,
  ): Promise<s.CreateGroupResult> {
    const body: jsonP.JSONObject = {
      GroupName: params["GroupName"],
      FilterExpression: params["FilterExpression"],
      InsightsConfiguration: fromInsightsConfiguration(params["InsightsConfiguration"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGroup",
      requestUri: "/CreateGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Group": toGroup,
      },
    }, await resp.json());
  }

  async createSamplingRule(
    {abortSignal, ...params}: RequestConfig & s.CreateSamplingRuleRequest,
  ): Promise<s.CreateSamplingRuleResult> {
    const body: jsonP.JSONObject = {
      SamplingRule: fromSamplingRule(params["SamplingRule"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSamplingRule",
      requestUri: "/CreateSamplingRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SamplingRuleRecord": toSamplingRuleRecord,
      },
    }, await resp.json());
  }

  async deleteGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteGroupRequest = {},
  ): Promise<s.DeleteGroupResult> {
    const body: jsonP.JSONObject = {
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGroup",
      requestUri: "/DeleteGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteSamplingRule(
    {abortSignal, ...params}: RequestConfig & s.DeleteSamplingRuleRequest = {},
  ): Promise<s.DeleteSamplingRuleResult> {
    const body: jsonP.JSONObject = {
      RuleName: params["RuleName"],
      RuleARN: params["RuleARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSamplingRule",
      requestUri: "/DeleteSamplingRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SamplingRuleRecord": toSamplingRuleRecord,
      },
    }, await resp.json());
  }

  async getEncryptionConfig(
    {abortSignal, ...params}: RequestConfig & s.GetEncryptionConfigRequest = {},
  ): Promise<s.GetEncryptionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetEncryptionConfig",
      requestUri: "/EncryptionConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EncryptionConfig": toEncryptionConfig,
      },
    }, await resp.json());
  }

  async getGroup(
    {abortSignal, ...params}: RequestConfig & s.GetGroupRequest = {},
  ): Promise<s.GetGroupResult> {
    const body: jsonP.JSONObject = {
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroup",
      requestUri: "/GetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Group": toGroup,
      },
    }, await resp.json());
  }

  async getGroups(
    {abortSignal, ...params}: RequestConfig & s.GetGroupsRequest = {},
  ): Promise<s.GetGroupsResult> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroups",
      requestUri: "/Groups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Groups": [toGroupSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getInsight(
    {abortSignal, ...params}: RequestConfig & s.GetInsightRequest,
  ): Promise<s.GetInsightResult> {
    const body: jsonP.JSONObject = {
      InsightId: params["InsightId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInsight",
      requestUri: "/Insight",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Insight": toInsight,
      },
    }, await resp.json());
  }

  async getInsightEvents(
    {abortSignal, ...params}: RequestConfig & s.GetInsightEventsRequest,
  ): Promise<s.GetInsightEventsResult> {
    const body: jsonP.JSONObject = {
      InsightId: params["InsightId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInsightEvents",
      requestUri: "/InsightEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InsightEvents": [toInsightEvent],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getInsightImpactGraph(
    {abortSignal, ...params}: RequestConfig & s.GetInsightImpactGraphRequest,
  ): Promise<s.GetInsightImpactGraphResult> {
    const body: jsonP.JSONObject = {
      InsightId: params["InsightId"],
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInsightImpactGraph",
      requestUri: "/InsightImpactGraph",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InsightId": "s",
        "StartTime": "d",
        "EndTime": "d",
        "ServiceGraphStartTime": "d",
        "ServiceGraphEndTime": "d",
        "Services": [toInsightImpactGraphService],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getInsightSummaries(
    {abortSignal, ...params}: RequestConfig & s.GetInsightSummariesRequest,
  ): Promise<s.GetInsightSummariesResult> {
    const body: jsonP.JSONObject = {
      States: params["States"],
      GroupARN: params["GroupARN"],
      GroupName: params["GroupName"],
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInsightSummaries",
      requestUri: "/InsightSummaries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InsightSummaries": [toInsightSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getSamplingRules(
    {abortSignal, ...params}: RequestConfig & s.GetSamplingRulesRequest = {},
  ): Promise<s.GetSamplingRulesResult> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSamplingRules",
      requestUri: "/GetSamplingRules",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SamplingRuleRecords": [toSamplingRuleRecord],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getSamplingStatisticSummaries(
    {abortSignal, ...params}: RequestConfig & s.GetSamplingStatisticSummariesRequest = {},
  ): Promise<s.GetSamplingStatisticSummariesResult> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSamplingStatisticSummaries",
      requestUri: "/SamplingStatisticSummaries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SamplingStatisticSummaries": [toSamplingStatisticSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getSamplingTargets(
    {abortSignal, ...params}: RequestConfig & s.GetSamplingTargetsRequest,
  ): Promise<s.GetSamplingTargetsResult> {
    const body: jsonP.JSONObject = {
      SamplingStatisticsDocuments: params["SamplingStatisticsDocuments"]?.map(x => fromSamplingStatisticsDocument(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSamplingTargets",
      requestUri: "/SamplingTargets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SamplingTargetDocuments": [toSamplingTargetDocument],
        "LastRuleModification": "d",
        "UnprocessedStatistics": [toUnprocessedStatistics],
      },
    }, await resp.json());
  }

  async getServiceGraph(
    {abortSignal, ...params}: RequestConfig & s.GetServiceGraphRequest,
  ): Promise<s.GetServiceGraphResult> {
    const body: jsonP.JSONObject = {
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServiceGraph",
      requestUri: "/ServiceGraph",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StartTime": "d",
        "EndTime": "d",
        "Services": [toService],
        "ContainsOldGroupVersions": "b",
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTimeSeriesServiceStatistics(
    {abortSignal, ...params}: RequestConfig & s.GetTimeSeriesServiceStatisticsRequest,
  ): Promise<s.GetTimeSeriesServiceStatisticsResult> {
    const body: jsonP.JSONObject = {
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
      EntitySelectorExpression: params["EntitySelectorExpression"],
      Period: params["Period"],
      ForecastStatistics: params["ForecastStatistics"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTimeSeriesServiceStatistics",
      requestUri: "/TimeSeriesServiceStatistics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TimeSeriesServiceStatistics": [toTimeSeriesServiceStatistics],
        "ContainsOldGroupVersions": "b",
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTraceGraph(
    {abortSignal, ...params}: RequestConfig & s.GetTraceGraphRequest,
  ): Promise<s.GetTraceGraphResult> {
    const body: jsonP.JSONObject = {
      TraceIds: params["TraceIds"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTraceGraph",
      requestUri: "/TraceGraph",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Services": [toService],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTraceSummaries(
    {abortSignal, ...params}: RequestConfig & s.GetTraceSummariesRequest,
  ): Promise<s.GetTraceSummariesResult> {
    const body: jsonP.JSONObject = {
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      TimeRangeType: params["TimeRangeType"],
      Sampling: params["Sampling"],
      SamplingStrategy: fromSamplingStrategy(params["SamplingStrategy"]),
      FilterExpression: params["FilterExpression"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTraceSummaries",
      requestUri: "/TraceSummaries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TraceSummaries": [toTraceSummary],
        "ApproximateTime": "d",
        "TracesProcessedCount": "n",
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
      requestUri: "/ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putEncryptionConfig(
    {abortSignal, ...params}: RequestConfig & s.PutEncryptionConfigRequest,
  ): Promise<s.PutEncryptionConfigResult> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Type: params["Type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutEncryptionConfig",
      requestUri: "/PutEncryptionConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EncryptionConfig": toEncryptionConfig,
      },
    }, await resp.json());
  }

  async putTelemetryRecords(
    {abortSignal, ...params}: RequestConfig & s.PutTelemetryRecordsRequest,
  ): Promise<s.PutTelemetryRecordsResult> {
    const body: jsonP.JSONObject = {
      TelemetryRecords: params["TelemetryRecords"]?.map(x => fromTelemetryRecord(x)),
      EC2InstanceId: params["EC2InstanceId"],
      Hostname: params["Hostname"],
      ResourceARN: params["ResourceARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutTelemetryRecords",
      requestUri: "/TelemetryRecords",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putTraceSegments(
    {abortSignal, ...params}: RequestConfig & s.PutTraceSegmentsRequest,
  ): Promise<s.PutTraceSegmentsResult> {
    const body: jsonP.JSONObject = {
      TraceSegmentDocuments: params["TraceSegmentDocuments"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutTraceSegments",
      requestUri: "/TraceSegments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UnprocessedTraceSegments": [toUnprocessedTraceSegment],
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: "/TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
      requestUri: "/UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateGroupRequest = {},
  ): Promise<s.UpdateGroupResult> {
    const body: jsonP.JSONObject = {
      GroupName: params["GroupName"],
      GroupARN: params["GroupARN"],
      FilterExpression: params["FilterExpression"],
      InsightsConfiguration: fromInsightsConfiguration(params["InsightsConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGroup",
      requestUri: "/UpdateGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Group": toGroup,
      },
    }, await resp.json());
  }

  async updateSamplingRule(
    {abortSignal, ...params}: RequestConfig & s.UpdateSamplingRuleRequest,
  ): Promise<s.UpdateSamplingRuleResult> {
    const body: jsonP.JSONObject = {
      SamplingRuleUpdate: fromSamplingRuleUpdate(params["SamplingRuleUpdate"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSamplingRule",
      requestUri: "/UpdateSamplingRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SamplingRuleRecord": toSamplingRuleRecord,
      },
    }, await resp.json());
  }

}

function fromInsightsConfiguration(input?: s.InsightsConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InsightsEnabled: input["InsightsEnabled"],
    NotificationsEnabled: input["NotificationsEnabled"],
  }
}
function toInsightsConfiguration(root: jsonP.JSONValue): s.InsightsConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "InsightsEnabled": "b",
      "NotificationsEnabled": "b",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromSamplingRule(input?: s.SamplingRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleName: input["RuleName"],
    RuleARN: input["RuleARN"],
    ResourceARN: input["ResourceARN"],
    Priority: input["Priority"],
    FixedRate: input["FixedRate"],
    ReservoirSize: input["ReservoirSize"],
    ServiceName: input["ServiceName"],
    ServiceType: input["ServiceType"],
    Host: input["Host"],
    HTTPMethod: input["HTTPMethod"],
    URLPath: input["URLPath"],
    Version: input["Version"],
    Attributes: input["Attributes"],
  }
}
function toSamplingRule(root: jsonP.JSONValue): s.SamplingRule {
  return jsonP.readObj({
    required: {
      "ResourceARN": "s",
      "Priority": "n",
      "FixedRate": "n",
      "ReservoirSize": "n",
      "ServiceName": "s",
      "ServiceType": "s",
      "Host": "s",
      "HTTPMethod": "s",
      "URLPath": "s",
      "Version": "n",
    },
    optional: {
      "RuleName": "s",
      "RuleARN": "s",
      "Attributes": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromSamplingStatisticsDocument(input?: s.SamplingStatisticsDocument | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleName: input["RuleName"],
    ClientID: input["ClientID"],
    Timestamp: jsonP.serializeDate_unixTimestamp(input["Timestamp"]),
    RequestCount: input["RequestCount"],
    SampledCount: input["SampledCount"],
    BorrowCount: input["BorrowCount"],
  }
}

function fromSamplingStrategy(input?: s.SamplingStrategy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}

function fromTelemetryRecord(input?: s.TelemetryRecord | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Timestamp: jsonP.serializeDate_unixTimestamp(input["Timestamp"]),
    SegmentsReceivedCount: input["SegmentsReceivedCount"],
    SegmentsSentCount: input["SegmentsSentCount"],
    SegmentsSpilloverCount: input["SegmentsSpilloverCount"],
    SegmentsRejectedCount: input["SegmentsRejectedCount"],
    BackendConnectionErrors: fromBackendConnectionErrors(input["BackendConnectionErrors"]),
  }
}

function fromBackendConnectionErrors(input?: s.BackendConnectionErrors | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TimeoutCount: input["TimeoutCount"],
    ConnectionRefusedCount: input["ConnectionRefusedCount"],
    HTTPCode4XXCount: input["HTTPCode4XXCount"],
    HTTPCode5XXCount: input["HTTPCode5XXCount"],
    UnknownHostCount: input["UnknownHostCount"],
    OtherCount: input["OtherCount"],
  }
}

function fromSamplingRuleUpdate(input?: s.SamplingRuleUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleName: input["RuleName"],
    RuleARN: input["RuleARN"],
    ResourceARN: input["ResourceARN"],
    Priority: input["Priority"],
    FixedRate: input["FixedRate"],
    ReservoirSize: input["ReservoirSize"],
    Host: input["Host"],
    ServiceName: input["ServiceName"],
    ServiceType: input["ServiceType"],
    HTTPMethod: input["HTTPMethod"],
    URLPath: input["URLPath"],
    Attributes: input["Attributes"],
  }
}

function toTrace(root: jsonP.JSONValue): s.Trace {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Duration": "n",
      "LimitExceeded": "b",
      "Segments": [toSegment],
    },
  }, root);
}

function toSegment(root: jsonP.JSONValue): s.Segment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Document": "s",
    },
  }, root);
}

function toGroup(root: jsonP.JSONValue): s.Group {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroupName": "s",
      "GroupARN": "s",
      "FilterExpression": "s",
      "InsightsConfiguration": toInsightsConfiguration,
    },
  }, root);
}

function toSamplingRuleRecord(root: jsonP.JSONValue): s.SamplingRuleRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "SamplingRule": toSamplingRule,
      "CreatedAt": "d",
      "ModifiedAt": "d",
    },
  }, root);
}

function toEncryptionConfig(root: jsonP.JSONValue): s.EncryptionConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionStatus>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionType>(x),
    },
  }, root);
}

function toGroupSummary(root: jsonP.JSONValue): s.GroupSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroupName": "s",
      "GroupARN": "s",
      "FilterExpression": "s",
      "InsightsConfiguration": toInsightsConfiguration,
    },
  }, root);
}

function toInsight(root: jsonP.JSONValue): s.Insight {
  return jsonP.readObj({
    required: {},
    optional: {
      "InsightId": "s",
      "GroupARN": "s",
      "GroupName": "s",
      "RootCauseServiceId": toServiceId,
      "Categories": [(x: jsonP.JSONValue) => cmnP.readEnum<s.InsightCategory>(x)],
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InsightState>(x),
      "StartTime": "d",
      "EndTime": "d",
      "Summary": "s",
      "ClientRequestImpactStatistics": toRequestImpactStatistics,
      "RootCauseServiceRequestImpactStatistics": toRequestImpactStatistics,
      "TopAnomalousServices": [toAnomalousService],
    },
  }, root);
}

function toServiceId(root: jsonP.JSONValue): s.ServiceId {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "AccountId": "s",
      "Type": "s",
    },
  }, root);
}

function toRequestImpactStatistics(root: jsonP.JSONValue): s.RequestImpactStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "FaultCount": "n",
      "OkCount": "n",
      "TotalCount": "n",
    },
  }, root);
}

function toAnomalousService(root: jsonP.JSONValue): s.AnomalousService {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServiceId": toServiceId,
    },
  }, root);
}

function toInsightEvent(root: jsonP.JSONValue): s.InsightEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "Summary": "s",
      "EventTime": "d",
      "ClientRequestImpactStatistics": toRequestImpactStatistics,
      "RootCauseServiceRequestImpactStatistics": toRequestImpactStatistics,
      "TopAnomalousServices": [toAnomalousService],
    },
  }, root);
}

function toInsightImpactGraphService(root: jsonP.JSONValue): s.InsightImpactGraphService {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReferenceId": "n",
      "Type": "s",
      "Name": "s",
      "Names": ["s"],
      "AccountId": "s",
      "Edges": [toInsightImpactGraphEdge],
    },
  }, root);
}

function toInsightImpactGraphEdge(root: jsonP.JSONValue): s.InsightImpactGraphEdge {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReferenceId": "n",
    },
  }, root);
}

function toInsightSummary(root: jsonP.JSONValue): s.InsightSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "InsightId": "s",
      "GroupARN": "s",
      "GroupName": "s",
      "RootCauseServiceId": toServiceId,
      "Categories": [(x: jsonP.JSONValue) => cmnP.readEnum<s.InsightCategory>(x)],
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InsightState>(x),
      "StartTime": "d",
      "EndTime": "d",
      "Summary": "s",
      "ClientRequestImpactStatistics": toRequestImpactStatistics,
      "RootCauseServiceRequestImpactStatistics": toRequestImpactStatistics,
      "TopAnomalousServices": [toAnomalousService],
      "LastUpdateTime": "d",
    },
  }, root);
}

function toSamplingStatisticSummary(root: jsonP.JSONValue): s.SamplingStatisticSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleName": "s",
      "Timestamp": "d",
      "RequestCount": "n",
      "BorrowCount": "n",
      "SampledCount": "n",
    },
  }, root);
}

function toSamplingTargetDocument(root: jsonP.JSONValue): s.SamplingTargetDocument {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleName": "s",
      "FixedRate": "n",
      "ReservoirQuota": "n",
      "ReservoirQuotaTTL": "d",
      "Interval": "n",
    },
  }, root);
}

function toUnprocessedStatistics(root: jsonP.JSONValue): s.UnprocessedStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleName": "s",
      "ErrorCode": "s",
      "Message": "s",
    },
  }, root);
}

function toService(root: jsonP.JSONValue): s.Service {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReferenceId": "n",
      "Name": "s",
      "Names": ["s"],
      "Root": "b",
      "AccountId": "s",
      "Type": "s",
      "State": "s",
      "StartTime": "d",
      "EndTime": "d",
      "Edges": [toEdge],
      "SummaryStatistics": toServiceStatistics,
      "DurationHistogram": [toHistogramEntry],
      "ResponseTimeHistogram": [toHistogramEntry],
    },
  }, root);
}

function toEdge(root: jsonP.JSONValue): s.Edge {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReferenceId": "n",
      "StartTime": "d",
      "EndTime": "d",
      "SummaryStatistics": toEdgeStatistics,
      "ResponseTimeHistogram": [toHistogramEntry],
      "Aliases": [toAlias],
    },
  }, root);
}

function toEdgeStatistics(root: jsonP.JSONValue): s.EdgeStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "OkCount": "n",
      "ErrorStatistics": toErrorStatistics,
      "FaultStatistics": toFaultStatistics,
      "TotalCount": "n",
      "TotalResponseTime": "n",
    },
  }, root);
}

function toErrorStatistics(root: jsonP.JSONValue): s.ErrorStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "ThrottleCount": "n",
      "OtherCount": "n",
      "TotalCount": "n",
    },
  }, root);
}

function toFaultStatistics(root: jsonP.JSONValue): s.FaultStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "OtherCount": "n",
      "TotalCount": "n",
    },
  }, root);
}

function toHistogramEntry(root: jsonP.JSONValue): s.HistogramEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "n",
      "Count": "n",
    },
  }, root);
}

function toAlias(root: jsonP.JSONValue): s.Alias {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "Type": "s",
    },
  }, root);
}

function toServiceStatistics(root: jsonP.JSONValue): s.ServiceStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "OkCount": "n",
      "ErrorStatistics": toErrorStatistics,
      "FaultStatistics": toFaultStatistics,
      "TotalCount": "n",
      "TotalResponseTime": "n",
    },
  }, root);
}

function toTimeSeriesServiceStatistics(root: jsonP.JSONValue): s.TimeSeriesServiceStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timestamp": "d",
      "EdgeSummaryStatistics": toEdgeStatistics,
      "ServiceSummaryStatistics": toServiceStatistics,
      "ServiceForecastStatistics": toForecastStatistics,
      "ResponseTimeHistogram": [toHistogramEntry],
    },
  }, root);
}

function toForecastStatistics(root: jsonP.JSONValue): s.ForecastStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "FaultCountHigh": "n",
      "FaultCountLow": "n",
    },
  }, root);
}

function toTraceSummary(root: jsonP.JSONValue): s.TraceSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Duration": "n",
      "ResponseTime": "n",
      "HasFault": "b",
      "HasError": "b",
      "HasThrottle": "b",
      "IsPartial": "b",
      "Http": toHttp,
      "Annotations": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toValueWithServiceIds) : [], x),
      "Users": [toTraceUser],
      "ServiceIds": [toServiceId],
      "ResourceARNs": [toResourceARNDetail],
      "InstanceIds": [toInstanceIdDetail],
      "AvailabilityZones": [toAvailabilityZoneDetail],
      "EntryPoint": toServiceId,
      "FaultRootCauses": [toFaultRootCause],
      "ErrorRootCauses": [toErrorRootCause],
      "ResponseTimeRootCauses": [toResponseTimeRootCause],
      "Revision": "n",
      "MatchedEventTime": "d",
    },
  }, root);
}

function toHttp(root: jsonP.JSONValue): s.Http {
  return jsonP.readObj({
    required: {},
    optional: {
      "HttpURL": "s",
      "HttpStatus": "n",
      "HttpMethod": "s",
      "UserAgent": "s",
      "ClientIp": "s",
    },
  }, root);
}

function toValueWithServiceIds(root: jsonP.JSONValue): s.ValueWithServiceIds {
  return jsonP.readObj({
    required: {},
    optional: {
      "AnnotationValue": toAnnotationValue,
      "ServiceIds": [toServiceId],
    },
  }, root);
}

function toAnnotationValue(root: jsonP.JSONValue): s.AnnotationValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "NumberValue": "n",
      "BooleanValue": "b",
      "StringValue": "s",
    },
  }, root);
}

function toTraceUser(root: jsonP.JSONValue): s.TraceUser {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserName": "s",
      "ServiceIds": [toServiceId],
    },
  }, root);
}

function toResourceARNDetail(root: jsonP.JSONValue): s.ResourceARNDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ARN": "s",
    },
  }, root);
}

function toInstanceIdDetail(root: jsonP.JSONValue): s.InstanceIdDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
    },
  }, root);
}

function toAvailabilityZoneDetail(root: jsonP.JSONValue): s.AvailabilityZoneDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
    },
  }, root);
}

function toFaultRootCause(root: jsonP.JSONValue): s.FaultRootCause {
  return jsonP.readObj({
    required: {},
    optional: {
      "Services": [toFaultRootCauseService],
      "ClientImpacting": "b",
    },
  }, root);
}

function toFaultRootCauseService(root: jsonP.JSONValue): s.FaultRootCauseService {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "Type": "s",
      "AccountId": "s",
      "EntityPath": [toFaultRootCauseEntity],
      "Inferred": "b",
    },
  }, root);
}

function toFaultRootCauseEntity(root: jsonP.JSONValue): s.FaultRootCauseEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Exceptions": [toRootCauseException],
      "Remote": "b",
    },
  }, root);
}

function toRootCauseException(root: jsonP.JSONValue): s.RootCauseException {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Message": "s",
    },
  }, root);
}

function toErrorRootCause(root: jsonP.JSONValue): s.ErrorRootCause {
  return jsonP.readObj({
    required: {},
    optional: {
      "Services": [toErrorRootCauseService],
      "ClientImpacting": "b",
    },
  }, root);
}

function toErrorRootCauseService(root: jsonP.JSONValue): s.ErrorRootCauseService {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "Type": "s",
      "AccountId": "s",
      "EntityPath": [toErrorRootCauseEntity],
      "Inferred": "b",
    },
  }, root);
}

function toErrorRootCauseEntity(root: jsonP.JSONValue): s.ErrorRootCauseEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Exceptions": [toRootCauseException],
      "Remote": "b",
    },
  }, root);
}

function toResponseTimeRootCause(root: jsonP.JSONValue): s.ResponseTimeRootCause {
  return jsonP.readObj({
    required: {},
    optional: {
      "Services": [toResponseTimeRootCauseService],
      "ClientImpacting": "b",
    },
  }, root);
}

function toResponseTimeRootCauseService(root: jsonP.JSONValue): s.ResponseTimeRootCauseService {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Names": ["s"],
      "Type": "s",
      "AccountId": "s",
      "EntityPath": [toResponseTimeRootCauseEntity],
      "Inferred": "b",
    },
  }, root);
}

function toResponseTimeRootCauseEntity(root: jsonP.JSONValue): s.ResponseTimeRootCauseEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Coverage": "n",
      "Remote": "b",
    },
  }, root);
}

function toUnprocessedTraceSegment(root: jsonP.JSONValue): s.UnprocessedTraceSegment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "ErrorCode": "s",
      "Message": "s",
    },
  }, root);
}
