// Autogenerated API client for: Amazon CloudFront

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export default class CloudFront {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudFront.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-03-25",
    "endpointPrefix": "cloudfront",
    "globalEndpoint": "cloudfront.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "CloudFront",
    "serviceFullName": "Amazon CloudFront",
    "serviceId": "CloudFront",
    "signatureVersion": "v4",
    "uid": "cloudfront-2017-03-25"
  };

  async createCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & s.CreateCloudFrontOriginAccessIdentityRequest,
  ): Promise<s.CreateCloudFrontOriginAccessIdentityResult> {
    const inner = params["CloudFrontOriginAccessIdentityConfig"];
    const body = inner ? xmlP.stringify({
      name: "CloudFrontOriginAccessIdentityConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCloudFrontOriginAccessIdentity2017_03_25",
      requestUri: "/2017-03-25/origin-access-identity/cloudfront",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async createDistribution(
    {abortSignal, ...params}: RequestConfig & s.CreateDistributionRequest,
  ): Promise<s.CreateDistributionResult> {
    const inner = params["DistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "DefaultRootObject", content: inner["DefaultRootObject"]?.toString()},
        {name: "Origins", ...Origins_Serialize(inner["Origins"])},
        {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(inner["DefaultCacheBehavior"])},
        {name: "CacheBehaviors", ...CacheBehaviors_Serialize(inner["CacheBehaviors"])},
        {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(inner["CustomErrorResponses"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...LoggingConfig_Serialize(inner["Logging"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
        {name: "ViewerCertificate", ...ViewerCertificate_Serialize(inner["ViewerCertificate"])},
        {name: "Restrictions", ...Restrictions_Serialize(inner["Restrictions"])},
        {name: "WebACLId", content: inner["WebACLId"]?.toString()},
        {name: "HttpVersion", content: inner["HttpVersion"]?.toString()},
        {name: "IsIPV6Enabled", content: inner["IsIPV6Enabled"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistribution2017_03_25",
      requestUri: "/2017-03-25/distribution",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async createDistributionWithTags(
    {abortSignal, ...params}: RequestConfig & s.CreateDistributionWithTagsRequest,
  ): Promise<s.CreateDistributionWithTagsResult> {
    const inner = params["DistributionConfigWithTags"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfigWithTags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "DistributionConfig", ...DistributionConfig_Serialize(inner["DistributionConfig"])},
        {name: "Tags", ...Tags_Serialize(inner["Tags"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistributionWithTags2017_03_25",
      requestUri: "/2017-03-25/distribution?WithTags",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async createInvalidation(
    {abortSignal, ...params}: RequestConfig & s.CreateInvalidationRequest,
  ): Promise<s.CreateInvalidationResult> {
    const inner = params["InvalidationBatch"];
    const body = inner ? xmlP.stringify({
      name: "InvalidationBatch",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "Paths", ...Paths_Serialize(inner["Paths"])},
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInvalidation2017_03_25",
      requestUri: cmnP.encodePath`/2017-03-25/distribution/${params["DistributionId"]}/invalidation`,
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    Invalidation: Invalidation_Parse(xml),
  };
  }

  async createStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & s.CreateStreamingDistributionRequest,
  ): Promise<s.CreateStreamingDistributionResult> {
    const inner = params["StreamingDistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "S3Origin", ...S3Origin_Serialize(inner["S3Origin"])},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...StreamingLoggingConfig_Serialize(inner["Logging"])},
        {name: "TrustedSigners", ...TrustedSigners_Serialize(inner["TrustedSigners"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamingDistribution2017_03_25",
      requestUri: "/2017-03-25/streaming-distribution",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async createStreamingDistributionWithTags(
    {abortSignal, ...params}: RequestConfig & s.CreateStreamingDistributionWithTagsRequest,
  ): Promise<s.CreateStreamingDistributionWithTagsResult> {
    const inner = params["StreamingDistributionConfigWithTags"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfigWithTags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "StreamingDistributionConfig", ...StreamingDistributionConfig_Serialize(inner["StreamingDistributionConfig"])},
        {name: "Tags", ...Tags_Serialize(inner["Tags"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamingDistributionWithTags2017_03_25",
      requestUri: "/2017-03-25/streaming-distribution?WithTags",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async deleteCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & s.DeleteCloudFrontOriginAccessIdentityRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteCloudFrontOriginAccessIdentity2017_03_25",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-03-25/origin-access-identity/cloudfront/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteDistribution(
    {abortSignal, ...params}: RequestConfig & s.DeleteDistributionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteDistribution2017_03_25",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-03-25/distribution/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteServiceLinkedRole(
    {abortSignal, ...params}: RequestConfig & s.DeleteServiceLinkedRoleRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteServiceLinkedRole2017_03_25",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-03-25/service-linked-role/${params["RoleName"]}`,
      responseCode: 204,
    });
  }

  async deleteStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & s.DeleteStreamingDistributionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteStreamingDistribution2017_03_25",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-03-25/streaming-distribution/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async getCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & s.GetCloudFrontOriginAccessIdentityRequest,
  ): Promise<s.GetCloudFrontOriginAccessIdentityResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCloudFrontOriginAccessIdentity2017_03_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-25/origin-access-identity/cloudfront/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async getCloudFrontOriginAccessIdentityConfig(
    {abortSignal, ...params}: RequestConfig & s.GetCloudFrontOriginAccessIdentityConfigRequest,
  ): Promise<s.GetCloudFrontOriginAccessIdentityConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCloudFrontOriginAccessIdentityConfig2017_03_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-25/origin-access-identity/cloudfront/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig_Parse(xml),
  };
  }

  async getDistribution(
    {abortSignal, ...params}: RequestConfig & s.GetDistributionRequest,
  ): Promise<s.GetDistributionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDistribution2017_03_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-25/distribution/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async getDistributionConfig(
    {abortSignal, ...params}: RequestConfig & s.GetDistributionConfigRequest,
  ): Promise<s.GetDistributionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDistributionConfig2017_03_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-25/distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    DistributionConfig: DistributionConfig_Parse(xml),
  };
  }

  async getInvalidation(
    {abortSignal, ...params}: RequestConfig & s.GetInvalidationRequest,
  ): Promise<s.GetInvalidationResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetInvalidation2017_03_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-25/distribution/${params["DistributionId"]}/invalidation/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Invalidation: Invalidation_Parse(xml),
  };
  }

  async getStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & s.GetStreamingDistributionRequest,
  ): Promise<s.GetStreamingDistributionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStreamingDistribution2017_03_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-25/streaming-distribution/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async getStreamingDistributionConfig(
    {abortSignal, ...params}: RequestConfig & s.GetStreamingDistributionConfigRequest,
  ): Promise<s.GetStreamingDistributionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStreamingDistributionConfig2017_03_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-25/streaming-distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistributionConfig: StreamingDistributionConfig_Parse(xml),
  };
  }

  async listCloudFrontOriginAccessIdentities(
    {abortSignal, ...params}: RequestConfig & s.ListCloudFrontOriginAccessIdentitiesRequest = {},
  ): Promise<s.ListCloudFrontOriginAccessIdentitiesResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCloudFrontOriginAccessIdentities2017_03_25",
      method: "GET",
      requestUri: "/2017-03-25/origin-access-identity/cloudfront",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    CloudFrontOriginAccessIdentityList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "CloudFrontOriginAccessIdentitySummary").map(CloudFrontOriginAccessIdentitySummary_Parse),
      },
  };
  }

  async listDistributions(
    {abortSignal, ...params}: RequestConfig & s.ListDistributionsRequest = {},
  ): Promise<s.ListDistributionsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributions2017_03_25",
      method: "GET",
      requestUri: "/2017-03-25/distribution",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listDistributionsByWebACLId(
    {abortSignal, ...params}: RequestConfig & s.ListDistributionsByWebACLIdRequest,
  ): Promise<s.ListDistributionsByWebACLIdResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByWebACLId2017_03_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-25/distributionsByWebACLId/${params["WebACLId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listInvalidations(
    {abortSignal, ...params}: RequestConfig & s.ListInvalidationsRequest,
  ): Promise<s.ListInvalidationsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInvalidations2017_03_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-25/distribution/${params["DistributionId"]}/invalidation`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    InvalidationList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "InvalidationSummary").map(InvalidationSummary_Parse),
      },
  };
  }

  async listStreamingDistributions(
    {abortSignal, ...params}: RequestConfig & s.ListStreamingDistributionsRequest = {},
  ): Promise<s.ListStreamingDistributionsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListStreamingDistributions2017_03_25",
      method: "GET",
      requestUri: "/2017-03-25/streaming-distribution",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    StreamingDistributionList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "StreamingDistributionSummary").map(StreamingDistributionSummary_Parse),
      },
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResult> {
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource2017_03_25",
      method: "GET",
      requestUri: "/2017-03-25/tagging",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Tags: Tags_Parse(xml),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const inner = params["Tags"];
    const body = inner ? xmlP.stringify({
      name: "Tags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "Items", children: inner["Items"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
      ]}) : "";
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TagResource2017_03_25",
      requestUri: "/2017-03-25/tagging?Operation=Tag",
      responseCode: 204,
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const inner = params["TagKeys"];
    const body = inner ? xmlP.stringify({
      name: "TagKeys",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "Items", children: inner["Items"]?.map(x => ({name: "Key", content: x}))},
      ]}) : "";
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UntagResource2017_03_25",
      requestUri: "/2017-03-25/tagging?Operation=Untag",
      responseCode: 204,
    });
  }

  async updateCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & s.UpdateCloudFrontOriginAccessIdentityRequest,
  ): Promise<s.UpdateCloudFrontOriginAccessIdentityResult> {
    const inner = params["CloudFrontOriginAccessIdentityConfig"];
    const body = inner ? xmlP.stringify({
      name: "CloudFrontOriginAccessIdentityConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateCloudFrontOriginAccessIdentity2017_03_25",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-03-25/origin-access-identity/cloudfront/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async updateDistribution(
    {abortSignal, ...params}: RequestConfig & s.UpdateDistributionRequest,
  ): Promise<s.UpdateDistributionResult> {
    const inner = params["DistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "DefaultRootObject", content: inner["DefaultRootObject"]?.toString()},
        {name: "Origins", ...Origins_Serialize(inner["Origins"])},
        {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(inner["DefaultCacheBehavior"])},
        {name: "CacheBehaviors", ...CacheBehaviors_Serialize(inner["CacheBehaviors"])},
        {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(inner["CustomErrorResponses"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...LoggingConfig_Serialize(inner["Logging"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
        {name: "ViewerCertificate", ...ViewerCertificate_Serialize(inner["ViewerCertificate"])},
        {name: "Restrictions", ...Restrictions_Serialize(inner["Restrictions"])},
        {name: "WebACLId", content: inner["WebACLId"]?.toString()},
        {name: "HttpVersion", content: inner["HttpVersion"]?.toString()},
        {name: "IsIPV6Enabled", content: inner["IsIPV6Enabled"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateDistribution2017_03_25",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-03-25/distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async updateStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & s.UpdateStreamingDistributionRequest,
  ): Promise<s.UpdateStreamingDistributionResult> {
    const inner = params["StreamingDistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2017-03-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "S3Origin", ...S3Origin_Serialize(inner["S3Origin"])},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...StreamingLoggingConfig_Serialize(inner["Logging"])},
        {name: "TrustedSigners", ...TrustedSigners_Serialize(inner["TrustedSigners"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateStreamingDistribution2017_03_25",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-03-25/streaming-distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  // Resource State Waiters

  /**
   * Wait until a distribution is deployed.
   * Checks state up to 25 times, 60 seconds apart (about 25 minutes max wait time).
   */
  async waitForDistributionDeployed(
    params: RequestConfig & s.GetDistributionRequest,
  ): Promise<s.GetDistributionResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DistributionDeployed';
    for (let i = 0; i < 25; i++) {
      const resp = await this.getDistribution(params);
      if (resp?.Distribution?.Status === "Deployed") return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an invalidation has completed.
   * Checks state up to 30 times, 20 seconds apart (about 10 minutes max wait time).
   */
  async waitForInvalidationCompleted(
    params: RequestConfig & s.GetInvalidationRequest,
  ): Promise<s.GetInvalidationResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InvalidationCompleted';
    for (let i = 0; i < 30; i++) {
      const resp = await this.getInvalidation(params);
      if (resp?.Invalidation?.Status === "Completed") return resp;
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a streaming distribution is deployed.
   * Checks state up to 25 times, 60 seconds apart (about 25 minutes max wait time).
   */
  async waitForStreamingDistributionDeployed(
    params: RequestConfig & s.GetStreamingDistributionRequest,
  ): Promise<s.GetStreamingDistributionResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StreamingDistributionDeployed';
    for (let i = 0; i < 25; i++) {
      const resp = await this.getStreamingDistribution(params);
      if (resp?.StreamingDistribution?.Status === "Deployed") return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

}

function CloudFrontOriginAccessIdentityConfig_Serialize(data: s.CloudFrontOriginAccessIdentityConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
  ]};
}
function CloudFrontOriginAccessIdentityConfig_Parse(node: xmlP.XmlNode): s.CloudFrontOriginAccessIdentityConfig {
  return node.strings({
    required: {"CallerReference":true,"Comment":true},
  });
}

function DistributionConfig_Serialize(data: s.DistributionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Aliases", ...Aliases_Serialize(data["Aliases"])},
    {name: "DefaultRootObject", content: data["DefaultRootObject"]?.toString()},
    {name: "Origins", ...Origins_Serialize(data["Origins"])},
    {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(data["DefaultCacheBehavior"])},
    {name: "CacheBehaviors", ...CacheBehaviors_Serialize(data["CacheBehaviors"])},
    {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(data["CustomErrorResponses"])},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Logging", ...LoggingConfig_Serialize(data["Logging"])},
    {name: "PriceClass", content: data["PriceClass"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "ViewerCertificate", ...ViewerCertificate_Serialize(data["ViewerCertificate"])},
    {name: "Restrictions", ...Restrictions_Serialize(data["Restrictions"])},
    {name: "WebACLId", content: data["WebACLId"]?.toString()},
    {name: "HttpVersion", content: data["HttpVersion"]?.toString()},
    {name: "IsIPV6Enabled", content: data["IsIPV6Enabled"]?.toString()},
  ]};
}
function DistributionConfig_Parse(node: xmlP.XmlNode): s.DistributionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true,"Comment":true},
      optional: {"DefaultRootObject":true,"WebACLId":true},
    }),
    Aliases: node.first("Aliases", false, Aliases_Parse),
    Origins: node.first("Origins", true, Origins_Parse),
    DefaultCacheBehavior: node.first("DefaultCacheBehavior", true, DefaultCacheBehavior_Parse),
    CacheBehaviors: node.first("CacheBehaviors", false, CacheBehaviors_Parse),
    CustomErrorResponses: node.first("CustomErrorResponses", false, CustomErrorResponses_Parse),
    Logging: node.first("Logging", false, LoggingConfig_Parse),
    PriceClass: node.first("PriceClass", false, x => (x.content ?? '') as s.PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ViewerCertificate: node.first("ViewerCertificate", false, ViewerCertificate_Parse),
    Restrictions: node.first("Restrictions", false, Restrictions_Parse),
    HttpVersion: node.first("HttpVersion", false, x => (x.content ?? '') as s.HttpVersion),
    IsIPV6Enabled: node.first("IsIPV6Enabled", false, x => x.content === 'true'),
  };
}

function Aliases_Serialize(data: s.Aliases | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CNAME", content: x}))},
  ]};
}
function Aliases_Parse(node: xmlP.XmlNode): s.Aliases {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CNAME").map(x => x.content ?? ''),
  };
}

function Origins_Serialize(data: s.Origins | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Origin", ...Origin_Serialize(x)}))},
  ]};
}
function Origins_Parse(node: xmlP.XmlNode): s.Origins {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Origin").map(Origin_Parse),
  };
}

function Origin_Serialize(data: s.Origin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "DomainName", content: data["DomainName"]?.toString()},
    {name: "OriginPath", content: data["OriginPath"]?.toString()},
    {name: "CustomHeaders", ...CustomHeaders_Serialize(data["CustomHeaders"])},
    {name: "S3OriginConfig", ...S3OriginConfig_Serialize(data["S3OriginConfig"])},
    {name: "CustomOriginConfig", ...CustomOriginConfig_Serialize(data["CustomOriginConfig"])},
  ]};
}
function Origin_Parse(node: xmlP.XmlNode): s.Origin {
  return {
    ...node.strings({
      required: {"Id":true,"DomainName":true},
      optional: {"OriginPath":true},
    }),
    CustomHeaders: node.first("CustomHeaders", false, CustomHeaders_Parse),
    S3OriginConfig: node.first("S3OriginConfig", false, S3OriginConfig_Parse),
    CustomOriginConfig: node.first("CustomOriginConfig", false, CustomOriginConfig_Parse),
  };
}

function CustomHeaders_Serialize(data: s.CustomHeaders | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "OriginCustomHeader", ...OriginCustomHeader_Serialize(x)}))},
  ]};
}
function CustomHeaders_Parse(node: xmlP.XmlNode): s.CustomHeaders {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginCustomHeader").map(OriginCustomHeader_Parse),
  };
}

function OriginCustomHeader_Serialize(data: s.OriginCustomHeader | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HeaderName", content: data["HeaderName"]?.toString()},
    {name: "HeaderValue", content: data["HeaderValue"]?.toString()},
  ]};
}
function OriginCustomHeader_Parse(node: xmlP.XmlNode): s.OriginCustomHeader {
  return node.strings({
    required: {"HeaderName":true,"HeaderValue":true},
  });
}

function S3OriginConfig_Serialize(data: s.S3OriginConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "OriginAccessIdentity", content: data["OriginAccessIdentity"]?.toString()},
  ]};
}
function S3OriginConfig_Parse(node: xmlP.XmlNode): s.S3OriginConfig {
  return node.strings({
    required: {"OriginAccessIdentity":true},
  });
}

function CustomOriginConfig_Serialize(data: s.CustomOriginConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HTTPPort", content: data["HTTPPort"]?.toString()},
    {name: "HTTPSPort", content: data["HTTPSPort"]?.toString()},
    {name: "OriginProtocolPolicy", content: data["OriginProtocolPolicy"]?.toString()},
    {name: "OriginSslProtocols", ...OriginSslProtocols_Serialize(data["OriginSslProtocols"])},
    {name: "OriginReadTimeout", content: data["OriginReadTimeout"]?.toString()},
    {name: "OriginKeepaliveTimeout", content: data["OriginKeepaliveTimeout"]?.toString()},
  ]};
}
function CustomOriginConfig_Parse(node: xmlP.XmlNode): s.CustomOriginConfig {
  return {
    HTTPPort: node.first("HTTPPort", true, x => parseInt(x.content ?? '0')),
    HTTPSPort: node.first("HTTPSPort", true, x => parseInt(x.content ?? '0')),
    OriginProtocolPolicy: node.first("OriginProtocolPolicy", true, x => (x.content ?? '') as s.OriginProtocolPolicy),
    OriginSslProtocols: node.first("OriginSslProtocols", false, OriginSslProtocols_Parse),
    OriginReadTimeout: node.first("OriginReadTimeout", false, x => parseInt(x.content ?? '0')),
    OriginKeepaliveTimeout: node.first("OriginKeepaliveTimeout", false, x => parseInt(x.content ?? '0')),
  };
}

function OriginSslProtocols_Serialize(data: s.OriginSslProtocols | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "SslProtocol", content: x}))},
  ]};
}
function OriginSslProtocols_Parse(node: xmlP.XmlNode): s.OriginSslProtocols {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "SslProtocol").map(x => (x.content ?? '') as s.SslProtocol),
  };
}

function DefaultCacheBehavior_Serialize(data: s.DefaultCacheBehavior | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TargetOriginId", content: data["TargetOriginId"]?.toString()},
    {name: "ForwardedValues", ...ForwardedValues_Serialize(data["ForwardedValues"])},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "ViewerProtocolPolicy", content: data["ViewerProtocolPolicy"]?.toString()},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "AllowedMethods", ...AllowedMethods_Serialize(data["AllowedMethods"])},
    {name: "SmoothStreaming", content: data["SmoothStreaming"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
    {name: "Compress", content: data["Compress"]?.toString()},
    {name: "LambdaFunctionAssociations", ...LambdaFunctionAssociations_Serialize(data["LambdaFunctionAssociations"])},
  ]};
}
function DefaultCacheBehavior_Parse(node: xmlP.XmlNode): s.DefaultCacheBehavior {
  return {
    ...node.strings({
      required: {"TargetOriginId":true},
    }),
    ForwardedValues: node.first("ForwardedValues", true, ForwardedValues_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    ViewerProtocolPolicy: node.first("ViewerProtocolPolicy", true, x => (x.content ?? '') as s.ViewerProtocolPolicy),
    MinTTL: node.first("MinTTL", true, x => parseInt(x.content ?? '0')),
    AllowedMethods: node.first("AllowedMethods", false, AllowedMethods_Parse),
    SmoothStreaming: node.first("SmoothStreaming", false, x => x.content === 'true'),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
    Compress: node.first("Compress", false, x => x.content === 'true'),
    LambdaFunctionAssociations: node.first("LambdaFunctionAssociations", false, LambdaFunctionAssociations_Parse),
  };
}

function ForwardedValues_Serialize(data: s.ForwardedValues | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryString", content: data["QueryString"]?.toString()},
    {name: "Cookies", ...CookiePreference_Serialize(data["Cookies"])},
    {name: "Headers", ...Headers_Serialize(data["Headers"])},
    {name: "QueryStringCacheKeys", ...QueryStringCacheKeys_Serialize(data["QueryStringCacheKeys"])},
  ]};
}
function ForwardedValues_Parse(node: xmlP.XmlNode): s.ForwardedValues {
  return {
    QueryString: node.first("QueryString", true, x => x.content === 'true'),
    Cookies: node.first("Cookies", true, CookiePreference_Parse),
    Headers: node.first("Headers", false, Headers_Parse),
    QueryStringCacheKeys: node.first("QueryStringCacheKeys", false, QueryStringCacheKeys_Parse),
  };
}

function CookiePreference_Serialize(data: s.CookiePreference | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Forward", content: data["Forward"]?.toString()},
    {name: "WhitelistedNames", ...CookieNames_Serialize(data["WhitelistedNames"])},
  ]};
}
function CookiePreference_Parse(node: xmlP.XmlNode): s.CookiePreference {
  return {
    Forward: node.first("Forward", true, x => (x.content ?? '') as s.ItemSelection),
    WhitelistedNames: node.first("WhitelistedNames", false, CookieNames_Parse),
  };
}

function CookieNames_Serialize(data: s.CookieNames | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function CookieNames_Parse(node: xmlP.XmlNode): s.CookieNames {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

function Headers_Serialize(data: s.Headers | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function Headers_Parse(node: xmlP.XmlNode): s.Headers {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

function QueryStringCacheKeys_Serialize(data: s.QueryStringCacheKeys | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function QueryStringCacheKeys_Parse(node: xmlP.XmlNode): s.QueryStringCacheKeys {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

function TrustedSigners_Serialize(data: s.TrustedSigners | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "AwsAccountNumber", content: x}))},
  ]};
}
function TrustedSigners_Parse(node: xmlP.XmlNode): s.TrustedSigners {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "AwsAccountNumber").map(x => x.content ?? ''),
  };
}

function AllowedMethods_Serialize(data: s.AllowedMethods | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Method", content: x}))},
    {name: "CachedMethods", ...CachedMethods_Serialize(data["CachedMethods"])},
  ]};
}
function AllowedMethods_Parse(node: xmlP.XmlNode): s.AllowedMethods {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Method").map(x => (x.content ?? '') as s.Method),
    CachedMethods: node.first("CachedMethods", false, CachedMethods_Parse),
  };
}

function CachedMethods_Serialize(data: s.CachedMethods | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Method", content: x}))},
  ]};
}
function CachedMethods_Parse(node: xmlP.XmlNode): s.CachedMethods {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Method").map(x => (x.content ?? '') as s.Method),
  };
}

function LambdaFunctionAssociations_Serialize(data: s.LambdaFunctionAssociations | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "LambdaFunctionAssociation", ...LambdaFunctionAssociation_Serialize(x)}))},
  ]};
}
function LambdaFunctionAssociations_Parse(node: xmlP.XmlNode): s.LambdaFunctionAssociations {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "LambdaFunctionAssociation").map(LambdaFunctionAssociation_Parse),
  };
}

function LambdaFunctionAssociation_Serialize(data: s.LambdaFunctionAssociation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LambdaFunctionARN", content: data["LambdaFunctionARN"]?.toString()},
    {name: "EventType", content: data["EventType"]?.toString()},
  ]};
}
function LambdaFunctionAssociation_Parse(node: xmlP.XmlNode): s.LambdaFunctionAssociation {
  return {
    ...node.strings({
      optional: {"LambdaFunctionARN":true},
    }),
    EventType: node.first("EventType", false, x => (x.content ?? '') as s.EventType),
  };
}

function CacheBehaviors_Serialize(data: s.CacheBehaviors | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CacheBehavior", ...CacheBehavior_Serialize(x)}))},
  ]};
}
function CacheBehaviors_Parse(node: xmlP.XmlNode): s.CacheBehaviors {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CacheBehavior").map(CacheBehavior_Parse),
  };
}

function CacheBehavior_Serialize(data: s.CacheBehavior | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "PathPattern", content: data["PathPattern"]?.toString()},
    {name: "TargetOriginId", content: data["TargetOriginId"]?.toString()},
    {name: "ForwardedValues", ...ForwardedValues_Serialize(data["ForwardedValues"])},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "ViewerProtocolPolicy", content: data["ViewerProtocolPolicy"]?.toString()},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "AllowedMethods", ...AllowedMethods_Serialize(data["AllowedMethods"])},
    {name: "SmoothStreaming", content: data["SmoothStreaming"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
    {name: "Compress", content: data["Compress"]?.toString()},
    {name: "LambdaFunctionAssociations", ...LambdaFunctionAssociations_Serialize(data["LambdaFunctionAssociations"])},
  ]};
}
function CacheBehavior_Parse(node: xmlP.XmlNode): s.CacheBehavior {
  return {
    ...node.strings({
      required: {"PathPattern":true,"TargetOriginId":true},
    }),
    ForwardedValues: node.first("ForwardedValues", true, ForwardedValues_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    ViewerProtocolPolicy: node.first("ViewerProtocolPolicy", true, x => (x.content ?? '') as s.ViewerProtocolPolicy),
    MinTTL: node.first("MinTTL", true, x => parseInt(x.content ?? '0')),
    AllowedMethods: node.first("AllowedMethods", false, AllowedMethods_Parse),
    SmoothStreaming: node.first("SmoothStreaming", false, x => x.content === 'true'),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
    Compress: node.first("Compress", false, x => x.content === 'true'),
    LambdaFunctionAssociations: node.first("LambdaFunctionAssociations", false, LambdaFunctionAssociations_Parse),
  };
}

function CustomErrorResponses_Serialize(data: s.CustomErrorResponses | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CustomErrorResponse", ...CustomErrorResponse_Serialize(x)}))},
  ]};
}
function CustomErrorResponses_Parse(node: xmlP.XmlNode): s.CustomErrorResponses {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CustomErrorResponse").map(CustomErrorResponse_Parse),
  };
}

function CustomErrorResponse_Serialize(data: s.CustomErrorResponse | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ErrorCode", content: data["ErrorCode"]?.toString()},
    {name: "ResponsePagePath", content: data["ResponsePagePath"]?.toString()},
    {name: "ResponseCode", content: data["ResponseCode"]?.toString()},
    {name: "ErrorCachingMinTTL", content: data["ErrorCachingMinTTL"]?.toString()},
  ]};
}
function CustomErrorResponse_Parse(node: xmlP.XmlNode): s.CustomErrorResponse {
  return {
    ...node.strings({
      optional: {"ResponsePagePath":true,"ResponseCode":true},
    }),
    ErrorCode: node.first("ErrorCode", true, x => parseInt(x.content ?? '0')),
    ErrorCachingMinTTL: node.first("ErrorCachingMinTTL", false, x => parseInt(x.content ?? '0')),
  };
}

function LoggingConfig_Serialize(data: s.LoggingConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "IncludeCookies", content: data["IncludeCookies"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function LoggingConfig_Parse(node: xmlP.XmlNode): s.LoggingConfig {
  return {
    ...node.strings({
      required: {"Bucket":true,"Prefix":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    IncludeCookies: node.first("IncludeCookies", true, x => x.content === 'true'),
  };
}

function ViewerCertificate_Serialize(data: s.ViewerCertificate | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CloudFrontDefaultCertificate", content: data["CloudFrontDefaultCertificate"]?.toString()},
    {name: "IAMCertificateId", content: data["IAMCertificateId"]?.toString()},
    {name: "ACMCertificateArn", content: data["ACMCertificateArn"]?.toString()},
    {name: "SSLSupportMethod", content: data["SSLSupportMethod"]?.toString()},
    {name: "MinimumProtocolVersion", content: data["MinimumProtocolVersion"]?.toString()},
    {name: "Certificate", content: data["Certificate"]?.toString()},
    {name: "CertificateSource", content: data["CertificateSource"]?.toString()},
  ]};
}
function ViewerCertificate_Parse(node: xmlP.XmlNode): s.ViewerCertificate {
  return {
    ...node.strings({
      optional: {"IAMCertificateId":true,"ACMCertificateArn":true,"Certificate":true},
    }),
    CloudFrontDefaultCertificate: node.first("CloudFrontDefaultCertificate", false, x => x.content === 'true'),
    SSLSupportMethod: node.first("SSLSupportMethod", false, x => (x.content ?? '') as s.SSLSupportMethod),
    MinimumProtocolVersion: node.first("MinimumProtocolVersion", false, x => (x.content ?? '') as s.MinimumProtocolVersion),
    CertificateSource: node.first("CertificateSource", false, x => (x.content ?? '') as s.CertificateSource),
  };
}

function Restrictions_Serialize(data: s.Restrictions | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "GeoRestriction", ...GeoRestriction_Serialize(data["GeoRestriction"])},
  ]};
}
function Restrictions_Parse(node: xmlP.XmlNode): s.Restrictions {
  return {
    GeoRestriction: node.first("GeoRestriction", true, GeoRestriction_Parse),
  };
}

function GeoRestriction_Serialize(data: s.GeoRestriction | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RestrictionType", content: data["RestrictionType"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Location", content: x}))},
  ]};
}
function GeoRestriction_Parse(node: xmlP.XmlNode): s.GeoRestriction {
  return {
    RestrictionType: node.first("RestrictionType", true, x => (x.content ?? '') as s.GeoRestrictionType),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Location").map(x => x.content ?? ''),
  };
}

function DistributionConfigWithTags_Serialize(data: s.DistributionConfigWithTags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DistributionConfig", ...DistributionConfig_Serialize(data["DistributionConfig"])},
    {name: "Tags", ...Tags_Serialize(data["Tags"])},
  ]};
}

function Tags_Serialize(data: s.Tags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Items", children: data["Items"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
  ]};
}
function Tags_Parse(node: xmlP.XmlNode): s.Tags {
  return {
    Items: node.getList("Items", "Tag").map(Tag_Parse),
  };
}

function Tag_Serialize(data: s.Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    required: {"Key":true},
    optional: {"Value":true},
  });
}

function InvalidationBatch_Serialize(data: s.InvalidationBatch | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Paths", ...Paths_Serialize(data["Paths"])},
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
  ]};
}
function InvalidationBatch_Parse(node: xmlP.XmlNode): s.InvalidationBatch {
  return {
    ...node.strings({
      required: {"CallerReference":true},
    }),
    Paths: node.first("Paths", true, Paths_Parse),
  };
}

function Paths_Serialize(data: s.Paths | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Path", content: x}))},
  ]};
}
function Paths_Parse(node: xmlP.XmlNode): s.Paths {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Path").map(x => x.content ?? ''),
  };
}

function StreamingDistributionConfig_Serialize(data: s.StreamingDistributionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "S3Origin", ...S3Origin_Serialize(data["S3Origin"])},
    {name: "Aliases", ...Aliases_Serialize(data["Aliases"])},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Logging", ...StreamingLoggingConfig_Serialize(data["Logging"])},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "PriceClass", content: data["PriceClass"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
  ]};
}
function StreamingDistributionConfig_Parse(node: xmlP.XmlNode): s.StreamingDistributionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true,"Comment":true},
    }),
    S3Origin: node.first("S3Origin", true, S3Origin_Parse),
    Aliases: node.first("Aliases", false, Aliases_Parse),
    Logging: node.first("Logging", false, StreamingLoggingConfig_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    PriceClass: node.first("PriceClass", false, x => (x.content ?? '') as s.PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

function S3Origin_Serialize(data: s.S3Origin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DomainName", content: data["DomainName"]?.toString()},
    {name: "OriginAccessIdentity", content: data["OriginAccessIdentity"]?.toString()},
  ]};
}
function S3Origin_Parse(node: xmlP.XmlNode): s.S3Origin {
  return node.strings({
    required: {"DomainName":true,"OriginAccessIdentity":true},
  });
}

function StreamingLoggingConfig_Serialize(data: s.StreamingLoggingConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function StreamingLoggingConfig_Parse(node: xmlP.XmlNode): s.StreamingLoggingConfig {
  return {
    ...node.strings({
      required: {"Bucket":true,"Prefix":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

function StreamingDistributionConfigWithTags_Serialize(data: s.StreamingDistributionConfigWithTags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StreamingDistributionConfig", ...StreamingDistributionConfig_Serialize(data["StreamingDistributionConfig"])},
    {name: "Tags", ...Tags_Serialize(data["Tags"])},
  ]};
}

function TagKeys_Serialize(data: s.TagKeys | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Items", children: data["Items"]?.map(x => ({name: "Key", content: x}))},
  ]};
}

function CloudFrontOriginAccessIdentity_Parse(node: xmlP.XmlNode): s.CloudFrontOriginAccessIdentity {
  return {
    ...node.strings({
      required: {"Id":true,"S3CanonicalUserId":true},
    }),
    CloudFrontOriginAccessIdentityConfig: node.first("CloudFrontOriginAccessIdentityConfig", false, CloudFrontOriginAccessIdentityConfig_Parse),
  };
}

function Distribution_Parse(node: xmlP.XmlNode): s.Distribution {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    InProgressInvalidationBatches: node.first("InProgressInvalidationBatches", true, x => parseInt(x.content ?? '0')),
    ActiveTrustedSigners: node.first("ActiveTrustedSigners", true, ActiveTrustedSigners_Parse),
    DistributionConfig: node.first("DistributionConfig", true, DistributionConfig_Parse),
  };
}

function ActiveTrustedSigners_Parse(node: xmlP.XmlNode): s.ActiveTrustedSigners {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Signer").map(Signer_Parse),
  };
}

function Signer_Parse(node: xmlP.XmlNode): s.Signer {
  return {
    ...node.strings({
      optional: {"AwsAccountNumber":true},
    }),
    KeyPairIds: node.first("KeyPairIds", false, KeyPairIds_Parse),
  };
}

function KeyPairIds_Parse(node: xmlP.XmlNode): s.KeyPairIds {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyPairId").map(x => x.content ?? ''),
  };
}

function Invalidation_Parse(node: xmlP.XmlNode): s.Invalidation {
  return {
    ...node.strings({
      required: {"Id":true,"Status":true},
    }),
    CreateTime: node.first("CreateTime", true, x => xmlP.parseTimestamp(x.content)),
    InvalidationBatch: node.first("InvalidationBatch", true, InvalidationBatch_Parse),
  };
}

function StreamingDistribution_Parse(node: xmlP.XmlNode): s.StreamingDistribution {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", false, x => xmlP.parseTimestamp(x.content)),
    ActiveTrustedSigners: node.first("ActiveTrustedSigners", true, ActiveTrustedSigners_Parse),
    StreamingDistributionConfig: node.first("StreamingDistributionConfig", true, StreamingDistributionConfig_Parse),
  };
}

function CloudFrontOriginAccessIdentityList_Parse(node: xmlP.XmlNode): s.CloudFrontOriginAccessIdentityList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CloudFrontOriginAccessIdentitySummary").map(CloudFrontOriginAccessIdentitySummary_Parse),
  };
}

function CloudFrontOriginAccessIdentitySummary_Parse(node: xmlP.XmlNode): s.CloudFrontOriginAccessIdentitySummary {
  return node.strings({
    required: {"Id":true,"S3CanonicalUserId":true,"Comment":true},
  });
}

function DistributionList_Parse(node: xmlP.XmlNode): s.DistributionList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "DistributionSummary").map(DistributionSummary_Parse),
  };
}

function DistributionSummary_Parse(node: xmlP.XmlNode): s.DistributionSummary {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true,"Comment":true,"WebACLId":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    Aliases: node.first("Aliases", true, Aliases_Parse),
    Origins: node.first("Origins", true, Origins_Parse),
    DefaultCacheBehavior: node.first("DefaultCacheBehavior", true, DefaultCacheBehavior_Parse),
    CacheBehaviors: node.first("CacheBehaviors", true, CacheBehaviors_Parse),
    CustomErrorResponses: node.first("CustomErrorResponses", true, CustomErrorResponses_Parse),
    PriceClass: node.first("PriceClass", true, x => (x.content ?? '') as s.PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ViewerCertificate: node.first("ViewerCertificate", true, ViewerCertificate_Parse),
    Restrictions: node.first("Restrictions", true, Restrictions_Parse),
    HttpVersion: node.first("HttpVersion", true, x => (x.content ?? '') as s.HttpVersion),
    IsIPV6Enabled: node.first("IsIPV6Enabled", true, x => x.content === 'true'),
  };
}

function InvalidationList_Parse(node: xmlP.XmlNode): s.InvalidationList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "InvalidationSummary").map(InvalidationSummary_Parse),
  };
}

function InvalidationSummary_Parse(node: xmlP.XmlNode): s.InvalidationSummary {
  return {
    ...node.strings({
      required: {"Id":true,"Status":true},
    }),
    CreateTime: node.first("CreateTime", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function StreamingDistributionList_Parse(node: xmlP.XmlNode): s.StreamingDistributionList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "StreamingDistributionSummary").map(StreamingDistributionSummary_Parse),
  };
}

function StreamingDistributionSummary_Parse(node: xmlP.XmlNode): s.StreamingDistributionSummary {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true,"Comment":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    S3Origin: node.first("S3Origin", true, S3Origin_Parse),
    Aliases: node.first("Aliases", true, Aliases_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    PriceClass: node.first("PriceClass", true, x => (x.content ?? '') as s.PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}
