// Autogenerated API client for: AWS IoT Analytics

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class IoTAnalytics {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(IoTAnalytics.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-11-27",
    "endpointPrefix": "iotanalytics",
    "protocol": "rest-json",
    "serviceFullName": "AWS IoT Analytics",
    "serviceId": "IoTAnalytics",
    "signatureVersion": "v4",
    "signingName": "iotanalytics",
    "uid": "iotanalytics-2017-11-27"
  };

  async batchPutMessage(
    {abortSignal, ...params}: RequestConfig & BatchPutMessageRequest,
  ): Promise<BatchPutMessageResponse> {
    const body: jsonP.JSONObject = {
      channelName: params["channelName"],
      messages: params["messages"]?.map(x => fromMessage(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchPutMessage",
      requestUri: "/messages/batch",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "batchPutMessageErrorEntries": [toBatchPutMessageErrorEntry],
      },
    }, await resp.json());
  }

  async cancelPipelineReprocessing(
    {abortSignal, ...params}: RequestConfig & CancelPipelineReprocessingRequest,
  ): Promise<CancelPipelineReprocessingResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelPipelineReprocessing",
      method: "DELETE",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}/reprocessing/${params["reprocessingId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createChannel(
    {abortSignal, ...params}: RequestConfig & CreateChannelRequest,
  ): Promise<CreateChannelResponse> {
    const body: jsonP.JSONObject = {
      channelName: params["channelName"],
      channelStorage: fromChannelStorage(params["channelStorage"]),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChannel",
      requestUri: "/channels",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channelName": "s",
        "channelArn": "s",
        "retentionPeriod": toRetentionPeriod,
      },
    }, await resp.json());
  }

  async createDataset(
    {abortSignal, ...params}: RequestConfig & CreateDatasetRequest,
  ): Promise<CreateDatasetResponse> {
    const body: jsonP.JSONObject = {
      datasetName: params["datasetName"],
      actions: params["actions"]?.map(x => fromDatasetAction(x)),
      triggers: params["triggers"]?.map(x => fromDatasetTrigger(x)),
      contentDeliveryRules: params["contentDeliveryRules"]?.map(x => fromDatasetContentDeliveryRule(x)),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      versioningConfiguration: fromVersioningConfiguration(params["versioningConfiguration"]),
      tags: params["tags"]?.map(x => fromTag(x)),
      lateDataRules: params["lateDataRules"]?.map(x => fromLateDataRule(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataset",
      requestUri: "/datasets",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetName": "s",
        "datasetArn": "s",
        "retentionPeriod": toRetentionPeriod,
      },
    }, await resp.json());
  }

  async createDatasetContent(
    {abortSignal, ...params}: RequestConfig & CreateDatasetContentRequest,
  ): Promise<CreateDatasetContentResponse> {
    const body: jsonP.JSONObject = {
      versionId: params["versionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetContent",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}/content`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "versionId": "s",
      },
    }, await resp.json());
  }

  async createDatastore(
    {abortSignal, ...params}: RequestConfig & CreateDatastoreRequest,
  ): Promise<CreateDatastoreResponse> {
    const body: jsonP.JSONObject = {
      datastoreName: params["datastoreName"],
      datastoreStorage: fromDatastoreStorage(params["datastoreStorage"]),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      tags: params["tags"]?.map(x => fromTag(x)),
      fileFormatConfiguration: fromFileFormatConfiguration(params["fileFormatConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatastore",
      requestUri: "/datastores",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datastoreName": "s",
        "datastoreArn": "s",
        "retentionPeriod": toRetentionPeriod,
      },
    }, await resp.json());
  }

  async createPipeline(
    {abortSignal, ...params}: RequestConfig & CreatePipelineRequest,
  ): Promise<CreatePipelineResponse> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      pipelineActivities: params["pipelineActivities"]?.map(x => fromPipelineActivity(x)),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePipeline",
      requestUri: "/pipelines",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineName": "s",
        "pipelineArn": "s",
      },
    }, await resp.json());
  }

  async deleteChannel(
    {abortSignal, ...params}: RequestConfig & DeleteChannelRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/channels/${params["channelName"]}`,
      responseCode: 204,
    });
  }

  async deleteDataset(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDataset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}`,
      responseCode: 204,
    });
  }

  async deleteDatasetContent(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetContentRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["versionId"] != null) query.set("versionId", params["versionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteDatasetContent",
      method: "DELETE",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}/content`,
      responseCode: 204,
    });
  }

  async deleteDatastore(
    {abortSignal, ...params}: RequestConfig & DeleteDatastoreRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDatastore",
      method: "DELETE",
      requestUri: cmnP.encodePath`/datastores/${params["datastoreName"]}`,
      responseCode: 204,
    });
  }

  async deletePipeline(
    {abortSignal, ...params}: RequestConfig & DeletePipelineRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePipeline",
      method: "DELETE",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}`,
      responseCode: 204,
    });
  }

  async describeChannel(
    {abortSignal, ...params}: RequestConfig & DescribeChannelRequest,
  ): Promise<DescribeChannelResponse> {
    const query = new URLSearchParams;
    if (params["includeStatistics"] != null) query.set("includeStatistics", params["includeStatistics"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/channels/${params["channelName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channel": toChannel,
        "statistics": toChannelStatistics,
      },
    }, await resp.json());
  }

  async describeDataset(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetRequest,
  ): Promise<DescribeDatasetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDataset",
      method: "GET",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "dataset": toDataset,
      },
    }, await resp.json());
  }

  async describeDatastore(
    {abortSignal, ...params}: RequestConfig & DescribeDatastoreRequest,
  ): Promise<DescribeDatastoreResponse> {
    const query = new URLSearchParams;
    if (params["includeStatistics"] != null) query.set("includeStatistics", params["includeStatistics"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeDatastore",
      method: "GET",
      requestUri: cmnP.encodePath`/datastores/${params["datastoreName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datastore": toDatastore,
        "statistics": toDatastoreStatistics,
      },
    }, await resp.json());
  }

  async describeLoggingOptions(
    {abortSignal, ...params}: RequestConfig & DescribeLoggingOptionsRequest = {},
  ): Promise<DescribeLoggingOptionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeLoggingOptions",
      method: "GET",
      requestUri: "/logging",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "loggingOptions": toLoggingOptions,
      },
    }, await resp.json());
  }

  async describePipeline(
    {abortSignal, ...params}: RequestConfig & DescribePipelineRequest,
  ): Promise<DescribePipelineResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribePipeline",
      method: "GET",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipeline": toPipeline,
      },
    }, await resp.json());
  }

  async getDatasetContent(
    {abortSignal, ...params}: RequestConfig & GetDatasetContentRequest,
  ): Promise<GetDatasetContentResponse> {
    const query = new URLSearchParams;
    if (params["versionId"] != null) query.set("versionId", params["versionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDatasetContent",
      method: "GET",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}/content`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "entries": [toDatasetEntry],
        "timestamp": "d",
        "status": toDatasetContentStatus,
      },
    }, await resp.json());
  }

  async listChannels(
    {abortSignal, ...params}: RequestConfig & ListChannelsRequest = {},
  ): Promise<ListChannelsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListChannels",
      method: "GET",
      requestUri: "/channels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channelSummaries": [toChannelSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasetContents(
    {abortSignal, ...params}: RequestConfig & ListDatasetContentsRequest,
  ): Promise<ListDatasetContentsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["scheduledOnOrAfter"] != null) query.set("scheduledOnOrAfter", cmnP.serializeDate_iso8601(params["scheduledOnOrAfter"]) ?? "");
    if (params["scheduledBefore"] != null) query.set("scheduledBefore", cmnP.serializeDate_iso8601(params["scheduledBefore"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDatasetContents",
      method: "GET",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}/contents`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetContentSummaries": [toDatasetContentSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasets(
    {abortSignal, ...params}: RequestConfig & ListDatasetsRequest = {},
  ): Promise<ListDatasetsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDatasets",
      method: "GET",
      requestUri: "/datasets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetSummaries": [toDatasetSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatastores(
    {abortSignal, ...params}: RequestConfig & ListDatastoresRequest = {},
  ): Promise<ListDatastoresResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDatastores",
      method: "GET",
      requestUri: "/datastores",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datastoreSummaries": [toDatastoreSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPipelines(
    {abortSignal, ...params}: RequestConfig & ListPipelinesRequest = {},
  ): Promise<ListPipelinesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPipelines",
      method: "GET",
      requestUri: "/pipelines",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineSummaries": [toPipelineSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const query = new URLSearchParams;
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: "/tags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async putLoggingOptions(
    {abortSignal, ...params}: RequestConfig & PutLoggingOptionsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      loggingOptions: fromLoggingOptions(params["loggingOptions"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLoggingOptions",
      method: "PUT",
      requestUri: "/logging",
    });
  }

  async runPipelineActivity(
    {abortSignal, ...params}: RequestConfig & RunPipelineActivityRequest,
  ): Promise<RunPipelineActivityResponse> {
    const body: jsonP.JSONObject = {
      pipelineActivity: fromPipelineActivity(params["pipelineActivity"]),
      payloads: params["payloads"]?.map(x => jsonP.serializeBlob(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunPipelineActivity",
      requestUri: "/pipelineactivities/run",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "payloads": ["a"],
        "logResult": "s",
      },
    }, await resp.json());
  }

  async sampleChannelData(
    {abortSignal, ...params}: RequestConfig & SampleChannelDataRequest,
  ): Promise<SampleChannelDataResponse> {
    const query = new URLSearchParams;
    if (params["maxMessages"] != null) query.set("maxMessages", params["maxMessages"]?.toString() ?? "");
    if (params["startTime"] != null) query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    if (params["endTime"] != null) query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "SampleChannelData",
      method: "GET",
      requestUri: cmnP.encodePath`/channels/${params["channelName"]}/sample`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "payloads": ["a"],
      },
    }, await resp.json());
  }

  async startPipelineReprocessing(
    {abortSignal, ...params}: RequestConfig & StartPipelineReprocessingRequest,
  ): Promise<StartPipelineReprocessingResponse> {
    const body: jsonP.JSONObject = {
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      channelMessages: fromChannelMessages(params["channelMessages"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartPipelineReprocessing",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}/reprocessing`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reprocessingId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TagResource",
      requestUri: "/tags",
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: "/tags",
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateChannel(
    {abortSignal, ...params}: RequestConfig & UpdateChannelRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      channelStorage: fromChannelStorage(params["channelStorage"]),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["channelName"]}`,
    });
  }

  async updateDataset(
    {abortSignal, ...params}: RequestConfig & UpdateDatasetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      actions: params["actions"]?.map(x => fromDatasetAction(x)),
      triggers: params["triggers"]?.map(x => fromDatasetTrigger(x)),
      contentDeliveryRules: params["contentDeliveryRules"]?.map(x => fromDatasetContentDeliveryRule(x)),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      versioningConfiguration: fromVersioningConfiguration(params["versioningConfiguration"]),
      lateDataRules: params["lateDataRules"]?.map(x => fromLateDataRule(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataset",
      method: "PUT",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}`,
    });
  }

  async updateDatastore(
    {abortSignal, ...params}: RequestConfig & UpdateDatastoreRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      datastoreStorage: fromDatastoreStorage(params["datastoreStorage"]),
      fileFormatConfiguration: fromFileFormatConfiguration(params["fileFormatConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDatastore",
      method: "PUT",
      requestUri: cmnP.encodePath`/datastores/${params["datastoreName"]}`,
    });
  }

  async updatePipeline(
    {abortSignal, ...params}: RequestConfig & UpdatePipelineRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pipelineActivities: params["pipelineActivities"]?.map(x => fromPipelineActivity(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipeline",
      method: "PUT",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}`,
    });
  }

}

// refs: 1 - tags: named, input
export interface BatchPutMessageRequest {
  channelName: string;
  messages: Message[];
}

// refs: 1 - tags: named, input
export interface CancelPipelineReprocessingRequest {
  pipelineName: string;
  reprocessingId: string;
}

// refs: 1 - tags: named, input
export interface CreateChannelRequest {
  channelName: string;
  channelStorage?: ChannelStorage | null;
  retentionPeriod?: RetentionPeriod | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDatasetRequest {
  datasetName: string;
  actions: DatasetAction[];
  triggers?: DatasetTrigger[] | null;
  contentDeliveryRules?: DatasetContentDeliveryRule[] | null;
  retentionPeriod?: RetentionPeriod | null;
  versioningConfiguration?: VersioningConfiguration | null;
  tags?: Tag[] | null;
  lateDataRules?: LateDataRule[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDatasetContentRequest {
  datasetName: string;
  versionId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateDatastoreRequest {
  datastoreName: string;
  datastoreStorage?: DatastoreStorage | null;
  retentionPeriod?: RetentionPeriod | null;
  tags?: Tag[] | null;
  fileFormatConfiguration?: FileFormatConfiguration | null;
}

// refs: 1 - tags: named, input
export interface CreatePipelineRequest {
  pipelineName: string;
  pipelineActivities: PipelineActivity[];
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteChannelRequest {
  channelName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetRequest {
  datasetName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetContentRequest {
  datasetName: string;
  versionId?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteDatastoreRequest {
  datastoreName: string;
}

// refs: 1 - tags: named, input
export interface DeletePipelineRequest {
  pipelineName: string;
}

// refs: 1 - tags: named, input
export interface DescribeChannelRequest {
  channelName: string;
  includeStatistics?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetRequest {
  datasetName: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatastoreRequest {
  datastoreName: string;
  includeStatistics?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeLoggingOptionsRequest {
}

// refs: 1 - tags: named, input
export interface DescribePipelineRequest {
  pipelineName: string;
}

// refs: 1 - tags: named, input
export interface GetDatasetContentRequest {
  datasetName: string;
  versionId?: string | null;
}

// refs: 1 - tags: named, input
export interface ListChannelsRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListDatasetContentsRequest {
  datasetName: string;
  nextToken?: string | null;
  maxResults?: number | null;
  scheduledOnOrAfter?: Date | number | null;
  scheduledBefore?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface ListDatasetsRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListDatastoresRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListPipelinesRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface PutLoggingOptionsRequest {
  loggingOptions: LoggingOptions;
}

// refs: 1 - tags: named, input
export interface RunPipelineActivityRequest {
  pipelineActivity: PipelineActivity;
  payloads: (Uint8Array | string)[];
}

// refs: 1 - tags: named, input
export interface SampleChannelDataRequest {
  channelName: string;
  maxMessages?: number | null;
  startTime?: Date | number | null;
  endTime?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface StartPipelineReprocessingRequest {
  pipelineName: string;
  startTime?: Date | number | null;
  endTime?: Date | number | null;
  channelMessages?: ChannelMessages | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateChannelRequest {
  channelName: string;
  channelStorage?: ChannelStorage | null;
  retentionPeriod?: RetentionPeriod | null;
}

// refs: 1 - tags: named, input
export interface UpdateDatasetRequest {
  datasetName: string;
  actions: DatasetAction[];
  triggers?: DatasetTrigger[] | null;
  contentDeliveryRules?: DatasetContentDeliveryRule[] | null;
  retentionPeriod?: RetentionPeriod | null;
  versioningConfiguration?: VersioningConfiguration | null;
  lateDataRules?: LateDataRule[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateDatastoreRequest {
  datastoreName: string;
  retentionPeriod?: RetentionPeriod | null;
  datastoreStorage?: DatastoreStorage | null;
  fileFormatConfiguration?: FileFormatConfiguration | null;
}

// refs: 1 - tags: named, input
export interface UpdatePipelineRequest {
  pipelineName: string;
  pipelineActivities: PipelineActivity[];
}

// refs: 1 - tags: named, output
export interface BatchPutMessageResponse {
  batchPutMessageErrorEntries?: BatchPutMessageErrorEntry[] | null;
}

// refs: 1 - tags: named, output
export interface CancelPipelineReprocessingResponse {
}

// refs: 1 - tags: named, output
export interface CreateChannelResponse {
  channelName?: string | null;
  channelArn?: string | null;
  retentionPeriod?: RetentionPeriod | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetResponse {
  datasetName?: string | null;
  datasetArn?: string | null;
  retentionPeriod?: RetentionPeriod | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetContentResponse {
  versionId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDatastoreResponse {
  datastoreName?: string | null;
  datastoreArn?: string | null;
  retentionPeriod?: RetentionPeriod | null;
}

// refs: 1 - tags: named, output
export interface CreatePipelineResponse {
  pipelineName?: string | null;
  pipelineArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeChannelResponse {
  channel?: Channel | null;
  statistics?: ChannelStatistics | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetResponse {
  dataset?: Dataset | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatastoreResponse {
  datastore?: Datastore | null;
  statistics?: DatastoreStatistics | null;
}

// refs: 1 - tags: named, output
export interface DescribeLoggingOptionsResponse {
  loggingOptions?: LoggingOptions | null;
}

// refs: 1 - tags: named, output
export interface DescribePipelineResponse {
  pipeline?: Pipeline | null;
}

// refs: 1 - tags: named, output
export interface GetDatasetContentResponse {
  entries?: DatasetEntry[] | null;
  timestamp?: Date | number | null;
  status?: DatasetContentStatus | null;
}

// refs: 1 - tags: named, output
export interface ListChannelsResponse {
  channelSummaries?: ChannelSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetContentsResponse {
  datasetContentSummaries?: DatasetContentSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetsResponse {
  datasetSummaries?: DatasetSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatastoresResponse {
  datastoreSummaries?: DatastoreSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPipelinesResponse {
  pipelineSummaries?: PipelineSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface RunPipelineActivityResponse {
  payloads?: (Uint8Array | string)[] | null;
  logResult?: string | null;
}

// refs: 1 - tags: named, output
export interface SampleChannelDataResponse {
  payloads?: (Uint8Array | string)[] | null;
}

// refs: 1 - tags: named, output
export interface StartPipelineReprocessingResponse {
  reprocessingId?: string | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: input, named, interface
export interface Message {
  messageId: string;
  payload: Uint8Array | string;
}
function fromMessage(input?: Message | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messageId: input["messageId"],
    payload: jsonP.serializeBlob(input["payload"]),
  }
}

// refs: 3 - tags: input, named, interface, output
export interface ChannelStorage {
  serviceManagedS3?: ServiceManagedChannelS3Storage | null;
  customerManagedS3?: CustomerManagedChannelS3Storage | null;
}
function fromChannelStorage(input?: ChannelStorage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceManagedS3: fromServiceManagedChannelS3Storage(input["serviceManagedS3"]),
    customerManagedS3: fromCustomerManagedChannelS3Storage(input["customerManagedS3"]),
  }
}
function toChannelStorage(root: jsonP.JSONValue): ChannelStorage {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceManagedS3": toServiceManagedChannelS3Storage,
      "customerManagedS3": toCustomerManagedChannelS3Storage,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ServiceManagedChannelS3Storage {
}
function fromServiceManagedChannelS3Storage(input?: ServiceManagedChannelS3Storage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toServiceManagedChannelS3Storage(root: jsonP.JSONValue): ServiceManagedChannelS3Storage {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface CustomerManagedChannelS3Storage {
  bucket: string;
  keyPrefix?: string | null;
  roleArn: string;
}
function fromCustomerManagedChannelS3Storage(input?: CustomerManagedChannelS3Storage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    keyPrefix: input["keyPrefix"],
    roleArn: input["roleArn"],
  }
}
function toCustomerManagedChannelS3Storage(root: jsonP.JSONValue): CustomerManagedChannelS3Storage {
  return jsonP.readObj({
    required: {
      "bucket": "s",
      "roleArn": "s",
    },
    optional: {
      "keyPrefix": "s",
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface RetentionPeriod {
  unlimited?: boolean | null;
  numberOfDays?: number | null;
}
function fromRetentionPeriod(input?: RetentionPeriod | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    unlimited: input["unlimited"],
    numberOfDays: input["numberOfDays"],
  }
}
function toRetentionPeriod(root: jsonP.JSONValue): RetentionPeriod {
  return jsonP.readObj({
    required: {},
    optional: {
      "unlimited": "b",
      "numberOfDays": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Tag {
  key: string;
  value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DatasetAction {
  actionName?: string | null;
  queryAction?: SqlQueryDatasetAction | null;
  containerAction?: ContainerDatasetAction | null;
}
function fromDatasetAction(input?: DatasetAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actionName: input["actionName"],
    queryAction: fromSqlQueryDatasetAction(input["queryAction"]),
    containerAction: fromContainerDatasetAction(input["containerAction"]),
  }
}
function toDatasetAction(root: jsonP.JSONValue): DatasetAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionName": "s",
      "queryAction": toSqlQueryDatasetAction,
      "containerAction": toContainerDatasetAction,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface SqlQueryDatasetAction {
  sqlQuery: string;
  filters?: QueryFilter[] | null;
}
function fromSqlQueryDatasetAction(input?: SqlQueryDatasetAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sqlQuery: input["sqlQuery"],
    filters: input["filters"]?.map(x => fromQueryFilter(x)),
  }
}
function toSqlQueryDatasetAction(root: jsonP.JSONValue): SqlQueryDatasetAction {
  return jsonP.readObj({
    required: {
      "sqlQuery": "s",
    },
    optional: {
      "filters": [toQueryFilter],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface QueryFilter {
  deltaTime?: DeltaTime | null;
}
function fromQueryFilter(input?: QueryFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deltaTime: fromDeltaTime(input["deltaTime"]),
  }
}
function toQueryFilter(root: jsonP.JSONValue): QueryFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "deltaTime": toDeltaTime,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DeltaTime {
  offsetSeconds: number;
  timeExpression: string;
}
function fromDeltaTime(input?: DeltaTime | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    offsetSeconds: input["offsetSeconds"],
    timeExpression: input["timeExpression"],
  }
}
function toDeltaTime(root: jsonP.JSONValue): DeltaTime {
  return jsonP.readObj({
    required: {
      "offsetSeconds": "n",
      "timeExpression": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ContainerDatasetAction {
  image: string;
  executionRoleArn: string;
  resourceConfiguration: ResourceConfiguration;
  variables?: Variable[] | null;
}
function fromContainerDatasetAction(input?: ContainerDatasetAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    image: input["image"],
    executionRoleArn: input["executionRoleArn"],
    resourceConfiguration: fromResourceConfiguration(input["resourceConfiguration"]),
    variables: input["variables"]?.map(x => fromVariable(x)),
  }
}
function toContainerDatasetAction(root: jsonP.JSONValue): ContainerDatasetAction {
  return jsonP.readObj({
    required: {
      "image": "s",
      "executionRoleArn": "s",
      "resourceConfiguration": toResourceConfiguration,
    },
    optional: {
      "variables": [toVariable],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ResourceConfiguration {
  computeType: ComputeType;
  volumeSizeInGB: number;
}
function fromResourceConfiguration(input?: ResourceConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    computeType: input["computeType"],
    volumeSizeInGB: input["volumeSizeInGB"],
  }
}
function toResourceConfiguration(root: jsonP.JSONValue): ResourceConfiguration {
  return jsonP.readObj({
    required: {
      "computeType": (x: jsonP.JSONValue) => cmnP.readEnum<ComputeType>(x),
      "volumeSizeInGB": "n",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ComputeType =
| "ACU_1"
| "ACU_2"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface Variable {
  name: string;
  stringValue?: string | null;
  doubleValue?: number | null;
  datasetContentVersionValue?: DatasetContentVersionValue | null;
  outputFileUriValue?: OutputFileUriValue | null;
}
function fromVariable(input?: Variable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    stringValue: input["stringValue"],
    doubleValue: input["doubleValue"],
    datasetContentVersionValue: fromDatasetContentVersionValue(input["datasetContentVersionValue"]),
    outputFileUriValue: fromOutputFileUriValue(input["outputFileUriValue"]),
  }
}
function toVariable(root: jsonP.JSONValue): Variable {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "stringValue": "s",
      "doubleValue": "n",
      "datasetContentVersionValue": toDatasetContentVersionValue,
      "outputFileUriValue": toOutputFileUriValue,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DatasetContentVersionValue {
  datasetName: string;
}
function fromDatasetContentVersionValue(input?: DatasetContentVersionValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    datasetName: input["datasetName"],
  }
}
function toDatasetContentVersionValue(root: jsonP.JSONValue): DatasetContentVersionValue {
  return jsonP.readObj({
    required: {
      "datasetName": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface OutputFileUriValue {
  fileName: string;
}
function fromOutputFileUriValue(input?: OutputFileUriValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fileName: input["fileName"],
  }
}
function toOutputFileUriValue(root: jsonP.JSONValue): OutputFileUriValue {
  return jsonP.readObj({
    required: {
      "fileName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DatasetTrigger {
  schedule?: Schedule | null;
  dataset?: TriggeringDataset | null;
}
function fromDatasetTrigger(input?: DatasetTrigger | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    schedule: fromSchedule(input["schedule"]),
    dataset: fromTriggeringDataset(input["dataset"]),
  }
}
function toDatasetTrigger(root: jsonP.JSONValue): DatasetTrigger {
  return jsonP.readObj({
    required: {},
    optional: {
      "schedule": toSchedule,
      "dataset": toTriggeringDataset,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Schedule {
  expression?: string | null;
}
function fromSchedule(input?: Schedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    expression: input["expression"],
  }
}
function toSchedule(root: jsonP.JSONValue): Schedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "expression": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface TriggeringDataset {
  name: string;
}
function fromTriggeringDataset(input?: TriggeringDataset | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toTriggeringDataset(root: jsonP.JSONValue): TriggeringDataset {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DatasetContentDeliveryRule {
  entryName?: string | null;
  destination: DatasetContentDeliveryDestination;
}
function fromDatasetContentDeliveryRule(input?: DatasetContentDeliveryRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    entryName: input["entryName"],
    destination: fromDatasetContentDeliveryDestination(input["destination"]),
  }
}
function toDatasetContentDeliveryRule(root: jsonP.JSONValue): DatasetContentDeliveryRule {
  return jsonP.readObj({
    required: {
      "destination": toDatasetContentDeliveryDestination,
    },
    optional: {
      "entryName": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DatasetContentDeliveryDestination {
  iotEventsDestinationConfiguration?: IotEventsDestinationConfiguration | null;
  s3DestinationConfiguration?: S3DestinationConfiguration | null;
}
function fromDatasetContentDeliveryDestination(input?: DatasetContentDeliveryDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    iotEventsDestinationConfiguration: fromIotEventsDestinationConfiguration(input["iotEventsDestinationConfiguration"]),
    s3DestinationConfiguration: fromS3DestinationConfiguration(input["s3DestinationConfiguration"]),
  }
}
function toDatasetContentDeliveryDestination(root: jsonP.JSONValue): DatasetContentDeliveryDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "iotEventsDestinationConfiguration": toIotEventsDestinationConfiguration,
      "s3DestinationConfiguration": toS3DestinationConfiguration,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface IotEventsDestinationConfiguration {
  inputName: string;
  roleArn: string;
}
function fromIotEventsDestinationConfiguration(input?: IotEventsDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputName: input["inputName"],
    roleArn: input["roleArn"],
  }
}
function toIotEventsDestinationConfiguration(root: jsonP.JSONValue): IotEventsDestinationConfiguration {
  return jsonP.readObj({
    required: {
      "inputName": "s",
      "roleArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface S3DestinationConfiguration {
  bucket: string;
  key: string;
  glueConfiguration?: GlueConfiguration | null;
  roleArn: string;
}
function fromS3DestinationConfiguration(input?: S3DestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    key: input["key"],
    glueConfiguration: fromGlueConfiguration(input["glueConfiguration"]),
    roleArn: input["roleArn"],
  }
}
function toS3DestinationConfiguration(root: jsonP.JSONValue): S3DestinationConfiguration {
  return jsonP.readObj({
    required: {
      "bucket": "s",
      "key": "s",
      "roleArn": "s",
    },
    optional: {
      "glueConfiguration": toGlueConfiguration,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface GlueConfiguration {
  tableName: string;
  databaseName: string;
}
function fromGlueConfiguration(input?: GlueConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tableName: input["tableName"],
    databaseName: input["databaseName"],
  }
}
function toGlueConfiguration(root: jsonP.JSONValue): GlueConfiguration {
  return jsonP.readObj({
    required: {
      "tableName": "s",
      "databaseName": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface VersioningConfiguration {
  unlimited?: boolean | null;
  maxVersions?: number | null;
}
function fromVersioningConfiguration(input?: VersioningConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    unlimited: input["unlimited"],
    maxVersions: input["maxVersions"],
  }
}
function toVersioningConfiguration(root: jsonP.JSONValue): VersioningConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "unlimited": "b",
      "maxVersions": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface LateDataRule {
  ruleName?: string | null;
  ruleConfiguration: LateDataRuleConfiguration;
}
function fromLateDataRule(input?: LateDataRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ruleName: input["ruleName"],
    ruleConfiguration: fromLateDataRuleConfiguration(input["ruleConfiguration"]),
  }
}
function toLateDataRule(root: jsonP.JSONValue): LateDataRule {
  return jsonP.readObj({
    required: {
      "ruleConfiguration": toLateDataRuleConfiguration,
    },
    optional: {
      "ruleName": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface LateDataRuleConfiguration {
  deltaTimeSessionWindowConfiguration?: DeltaTimeSessionWindowConfiguration | null;
}
function fromLateDataRuleConfiguration(input?: LateDataRuleConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deltaTimeSessionWindowConfiguration: fromDeltaTimeSessionWindowConfiguration(input["deltaTimeSessionWindowConfiguration"]),
  }
}
function toLateDataRuleConfiguration(root: jsonP.JSONValue): LateDataRuleConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "deltaTimeSessionWindowConfiguration": toDeltaTimeSessionWindowConfiguration,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DeltaTimeSessionWindowConfiguration {
  timeoutInMinutes: number;
}
function fromDeltaTimeSessionWindowConfiguration(input?: DeltaTimeSessionWindowConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timeoutInMinutes: input["timeoutInMinutes"],
  }
}
function toDeltaTimeSessionWindowConfiguration(root: jsonP.JSONValue): DeltaTimeSessionWindowConfiguration {
  return jsonP.readObj({
    required: {
      "timeoutInMinutes": "n",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DatastoreStorage {
  serviceManagedS3?: ServiceManagedDatastoreS3Storage | null;
  customerManagedS3?: CustomerManagedDatastoreS3Storage | null;
}
function fromDatastoreStorage(input?: DatastoreStorage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceManagedS3: fromServiceManagedDatastoreS3Storage(input["serviceManagedS3"]),
    customerManagedS3: fromCustomerManagedDatastoreS3Storage(input["customerManagedS3"]),
  }
}
function toDatastoreStorage(root: jsonP.JSONValue): DatastoreStorage {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceManagedS3": toServiceManagedDatastoreS3Storage,
      "customerManagedS3": toCustomerManagedDatastoreS3Storage,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ServiceManagedDatastoreS3Storage {
}
function fromServiceManagedDatastoreS3Storage(input?: ServiceManagedDatastoreS3Storage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toServiceManagedDatastoreS3Storage(root: jsonP.JSONValue): ServiceManagedDatastoreS3Storage {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface CustomerManagedDatastoreS3Storage {
  bucket: string;
  keyPrefix?: string | null;
  roleArn: string;
}
function fromCustomerManagedDatastoreS3Storage(input?: CustomerManagedDatastoreS3Storage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    keyPrefix: input["keyPrefix"],
    roleArn: input["roleArn"],
  }
}
function toCustomerManagedDatastoreS3Storage(root: jsonP.JSONValue): CustomerManagedDatastoreS3Storage {
  return jsonP.readObj({
    required: {
      "bucket": "s",
      "roleArn": "s",
    },
    optional: {
      "keyPrefix": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface FileFormatConfiguration {
  jsonConfiguration?: JsonConfiguration | null;
  parquetConfiguration?: ParquetConfiguration | null;
}
function fromFileFormatConfiguration(input?: FileFormatConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    jsonConfiguration: fromJsonConfiguration(input["jsonConfiguration"]),
    parquetConfiguration: fromParquetConfiguration(input["parquetConfiguration"]),
  }
}
function toFileFormatConfiguration(root: jsonP.JSONValue): FileFormatConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "jsonConfiguration": toJsonConfiguration,
      "parquetConfiguration": toParquetConfiguration,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface JsonConfiguration {
}
function fromJsonConfiguration(input?: JsonConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toJsonConfiguration(root: jsonP.JSONValue): JsonConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ParquetConfiguration {
  schemaDefinition?: SchemaDefinition | null;
}
function fromParquetConfiguration(input?: ParquetConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    schemaDefinition: fromSchemaDefinition(input["schemaDefinition"]),
  }
}
function toParquetConfiguration(root: jsonP.JSONValue): ParquetConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "schemaDefinition": toSchemaDefinition,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface SchemaDefinition {
  columns?: Column[] | null;
}
function fromSchemaDefinition(input?: SchemaDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    columns: input["columns"]?.map(x => fromColumn(x)),
  }
}
function toSchemaDefinition(root: jsonP.JSONValue): SchemaDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "columns": [toColumn],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Column {
  name: string;
  type: string;
}
function fromColumn(input?: Column | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    type: input["type"],
  }
}
function toColumn(root: jsonP.JSONValue): Column {
  return jsonP.readObj({
    required: {
      "name": "s",
      "type": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface PipelineActivity {
  channel?: ChannelActivity | null;
  lambda?: LambdaActivity | null;
  datastore?: DatastoreActivity | null;
  addAttributes?: AddAttributesActivity | null;
  removeAttributes?: RemoveAttributesActivity | null;
  selectAttributes?: SelectAttributesActivity | null;
  filter?: FilterActivity | null;
  math?: MathActivity | null;
  deviceRegistryEnrich?: DeviceRegistryEnrichActivity | null;
  deviceShadowEnrich?: DeviceShadowEnrichActivity | null;
}
function fromPipelineActivity(input?: PipelineActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channel: fromChannelActivity(input["channel"]),
    lambda: fromLambdaActivity(input["lambda"]),
    datastore: fromDatastoreActivity(input["datastore"]),
    addAttributes: fromAddAttributesActivity(input["addAttributes"]),
    removeAttributes: fromRemoveAttributesActivity(input["removeAttributes"]),
    selectAttributes: fromSelectAttributesActivity(input["selectAttributes"]),
    filter: fromFilterActivity(input["filter"]),
    math: fromMathActivity(input["math"]),
    deviceRegistryEnrich: fromDeviceRegistryEnrichActivity(input["deviceRegistryEnrich"]),
    deviceShadowEnrich: fromDeviceShadowEnrichActivity(input["deviceShadowEnrich"]),
  }
}
function toPipelineActivity(root: jsonP.JSONValue): PipelineActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "channel": toChannelActivity,
      "lambda": toLambdaActivity,
      "datastore": toDatastoreActivity,
      "addAttributes": toAddAttributesActivity,
      "removeAttributes": toRemoveAttributesActivity,
      "selectAttributes": toSelectAttributesActivity,
      "filter": toFilterActivity,
      "math": toMathActivity,
      "deviceRegistryEnrich": toDeviceRegistryEnrichActivity,
      "deviceShadowEnrich": toDeviceShadowEnrichActivity,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ChannelActivity {
  name: string;
  channelName: string;
  next?: string | null;
}
function fromChannelActivity(input?: ChannelActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    channelName: input["channelName"],
    next: input["next"],
  }
}
function toChannelActivity(root: jsonP.JSONValue): ChannelActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "channelName": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface LambdaActivity {
  name: string;
  lambdaName: string;
  batchSize: number;
  next?: string | null;
}
function fromLambdaActivity(input?: LambdaActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    lambdaName: input["lambdaName"],
    batchSize: input["batchSize"],
    next: input["next"],
  }
}
function toLambdaActivity(root: jsonP.JSONValue): LambdaActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "lambdaName": "s",
      "batchSize": "n",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DatastoreActivity {
  name: string;
  datastoreName: string;
}
function fromDatastoreActivity(input?: DatastoreActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    datastoreName: input["datastoreName"],
  }
}
function toDatastoreActivity(root: jsonP.JSONValue): DatastoreActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "datastoreName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface AddAttributesActivity {
  name: string;
  attributes: { [key: string]: string | null | undefined };
  next?: string | null;
}
function fromAddAttributesActivity(input?: AddAttributesActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attributes: input["attributes"],
    next: input["next"],
  }
}
function toAddAttributesActivity(root: jsonP.JSONValue): AddAttributesActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attributes": x => jsonP.readMap(String, String, x),
    },
    optional: {
      "next": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface RemoveAttributesActivity {
  name: string;
  attributes: string[];
  next?: string | null;
}
function fromRemoveAttributesActivity(input?: RemoveAttributesActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attributes: input["attributes"],
    next: input["next"],
  }
}
function toRemoveAttributesActivity(root: jsonP.JSONValue): RemoveAttributesActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attributes": ["s"],
    },
    optional: {
      "next": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface SelectAttributesActivity {
  name: string;
  attributes: string[];
  next?: string | null;
}
function fromSelectAttributesActivity(input?: SelectAttributesActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attributes: input["attributes"],
    next: input["next"],
  }
}
function toSelectAttributesActivity(root: jsonP.JSONValue): SelectAttributesActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attributes": ["s"],
    },
    optional: {
      "next": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface FilterActivity {
  name: string;
  filter: string;
  next?: string | null;
}
function fromFilterActivity(input?: FilterActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    filter: input["filter"],
    next: input["next"],
  }
}
function toFilterActivity(root: jsonP.JSONValue): FilterActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "filter": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface MathActivity {
  name: string;
  attribute: string;
  math: string;
  next?: string | null;
}
function fromMathActivity(input?: MathActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attribute: input["attribute"],
    math: input["math"],
    next: input["next"],
  }
}
function toMathActivity(root: jsonP.JSONValue): MathActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attribute": "s",
      "math": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DeviceRegistryEnrichActivity {
  name: string;
  attribute: string;
  thingName: string;
  roleArn: string;
  next?: string | null;
}
function fromDeviceRegistryEnrichActivity(input?: DeviceRegistryEnrichActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attribute: input["attribute"],
    thingName: input["thingName"],
    roleArn: input["roleArn"],
    next: input["next"],
  }
}
function toDeviceRegistryEnrichActivity(root: jsonP.JSONValue): DeviceRegistryEnrichActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attribute": "s",
      "thingName": "s",
      "roleArn": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DeviceShadowEnrichActivity {
  name: string;
  attribute: string;
  thingName: string;
  roleArn: string;
  next?: string | null;
}
function fromDeviceShadowEnrichActivity(input?: DeviceShadowEnrichActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attribute: input["attribute"],
    thingName: input["thingName"],
    roleArn: input["roleArn"],
    next: input["next"],
  }
}
function toDeviceShadowEnrichActivity(root: jsonP.JSONValue): DeviceShadowEnrichActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attribute": "s",
      "thingName": "s",
      "roleArn": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface LoggingOptions {
  roleArn: string;
  level: LoggingLevel;
  enabled: boolean;
}
function fromLoggingOptions(input?: LoggingOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    level: input["level"],
    enabled: input["enabled"],
  }
}
function toLoggingOptions(root: jsonP.JSONValue): LoggingOptions {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "level": (x: jsonP.JSONValue) => cmnP.readEnum<LoggingLevel>(x),
      "enabled": "b",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type LoggingLevel =
| "ERROR"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ChannelMessages {
  s3Paths?: string[] | null;
}
function fromChannelMessages(input?: ChannelMessages | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Paths: input["s3Paths"],
  }
}

// refs: 1 - tags: output, named, interface
export interface BatchPutMessageErrorEntry {
  messageId?: string | null;
  errorCode?: string | null;
  errorMessage?: string | null;
}
function toBatchPutMessageErrorEntry(root: jsonP.JSONValue): BatchPutMessageErrorEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "messageId": "s",
      "errorCode": "s",
      "errorMessage": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Channel {
  name?: string | null;
  storage?: ChannelStorage | null;
  arn?: string | null;
  status?: ChannelStatus | null;
  retentionPeriod?: RetentionPeriod | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
  lastMessageArrivalTime?: Date | number | null;
}
function toChannel(root: jsonP.JSONValue): Channel {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "storage": toChannelStorage,
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelStatus>(x),
      "retentionPeriod": toRetentionPeriod,
      "creationTime": "d",
      "lastUpdateTime": "d",
      "lastMessageArrivalTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ChannelStatus =
| "CREATING"
| "ACTIVE"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ChannelStatistics {
  size?: EstimatedResourceSize | null;
}
function toChannelStatistics(root: jsonP.JSONValue): ChannelStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "size": toEstimatedResourceSize,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EstimatedResourceSize {
  estimatedSizeInBytes?: number | null;
  estimatedOn?: Date | number | null;
}
function toEstimatedResourceSize(root: jsonP.JSONValue): EstimatedResourceSize {
  return jsonP.readObj({
    required: {},
    optional: {
      "estimatedSizeInBytes": "n",
      "estimatedOn": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Dataset {
  name?: string | null;
  arn?: string | null;
  actions?: DatasetAction[] | null;
  triggers?: DatasetTrigger[] | null;
  contentDeliveryRules?: DatasetContentDeliveryRule[] | null;
  status?: DatasetStatus | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
  retentionPeriod?: RetentionPeriod | null;
  versioningConfiguration?: VersioningConfiguration | null;
  lateDataRules?: LateDataRule[] | null;
}
function toDataset(root: jsonP.JSONValue): Dataset {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "actions": [toDatasetAction],
      "triggers": [toDatasetTrigger],
      "contentDeliveryRules": [toDatasetContentDeliveryRule],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<DatasetStatus>(x),
      "creationTime": "d",
      "lastUpdateTime": "d",
      "retentionPeriod": toRetentionPeriod,
      "versioningConfiguration": toVersioningConfiguration,
      "lateDataRules": [toLateDataRule],
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DatasetStatus =
| "CREATING"
| "ACTIVE"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Datastore {
  name?: string | null;
  storage?: DatastoreStorage | null;
  arn?: string | null;
  status?: DatastoreStatus | null;
  retentionPeriod?: RetentionPeriod | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
  lastMessageArrivalTime?: Date | number | null;
  fileFormatConfiguration?: FileFormatConfiguration | null;
}
function toDatastore(root: jsonP.JSONValue): Datastore {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "storage": toDatastoreStorage,
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<DatastoreStatus>(x),
      "retentionPeriod": toRetentionPeriod,
      "creationTime": "d",
      "lastUpdateTime": "d",
      "lastMessageArrivalTime": "d",
      "fileFormatConfiguration": toFileFormatConfiguration,
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DatastoreStatus =
| "CREATING"
| "ACTIVE"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DatastoreStatistics {
  size?: EstimatedResourceSize | null;
}
function toDatastoreStatistics(root: jsonP.JSONValue): DatastoreStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "size": toEstimatedResourceSize,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Pipeline {
  name?: string | null;
  arn?: string | null;
  activities?: PipelineActivity[] | null;
  reprocessingSummaries?: ReprocessingSummary[] | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
}
function toPipeline(root: jsonP.JSONValue): Pipeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "activities": [toPipelineActivity],
      "reprocessingSummaries": [toReprocessingSummary],
      "creationTime": "d",
      "lastUpdateTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ReprocessingSummary {
  id?: string | null;
  status?: ReprocessingStatus | null;
  creationTime?: Date | number | null;
}
function toReprocessingSummary(root: jsonP.JSONValue): ReprocessingSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ReprocessingStatus>(x),
      "creationTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ReprocessingStatus =
| "RUNNING"
| "SUCCEEDED"
| "CANCELLED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DatasetEntry {
  entryName?: string | null;
  dataURI?: string | null;
}
function toDatasetEntry(root: jsonP.JSONValue): DatasetEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "entryName": "s",
      "dataURI": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface DatasetContentStatus {
  state?: DatasetContentState | null;
  reason?: string | null;
}
function toDatasetContentStatus(root: jsonP.JSONValue): DatasetContentStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<DatasetContentState>(x),
      "reason": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DatasetContentState =
| "CREATING"
| "SUCCEEDED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ChannelSummary {
  channelName?: string | null;
  channelStorage?: ChannelStorageSummary | null;
  status?: ChannelStatus | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
  lastMessageArrivalTime?: Date | number | null;
}
function toChannelSummary(root: jsonP.JSONValue): ChannelSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "channelName": "s",
      "channelStorage": toChannelStorageSummary,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelStatus>(x),
      "creationTime": "d",
      "lastUpdateTime": "d",
      "lastMessageArrivalTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ChannelStorageSummary {
  serviceManagedS3?: ServiceManagedChannelS3StorageSummary | null;
  customerManagedS3?: CustomerManagedChannelS3StorageSummary | null;
}
function toChannelStorageSummary(root: jsonP.JSONValue): ChannelStorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceManagedS3": toServiceManagedChannelS3StorageSummary,
      "customerManagedS3": toCustomerManagedChannelS3StorageSummary,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ServiceManagedChannelS3StorageSummary {
}
function toServiceManagedChannelS3StorageSummary(root: jsonP.JSONValue): ServiceManagedChannelS3StorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CustomerManagedChannelS3StorageSummary {
  bucket?: string | null;
  keyPrefix?: string | null;
  roleArn?: string | null;
}
function toCustomerManagedChannelS3StorageSummary(root: jsonP.JSONValue): CustomerManagedChannelS3StorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "keyPrefix": "s",
      "roleArn": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetContentSummary {
  version?: string | null;
  status?: DatasetContentStatus | null;
  creationTime?: Date | number | null;
  scheduleTime?: Date | number | null;
  completionTime?: Date | number | null;
}
function toDatasetContentSummary(root: jsonP.JSONValue): DatasetContentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "version": "s",
      "status": toDatasetContentStatus,
      "creationTime": "d",
      "scheduleTime": "d",
      "completionTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetSummary {
  datasetName?: string | null;
  status?: DatasetStatus | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
  triggers?: DatasetTrigger[] | null;
  actions?: DatasetActionSummary[] | null;
}
function toDatasetSummary(root: jsonP.JSONValue): DatasetSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "datasetName": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<DatasetStatus>(x),
      "creationTime": "d",
      "lastUpdateTime": "d",
      "triggers": [toDatasetTrigger],
      "actions": [toDatasetActionSummary],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetActionSummary {
  actionName?: string | null;
  actionType?: DatasetActionType | null;
}
function toDatasetActionSummary(root: jsonP.JSONValue): DatasetActionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionName": "s",
      "actionType": (x: jsonP.JSONValue) => cmnP.readEnum<DatasetActionType>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type DatasetActionType =
| "QUERY"
| "CONTAINER"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DatastoreSummary {
  datastoreName?: string | null;
  datastoreStorage?: DatastoreStorageSummary | null;
  status?: DatastoreStatus | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
  lastMessageArrivalTime?: Date | number | null;
  fileFormatType?: FileFormatType | null;
}
function toDatastoreSummary(root: jsonP.JSONValue): DatastoreSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "datastoreName": "s",
      "datastoreStorage": toDatastoreStorageSummary,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<DatastoreStatus>(x),
      "creationTime": "d",
      "lastUpdateTime": "d",
      "lastMessageArrivalTime": "d",
      "fileFormatType": (x: jsonP.JSONValue) => cmnP.readEnum<FileFormatType>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatastoreStorageSummary {
  serviceManagedS3?: ServiceManagedDatastoreS3StorageSummary | null;
  customerManagedS3?: CustomerManagedDatastoreS3StorageSummary | null;
}
function toDatastoreStorageSummary(root: jsonP.JSONValue): DatastoreStorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceManagedS3": toServiceManagedDatastoreS3StorageSummary,
      "customerManagedS3": toCustomerManagedDatastoreS3StorageSummary,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ServiceManagedDatastoreS3StorageSummary {
}
function toServiceManagedDatastoreS3StorageSummary(root: jsonP.JSONValue): ServiceManagedDatastoreS3StorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CustomerManagedDatastoreS3StorageSummary {
  bucket?: string | null;
  keyPrefix?: string | null;
  roleArn?: string | null;
}
function toCustomerManagedDatastoreS3StorageSummary(root: jsonP.JSONValue): CustomerManagedDatastoreS3StorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "keyPrefix": "s",
      "roleArn": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type FileFormatType =
| "JSON"
| "PARQUET"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface PipelineSummary {
  pipelineName?: string | null;
  reprocessingSummaries?: ReprocessingSummary[] | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
}
function toPipelineSummary(root: jsonP.JSONValue): PipelineSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "pipelineName": "s",
      "reprocessingSummaries": [toReprocessingSummary],
      "creationTime": "d",
      "lastUpdateTime": "d",
    },
  }, root);
}
