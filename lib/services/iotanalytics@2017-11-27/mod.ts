// Autogenerated API client for: AWS IoT Analytics

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class IoTAnalytics {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(IoTAnalytics.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-11-27",
    "endpointPrefix": "iotanalytics",
    "protocol": "rest-json",
    "serviceFullName": "AWS IoT Analytics",
    "serviceId": "IoTAnalytics",
    "signatureVersion": "v4",
    "signingName": "iotanalytics",
    "uid": "iotanalytics-2017-11-27"
  };

  async batchPutMessage(
    {abortSignal, ...params}: RequestConfig & s.BatchPutMessageRequest,
  ): Promise<s.BatchPutMessageResponse> {
    const body: jsonP.JSONObject = {
      channelName: params["channelName"],
      messages: params["messages"]?.map(x => fromMessage(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchPutMessage",
      requestUri: "/messages/batch",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "batchPutMessageErrorEntries": [toBatchPutMessageErrorEntry],
      },
    }, await resp.json());
  }

  async cancelPipelineReprocessing(
    {abortSignal, ...params}: RequestConfig & s.CancelPipelineReprocessingRequest,
  ): Promise<s.CancelPipelineReprocessingResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelPipelineReprocessing",
      method: "DELETE",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}/reprocessing/${params["reprocessingId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createChannel(
    {abortSignal, ...params}: RequestConfig & s.CreateChannelRequest,
  ): Promise<s.CreateChannelResponse> {
    const body: jsonP.JSONObject = {
      channelName: params["channelName"],
      channelStorage: fromChannelStorage(params["channelStorage"]),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChannel",
      requestUri: "/channels",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channelName": "s",
        "channelArn": "s",
        "retentionPeriod": toRetentionPeriod,
      },
    }, await resp.json());
  }

  async createDataset(
    {abortSignal, ...params}: RequestConfig & s.CreateDatasetRequest,
  ): Promise<s.CreateDatasetResponse> {
    const body: jsonP.JSONObject = {
      datasetName: params["datasetName"],
      actions: params["actions"]?.map(x => fromDatasetAction(x)),
      triggers: params["triggers"]?.map(x => fromDatasetTrigger(x)),
      contentDeliveryRules: params["contentDeliveryRules"]?.map(x => fromDatasetContentDeliveryRule(x)),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      versioningConfiguration: fromVersioningConfiguration(params["versioningConfiguration"]),
      tags: params["tags"]?.map(x => fromTag(x)),
      lateDataRules: params["lateDataRules"]?.map(x => fromLateDataRule(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataset",
      requestUri: "/datasets",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetName": "s",
        "datasetArn": "s",
        "retentionPeriod": toRetentionPeriod,
      },
    }, await resp.json());
  }

  async createDatasetContent(
    {abortSignal, ...params}: RequestConfig & s.CreateDatasetContentRequest,
  ): Promise<s.CreateDatasetContentResponse> {
    const body: jsonP.JSONObject = {
      versionId: params["versionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetContent",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}/content`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "versionId": "s",
      },
    }, await resp.json());
  }

  async createDatastore(
    {abortSignal, ...params}: RequestConfig & s.CreateDatastoreRequest,
  ): Promise<s.CreateDatastoreResponse> {
    const body: jsonP.JSONObject = {
      datastoreName: params["datastoreName"],
      datastoreStorage: fromDatastoreStorage(params["datastoreStorage"]),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      tags: params["tags"]?.map(x => fromTag(x)),
      fileFormatConfiguration: fromFileFormatConfiguration(params["fileFormatConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatastore",
      requestUri: "/datastores",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datastoreName": "s",
        "datastoreArn": "s",
        "retentionPeriod": toRetentionPeriod,
      },
    }, await resp.json());
  }

  async createPipeline(
    {abortSignal, ...params}: RequestConfig & s.CreatePipelineRequest,
  ): Promise<s.CreatePipelineResponse> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      pipelineActivities: params["pipelineActivities"]?.map(x => fromPipelineActivity(x)),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePipeline",
      requestUri: "/pipelines",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineName": "s",
        "pipelineArn": "s",
      },
    }, await resp.json());
  }

  async deleteChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteChannelRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/channels/${params["channelName"]}`,
      responseCode: 204,
    });
  }

  async deleteDataset(
    {abortSignal, ...params}: RequestConfig & s.DeleteDatasetRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDataset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}`,
      responseCode: 204,
    });
  }

  async deleteDatasetContent(
    {abortSignal, ...params}: RequestConfig & s.DeleteDatasetContentRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["versionId"] != null) query.set("versionId", params["versionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteDatasetContent",
      method: "DELETE",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}/content`,
      responseCode: 204,
    });
  }

  async deleteDatastore(
    {abortSignal, ...params}: RequestConfig & s.DeleteDatastoreRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDatastore",
      method: "DELETE",
      requestUri: cmnP.encodePath`/datastores/${params["datastoreName"]}`,
      responseCode: 204,
    });
  }

  async deletePipeline(
    {abortSignal, ...params}: RequestConfig & s.DeletePipelineRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePipeline",
      method: "DELETE",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}`,
      responseCode: 204,
    });
  }

  async describeChannel(
    {abortSignal, ...params}: RequestConfig & s.DescribeChannelRequest,
  ): Promise<s.DescribeChannelResponse> {
    const query = new URLSearchParams;
    if (params["includeStatistics"] != null) query.set("includeStatistics", params["includeStatistics"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/channels/${params["channelName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channel": toChannel,
        "statistics": toChannelStatistics,
      },
    }, await resp.json());
  }

  async describeDataset(
    {abortSignal, ...params}: RequestConfig & s.DescribeDatasetRequest,
  ): Promise<s.DescribeDatasetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDataset",
      method: "GET",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "dataset": toDataset,
      },
    }, await resp.json());
  }

  async describeDatastore(
    {abortSignal, ...params}: RequestConfig & s.DescribeDatastoreRequest,
  ): Promise<s.DescribeDatastoreResponse> {
    const query = new URLSearchParams;
    if (params["includeStatistics"] != null) query.set("includeStatistics", params["includeStatistics"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeDatastore",
      method: "GET",
      requestUri: cmnP.encodePath`/datastores/${params["datastoreName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datastore": toDatastore,
        "statistics": toDatastoreStatistics,
      },
    }, await resp.json());
  }

  async describeLoggingOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeLoggingOptionsRequest = {},
  ): Promise<s.DescribeLoggingOptionsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeLoggingOptions",
      method: "GET",
      requestUri: "/logging",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "loggingOptions": toLoggingOptions,
      },
    }, await resp.json());
  }

  async describePipeline(
    {abortSignal, ...params}: RequestConfig & s.DescribePipelineRequest,
  ): Promise<s.DescribePipelineResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribePipeline",
      method: "GET",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipeline": toPipeline,
      },
    }, await resp.json());
  }

  async getDatasetContent(
    {abortSignal, ...params}: RequestConfig & s.GetDatasetContentRequest,
  ): Promise<s.GetDatasetContentResponse> {
    const query = new URLSearchParams;
    if (params["versionId"] != null) query.set("versionId", params["versionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDatasetContent",
      method: "GET",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}/content`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "entries": [toDatasetEntry],
        "timestamp": "d",
        "status": toDatasetContentStatus,
      },
    }, await resp.json());
  }

  async listChannels(
    {abortSignal, ...params}: RequestConfig & s.ListChannelsRequest = {},
  ): Promise<s.ListChannelsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListChannels",
      method: "GET",
      requestUri: "/channels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channelSummaries": [toChannelSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasetContents(
    {abortSignal, ...params}: RequestConfig & s.ListDatasetContentsRequest,
  ): Promise<s.ListDatasetContentsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["scheduledOnOrAfter"] != null) query.set("scheduledOnOrAfter", cmnP.serializeDate_iso8601(params["scheduledOnOrAfter"]) ?? "");
    if (params["scheduledBefore"] != null) query.set("scheduledBefore", cmnP.serializeDate_iso8601(params["scheduledBefore"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDatasetContents",
      method: "GET",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}/contents`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetContentSummaries": [toDatasetContentSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasets(
    {abortSignal, ...params}: RequestConfig & s.ListDatasetsRequest = {},
  ): Promise<s.ListDatasetsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDatasets",
      method: "GET",
      requestUri: "/datasets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetSummaries": [toDatasetSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatastores(
    {abortSignal, ...params}: RequestConfig & s.ListDatastoresRequest = {},
  ): Promise<s.ListDatastoresResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDatastores",
      method: "GET",
      requestUri: "/datastores",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datastoreSummaries": [toDatastoreSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPipelines(
    {abortSignal, ...params}: RequestConfig & s.ListPipelinesRequest = {},
  ): Promise<s.ListPipelinesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPipelines",
      method: "GET",
      requestUri: "/pipelines",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineSummaries": [toPipelineSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const query = new URLSearchParams;
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: "/tags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async putLoggingOptions(
    {abortSignal, ...params}: RequestConfig & s.PutLoggingOptionsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      loggingOptions: fromLoggingOptions(params["loggingOptions"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLoggingOptions",
      method: "PUT",
      requestUri: "/logging",
    });
  }

  async runPipelineActivity(
    {abortSignal, ...params}: RequestConfig & s.RunPipelineActivityRequest,
  ): Promise<s.RunPipelineActivityResponse> {
    const body: jsonP.JSONObject = {
      pipelineActivity: fromPipelineActivity(params["pipelineActivity"]),
      payloads: params["payloads"]?.map(x => serializeBlob(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunPipelineActivity",
      requestUri: "/pipelineactivities/run",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "payloads": ["a"],
        "logResult": "s",
      },
    }, await resp.json());
  }

  async sampleChannelData(
    {abortSignal, ...params}: RequestConfig & s.SampleChannelDataRequest,
  ): Promise<s.SampleChannelDataResponse> {
    const query = new URLSearchParams;
    if (params["maxMessages"] != null) query.set("maxMessages", params["maxMessages"]?.toString() ?? "");
    if (params["startTime"] != null) query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    if (params["endTime"] != null) query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "SampleChannelData",
      method: "GET",
      requestUri: cmnP.encodePath`/channels/${params["channelName"]}/sample`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "payloads": ["a"],
      },
    }, await resp.json());
  }

  async startPipelineReprocessing(
    {abortSignal, ...params}: RequestConfig & s.StartPipelineReprocessingRequest,
  ): Promise<s.StartPipelineReprocessingResponse> {
    const body: jsonP.JSONObject = {
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      channelMessages: fromChannelMessages(params["channelMessages"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartPipelineReprocessing",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}/reprocessing`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reprocessingId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TagResource",
      requestUri: "/tags",
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: "/tags",
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateChannelRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      channelStorage: fromChannelStorage(params["channelStorage"]),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["channelName"]}`,
    });
  }

  async updateDataset(
    {abortSignal, ...params}: RequestConfig & s.UpdateDatasetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      actions: params["actions"]?.map(x => fromDatasetAction(x)),
      triggers: params["triggers"]?.map(x => fromDatasetTrigger(x)),
      contentDeliveryRules: params["contentDeliveryRules"]?.map(x => fromDatasetContentDeliveryRule(x)),
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      versioningConfiguration: fromVersioningConfiguration(params["versioningConfiguration"]),
      lateDataRules: params["lateDataRules"]?.map(x => fromLateDataRule(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataset",
      method: "PUT",
      requestUri: cmnP.encodePath`/datasets/${params["datasetName"]}`,
    });
  }

  async updateDatastore(
    {abortSignal, ...params}: RequestConfig & s.UpdateDatastoreRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      retentionPeriod: fromRetentionPeriod(params["retentionPeriod"]),
      datastoreStorage: fromDatastoreStorage(params["datastoreStorage"]),
      fileFormatConfiguration: fromFileFormatConfiguration(params["fileFormatConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDatastore",
      method: "PUT",
      requestUri: cmnP.encodePath`/datastores/${params["datastoreName"]}`,
    });
  }

  async updatePipeline(
    {abortSignal, ...params}: RequestConfig & s.UpdatePipelineRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pipelineActivities: params["pipelineActivities"]?.map(x => fromPipelineActivity(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipeline",
      method: "PUT",
      requestUri: cmnP.encodePath`/pipelines/${params["pipelineName"]}`,
    });
  }

}

function fromMessage(input?: s.Message | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messageId: input["messageId"],
    payload: serializeBlob(input["payload"]),
  }
}

function fromChannelStorage(input?: s.ChannelStorage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceManagedS3: fromServiceManagedChannelS3Storage(input["serviceManagedS3"]),
    customerManagedS3: fromCustomerManagedChannelS3Storage(input["customerManagedS3"]),
  }
}
function toChannelStorage(root: jsonP.JSONValue): s.ChannelStorage {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceManagedS3": toServiceManagedChannelS3Storage,
      "customerManagedS3": toCustomerManagedChannelS3Storage,
    },
  }, root);
}

function fromServiceManagedChannelS3Storage(input?: s.ServiceManagedChannelS3Storage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toServiceManagedChannelS3Storage(root: jsonP.JSONValue): s.ServiceManagedChannelS3Storage {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromCustomerManagedChannelS3Storage(input?: s.CustomerManagedChannelS3Storage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    keyPrefix: input["keyPrefix"],
    roleArn: input["roleArn"],
  }
}
function toCustomerManagedChannelS3Storage(root: jsonP.JSONValue): s.CustomerManagedChannelS3Storage {
  return jsonP.readObj({
    required: {
      "bucket": "s",
      "roleArn": "s",
    },
    optional: {
      "keyPrefix": "s",
    },
  }, root);
}

function fromRetentionPeriod(input?: s.RetentionPeriod | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    unlimited: input["unlimited"],
    numberOfDays: input["numberOfDays"],
  }
}
function toRetentionPeriod(root: jsonP.JSONValue): s.RetentionPeriod {
  return jsonP.readObj({
    required: {},
    optional: {
      "unlimited": "b",
      "numberOfDays": "n",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromDatasetAction(input?: s.DatasetAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actionName: input["actionName"],
    queryAction: fromSqlQueryDatasetAction(input["queryAction"]),
    containerAction: fromContainerDatasetAction(input["containerAction"]),
  }
}
function toDatasetAction(root: jsonP.JSONValue): s.DatasetAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionName": "s",
      "queryAction": toSqlQueryDatasetAction,
      "containerAction": toContainerDatasetAction,
    },
  }, root);
}

function fromSqlQueryDatasetAction(input?: s.SqlQueryDatasetAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sqlQuery: input["sqlQuery"],
    filters: input["filters"]?.map(x => fromQueryFilter(x)),
  }
}
function toSqlQueryDatasetAction(root: jsonP.JSONValue): s.SqlQueryDatasetAction {
  return jsonP.readObj({
    required: {
      "sqlQuery": "s",
    },
    optional: {
      "filters": [toQueryFilter],
    },
  }, root);
}

function fromQueryFilter(input?: s.QueryFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deltaTime: fromDeltaTime(input["deltaTime"]),
  }
}
function toQueryFilter(root: jsonP.JSONValue): s.QueryFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "deltaTime": toDeltaTime,
    },
  }, root);
}

function fromDeltaTime(input?: s.DeltaTime | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    offsetSeconds: input["offsetSeconds"],
    timeExpression: input["timeExpression"],
  }
}
function toDeltaTime(root: jsonP.JSONValue): s.DeltaTime {
  return jsonP.readObj({
    required: {
      "offsetSeconds": "n",
      "timeExpression": "s",
    },
    optional: {},
  }, root);
}

function fromContainerDatasetAction(input?: s.ContainerDatasetAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    image: input["image"],
    executionRoleArn: input["executionRoleArn"],
    resourceConfiguration: fromResourceConfiguration(input["resourceConfiguration"]),
    variables: input["variables"]?.map(x => fromVariable(x)),
  }
}
function toContainerDatasetAction(root: jsonP.JSONValue): s.ContainerDatasetAction {
  return jsonP.readObj({
    required: {
      "image": "s",
      "executionRoleArn": "s",
      "resourceConfiguration": toResourceConfiguration,
    },
    optional: {
      "variables": [toVariable],
    },
  }, root);
}

function fromResourceConfiguration(input?: s.ResourceConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    computeType: input["computeType"],
    volumeSizeInGB: input["volumeSizeInGB"],
  }
}
function toResourceConfiguration(root: jsonP.JSONValue): s.ResourceConfiguration {
  return jsonP.readObj({
    required: {
      "computeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComputeType>(x),
      "volumeSizeInGB": "n",
    },
    optional: {},
  }, root);
}

function fromVariable(input?: s.Variable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    stringValue: input["stringValue"],
    doubleValue: input["doubleValue"],
    datasetContentVersionValue: fromDatasetContentVersionValue(input["datasetContentVersionValue"]),
    outputFileUriValue: fromOutputFileUriValue(input["outputFileUriValue"]),
  }
}
function toVariable(root: jsonP.JSONValue): s.Variable {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "stringValue": "s",
      "doubleValue": "n",
      "datasetContentVersionValue": toDatasetContentVersionValue,
      "outputFileUriValue": toOutputFileUriValue,
    },
  }, root);
}

function fromDatasetContentVersionValue(input?: s.DatasetContentVersionValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    datasetName: input["datasetName"],
  }
}
function toDatasetContentVersionValue(root: jsonP.JSONValue): s.DatasetContentVersionValue {
  return jsonP.readObj({
    required: {
      "datasetName": "s",
    },
    optional: {},
  }, root);
}

function fromOutputFileUriValue(input?: s.OutputFileUriValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fileName: input["fileName"],
  }
}
function toOutputFileUriValue(root: jsonP.JSONValue): s.OutputFileUriValue {
  return jsonP.readObj({
    required: {
      "fileName": "s",
    },
    optional: {},
  }, root);
}

function fromDatasetTrigger(input?: s.DatasetTrigger | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    schedule: fromSchedule(input["schedule"]),
    dataset: fromTriggeringDataset(input["dataset"]),
  }
}
function toDatasetTrigger(root: jsonP.JSONValue): s.DatasetTrigger {
  return jsonP.readObj({
    required: {},
    optional: {
      "schedule": toSchedule,
      "dataset": toTriggeringDataset,
    },
  }, root);
}

function fromSchedule(input?: s.Schedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    expression: input["expression"],
  }
}
function toSchedule(root: jsonP.JSONValue): s.Schedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "expression": "s",
    },
  }, root);
}

function fromTriggeringDataset(input?: s.TriggeringDataset | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toTriggeringDataset(root: jsonP.JSONValue): s.TriggeringDataset {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {},
  }, root);
}

function fromDatasetContentDeliveryRule(input?: s.DatasetContentDeliveryRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    entryName: input["entryName"],
    destination: fromDatasetContentDeliveryDestination(input["destination"]),
  }
}
function toDatasetContentDeliveryRule(root: jsonP.JSONValue): s.DatasetContentDeliveryRule {
  return jsonP.readObj({
    required: {
      "destination": toDatasetContentDeliveryDestination,
    },
    optional: {
      "entryName": "s",
    },
  }, root);
}

function fromDatasetContentDeliveryDestination(input?: s.DatasetContentDeliveryDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    iotEventsDestinationConfiguration: fromIotEventsDestinationConfiguration(input["iotEventsDestinationConfiguration"]),
    s3DestinationConfiguration: fromS3DestinationConfiguration(input["s3DestinationConfiguration"]),
  }
}
function toDatasetContentDeliveryDestination(root: jsonP.JSONValue): s.DatasetContentDeliveryDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "iotEventsDestinationConfiguration": toIotEventsDestinationConfiguration,
      "s3DestinationConfiguration": toS3DestinationConfiguration,
    },
  }, root);
}

function fromIotEventsDestinationConfiguration(input?: s.IotEventsDestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputName: input["inputName"],
    roleArn: input["roleArn"],
  }
}
function toIotEventsDestinationConfiguration(root: jsonP.JSONValue): s.IotEventsDestinationConfiguration {
  return jsonP.readObj({
    required: {
      "inputName": "s",
      "roleArn": "s",
    },
    optional: {},
  }, root);
}

function fromS3DestinationConfiguration(input?: s.S3DestinationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    key: input["key"],
    glueConfiguration: fromGlueConfiguration(input["glueConfiguration"]),
    roleArn: input["roleArn"],
  }
}
function toS3DestinationConfiguration(root: jsonP.JSONValue): s.S3DestinationConfiguration {
  return jsonP.readObj({
    required: {
      "bucket": "s",
      "key": "s",
      "roleArn": "s",
    },
    optional: {
      "glueConfiguration": toGlueConfiguration,
    },
  }, root);
}

function fromGlueConfiguration(input?: s.GlueConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tableName: input["tableName"],
    databaseName: input["databaseName"],
  }
}
function toGlueConfiguration(root: jsonP.JSONValue): s.GlueConfiguration {
  return jsonP.readObj({
    required: {
      "tableName": "s",
      "databaseName": "s",
    },
    optional: {},
  }, root);
}

function fromVersioningConfiguration(input?: s.VersioningConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    unlimited: input["unlimited"],
    maxVersions: input["maxVersions"],
  }
}
function toVersioningConfiguration(root: jsonP.JSONValue): s.VersioningConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "unlimited": "b",
      "maxVersions": "n",
    },
  }, root);
}

function fromLateDataRule(input?: s.LateDataRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ruleName: input["ruleName"],
    ruleConfiguration: fromLateDataRuleConfiguration(input["ruleConfiguration"]),
  }
}
function toLateDataRule(root: jsonP.JSONValue): s.LateDataRule {
  return jsonP.readObj({
    required: {
      "ruleConfiguration": toLateDataRuleConfiguration,
    },
    optional: {
      "ruleName": "s",
    },
  }, root);
}

function fromLateDataRuleConfiguration(input?: s.LateDataRuleConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deltaTimeSessionWindowConfiguration: fromDeltaTimeSessionWindowConfiguration(input["deltaTimeSessionWindowConfiguration"]),
  }
}
function toLateDataRuleConfiguration(root: jsonP.JSONValue): s.LateDataRuleConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "deltaTimeSessionWindowConfiguration": toDeltaTimeSessionWindowConfiguration,
    },
  }, root);
}

function fromDeltaTimeSessionWindowConfiguration(input?: s.DeltaTimeSessionWindowConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timeoutInMinutes: input["timeoutInMinutes"],
  }
}
function toDeltaTimeSessionWindowConfiguration(root: jsonP.JSONValue): s.DeltaTimeSessionWindowConfiguration {
  return jsonP.readObj({
    required: {
      "timeoutInMinutes": "n",
    },
    optional: {},
  }, root);
}

function fromDatastoreStorage(input?: s.DatastoreStorage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceManagedS3: fromServiceManagedDatastoreS3Storage(input["serviceManagedS3"]),
    customerManagedS3: fromCustomerManagedDatastoreS3Storage(input["customerManagedS3"]),
  }
}
function toDatastoreStorage(root: jsonP.JSONValue): s.DatastoreStorage {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceManagedS3": toServiceManagedDatastoreS3Storage,
      "customerManagedS3": toCustomerManagedDatastoreS3Storage,
    },
  }, root);
}

function fromServiceManagedDatastoreS3Storage(input?: s.ServiceManagedDatastoreS3Storage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toServiceManagedDatastoreS3Storage(root: jsonP.JSONValue): s.ServiceManagedDatastoreS3Storage {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromCustomerManagedDatastoreS3Storage(input?: s.CustomerManagedDatastoreS3Storage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    keyPrefix: input["keyPrefix"],
    roleArn: input["roleArn"],
  }
}
function toCustomerManagedDatastoreS3Storage(root: jsonP.JSONValue): s.CustomerManagedDatastoreS3Storage {
  return jsonP.readObj({
    required: {
      "bucket": "s",
      "roleArn": "s",
    },
    optional: {
      "keyPrefix": "s",
    },
  }, root);
}

function fromFileFormatConfiguration(input?: s.FileFormatConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    jsonConfiguration: fromJsonConfiguration(input["jsonConfiguration"]),
    parquetConfiguration: fromParquetConfiguration(input["parquetConfiguration"]),
  }
}
function toFileFormatConfiguration(root: jsonP.JSONValue): s.FileFormatConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "jsonConfiguration": toJsonConfiguration,
      "parquetConfiguration": toParquetConfiguration,
    },
  }, root);
}

function fromJsonConfiguration(input?: s.JsonConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toJsonConfiguration(root: jsonP.JSONValue): s.JsonConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromParquetConfiguration(input?: s.ParquetConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    schemaDefinition: fromSchemaDefinition(input["schemaDefinition"]),
  }
}
function toParquetConfiguration(root: jsonP.JSONValue): s.ParquetConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "schemaDefinition": toSchemaDefinition,
    },
  }, root);
}

function fromSchemaDefinition(input?: s.SchemaDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    columns: input["columns"]?.map(x => fromColumn(x)),
  }
}
function toSchemaDefinition(root: jsonP.JSONValue): s.SchemaDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "columns": [toColumn],
    },
  }, root);
}

function fromColumn(input?: s.Column | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    type: input["type"],
  }
}
function toColumn(root: jsonP.JSONValue): s.Column {
  return jsonP.readObj({
    required: {
      "name": "s",
      "type": "s",
    },
    optional: {},
  }, root);
}

function fromPipelineActivity(input?: s.PipelineActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channel: fromChannelActivity(input["channel"]),
    lambda: fromLambdaActivity(input["lambda"]),
    datastore: fromDatastoreActivity(input["datastore"]),
    addAttributes: fromAddAttributesActivity(input["addAttributes"]),
    removeAttributes: fromRemoveAttributesActivity(input["removeAttributes"]),
    selectAttributes: fromSelectAttributesActivity(input["selectAttributes"]),
    filter: fromFilterActivity(input["filter"]),
    math: fromMathActivity(input["math"]),
    deviceRegistryEnrich: fromDeviceRegistryEnrichActivity(input["deviceRegistryEnrich"]),
    deviceShadowEnrich: fromDeviceShadowEnrichActivity(input["deviceShadowEnrich"]),
  }
}
function toPipelineActivity(root: jsonP.JSONValue): s.PipelineActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "channel": toChannelActivity,
      "lambda": toLambdaActivity,
      "datastore": toDatastoreActivity,
      "addAttributes": toAddAttributesActivity,
      "removeAttributes": toRemoveAttributesActivity,
      "selectAttributes": toSelectAttributesActivity,
      "filter": toFilterActivity,
      "math": toMathActivity,
      "deviceRegistryEnrich": toDeviceRegistryEnrichActivity,
      "deviceShadowEnrich": toDeviceShadowEnrichActivity,
    },
  }, root);
}

function fromChannelActivity(input?: s.ChannelActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    channelName: input["channelName"],
    next: input["next"],
  }
}
function toChannelActivity(root: jsonP.JSONValue): s.ChannelActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "channelName": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

function fromLambdaActivity(input?: s.LambdaActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    lambdaName: input["lambdaName"],
    batchSize: input["batchSize"],
    next: input["next"],
  }
}
function toLambdaActivity(root: jsonP.JSONValue): s.LambdaActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "lambdaName": "s",
      "batchSize": "n",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

function fromDatastoreActivity(input?: s.DatastoreActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    datastoreName: input["datastoreName"],
  }
}
function toDatastoreActivity(root: jsonP.JSONValue): s.DatastoreActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "datastoreName": "s",
    },
    optional: {},
  }, root);
}

function fromAddAttributesActivity(input?: s.AddAttributesActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attributes: input["attributes"],
    next: input["next"],
  }
}
function toAddAttributesActivity(root: jsonP.JSONValue): s.AddAttributesActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attributes": x => jsonP.readMap(String, String, x),
    },
    optional: {
      "next": "s",
    },
  }, root);
}

function fromRemoveAttributesActivity(input?: s.RemoveAttributesActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attributes: input["attributes"],
    next: input["next"],
  }
}
function toRemoveAttributesActivity(root: jsonP.JSONValue): s.RemoveAttributesActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attributes": ["s"],
    },
    optional: {
      "next": "s",
    },
  }, root);
}

function fromSelectAttributesActivity(input?: s.SelectAttributesActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attributes: input["attributes"],
    next: input["next"],
  }
}
function toSelectAttributesActivity(root: jsonP.JSONValue): s.SelectAttributesActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attributes": ["s"],
    },
    optional: {
      "next": "s",
    },
  }, root);
}

function fromFilterActivity(input?: s.FilterActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    filter: input["filter"],
    next: input["next"],
  }
}
function toFilterActivity(root: jsonP.JSONValue): s.FilterActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "filter": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

function fromMathActivity(input?: s.MathActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attribute: input["attribute"],
    math: input["math"],
    next: input["next"],
  }
}
function toMathActivity(root: jsonP.JSONValue): s.MathActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attribute": "s",
      "math": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

function fromDeviceRegistryEnrichActivity(input?: s.DeviceRegistryEnrichActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attribute: input["attribute"],
    thingName: input["thingName"],
    roleArn: input["roleArn"],
    next: input["next"],
  }
}
function toDeviceRegistryEnrichActivity(root: jsonP.JSONValue): s.DeviceRegistryEnrichActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attribute": "s",
      "thingName": "s",
      "roleArn": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

function fromDeviceShadowEnrichActivity(input?: s.DeviceShadowEnrichActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    attribute: input["attribute"],
    thingName: input["thingName"],
    roleArn: input["roleArn"],
    next: input["next"],
  }
}
function toDeviceShadowEnrichActivity(root: jsonP.JSONValue): s.DeviceShadowEnrichActivity {
  return jsonP.readObj({
    required: {
      "name": "s",
      "attribute": "s",
      "thingName": "s",
      "roleArn": "s",
    },
    optional: {
      "next": "s",
    },
  }, root);
}

function fromLoggingOptions(input?: s.LoggingOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["roleArn"],
    level: input["level"],
    enabled: input["enabled"],
  }
}
function toLoggingOptions(root: jsonP.JSONValue): s.LoggingOptions {
  return jsonP.readObj({
    required: {
      "roleArn": "s",
      "level": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoggingLevel>(x),
      "enabled": "b",
    },
    optional: {},
  }, root);
}

function fromChannelMessages(input?: s.ChannelMessages | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Paths: input["s3Paths"],
  }
}

function toBatchPutMessageErrorEntry(root: jsonP.JSONValue): s.BatchPutMessageErrorEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "messageId": "s",
      "errorCode": "s",
      "errorMessage": "s",
    },
  }, root);
}

function toChannel(root: jsonP.JSONValue): s.Channel {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "storage": toChannelStorage,
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelStatus>(x),
      "retentionPeriod": toRetentionPeriod,
      "creationTime": "d",
      "lastUpdateTime": "d",
      "lastMessageArrivalTime": "d",
    },
  }, root);
}

function toChannelStatistics(root: jsonP.JSONValue): s.ChannelStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "size": toEstimatedResourceSize,
    },
  }, root);
}

function toEstimatedResourceSize(root: jsonP.JSONValue): s.EstimatedResourceSize {
  return jsonP.readObj({
    required: {},
    optional: {
      "estimatedSizeInBytes": "n",
      "estimatedOn": "d",
    },
  }, root);
}

function toDataset(root: jsonP.JSONValue): s.Dataset {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "actions": [toDatasetAction],
      "triggers": [toDatasetTrigger],
      "contentDeliveryRules": [toDatasetContentDeliveryRule],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatasetStatus>(x),
      "creationTime": "d",
      "lastUpdateTime": "d",
      "retentionPeriod": toRetentionPeriod,
      "versioningConfiguration": toVersioningConfiguration,
      "lateDataRules": [toLateDataRule],
    },
  }, root);
}

function toDatastore(root: jsonP.JSONValue): s.Datastore {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "storage": toDatastoreStorage,
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatastoreStatus>(x),
      "retentionPeriod": toRetentionPeriod,
      "creationTime": "d",
      "lastUpdateTime": "d",
      "lastMessageArrivalTime": "d",
      "fileFormatConfiguration": toFileFormatConfiguration,
    },
  }, root);
}

function toDatastoreStatistics(root: jsonP.JSONValue): s.DatastoreStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "size": toEstimatedResourceSize,
    },
  }, root);
}

function toPipeline(root: jsonP.JSONValue): s.Pipeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "activities": [toPipelineActivity],
      "reprocessingSummaries": [toReprocessingSummary],
      "creationTime": "d",
      "lastUpdateTime": "d",
    },
  }, root);
}

function toReprocessingSummary(root: jsonP.JSONValue): s.ReprocessingSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReprocessingStatus>(x),
      "creationTime": "d",
    },
  }, root);
}

function toDatasetEntry(root: jsonP.JSONValue): s.DatasetEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "entryName": "s",
      "dataURI": "s",
    },
  }, root);
}

function toDatasetContentStatus(root: jsonP.JSONValue): s.DatasetContentStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatasetContentState>(x),
      "reason": "s",
    },
  }, root);
}

function toChannelSummary(root: jsonP.JSONValue): s.ChannelSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "channelName": "s",
      "channelStorage": toChannelStorageSummary,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelStatus>(x),
      "creationTime": "d",
      "lastUpdateTime": "d",
      "lastMessageArrivalTime": "d",
    },
  }, root);
}

function toChannelStorageSummary(root: jsonP.JSONValue): s.ChannelStorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceManagedS3": toServiceManagedChannelS3StorageSummary,
      "customerManagedS3": toCustomerManagedChannelS3StorageSummary,
    },
  }, root);
}

function toServiceManagedChannelS3StorageSummary(root: jsonP.JSONValue): s.ServiceManagedChannelS3StorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function toCustomerManagedChannelS3StorageSummary(root: jsonP.JSONValue): s.CustomerManagedChannelS3StorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "keyPrefix": "s",
      "roleArn": "s",
    },
  }, root);
}

function toDatasetContentSummary(root: jsonP.JSONValue): s.DatasetContentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "version": "s",
      "status": toDatasetContentStatus,
      "creationTime": "d",
      "scheduleTime": "d",
      "completionTime": "d",
    },
  }, root);
}

function toDatasetSummary(root: jsonP.JSONValue): s.DatasetSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "datasetName": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatasetStatus>(x),
      "creationTime": "d",
      "lastUpdateTime": "d",
      "triggers": [toDatasetTrigger],
      "actions": [toDatasetActionSummary],
    },
  }, root);
}

function toDatasetActionSummary(root: jsonP.JSONValue): s.DatasetActionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionName": "s",
      "actionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatasetActionType>(x),
    },
  }, root);
}

function toDatastoreSummary(root: jsonP.JSONValue): s.DatastoreSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "datastoreName": "s",
      "datastoreStorage": toDatastoreStorageSummary,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatastoreStatus>(x),
      "creationTime": "d",
      "lastUpdateTime": "d",
      "lastMessageArrivalTime": "d",
      "fileFormatType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileFormatType>(x),
    },
  }, root);
}

function toDatastoreStorageSummary(root: jsonP.JSONValue): s.DatastoreStorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceManagedS3": toServiceManagedDatastoreS3StorageSummary,
      "customerManagedS3": toCustomerManagedDatastoreS3StorageSummary,
    },
  }, root);
}

function toServiceManagedDatastoreS3StorageSummary(root: jsonP.JSONValue): s.ServiceManagedDatastoreS3StorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function toCustomerManagedDatastoreS3StorageSummary(root: jsonP.JSONValue): s.CustomerManagedDatastoreS3StorageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "keyPrefix": "s",
      "roleArn": "s",
    },
  }, root);
}

function toPipelineSummary(root: jsonP.JSONValue): s.PipelineSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "pipelineName": "s",
      "reprocessingSummaries": [toReprocessingSummary],
      "creationTime": "d",
      "lastUpdateTime": "d",
    },
  }, root);
}
