// Autogenerated API client for: Amazon Interactive Video Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class IVS {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(IVS.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2020-07-14",
    "endpointPrefix": "ivs",
    "protocol": "rest-json",
    "serviceAbbreviation": "Amazon IVS",
    "serviceFullName": "Amazon Interactive Video Service",
    "serviceId": "ivs",
    "signatureVersion": "v4",
    "signingName": "ivs",
    "uid": "ivs-2020-07-14"
  };

  async batchGetChannel(
    {abortSignal, ...params}: RequestConfig & BatchGetChannelRequest,
  ): Promise<BatchGetChannelResponse> {
    const body: jsonP.JSONObject = {
      arns: params["arns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetChannel",
      requestUri: "/BatchGetChannel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channels": [toChannel],
        "errors": [toBatchError],
      },
    }, await resp.json());
  }

  async batchGetStreamKey(
    {abortSignal, ...params}: RequestConfig & BatchGetStreamKeyRequest,
  ): Promise<BatchGetStreamKeyResponse> {
    const body: jsonP.JSONObject = {
      arns: params["arns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetStreamKey",
      requestUri: "/BatchGetStreamKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streamKeys": [toStreamKey],
        "errors": [toBatchError],
      },
    }, await resp.json());
  }

  async createChannel(
    {abortSignal, ...params}: RequestConfig & CreateChannelRequest = {},
  ): Promise<CreateChannelResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      latencyMode: params["latencyMode"],
      type: params["type"],
      authorized: params["authorized"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChannel",
      requestUri: "/CreateChannel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channel": toChannel,
        "streamKey": toStreamKey,
      },
    }, await resp.json());
  }

  async createStreamKey(
    {abortSignal, ...params}: RequestConfig & CreateStreamKeyRequest,
  ): Promise<CreateStreamKeyResponse> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamKey",
      requestUri: "/CreateStreamKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streamKey": toStreamKey,
      },
    }, await resp.json());
  }

  async deleteChannel(
    {abortSignal, ...params}: RequestConfig & DeleteChannelRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteChannel",
      requestUri: "/DeleteChannel",
    });
  }

  async deletePlaybackKeyPair(
    {abortSignal, ...params}: RequestConfig & DeletePlaybackKeyPairRequest,
  ): Promise<DeletePlaybackKeyPairResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePlaybackKeyPair",
      requestUri: "/DeletePlaybackKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteStreamKey(
    {abortSignal, ...params}: RequestConfig & DeleteStreamKeyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStreamKey",
      requestUri: "/DeleteStreamKey",
    });
  }

  async getChannel(
    {abortSignal, ...params}: RequestConfig & GetChannelRequest,
  ): Promise<GetChannelResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetChannel",
      requestUri: "/GetChannel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channel": toChannel,
      },
    }, await resp.json());
  }

  async getPlaybackKeyPair(
    {abortSignal, ...params}: RequestConfig & GetPlaybackKeyPairRequest,
  ): Promise<GetPlaybackKeyPairResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPlaybackKeyPair",
      requestUri: "/GetPlaybackKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "keyPair": toPlaybackKeyPair,
      },
    }, await resp.json());
  }

  async getStream(
    {abortSignal, ...params}: RequestConfig & GetStreamRequest,
  ): Promise<GetStreamResponse> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStream",
      requestUri: "/GetStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "stream": toStream,
      },
    }, await resp.json());
  }

  async getStreamKey(
    {abortSignal, ...params}: RequestConfig & GetStreamKeyRequest,
  ): Promise<GetStreamKeyResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStreamKey",
      requestUri: "/GetStreamKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streamKey": toStreamKey,
      },
    }, await resp.json());
  }

  async importPlaybackKeyPair(
    {abortSignal, ...params}: RequestConfig & ImportPlaybackKeyPairRequest,
  ): Promise<ImportPlaybackKeyPairResponse> {
    const body: jsonP.JSONObject = {
      publicKeyMaterial: params["publicKeyMaterial"],
      name: params["name"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportPlaybackKeyPair",
      requestUri: "/ImportPlaybackKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "keyPair": toPlaybackKeyPair,
      },
    }, await resp.json());
  }

  async listChannels(
    {abortSignal, ...params}: RequestConfig & ListChannelsRequest = {},
  ): Promise<ListChannelsResponse> {
    const body: jsonP.JSONObject = {
      filterByName: params["filterByName"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListChannels",
      requestUri: "/ListChannels",
    });
    return jsonP.readObj({
      required: {
        "channels": [toChannelSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPlaybackKeyPairs(
    {abortSignal, ...params}: RequestConfig & ListPlaybackKeyPairsRequest = {},
  ): Promise<ListPlaybackKeyPairsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPlaybackKeyPairs",
      requestUri: "/ListPlaybackKeyPairs",
    });
    return jsonP.readObj({
      required: {
        "keyPairs": [toPlaybackKeyPairSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listStreamKeys(
    {abortSignal, ...params}: RequestConfig & ListStreamKeysRequest,
  ): Promise<ListStreamKeysResponse> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStreamKeys",
      requestUri: "/ListStreamKeys",
    });
    return jsonP.readObj({
      required: {
        "streamKeys": [toStreamKeySummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listStreams(
    {abortSignal, ...params}: RequestConfig & ListStreamsRequest = {},
  ): Promise<ListStreamsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStreams",
      requestUri: "/ListStreams",
    });
    return jsonP.readObj({
      required: {
        "streams": [toStreamSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {
        "tags": x => jsonP.readMap(String, String, x),
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async putMetadata(
    {abortSignal, ...params}: RequestConfig & PutMetadataRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
      metadata: params["metadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMetadata",
      requestUri: "/PutMetadata",
    });
  }

  async stopStream(
    {abortSignal, ...params}: RequestConfig & StopStreamRequest,
  ): Promise<StopStreamResponse> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopStream",
      requestUri: "/StopStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateChannel(
    {abortSignal, ...params}: RequestConfig & UpdateChannelRequest,
  ): Promise<UpdateChannelResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
      name: params["name"],
      latencyMode: params["latencyMode"],
      type: params["type"],
      authorized: params["authorized"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannel",
      requestUri: "/UpdateChannel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channel": toChannel,
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface BatchGetChannelRequest {
  arns: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetStreamKeyRequest {
  arns: string[];
}

// refs: 1 - tags: named, input
export interface CreateChannelRequest {
  name?: string | null;
  latencyMode?: ChannelLatencyMode | null;
  type?: ChannelType | null;
  authorized?: boolean | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateStreamKeyRequest {
  channelArn: string;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface DeleteChannelRequest {
  arn: string;
}

// refs: 1 - tags: named, input
export interface DeletePlaybackKeyPairRequest {
  arn: string;
}

// refs: 1 - tags: named, input
export interface DeleteStreamKeyRequest {
  arn: string;
}

// refs: 1 - tags: named, input
export interface GetChannelRequest {
  arn: string;
}

// refs: 1 - tags: named, input
export interface GetPlaybackKeyPairRequest {
  arn: string;
}

// refs: 1 - tags: named, input
export interface GetStreamRequest {
  channelArn: string;
}

// refs: 1 - tags: named, input
export interface GetStreamKeyRequest {
  arn: string;
}

// refs: 1 - tags: named, input
export interface ImportPlaybackKeyPairRequest {
  publicKeyMaterial: string;
  name?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface ListChannelsRequest {
  filterByName?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListPlaybackKeyPairsRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListStreamKeysRequest {
  channelArn: string;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListStreamsRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface PutMetadataRequest {
  channelArn: string;
  metadata: string;
}

// refs: 1 - tags: named, input
export interface StopStreamRequest {
  channelArn: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateChannelRequest {
  arn: string;
  name?: string | null;
  latencyMode?: ChannelLatencyMode | null;
  type?: ChannelType | null;
  authorized?: boolean | null;
}

// refs: 1 - tags: named, output
export interface BatchGetChannelResponse {
  channels?: Channel[] | null;
  errors?: BatchError[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetStreamKeyResponse {
  streamKeys?: StreamKey[] | null;
  errors?: BatchError[] | null;
}

// refs: 1 - tags: named, output
export interface CreateChannelResponse {
  channel?: Channel | null;
  streamKey?: StreamKey | null;
}

// refs: 1 - tags: named, output
export interface CreateStreamKeyResponse {
  streamKey?: StreamKey | null;
}

// refs: 1 - tags: named, output
export interface DeletePlaybackKeyPairResponse {
}

// refs: 1 - tags: named, output
export interface GetChannelResponse {
  channel?: Channel | null;
}

// refs: 1 - tags: named, output
export interface GetPlaybackKeyPairResponse {
  keyPair?: PlaybackKeyPair | null;
}

// refs: 1 - tags: named, output
export interface GetStreamResponse {
  stream?: Stream | null;
}

// refs: 1 - tags: named, output
export interface GetStreamKeyResponse {
  streamKey?: StreamKey | null;
}

// refs: 1 - tags: named, output
export interface ImportPlaybackKeyPairResponse {
  keyPair?: PlaybackKeyPair | null;
}

// refs: 1 - tags: named, output
export interface ListChannelsResponse {
  channels: ChannelSummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPlaybackKeyPairsResponse {
  keyPairs: PlaybackKeyPairSummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStreamKeysResponse {
  streamKeys: StreamKeySummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStreamsResponse {
  streams: StreamSummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags: { [key: string]: string | null | undefined };
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface StopStreamResponse {
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateChannelResponse {
  channel?: Channel | null;
}

// refs: 7 - tags: input, named, enum, output
export type ChannelLatencyMode =
| "NORMAL"
| "LOW"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type ChannelType =
| "BASIC"
| "STANDARD"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Channel {
  arn?: string | null;
  name?: string | null;
  latencyMode?: ChannelLatencyMode | null;
  type?: ChannelType | null;
  ingestEndpoint?: string | null;
  playbackUrl?: string | null;
  authorized?: boolean | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toChannel(root: jsonP.JSONValue): Channel {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "latencyMode": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelLatencyMode>(x),
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelType>(x),
      "ingestEndpoint": "s",
      "playbackUrl": "s",
      "authorized": "b",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface BatchError {
  arn?: string | null;
  code?: string | null;
  message?: string | null;
}
function toBatchError(root: jsonP.JSONValue): BatchError {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "code": "s",
      "message": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface StreamKey {
  arn?: string | null;
  value?: string | null;
  channelArn?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toStreamKey(root: jsonP.JSONValue): StreamKey {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "value": "s",
      "channelArn": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface PlaybackKeyPair {
  arn?: string | null;
  name?: string | null;
  fingerprint?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toPlaybackKeyPair(root: jsonP.JSONValue): PlaybackKeyPair {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "fingerprint": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Stream {
  channelArn?: string | null;
  playbackUrl?: string | null;
  startTime?: Date | number | null;
  state?: StreamState | null;
  health?: StreamHealth | null;
  viewerCount?: number | null;
}
function toStream(root: jsonP.JSONValue): Stream {
  return jsonP.readObj({
    required: {},
    optional: {
      "channelArn": "s",
      "playbackUrl": "s",
      "startTime": "d",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<StreamState>(x),
      "health": (x: jsonP.JSONValue) => cmnP.readEnum<StreamHealth>(x),
      "viewerCount": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type StreamState =
| "LIVE"
| "OFFLINE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type StreamHealth =
| "HEALTHY"
| "STARVING"
| "UNKNOWN"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ChannelSummary {
  arn?: string | null;
  name?: string | null;
  latencyMode?: ChannelLatencyMode | null;
  authorized?: boolean | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toChannelSummary(root: jsonP.JSONValue): ChannelSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "latencyMode": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelLatencyMode>(x),
      "authorized": "b",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PlaybackKeyPairSummary {
  arn?: string | null;
  name?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toPlaybackKeyPairSummary(root: jsonP.JSONValue): PlaybackKeyPairSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StreamKeySummary {
  arn?: string | null;
  channelArn?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toStreamKeySummary(root: jsonP.JSONValue): StreamKeySummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "channelArn": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StreamSummary {
  channelArn?: string | null;
  state?: StreamState | null;
  health?: StreamHealth | null;
  viewerCount?: number | null;
  startTime?: Date | number | null;
}
function toStreamSummary(root: jsonP.JSONValue): StreamSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "channelArn": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<StreamState>(x),
      "health": (x: jsonP.JSONValue) => cmnP.readEnum<StreamHealth>(x),
      "viewerCount": "n",
      "startTime": "d",
    },
  }, root);
}
