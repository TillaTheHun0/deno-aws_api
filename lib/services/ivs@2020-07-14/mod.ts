// Autogenerated API client for: Amazon Interactive Video Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class IVS {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(IVS.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2020-07-14",
    "endpointPrefix": "ivs",
    "protocol": "rest-json",
    "serviceAbbreviation": "Amazon IVS",
    "serviceFullName": "Amazon Interactive Video Service",
    "serviceId": "ivs",
    "signatureVersion": "v4",
    "signingName": "ivs",
    "uid": "ivs-2020-07-14"
  };

  async batchGetChannel(
    {abortSignal, ...params}: RequestConfig & s.BatchGetChannelRequest,
  ): Promise<s.BatchGetChannelResponse> {
    const body: jsonP.JSONObject = {
      arns: params["arns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetChannel",
      requestUri: "/BatchGetChannel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channels": [toChannel],
        "errors": [toBatchError],
      },
    }, await resp.json());
  }

  async batchGetStreamKey(
    {abortSignal, ...params}: RequestConfig & s.BatchGetStreamKeyRequest,
  ): Promise<s.BatchGetStreamKeyResponse> {
    const body: jsonP.JSONObject = {
      arns: params["arns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetStreamKey",
      requestUri: "/BatchGetStreamKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streamKeys": [toStreamKey],
        "errors": [toBatchError],
      },
    }, await resp.json());
  }

  async createChannel(
    {abortSignal, ...params}: RequestConfig & s.CreateChannelRequest = {},
  ): Promise<s.CreateChannelResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      latencyMode: params["latencyMode"],
      type: params["type"],
      authorized: params["authorized"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChannel",
      requestUri: "/CreateChannel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channel": toChannel,
        "streamKey": toStreamKey,
      },
    }, await resp.json());
  }

  async createStreamKey(
    {abortSignal, ...params}: RequestConfig & s.CreateStreamKeyRequest,
  ): Promise<s.CreateStreamKeyResponse> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamKey",
      requestUri: "/CreateStreamKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streamKey": toStreamKey,
      },
    }, await resp.json());
  }

  async deleteChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteChannelRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteChannel",
      requestUri: "/DeleteChannel",
      responseCode: 204,
    });
    await resp.text();
  }

  async deletePlaybackKeyPair(
    {abortSignal, ...params}: RequestConfig & s.DeletePlaybackKeyPairRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePlaybackKeyPair",
      requestUri: "/DeletePlaybackKeyPair",
    });
    await resp.text();
  }

  async deleteStreamKey(
    {abortSignal, ...params}: RequestConfig & s.DeleteStreamKeyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStreamKey",
      requestUri: "/DeleteStreamKey",
      responseCode: 204,
    });
    await resp.text();
  }

  async getChannel(
    {abortSignal, ...params}: RequestConfig & s.GetChannelRequest,
  ): Promise<s.GetChannelResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetChannel",
      requestUri: "/GetChannel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channel": toChannel,
      },
    }, await resp.json());
  }

  async getPlaybackKeyPair(
    {abortSignal, ...params}: RequestConfig & s.GetPlaybackKeyPairRequest,
  ): Promise<s.GetPlaybackKeyPairResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPlaybackKeyPair",
      requestUri: "/GetPlaybackKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "keyPair": toPlaybackKeyPair,
      },
    }, await resp.json());
  }

  async getStream(
    {abortSignal, ...params}: RequestConfig & s.GetStreamRequest,
  ): Promise<s.GetStreamResponse> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStream",
      requestUri: "/GetStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "stream": toStream,
      },
    }, await resp.json());
  }

  async getStreamKey(
    {abortSignal, ...params}: RequestConfig & s.GetStreamKeyRequest,
  ): Promise<s.GetStreamKeyResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStreamKey",
      requestUri: "/GetStreamKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "streamKey": toStreamKey,
      },
    }, await resp.json());
  }

  async importPlaybackKeyPair(
    {abortSignal, ...params}: RequestConfig & s.ImportPlaybackKeyPairRequest,
  ): Promise<s.ImportPlaybackKeyPairResponse> {
    const body: jsonP.JSONObject = {
      publicKeyMaterial: params["publicKeyMaterial"],
      name: params["name"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportPlaybackKeyPair",
      requestUri: "/ImportPlaybackKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "keyPair": toPlaybackKeyPair,
      },
    }, await resp.json());
  }

  async listChannels(
    {abortSignal, ...params}: RequestConfig & s.ListChannelsRequest = {},
  ): Promise<s.ListChannelsResponse> {
    const body: jsonP.JSONObject = {
      filterByName: params["filterByName"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListChannels",
      requestUri: "/ListChannels",
    });
    return jsonP.readObj({
      required: {
        "channels": [toChannelSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPlaybackKeyPairs(
    {abortSignal, ...params}: RequestConfig & s.ListPlaybackKeyPairsRequest = {},
  ): Promise<s.ListPlaybackKeyPairsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPlaybackKeyPairs",
      requestUri: "/ListPlaybackKeyPairs",
    });
    return jsonP.readObj({
      required: {
        "keyPairs": [toPlaybackKeyPairSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listStreamKeys(
    {abortSignal, ...params}: RequestConfig & s.ListStreamKeysRequest,
  ): Promise<s.ListStreamKeysResponse> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStreamKeys",
      requestUri: "/ListStreamKeys",
    });
    return jsonP.readObj({
      required: {
        "streamKeys": [toStreamKeySummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listStreams(
    {abortSignal, ...params}: RequestConfig & s.ListStreamsRequest = {},
  ): Promise<s.ListStreamsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStreams",
      requestUri: "/ListStreams",
    });
    return jsonP.readObj({
      required: {
        "streams": [toStreamSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {
        "tags": x => jsonP.readMap(String, String, x),
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async putMetadata(
    {abortSignal, ...params}: RequestConfig & s.PutMetadataRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
      metadata: params["metadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMetadata",
      requestUri: "/PutMetadata",
    });
    await resp.text();
  }

  async stopStream(
    {abortSignal, ...params}: RequestConfig & s.StopStreamRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      channelArn: params["channelArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopStream",
      requestUri: "/StopStream",
    });
    await resp.text();
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    await resp.text();
  }

  async updateChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateChannelRequest,
  ): Promise<s.UpdateChannelResponse> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
      name: params["name"],
      latencyMode: params["latencyMode"],
      type: params["type"],
      authorized: params["authorized"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannel",
      requestUri: "/UpdateChannel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "channel": toChannel,
      },
    }, await resp.json());
  }

}

function toChannel(root: jsonP.JSONValue): s.Channel {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "latencyMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelLatencyMode>(x),
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelType>(x),
      "ingestEndpoint": "s",
      "playbackUrl": "s",
      "authorized": "b",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toBatchError(root: jsonP.JSONValue): s.BatchError {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "code": "s",
      "message": "s",
    },
  }, root);
}

function toStreamKey(root: jsonP.JSONValue): s.StreamKey {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "value": "s",
      "channelArn": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toPlaybackKeyPair(root: jsonP.JSONValue): s.PlaybackKeyPair {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "fingerprint": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toStream(root: jsonP.JSONValue): s.Stream {
  return jsonP.readObj({
    required: {},
    optional: {
      "channelArn": "s",
      "playbackUrl": "s",
      "startTime": "d",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamState>(x),
      "health": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamHealth>(x),
      "viewerCount": "n",
    },
  }, root);
}

function toChannelSummary(root: jsonP.JSONValue): s.ChannelSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "latencyMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelLatencyMode>(x),
      "authorized": "b",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toPlaybackKeyPairSummary(root: jsonP.JSONValue): s.PlaybackKeyPairSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toStreamKeySummary(root: jsonP.JSONValue): s.StreamKeySummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "channelArn": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toStreamSummary(root: jsonP.JSONValue): s.StreamSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "channelArn": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamState>(x),
      "health": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamHealth>(x),
      "viewerCount": "n",
      "startTime": "d",
    },
  }, root);
}
