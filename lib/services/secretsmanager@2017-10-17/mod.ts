// Autogenerated API client for: AWS Secrets Manager

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class SecretsManager {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SecretsManager.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-10-17",
    "endpointPrefix": "secretsmanager",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Secrets Manager",
    "serviceId": "Secrets Manager",
    "signatureVersion": "v4",
    "signingName": "secretsmanager",
    "targetPrefix": "secretsmanager",
    "uid": "secretsmanager-2017-10-17"
  };

  async cancelRotateSecret(
    {abortSignal, ...params}: RequestConfig & s.CancelRotateSecretRequest,
  ): Promise<s.CancelRotateSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelRotateSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
      },
    }, await resp.json());
  }

  async createSecret(
    {abortSignal, ...params}: RequestConfig & s.CreateSecretRequest,
  ): Promise<s.CreateSecretResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      Description: params["Description"],
      KmsKeyId: params["KmsKeyId"],
      SecretBinary: serializeBlob(params["SecretBinary"]),
      SecretString: params["SecretString"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
      },
    }, await resp.json());
  }

  async deleteResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteResourcePolicyRequest,
  ): Promise<s.DeleteResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async deleteSecret(
    {abortSignal, ...params}: RequestConfig & s.DeleteSecretRequest,
  ): Promise<s.DeleteSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      RecoveryWindowInDays: params["RecoveryWindowInDays"],
      ForceDeleteWithoutRecovery: params["ForceDeleteWithoutRecovery"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "DeletionDate": "d",
      },
    }, await resp.json());
  }

  async describeSecret(
    {abortSignal, ...params}: RequestConfig & s.DescribeSecretRequest,
  ): Promise<s.DescribeSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "Description": "s",
        "KmsKeyId": "s",
        "RotationEnabled": "b",
        "RotationLambdaARN": "s",
        "RotationRules": toRotationRulesType,
        "LastRotatedDate": "d",
        "LastChangedDate": "d",
        "LastAccessedDate": "d",
        "DeletedDate": "d",
        "Tags": [toTag],
        "VersionIdsToStages": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
        "OwningService": "s",
        "CreatedDate": "d",
      },
    }, await resp.json());
  }

  async getRandomPassword(
    {abortSignal, ...params}: RequestConfig & s.GetRandomPasswordRequest = {},
  ): Promise<s.GetRandomPasswordResponse> {
    const body: jsonP.JSONObject = {
      PasswordLength: params["PasswordLength"],
      ExcludeCharacters: params["ExcludeCharacters"],
      ExcludeNumbers: params["ExcludeNumbers"],
      ExcludePunctuation: params["ExcludePunctuation"],
      ExcludeUppercase: params["ExcludeUppercase"],
      ExcludeLowercase: params["ExcludeLowercase"],
      IncludeSpace: params["IncludeSpace"],
      RequireEachIncludedType: params["RequireEachIncludedType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRandomPassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RandomPassword": "s",
      },
    }, await resp.json());
  }

  async getResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.GetResourcePolicyRequest,
  ): Promise<s.GetResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "ResourcePolicy": "s",
      },
    }, await resp.json());
  }

  async getSecretValue(
    {abortSignal, ...params}: RequestConfig & s.GetSecretValueRequest,
  ): Promise<s.GetSecretValueResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      VersionId: params["VersionId"],
      VersionStage: params["VersionStage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSecretValue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
        "SecretBinary": "a",
        "SecretString": "s",
        "VersionStages": ["s"],
        "CreatedDate": "d",
      },
    }, await resp.json());
  }

  async listSecretVersionIds(
    {abortSignal, ...params}: RequestConfig & s.ListSecretVersionIdsRequest,
  ): Promise<s.ListSecretVersionIdsResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      IncludeDeprecated: params["IncludeDeprecated"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSecretVersionIds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Versions": [toSecretVersionsListEntry],
        "NextToken": "s",
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async listSecrets(
    {abortSignal, ...params}: RequestConfig & s.ListSecretsRequest = {},
  ): Promise<s.ListSecretsResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSecrets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecretList": [toSecretListEntry],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.PutResourcePolicyRequest,
  ): Promise<s.PutResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ResourcePolicy: params["ResourcePolicy"],
      BlockPublicPolicy: params["BlockPublicPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async putSecretValue(
    {abortSignal, ...params}: RequestConfig & s.PutSecretValueRequest,
  ): Promise<s.PutSecretValueResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      SecretBinary: serializeBlob(params["SecretBinary"]),
      SecretString: params["SecretString"],
      VersionStages: params["VersionStages"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutSecretValue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
        "VersionStages": ["s"],
      },
    }, await resp.json());
  }

  async restoreSecret(
    {abortSignal, ...params}: RequestConfig & s.RestoreSecretRequest,
  ): Promise<s.RestoreSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async rotateSecret(
    {abortSignal, ...params}: RequestConfig & s.RotateSecretRequest,
  ): Promise<s.RotateSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      RotationLambdaARN: params["RotationLambdaARN"],
      RotationRules: fromRotationRulesType(params["RotationRules"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RotateSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
  }

  async updateSecret(
    {abortSignal, ...params}: RequestConfig & s.UpdateSecretRequest,
  ): Promise<s.UpdateSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      Description: params["Description"],
      KmsKeyId: params["KmsKeyId"],
      SecretBinary: serializeBlob(params["SecretBinary"]),
      SecretString: params["SecretString"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
      },
    }, await resp.json());
  }

  async updateSecretVersionStage(
    {abortSignal, ...params}: RequestConfig & s.UpdateSecretVersionStageRequest,
  ): Promise<s.UpdateSecretVersionStageResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      VersionStage: params["VersionStage"],
      RemoveFromVersionId: params["RemoveFromVersionId"],
      MoveToVersionId: params["MoveToVersionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSecretVersionStage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async validateResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.ValidateResourcePolicyRequest,
  ): Promise<s.ValidateResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ResourcePolicy: params["ResourcePolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ValidateResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyValidationPassed": "b",
        "ValidationErrors": [toValidationErrorsEntry],
      },
    }, await resp.json());
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromFilter(input?: s.Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

function fromRotationRulesType(input?: s.RotationRulesType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AutomaticallyAfterDays: input["AutomaticallyAfterDays"],
  }
}
function toRotationRulesType(root: jsonP.JSONValue): s.RotationRulesType {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomaticallyAfterDays": "n",
    },
  }, root);
}

function toSecretVersionsListEntry(root: jsonP.JSONValue): s.SecretVersionsListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "VersionId": "s",
      "VersionStages": ["s"],
      "LastAccessedDate": "d",
      "CreatedDate": "d",
    },
  }, root);
}

function toSecretListEntry(root: jsonP.JSONValue): s.SecretListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "ARN": "s",
      "Name": "s",
      "Description": "s",
      "KmsKeyId": "s",
      "RotationEnabled": "b",
      "RotationLambdaARN": "s",
      "RotationRules": toRotationRulesType,
      "LastRotatedDate": "d",
      "LastChangedDate": "d",
      "LastAccessedDate": "d",
      "DeletedDate": "d",
      "Tags": [toTag],
      "SecretVersionsToStages": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "OwningService": "s",
      "CreatedDate": "d",
    },
  }, root);
}

function toValidationErrorsEntry(root: jsonP.JSONValue): s.ValidationErrorsEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "CheckName": "s",
      "ErrorMessage": "s",
    },
  }, root);
}
