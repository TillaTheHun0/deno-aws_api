// Autogenerated API client for: AWS Secrets Manager

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class SecretsManager {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SecretsManager.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-10-17",
    "endpointPrefix": "secretsmanager",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Secrets Manager",
    "serviceId": "Secrets Manager",
    "signatureVersion": "v4",
    "signingName": "secretsmanager",
    "targetPrefix": "secretsmanager",
    "uid": "secretsmanager-2017-10-17"
  };

  async cancelRotateSecret(
    {abortSignal, ...params}: RequestConfig & CancelRotateSecretRequest,
  ): Promise<CancelRotateSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelRotateSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
      },
    }, await resp.json());
  }

  async createSecret(
    {abortSignal, ...params}: RequestConfig & CreateSecretRequest,
  ): Promise<CreateSecretResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      Description: params["Description"],
      KmsKeyId: params["KmsKeyId"],
      SecretBinary: jsonP.serializeBlob(params["SecretBinary"]),
      SecretString: params["SecretString"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
      },
    }, await resp.json());
  }

  async deleteResourcePolicy(
    {abortSignal, ...params}: RequestConfig & DeleteResourcePolicyRequest,
  ): Promise<DeleteResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async deleteSecret(
    {abortSignal, ...params}: RequestConfig & DeleteSecretRequest,
  ): Promise<DeleteSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      RecoveryWindowInDays: params["RecoveryWindowInDays"],
      ForceDeleteWithoutRecovery: params["ForceDeleteWithoutRecovery"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "DeletionDate": "d",
      },
    }, await resp.json());
  }

  async describeSecret(
    {abortSignal, ...params}: RequestConfig & DescribeSecretRequest,
  ): Promise<DescribeSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "Description": "s",
        "KmsKeyId": "s",
        "RotationEnabled": "b",
        "RotationLambdaARN": "s",
        "RotationRules": toRotationRulesType,
        "LastRotatedDate": "d",
        "LastChangedDate": "d",
        "LastAccessedDate": "d",
        "DeletedDate": "d",
        "Tags": [toTag],
        "VersionIdsToStages": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
        "OwningService": "s",
        "CreatedDate": "d",
      },
    }, await resp.json());
  }

  async getRandomPassword(
    {abortSignal, ...params}: RequestConfig & GetRandomPasswordRequest = {},
  ): Promise<GetRandomPasswordResponse> {
    const body: jsonP.JSONObject = {
      PasswordLength: params["PasswordLength"],
      ExcludeCharacters: params["ExcludeCharacters"],
      ExcludeNumbers: params["ExcludeNumbers"],
      ExcludePunctuation: params["ExcludePunctuation"],
      ExcludeUppercase: params["ExcludeUppercase"],
      ExcludeLowercase: params["ExcludeLowercase"],
      IncludeSpace: params["IncludeSpace"],
      RequireEachIncludedType: params["RequireEachIncludedType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRandomPassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RandomPassword": "s",
      },
    }, await resp.json());
  }

  async getResourcePolicy(
    {abortSignal, ...params}: RequestConfig & GetResourcePolicyRequest,
  ): Promise<GetResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "ResourcePolicy": "s",
      },
    }, await resp.json());
  }

  async getSecretValue(
    {abortSignal, ...params}: RequestConfig & GetSecretValueRequest,
  ): Promise<GetSecretValueResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      VersionId: params["VersionId"],
      VersionStage: params["VersionStage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSecretValue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
        "SecretBinary": "a",
        "SecretString": "s",
        "VersionStages": ["s"],
        "CreatedDate": "d",
      },
    }, await resp.json());
  }

  async listSecretVersionIds(
    {abortSignal, ...params}: RequestConfig & ListSecretVersionIdsRequest,
  ): Promise<ListSecretVersionIdsResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      IncludeDeprecated: params["IncludeDeprecated"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSecretVersionIds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Versions": [toSecretVersionsListEntry],
        "NextToken": "s",
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async listSecrets(
    {abortSignal, ...params}: RequestConfig & ListSecretsRequest = {},
  ): Promise<ListSecretsResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSecrets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecretList": [toSecretListEntry],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putResourcePolicy(
    {abortSignal, ...params}: RequestConfig & PutResourcePolicyRequest,
  ): Promise<PutResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ResourcePolicy: params["ResourcePolicy"],
      BlockPublicPolicy: params["BlockPublicPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async putSecretValue(
    {abortSignal, ...params}: RequestConfig & PutSecretValueRequest,
  ): Promise<PutSecretValueResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      SecretBinary: jsonP.serializeBlob(params["SecretBinary"]),
      SecretString: params["SecretString"],
      VersionStages: params["VersionStages"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutSecretValue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
        "VersionStages": ["s"],
      },
    }, await resp.json());
  }

  async restoreSecret(
    {abortSignal, ...params}: RequestConfig & RestoreSecretRequest,
  ): Promise<RestoreSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async rotateSecret(
    {abortSignal, ...params}: RequestConfig & RotateSecretRequest,
  ): Promise<RotateSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      RotationLambdaARN: params["RotationLambdaARN"],
      RotationRules: fromRotationRulesType(params["RotationRules"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RotateSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
  }

  async updateSecret(
    {abortSignal, ...params}: RequestConfig & UpdateSecretRequest,
  ): Promise<UpdateSecretResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      Description: params["Description"],
      KmsKeyId: params["KmsKeyId"],
      SecretBinary: jsonP.serializeBlob(params["SecretBinary"]),
      SecretString: params["SecretString"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSecret",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
        "VersionId": "s",
      },
    }, await resp.json());
  }

  async updateSecretVersionStage(
    {abortSignal, ...params}: RequestConfig & UpdateSecretVersionStageRequest,
  ): Promise<UpdateSecretVersionStageResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      VersionStage: params["VersionStage"],
      RemoveFromVersionId: params["RemoveFromVersionId"],
      MoveToVersionId: params["MoveToVersionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSecretVersionStage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ARN": "s",
        "Name": "s",
      },
    }, await resp.json());
  }

  async validateResourcePolicy(
    {abortSignal, ...params}: RequestConfig & ValidateResourcePolicyRequest,
  ): Promise<ValidateResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      SecretId: params["SecretId"],
      ResourcePolicy: params["ResourcePolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ValidateResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyValidationPassed": "b",
        "ValidationErrors": [toValidationErrorsEntry],
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CancelRotateSecretRequest {
  SecretId: string;
}

// refs: 1 - tags: named, input
export interface CreateSecretRequest {
  Name: string;
  ClientRequestToken?: string | null;
  Description?: string | null;
  KmsKeyId?: string | null;
  SecretBinary?: Uint8Array | string | null;
  SecretString?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteResourcePolicyRequest {
  SecretId: string;
}

// refs: 1 - tags: named, input
export interface DeleteSecretRequest {
  SecretId: string;
  RecoveryWindowInDays?: number | null;
  ForceDeleteWithoutRecovery?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeSecretRequest {
  SecretId: string;
}

// refs: 1 - tags: named, input
export interface GetRandomPasswordRequest {
  PasswordLength?: number | null;
  ExcludeCharacters?: string | null;
  ExcludeNumbers?: boolean | null;
  ExcludePunctuation?: boolean | null;
  ExcludeUppercase?: boolean | null;
  ExcludeLowercase?: boolean | null;
  IncludeSpace?: boolean | null;
  RequireEachIncludedType?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetResourcePolicyRequest {
  SecretId: string;
}

// refs: 1 - tags: named, input
export interface GetSecretValueRequest {
  SecretId: string;
  VersionId?: string | null;
  VersionStage?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSecretVersionIdsRequest {
  SecretId: string;
  MaxResults?: number | null;
  NextToken?: string | null;
  IncludeDeprecated?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ListSecretsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
  Filters?: Filter[] | null;
  SortOrder?: SortOrderType | null;
}

// refs: 1 - tags: named, input
export interface PutResourcePolicyRequest {
  SecretId: string;
  ResourcePolicy: string;
  BlockPublicPolicy?: boolean | null;
}

// refs: 1 - tags: named, input
export interface PutSecretValueRequest {
  SecretId: string;
  ClientRequestToken?: string | null;
  SecretBinary?: Uint8Array | string | null;
  SecretString?: string | null;
  VersionStages?: string[] | null;
}

// refs: 1 - tags: named, input
export interface RestoreSecretRequest {
  SecretId: string;
}

// refs: 1 - tags: named, input
export interface RotateSecretRequest {
  SecretId: string;
  ClientRequestToken?: string | null;
  RotationLambdaARN?: string | null;
  RotationRules?: RotationRulesType | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  SecretId: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  SecretId: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateSecretRequest {
  SecretId: string;
  ClientRequestToken?: string | null;
  Description?: string | null;
  KmsKeyId?: string | null;
  SecretBinary?: Uint8Array | string | null;
  SecretString?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateSecretVersionStageRequest {
  SecretId: string;
  VersionStage: string;
  RemoveFromVersionId?: string | null;
  MoveToVersionId?: string | null;
}

// refs: 1 - tags: named, input
export interface ValidateResourcePolicyRequest {
  SecretId?: string | null;
  ResourcePolicy: string;
}

// refs: 1 - tags: named, output
export interface CancelRotateSecretResponse {
  ARN?: string | null;
  Name?: string | null;
  VersionId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSecretResponse {
  ARN?: string | null;
  Name?: string | null;
  VersionId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteResourcePolicyResponse {
  ARN?: string | null;
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteSecretResponse {
  ARN?: string | null;
  Name?: string | null;
  DeletionDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeSecretResponse {
  ARN?: string | null;
  Name?: string | null;
  Description?: string | null;
  KmsKeyId?: string | null;
  RotationEnabled?: boolean | null;
  RotationLambdaARN?: string | null;
  RotationRules?: RotationRulesType | null;
  LastRotatedDate?: Date | number | null;
  LastChangedDate?: Date | number | null;
  LastAccessedDate?: Date | number | null;
  DeletedDate?: Date | number | null;
  Tags?: Tag[] | null;
  VersionIdsToStages?: { [key: string]: string[] | null | undefined } | null;
  OwningService?: string | null;
  CreatedDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetRandomPasswordResponse {
  RandomPassword?: string | null;
}

// refs: 1 - tags: named, output
export interface GetResourcePolicyResponse {
  ARN?: string | null;
  Name?: string | null;
  ResourcePolicy?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSecretValueResponse {
  ARN?: string | null;
  Name?: string | null;
  VersionId?: string | null;
  SecretBinary?: Uint8Array | string | null;
  SecretString?: string | null;
  VersionStages?: string[] | null;
  CreatedDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface ListSecretVersionIdsResponse {
  Versions?: SecretVersionsListEntry[] | null;
  NextToken?: string | null;
  ARN?: string | null;
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSecretsResponse {
  SecretList?: SecretListEntry[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutResourcePolicyResponse {
  ARN?: string | null;
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface PutSecretValueResponse {
  ARN?: string | null;
  Name?: string | null;
  VersionId?: string | null;
  VersionStages?: string[] | null;
}

// refs: 1 - tags: named, output
export interface RestoreSecretResponse {
  ARN?: string | null;
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface RotateSecretResponse {
  ARN?: string | null;
  Name?: string | null;
  VersionId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateSecretResponse {
  ARN?: string | null;
  Name?: string | null;
  VersionId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateSecretVersionStageResponse {
  ARN?: string | null;
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface ValidateResourcePolicyResponse {
  PolicyValidationPassed?: boolean | null;
  ValidationErrors?: ValidationErrorsEntry[] | null;
}

// refs: 4 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface Filter {
  Key?: FilterNameStringType | null;
  Values?: string[] | null;
}
function fromFilter(input?: Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

// refs: 1 - tags: input, named, enum
export type FilterNameStringType =
| "description"
| "name"
| "tag-key"
| "tag-value"
| "all"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SortOrderType =
| "asc"
| "desc"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface RotationRulesType {
  AutomaticallyAfterDays?: number | null;
}
function fromRotationRulesType(input?: RotationRulesType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AutomaticallyAfterDays: input["AutomaticallyAfterDays"],
  }
}
function toRotationRulesType(root: jsonP.JSONValue): RotationRulesType {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomaticallyAfterDays": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SecretVersionsListEntry {
  VersionId?: string | null;
  VersionStages?: string[] | null;
  LastAccessedDate?: Date | number | null;
  CreatedDate?: Date | number | null;
}
function toSecretVersionsListEntry(root: jsonP.JSONValue): SecretVersionsListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "VersionId": "s",
      "VersionStages": ["s"],
      "LastAccessedDate": "d",
      "CreatedDate": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SecretListEntry {
  ARN?: string | null;
  Name?: string | null;
  Description?: string | null;
  KmsKeyId?: string | null;
  RotationEnabled?: boolean | null;
  RotationLambdaARN?: string | null;
  RotationRules?: RotationRulesType | null;
  LastRotatedDate?: Date | number | null;
  LastChangedDate?: Date | number | null;
  LastAccessedDate?: Date | number | null;
  DeletedDate?: Date | number | null;
  Tags?: Tag[] | null;
  SecretVersionsToStages?: { [key: string]: string[] | null | undefined } | null;
  OwningService?: string | null;
  CreatedDate?: Date | number | null;
}
function toSecretListEntry(root: jsonP.JSONValue): SecretListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "ARN": "s",
      "Name": "s",
      "Description": "s",
      "KmsKeyId": "s",
      "RotationEnabled": "b",
      "RotationLambdaARN": "s",
      "RotationRules": toRotationRulesType,
      "LastRotatedDate": "d",
      "LastChangedDate": "d",
      "LastAccessedDate": "d",
      "DeletedDate": "d",
      "Tags": [toTag],
      "SecretVersionsToStages": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "OwningService": "s",
      "CreatedDate": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ValidationErrorsEntry {
  CheckName?: string | null;
  ErrorMessage?: string | null;
}
function toValidationErrorsEntry(root: jsonP.JSONValue): ValidationErrorsEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "CheckName": "s",
      "ErrorMessage": "s",
    },
  }, root);
}
