// Autogenerated API client for: Amazon Data Lifecycle Manager

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class DLM {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DLM.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-01-12",
    "endpointPrefix": "dlm",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "Amazon DLM",
    "serviceFullName": "Amazon Data Lifecycle Manager",
    "serviceId": "DLM",
    "signatureVersion": "v4",
    "signingName": "dlm",
    "uid": "dlm-2018-01-12"
  };

  async createLifecyclePolicy(
    {abortSignal, ...params}: RequestConfig & s.CreateLifecyclePolicyRequest,
  ): Promise<s.CreateLifecyclePolicyResponse> {
    const body: jsonP.JSONObject = {
      ExecutionRoleArn: params["ExecutionRoleArn"],
      Description: params["Description"],
      State: params["State"],
      PolicyDetails: fromPolicyDetails(params["PolicyDetails"]),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLifecyclePolicy",
      requestUri: "/policies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyId": "s",
      },
    }, await resp.json());
  }

  async deleteLifecyclePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteLifecyclePolicyRequest,
  ): Promise<s.DeleteLifecyclePolicyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteLifecyclePolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/policies/${params["PolicyId"]}/`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async getLifecyclePolicies(
    {abortSignal, ...params}: RequestConfig & s.GetLifecyclePoliciesRequest = {},
  ): Promise<s.GetLifecyclePoliciesResponse> {
    const query = new URLSearchParams;
    for (const item of params["PolicyIds"] ?? []) {
      query.append("policyIds", item?.toString() ?? "");
    }
    if (params["State"] != null) query.set("state", params["State"]?.toString() ?? "");
    for (const item of params["ResourceTypes"] ?? []) {
      query.append("resourceTypes", item?.toString() ?? "");
    }
    for (const item of params["TargetTags"] ?? []) {
      query.append("targetTags", item?.toString() ?? "");
    }
    for (const item of params["TagsToAdd"] ?? []) {
      query.append("tagsToAdd", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetLifecyclePolicies",
      method: "GET",
      requestUri: "/policies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policies": [toLifecyclePolicySummary],
      },
    }, await resp.json());
  }

  async getLifecyclePolicy(
    {abortSignal, ...params}: RequestConfig & s.GetLifecyclePolicyRequest,
  ): Promise<s.GetLifecyclePolicyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetLifecyclePolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/policies/${params["PolicyId"]}/`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": toLifecyclePolicy,
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateLifecyclePolicy(
    {abortSignal, ...params}: RequestConfig & s.UpdateLifecyclePolicyRequest,
  ): Promise<s.UpdateLifecyclePolicyResponse> {
    const body: jsonP.JSONObject = {
      ExecutionRoleArn: params["ExecutionRoleArn"],
      State: params["State"],
      Description: params["Description"],
      PolicyDetails: fromPolicyDetails(params["PolicyDetails"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateLifecyclePolicy",
      method: "PATCH",
      requestUri: cmnP.encodePath`/policies/${params["PolicyId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromPolicyDetails(input?: s.PolicyDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyType: input["PolicyType"],
    ResourceTypes: input["ResourceTypes"],
    ResourceLocations: input["ResourceLocations"],
    TargetTags: input["TargetTags"]?.map(x => fromTag(x)),
    Schedules: input["Schedules"]?.map(x => fromSchedule(x)),
    Parameters: fromParameters(input["Parameters"]),
    EventSource: fromEventSource(input["EventSource"]),
    Actions: input["Actions"]?.map(x => fromAction(x)),
  }
}
function toPolicyDetails(root: jsonP.JSONValue): s.PolicyDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PolicyTypeValues>(x),
      "ResourceTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceTypeValues>(x)],
      "ResourceLocations": [(x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceLocationValues>(x)],
      "TargetTags": [toTag],
      "Schedules": [toSchedule],
      "Parameters": toParameters,
      "EventSource": toEventSource,
      "Actions": [toAction],
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromSchedule(input?: s.Schedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    CopyTags: input["CopyTags"],
    TagsToAdd: input["TagsToAdd"]?.map(x => fromTag(x)),
    VariableTags: input["VariableTags"]?.map(x => fromTag(x)),
    CreateRule: fromCreateRule(input["CreateRule"]),
    RetainRule: fromRetainRule(input["RetainRule"]),
    FastRestoreRule: fromFastRestoreRule(input["FastRestoreRule"]),
    CrossRegionCopyRules: input["CrossRegionCopyRules"]?.map(x => fromCrossRegionCopyRule(x)),
    ShareRules: input["ShareRules"]?.map(x => fromShareRule(x)),
  }
}
function toSchedule(root: jsonP.JSONValue): s.Schedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "CopyTags": "b",
      "TagsToAdd": [toTag],
      "VariableTags": [toTag],
      "CreateRule": toCreateRule,
      "RetainRule": toRetainRule,
      "FastRestoreRule": toFastRestoreRule,
      "CrossRegionCopyRules": [toCrossRegionCopyRule],
      "ShareRules": [toShareRule],
    },
  }, root);
}

function fromCreateRule(input?: s.CreateRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Location: input["Location"],
    Interval: input["Interval"],
    IntervalUnit: input["IntervalUnit"],
    Times: input["Times"],
    CronExpression: input["CronExpression"],
  }
}
function toCreateRule(root: jsonP.JSONValue): s.CreateRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Location": (x: jsonP.JSONValue) => cmnP.readEnum<s.LocationValues>(x),
      "Interval": "n",
      "IntervalUnit": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntervalUnitValues>(x),
      "Times": ["s"],
      "CronExpression": "s",
    },
  }, root);
}

function fromRetainRule(input?: s.RetainRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Count: input["Count"],
    Interval: input["Interval"],
    IntervalUnit: input["IntervalUnit"],
  }
}
function toRetainRule(root: jsonP.JSONValue): s.RetainRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Count": "n",
      "Interval": "n",
      "IntervalUnit": (x: jsonP.JSONValue) => cmnP.readEnum<s.RetentionIntervalUnitValues>(x),
    },
  }, root);
}

function fromFastRestoreRule(input?: s.FastRestoreRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Count: input["Count"],
    Interval: input["Interval"],
    IntervalUnit: input["IntervalUnit"],
    AvailabilityZones: input["AvailabilityZones"],
  }
}
function toFastRestoreRule(root: jsonP.JSONValue): s.FastRestoreRule {
  return jsonP.readObj({
    required: {
      "AvailabilityZones": ["s"],
    },
    optional: {
      "Count": "n",
      "Interval": "n",
      "IntervalUnit": (x: jsonP.JSONValue) => cmnP.readEnum<s.RetentionIntervalUnitValues>(x),
    },
  }, root);
}

function fromCrossRegionCopyRule(input?: s.CrossRegionCopyRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetRegion: input["TargetRegion"],
    Target: input["Target"],
    Encrypted: input["Encrypted"],
    CmkArn: input["CmkArn"],
    CopyTags: input["CopyTags"],
    RetainRule: fromCrossRegionCopyRetainRule(input["RetainRule"]),
  }
}
function toCrossRegionCopyRule(root: jsonP.JSONValue): s.CrossRegionCopyRule {
  return jsonP.readObj({
    required: {
      "Encrypted": "b",
    },
    optional: {
      "TargetRegion": "s",
      "Target": "s",
      "CmkArn": "s",
      "CopyTags": "b",
      "RetainRule": toCrossRegionCopyRetainRule,
    },
  }, root);
}

function fromCrossRegionCopyRetainRule(input?: s.CrossRegionCopyRetainRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Interval: input["Interval"],
    IntervalUnit: input["IntervalUnit"],
  }
}
function toCrossRegionCopyRetainRule(root: jsonP.JSONValue): s.CrossRegionCopyRetainRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Interval": "n",
      "IntervalUnit": (x: jsonP.JSONValue) => cmnP.readEnum<s.RetentionIntervalUnitValues>(x),
    },
  }, root);
}

function fromShareRule(input?: s.ShareRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetAccounts: input["TargetAccounts"],
    UnshareInterval: input["UnshareInterval"],
    UnshareIntervalUnit: input["UnshareIntervalUnit"],
  }
}
function toShareRule(root: jsonP.JSONValue): s.ShareRule {
  return jsonP.readObj({
    required: {
      "TargetAccounts": ["s"],
    },
    optional: {
      "UnshareInterval": "n",
      "UnshareIntervalUnit": (x: jsonP.JSONValue) => cmnP.readEnum<s.RetentionIntervalUnitValues>(x),
    },
  }, root);
}

function fromParameters(input?: s.Parameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExcludeBootVolume: input["ExcludeBootVolume"],
    NoReboot: input["NoReboot"],
  }
}
function toParameters(root: jsonP.JSONValue): s.Parameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExcludeBootVolume": "b",
      "NoReboot": "b",
    },
  }, root);
}

function fromEventSource(input?: s.EventSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Parameters: fromEventParameters(input["Parameters"]),
  }
}
function toEventSource(root: jsonP.JSONValue): s.EventSource {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventSourceValues>(x),
    },
    optional: {
      "Parameters": toEventParameters,
    },
  }, root);
}

function fromEventParameters(input?: s.EventParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EventType: input["EventType"],
    SnapshotOwner: input["SnapshotOwner"],
    DescriptionRegex: input["DescriptionRegex"],
  }
}
function toEventParameters(root: jsonP.JSONValue): s.EventParameters {
  return jsonP.readObj({
    required: {
      "EventType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventTypeValues>(x),
      "SnapshotOwner": ["s"],
      "DescriptionRegex": "s",
    },
    optional: {},
  }, root);
}

function fromAction(input?: s.Action | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    CrossRegionCopy: input["CrossRegionCopy"]?.map(x => fromCrossRegionCopyAction(x)),
  }
}
function toAction(root: jsonP.JSONValue): s.Action {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "CrossRegionCopy": [toCrossRegionCopyAction],
    },
    optional: {},
  }, root);
}

function fromCrossRegionCopyAction(input?: s.CrossRegionCopyAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Target: input["Target"],
    EncryptionConfiguration: fromEncryptionConfiguration(input["EncryptionConfiguration"]),
    RetainRule: fromCrossRegionCopyRetainRule(input["RetainRule"]),
  }
}
function toCrossRegionCopyAction(root: jsonP.JSONValue): s.CrossRegionCopyAction {
  return jsonP.readObj({
    required: {
      "Target": "s",
      "EncryptionConfiguration": toEncryptionConfiguration,
    },
    optional: {
      "RetainRule": toCrossRegionCopyRetainRule,
    },
  }, root);
}

function fromEncryptionConfiguration(input?: s.EncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Encrypted: input["Encrypted"],
    CmkArn: input["CmkArn"],
  }
}
function toEncryptionConfiguration(root: jsonP.JSONValue): s.EncryptionConfiguration {
  return jsonP.readObj({
    required: {
      "Encrypted": "b",
    },
    optional: {
      "CmkArn": "s",
    },
  }, root);
}

function toLifecyclePolicySummary(root: jsonP.JSONValue): s.LifecyclePolicySummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyId": "s",
      "Description": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.GettablePolicyStateValues>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "PolicyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PolicyTypeValues>(x),
    },
  }, root);
}

function toLifecyclePolicy(root: jsonP.JSONValue): s.LifecyclePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyId": "s",
      "Description": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.GettablePolicyStateValues>(x),
      "StatusMessage": "s",
      "ExecutionRoleArn": "s",
      "DateCreated": "d",
      "DateModified": "d",
      "PolicyDetails": toPolicyDetails,
      "Tags": x => jsonP.readMap(String, String, x),
      "PolicyArn": "s",
    },
  }, root);
}
