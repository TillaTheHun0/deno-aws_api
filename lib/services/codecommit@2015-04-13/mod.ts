// Autogenerated API client for: AWS CodeCommit

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.91.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class CodeCommit {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodeCommit.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-04-13",
    "endpointPrefix": "codecommit",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "CodeCommit",
    "serviceFullName": "AWS CodeCommit",
    "serviceId": "CodeCommit",
    "signatureVersion": "v4",
    "targetPrefix": "CodeCommit_20150413",
    "uid": "codecommit-2015-04-13"
  };

  async associateApprovalRuleTemplateWithRepository(
    {abortSignal, ...params}: RequestConfig & s.AssociateApprovalRuleTemplateWithRepositoryInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateApprovalRuleTemplateWithRepository",
    });
    await resp.text();
  }

  async batchAssociateApprovalRuleTemplateWithRepositories(
    {abortSignal, ...params}: RequestConfig & s.BatchAssociateApprovalRuleTemplateWithRepositoriesInput,
  ): Promise<s.BatchAssociateApprovalRuleTemplateWithRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      repositoryNames: params["repositoryNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchAssociateApprovalRuleTemplateWithRepositories",
    });
    return jsonP.readObj({
      required: {
        "associatedRepositoryNames": ["s"],
        "errors": [toBatchAssociateApprovalRuleTemplateWithRepositoriesError],
      },
      optional: {},
    }, await resp.json());
  }

  async batchDescribeMergeConflicts(
    {abortSignal, ...params}: RequestConfig & s.BatchDescribeMergeConflictsInput,
  ): Promise<s.BatchDescribeMergeConflictsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      mergeOption: params["mergeOption"],
      maxMergeHunks: params["maxMergeHunks"],
      maxConflictFiles: params["maxConflictFiles"],
      filePaths: params["filePaths"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDescribeMergeConflicts",
    });
    return jsonP.readObj({
      required: {
        "conflicts": [toConflict],
        "destinationCommitId": "s",
        "sourceCommitId": "s",
      },
      optional: {
        "nextToken": "s",
        "errors": [toBatchDescribeMergeConflictsError],
        "baseCommitId": "s",
      },
    }, await resp.json());
  }

  async batchDisassociateApprovalRuleTemplateFromRepositories(
    {abortSignal, ...params}: RequestConfig & s.BatchDisassociateApprovalRuleTemplateFromRepositoriesInput,
  ): Promise<s.BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      repositoryNames: params["repositoryNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDisassociateApprovalRuleTemplateFromRepositories",
    });
    return jsonP.readObj({
      required: {
        "disassociatedRepositoryNames": ["s"],
        "errors": [toBatchDisassociateApprovalRuleTemplateFromRepositoriesError],
      },
      optional: {},
    }, await resp.json());
  }

  async batchGetCommits(
    {abortSignal, ...params}: RequestConfig & s.BatchGetCommitsInput,
  ): Promise<s.BatchGetCommitsOutput> {
    const body: jsonP.JSONObject = {
      commitIds: params["commitIds"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetCommits",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commits": [toCommit],
        "errors": [toBatchGetCommitsError],
      },
    }, await resp.json());
  }

  async batchGetRepositories(
    {abortSignal, ...params}: RequestConfig & s.BatchGetRepositoriesInput,
  ): Promise<s.BatchGetRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      repositoryNames: params["repositoryNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetRepositories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositories": [toRepositoryMetadata],
        "repositoriesNotFound": ["s"],
      },
    }, await resp.json());
  }

  async createApprovalRuleTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateApprovalRuleTemplateInput,
  ): Promise<s.CreateApprovalRuleTemplateOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      approvalRuleTemplateContent: params["approvalRuleTemplateContent"],
      approvalRuleTemplateDescription: params["approvalRuleTemplateDescription"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApprovalRuleTemplate",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async createBranch(
    {abortSignal, ...params}: RequestConfig & s.CreateBranchInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
      commitId: params["commitId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBranch",
    });
    await resp.text();
  }

  async createCommit(
    {abortSignal, ...params}: RequestConfig & s.CreateCommitInput,
  ): Promise<s.CreateCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
      parentCommitId: params["parentCommitId"],
      authorName: params["authorName"],
      email: params["email"],
      commitMessage: params["commitMessage"],
      keepEmptyFolders: params["keepEmptyFolders"],
      putFiles: params["putFiles"]?.map(x => fromPutFileEntry(x)),
      deleteFiles: params["deleteFiles"]?.map(x => fromDeleteFileEntry(x)),
      setFileModes: params["setFileModes"]?.map(x => fromSetFileModeEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
        "filesAdded": [toFileMetadata],
        "filesUpdated": [toFileMetadata],
        "filesDeleted": [toFileMetadata],
      },
    }, await resp.json());
  }

  async createPullRequest(
    {abortSignal, ...params}: RequestConfig & s.CreatePullRequestInput,
  ): Promise<s.CreatePullRequestOutput> {
    const body: jsonP.JSONObject = {
      title: params["title"],
      description: params["description"],
      targets: params["targets"]?.map(x => fromTarget(x)),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePullRequest",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async createPullRequestApprovalRule(
    {abortSignal, ...params}: RequestConfig & s.CreatePullRequestApprovalRuleInput,
  ): Promise<s.CreatePullRequestApprovalRuleOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      approvalRuleName: params["approvalRuleName"],
      approvalRuleContent: params["approvalRuleContent"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePullRequestApprovalRule",
    });
    return jsonP.readObj({
      required: {
        "approvalRule": toApprovalRule,
      },
      optional: {},
    }, await resp.json());
  }

  async createRepository(
    {abortSignal, ...params}: RequestConfig & s.CreateRepositoryInput,
  ): Promise<s.CreateRepositoryOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      repositoryDescription: params["repositoryDescription"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryMetadata": toRepositoryMetadata,
      },
    }, await resp.json());
  }

  async createUnreferencedMergeCommit(
    {abortSignal, ...params}: RequestConfig & s.CreateUnreferencedMergeCommitInput,
  ): Promise<s.CreateUnreferencedMergeCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      mergeOption: params["mergeOption"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      authorName: params["authorName"],
      email: params["email"],
      commitMessage: params["commitMessage"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUnreferencedMergeCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
      },
    }, await resp.json());
  }

  async deleteApprovalRuleTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteApprovalRuleTemplateInput,
  ): Promise<s.DeleteApprovalRuleTemplateOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApprovalRuleTemplate",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplateId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteBranch(
    {abortSignal, ...params}: RequestConfig & s.DeleteBranchInput,
  ): Promise<s.DeleteBranchOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBranch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deletedBranch": toBranchInfo,
      },
    }, await resp.json());
  }

  async deleteCommentContent(
    {abortSignal, ...params}: RequestConfig & s.DeleteCommentContentInput,
  ): Promise<s.DeleteCommentContentOutput> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCommentContent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "comment": toComment,
      },
    }, await resp.json());
  }

  async deleteFile(
    {abortSignal, ...params}: RequestConfig & s.DeleteFileInput,
  ): Promise<s.DeleteFileOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
      filePath: params["filePath"],
      parentCommitId: params["parentCommitId"],
      keepEmptyFolders: params["keepEmptyFolders"],
      commitMessage: params["commitMessage"],
      name: params["name"],
      email: params["email"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFile",
    });
    return jsonP.readObj({
      required: {
        "commitId": "s",
        "blobId": "s",
        "treeId": "s",
        "filePath": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deletePullRequestApprovalRule(
    {abortSignal, ...params}: RequestConfig & s.DeletePullRequestApprovalRuleInput,
  ): Promise<s.DeletePullRequestApprovalRuleOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      approvalRuleName: params["approvalRuleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePullRequestApprovalRule",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteRepository(
    {abortSignal, ...params}: RequestConfig & s.DeleteRepositoryInput,
  ): Promise<s.DeleteRepositoryOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryId": "s",
      },
    }, await resp.json());
  }

  async describeMergeConflicts(
    {abortSignal, ...params}: RequestConfig & s.DescribeMergeConflictsInput,
  ): Promise<s.DescribeMergeConflictsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      mergeOption: params["mergeOption"],
      maxMergeHunks: params["maxMergeHunks"],
      filePath: params["filePath"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMergeConflicts",
    });
    return jsonP.readObj({
      required: {
        "conflictMetadata": toConflictMetadata,
        "mergeHunks": [toMergeHunk],
        "destinationCommitId": "s",
        "sourceCommitId": "s",
      },
      optional: {
        "nextToken": "s",
        "baseCommitId": "s",
      },
    }, await resp.json());
  }

  async describePullRequestEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribePullRequestEventsInput,
  ): Promise<s.DescribePullRequestEventsOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      pullRequestEventType: params["pullRequestEventType"],
      actorArn: params["actorArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePullRequestEvents",
    });
    return jsonP.readObj({
      required: {
        "pullRequestEvents": [toPullRequestEvent],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async disassociateApprovalRuleTemplateFromRepository(
    {abortSignal, ...params}: RequestConfig & s.DisassociateApprovalRuleTemplateFromRepositoryInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateApprovalRuleTemplateFromRepository",
    });
    await resp.text();
  }

  async evaluatePullRequestApprovalRules(
    {abortSignal, ...params}: RequestConfig & s.EvaluatePullRequestApprovalRulesInput,
  ): Promise<s.EvaluatePullRequestApprovalRulesOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EvaluatePullRequestApprovalRules",
    });
    return jsonP.readObj({
      required: {
        "evaluation": toEvaluation,
      },
      optional: {},
    }, await resp.json());
  }

  async getApprovalRuleTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetApprovalRuleTemplateInput,
  ): Promise<s.GetApprovalRuleTemplateOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetApprovalRuleTemplate",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async getBlob(
    {abortSignal, ...params}: RequestConfig & s.GetBlobInput,
  ): Promise<s.GetBlobOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      blobId: params["blobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBlob",
    });
    return jsonP.readObj({
      required: {
        "content": "a",
      },
      optional: {},
    }, await resp.json());
  }

  async getBranch(
    {abortSignal, ...params}: RequestConfig & s.GetBranchInput = {},
  ): Promise<s.GetBranchOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBranch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "branch": toBranchInfo,
      },
    }, await resp.json());
  }

  async getComment(
    {abortSignal, ...params}: RequestConfig & s.GetCommentInput,
  ): Promise<s.GetCommentOutput> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetComment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "comment": toComment,
      },
    }, await resp.json());
  }

  async getCommentReactions(
    {abortSignal, ...params}: RequestConfig & s.GetCommentReactionsInput,
  ): Promise<s.GetCommentReactionsOutput> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
      reactionUserArn: params["reactionUserArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCommentReactions",
    });
    return jsonP.readObj({
      required: {
        "reactionsForComment": [toReactionForComment],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getCommentsForComparedCommit(
    {abortSignal, ...params}: RequestConfig & s.GetCommentsForComparedCommitInput,
  ): Promise<s.GetCommentsForComparedCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      beforeCommitId: params["beforeCommitId"],
      afterCommitId: params["afterCommitId"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCommentsForComparedCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commentsForComparedCommitData": [toCommentsForComparedCommit],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getCommentsForPullRequest(
    {abortSignal, ...params}: RequestConfig & s.GetCommentsForPullRequestInput,
  ): Promise<s.GetCommentsForPullRequestOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      beforeCommitId: params["beforeCommitId"],
      afterCommitId: params["afterCommitId"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCommentsForPullRequest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commentsForPullRequestData": [toCommentsForPullRequest],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getCommit(
    {abortSignal, ...params}: RequestConfig & s.GetCommitInput,
  ): Promise<s.GetCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      commitId: params["commitId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCommit",
    });
    return jsonP.readObj({
      required: {
        "commit": toCommit,
      },
      optional: {},
    }, await resp.json());
  }

  async getDifferences(
    {abortSignal, ...params}: RequestConfig & s.GetDifferencesInput,
  ): Promise<s.GetDifferencesOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      beforeCommitSpecifier: params["beforeCommitSpecifier"],
      afterCommitSpecifier: params["afterCommitSpecifier"],
      beforePath: params["beforePath"],
      afterPath: params["afterPath"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDifferences",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "differences": [toDifference],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getFile(
    {abortSignal, ...params}: RequestConfig & s.GetFileInput,
  ): Promise<s.GetFileOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      commitSpecifier: params["commitSpecifier"],
      filePath: params["filePath"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFile",
    });
    return jsonP.readObj({
      required: {
        "commitId": "s",
        "blobId": "s",
        "filePath": "s",
        "fileMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileModeTypeEnum>(x),
        "fileSize": "n",
        "fileContent": "a",
      },
      optional: {},
    }, await resp.json());
  }

  async getFolder(
    {abortSignal, ...params}: RequestConfig & s.GetFolderInput,
  ): Promise<s.GetFolderOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      commitSpecifier: params["commitSpecifier"],
      folderPath: params["folderPath"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFolder",
    });
    return jsonP.readObj({
      required: {
        "commitId": "s",
        "folderPath": "s",
      },
      optional: {
        "treeId": "s",
        "subFolders": [toFolder],
        "files": [toFile],
        "symbolicLinks": [toSymbolicLink],
        "subModules": [toSubModule],
      },
    }, await resp.json());
  }

  async getMergeCommit(
    {abortSignal, ...params}: RequestConfig & s.GetMergeCommitInput,
  ): Promise<s.GetMergeCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMergeCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "sourceCommitId": "s",
        "destinationCommitId": "s",
        "baseCommitId": "s",
        "mergedCommitId": "s",
      },
    }, await resp.json());
  }

  async getMergeConflicts(
    {abortSignal, ...params}: RequestConfig & s.GetMergeConflictsInput,
  ): Promise<s.GetMergeConflictsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      mergeOption: params["mergeOption"],
      conflictDetailLevel: params["conflictDetailLevel"],
      maxConflictFiles: params["maxConflictFiles"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMergeConflicts",
    });
    return jsonP.readObj({
      required: {
        "mergeable": "b",
        "destinationCommitId": "s",
        "sourceCommitId": "s",
        "conflictMetadataList": [toConflictMetadata],
      },
      optional: {
        "baseCommitId": "s",
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getMergeOptions(
    {abortSignal, ...params}: RequestConfig & s.GetMergeOptionsInput,
  ): Promise<s.GetMergeOptionsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMergeOptions",
    });
    return jsonP.readObj({
      required: {
        "mergeOptions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.MergeOptionTypeEnum>(x)],
        "sourceCommitId": "s",
        "destinationCommitId": "s",
        "baseCommitId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getPullRequest(
    {abortSignal, ...params}: RequestConfig & s.GetPullRequestInput,
  ): Promise<s.GetPullRequestOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPullRequest",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async getPullRequestApprovalStates(
    {abortSignal, ...params}: RequestConfig & s.GetPullRequestApprovalStatesInput,
  ): Promise<s.GetPullRequestApprovalStatesOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPullRequestApprovalStates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "approvals": [toApproval],
      },
    }, await resp.json());
  }

  async getPullRequestOverrideState(
    {abortSignal, ...params}: RequestConfig & s.GetPullRequestOverrideStateInput,
  ): Promise<s.GetPullRequestOverrideStateOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPullRequestOverrideState",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "overridden": "b",
        "overrider": "s",
      },
    }, await resp.json());
  }

  async getRepository(
    {abortSignal, ...params}: RequestConfig & s.GetRepositoryInput,
  ): Promise<s.GetRepositoryOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryMetadata": toRepositoryMetadata,
      },
    }, await resp.json());
  }

  async getRepositoryTriggers(
    {abortSignal, ...params}: RequestConfig & s.GetRepositoryTriggersInput,
  ): Promise<s.GetRepositoryTriggersOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRepositoryTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "configurationId": "s",
        "triggers": [toRepositoryTrigger],
      },
    }, await resp.json());
  }

  async listApprovalRuleTemplates(
    {abortSignal, ...params}: RequestConfig & s.ListApprovalRuleTemplatesInput = {},
  ): Promise<s.ListApprovalRuleTemplatesOutput> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListApprovalRuleTemplates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "approvalRuleTemplateNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAssociatedApprovalRuleTemplatesForRepository(
    {abortSignal, ...params}: RequestConfig & s.ListAssociatedApprovalRuleTemplatesForRepositoryInput,
  ): Promise<s.ListAssociatedApprovalRuleTemplatesForRepositoryOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAssociatedApprovalRuleTemplatesForRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "approvalRuleTemplateNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBranches(
    {abortSignal, ...params}: RequestConfig & s.ListBranchesInput,
  ): Promise<s.ListBranchesOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBranches",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "branches": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPullRequests(
    {abortSignal, ...params}: RequestConfig & s.ListPullRequestsInput,
  ): Promise<s.ListPullRequestsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      authorArn: params["authorArn"],
      pullRequestStatus: params["pullRequestStatus"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPullRequests",
    });
    return jsonP.readObj({
      required: {
        "pullRequestIds": ["s"],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRepositories(
    {abortSignal, ...params}: RequestConfig & s.ListRepositoriesInput = {},
  ): Promise<s.ListRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      sortBy: params["sortBy"],
      order: params["order"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRepositories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositories": [toRepositoryNameIdPair],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRepositoriesForApprovalRuleTemplate(
    {abortSignal, ...params}: RequestConfig & s.ListRepositoriesForApprovalRuleTemplateInput,
  ): Promise<s.ListRepositoriesForApprovalRuleTemplateOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRepositoriesForApprovalRuleTemplate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceInput,
  ): Promise<s.ListTagsForResourceOutput> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async mergeBranchesByFastForward(
    {abortSignal, ...params}: RequestConfig & s.MergeBranchesByFastForwardInput,
  ): Promise<s.MergeBranchesByFastForwardOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      targetBranch: params["targetBranch"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergeBranchesByFastForward",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
      },
    }, await resp.json());
  }

  async mergeBranchesBySquash(
    {abortSignal, ...params}: RequestConfig & s.MergeBranchesBySquashInput,
  ): Promise<s.MergeBranchesBySquashOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      targetBranch: params["targetBranch"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      authorName: params["authorName"],
      email: params["email"],
      commitMessage: params["commitMessage"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergeBranchesBySquash",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
      },
    }, await resp.json());
  }

  async mergeBranchesByThreeWay(
    {abortSignal, ...params}: RequestConfig & s.MergeBranchesByThreeWayInput,
  ): Promise<s.MergeBranchesByThreeWayOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      targetBranch: params["targetBranch"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      authorName: params["authorName"],
      email: params["email"],
      commitMessage: params["commitMessage"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergeBranchesByThreeWay",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
      },
    }, await resp.json());
  }

  async mergePullRequestByFastForward(
    {abortSignal, ...params}: RequestConfig & s.MergePullRequestByFastForwardInput,
  ): Promise<s.MergePullRequestByFastForwardOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      sourceCommitId: params["sourceCommitId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergePullRequestByFastForward",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pullRequest": toPullRequest,
      },
    }, await resp.json());
  }

  async mergePullRequestBySquash(
    {abortSignal, ...params}: RequestConfig & s.MergePullRequestBySquashInput,
  ): Promise<s.MergePullRequestBySquashOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      sourceCommitId: params["sourceCommitId"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      commitMessage: params["commitMessage"],
      authorName: params["authorName"],
      email: params["email"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergePullRequestBySquash",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pullRequest": toPullRequest,
      },
    }, await resp.json());
  }

  async mergePullRequestByThreeWay(
    {abortSignal, ...params}: RequestConfig & s.MergePullRequestByThreeWayInput,
  ): Promise<s.MergePullRequestByThreeWayOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      sourceCommitId: params["sourceCommitId"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      commitMessage: params["commitMessage"],
      authorName: params["authorName"],
      email: params["email"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergePullRequestByThreeWay",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pullRequest": toPullRequest,
      },
    }, await resp.json());
  }

  async overridePullRequestApprovalRules(
    {abortSignal, ...params}: RequestConfig & s.OverridePullRequestApprovalRulesInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
      overrideStatus: params["overrideStatus"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "OverridePullRequestApprovalRules",
    });
    await resp.text();
  }

  async postCommentForComparedCommit(
    {abortSignal, ...params}: RequestConfig & s.PostCommentForComparedCommitInput,
  ): Promise<s.PostCommentForComparedCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      beforeCommitId: params["beforeCommitId"],
      afterCommitId: params["afterCommitId"],
      location: fromLocation(params["location"]),
      content: params["content"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PostCommentForComparedCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryName": "s",
        "beforeCommitId": "s",
        "afterCommitId": "s",
        "beforeBlobId": "s",
        "afterBlobId": "s",
        "location": toLocation,
        "comment": toComment,
      },
    }, await resp.json());
  }

  async postCommentForPullRequest(
    {abortSignal, ...params}: RequestConfig & s.PostCommentForPullRequestInput,
  ): Promise<s.PostCommentForPullRequestOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      beforeCommitId: params["beforeCommitId"],
      afterCommitId: params["afterCommitId"],
      location: fromLocation(params["location"]),
      content: params["content"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PostCommentForPullRequest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryName": "s",
        "pullRequestId": "s",
        "beforeCommitId": "s",
        "afterCommitId": "s",
        "beforeBlobId": "s",
        "afterBlobId": "s",
        "location": toLocation,
        "comment": toComment,
      },
    }, await resp.json());
  }

  async postCommentReply(
    {abortSignal, ...params}: RequestConfig & s.PostCommentReplyInput,
  ): Promise<s.PostCommentReplyOutput> {
    const body: jsonP.JSONObject = {
      inReplyTo: params["inReplyTo"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      content: params["content"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PostCommentReply",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "comment": toComment,
      },
    }, await resp.json());
  }

  async putCommentReaction(
    {abortSignal, ...params}: RequestConfig & s.PutCommentReactionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
      reactionValue: params["reactionValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutCommentReaction",
    });
    await resp.text();
  }

  async putFile(
    {abortSignal, ...params}: RequestConfig & s.PutFileInput,
  ): Promise<s.PutFileOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
      fileContent: serializeBlob(params["fileContent"]),
      filePath: params["filePath"],
      fileMode: params["fileMode"],
      parentCommitId: params["parentCommitId"],
      commitMessage: params["commitMessage"],
      name: params["name"],
      email: params["email"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutFile",
    });
    return jsonP.readObj({
      required: {
        "commitId": "s",
        "blobId": "s",
        "treeId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async putRepositoryTriggers(
    {abortSignal, ...params}: RequestConfig & s.PutRepositoryTriggersInput,
  ): Promise<s.PutRepositoryTriggersOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      triggers: params["triggers"]?.map(x => fromRepositoryTrigger(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRepositoryTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "configurationId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    await resp.text();
  }

  async testRepositoryTriggers(
    {abortSignal, ...params}: RequestConfig & s.TestRepositoryTriggersInput,
  ): Promise<s.TestRepositoryTriggersOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      triggers: params["triggers"]?.map(x => fromRepositoryTrigger(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestRepositoryTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "successfulExecutions": ["s"],
        "failedExecutions": [toRepositoryTriggerExecutionFailure],
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    await resp.text();
  }

  async updateApprovalRuleTemplateContent(
    {abortSignal, ...params}: RequestConfig & s.UpdateApprovalRuleTemplateContentInput,
  ): Promise<s.UpdateApprovalRuleTemplateContentOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      newRuleContent: params["newRuleContent"],
      existingRuleContentSha256: params["existingRuleContentSha256"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApprovalRuleTemplateContent",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async updateApprovalRuleTemplateDescription(
    {abortSignal, ...params}: RequestConfig & s.UpdateApprovalRuleTemplateDescriptionInput,
  ): Promise<s.UpdateApprovalRuleTemplateDescriptionOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      approvalRuleTemplateDescription: params["approvalRuleTemplateDescription"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApprovalRuleTemplateDescription",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async updateApprovalRuleTemplateName(
    {abortSignal, ...params}: RequestConfig & s.UpdateApprovalRuleTemplateNameInput,
  ): Promise<s.UpdateApprovalRuleTemplateNameOutput> {
    const body: jsonP.JSONObject = {
      oldApprovalRuleTemplateName: params["oldApprovalRuleTemplateName"],
      newApprovalRuleTemplateName: params["newApprovalRuleTemplateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApprovalRuleTemplateName",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async updateComment(
    {abortSignal, ...params}: RequestConfig & s.UpdateCommentInput,
  ): Promise<s.UpdateCommentOutput> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
      content: params["content"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateComment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "comment": toComment,
      },
    }, await resp.json());
  }

  async updateDefaultBranch(
    {abortSignal, ...params}: RequestConfig & s.UpdateDefaultBranchInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      defaultBranchName: params["defaultBranchName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDefaultBranch",
    });
    await resp.text();
  }

  async updatePullRequestApprovalRuleContent(
    {abortSignal, ...params}: RequestConfig & s.UpdatePullRequestApprovalRuleContentInput,
  ): Promise<s.UpdatePullRequestApprovalRuleContentOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      approvalRuleName: params["approvalRuleName"],
      existingRuleContentSha256: params["existingRuleContentSha256"],
      newRuleContent: params["newRuleContent"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestApprovalRuleContent",
    });
    return jsonP.readObj({
      required: {
        "approvalRule": toApprovalRule,
      },
      optional: {},
    }, await resp.json());
  }

  async updatePullRequestApprovalState(
    {abortSignal, ...params}: RequestConfig & s.UpdatePullRequestApprovalStateInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
      approvalState: params["approvalState"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestApprovalState",
    });
    await resp.text();
  }

  async updatePullRequestDescription(
    {abortSignal, ...params}: RequestConfig & s.UpdatePullRequestDescriptionInput,
  ): Promise<s.UpdatePullRequestDescriptionOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestDescription",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async updatePullRequestStatus(
    {abortSignal, ...params}: RequestConfig & s.UpdatePullRequestStatusInput,
  ): Promise<s.UpdatePullRequestStatusOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      pullRequestStatus: params["pullRequestStatus"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestStatus",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async updatePullRequestTitle(
    {abortSignal, ...params}: RequestConfig & s.UpdatePullRequestTitleInput,
  ): Promise<s.UpdatePullRequestTitleOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      title: params["title"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestTitle",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async updateRepositoryDescription(
    {abortSignal, ...params}: RequestConfig & s.UpdateRepositoryDescriptionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      repositoryDescription: params["repositoryDescription"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRepositoryDescription",
    });
    await resp.text();
  }

  async updateRepositoryName(
    {abortSignal, ...params}: RequestConfig & s.UpdateRepositoryNameInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      oldName: params["oldName"],
      newName: params["newName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRepositoryName",
    });
    await resp.text();
  }

}

function fromPutFileEntry(input?: s.PutFileEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    fileMode: input["fileMode"],
    fileContent: serializeBlob(input["fileContent"]),
    sourceFile: fromSourceFileSpecifier(input["sourceFile"]),
  }
}

function fromSourceFileSpecifier(input?: s.SourceFileSpecifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    isMove: input["isMove"],
  }
}

function fromDeleteFileEntry(input?: s.DeleteFileEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
  }
}

function fromSetFileModeEntry(input?: s.SetFileModeEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    fileMode: input["fileMode"],
  }
}

function fromTarget(input?: s.Target | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    repositoryName: input["repositoryName"],
    sourceReference: input["sourceReference"],
    destinationReference: input["destinationReference"],
  }
}

function fromConflictResolution(input?: s.ConflictResolution | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    replaceContents: input["replaceContents"]?.map(x => fromReplaceContentEntry(x)),
    deleteFiles: input["deleteFiles"]?.map(x => fromDeleteFileEntry(x)),
    setFileModes: input["setFileModes"]?.map(x => fromSetFileModeEntry(x)),
  }
}

function fromReplaceContentEntry(input?: s.ReplaceContentEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    replacementType: input["replacementType"],
    content: serializeBlob(input["content"]),
    fileMode: input["fileMode"],
  }
}

function fromLocation(input?: s.Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    filePosition: input["filePosition"],
    relativeFileVersion: input["relativeFileVersion"],
  }
}
function toLocation(root: jsonP.JSONValue): s.Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "filePath": "s",
      "filePosition": "n",
      "relativeFileVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.RelativeFileVersionEnum>(x),
    },
  }, root);
}

function fromRepositoryTrigger(input?: s.RepositoryTrigger | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    destinationArn: input["destinationArn"],
    customData: input["customData"],
    branches: input["branches"],
    events: input["events"],
  }
}
function toRepositoryTrigger(root: jsonP.JSONValue): s.RepositoryTrigger {
  return jsonP.readObj({
    required: {
      "name": "s",
      "destinationArn": "s",
      "events": [(x: jsonP.JSONValue) => cmnP.readEnum<s.RepositoryTriggerEventEnum>(x)],
    },
    optional: {
      "customData": "s",
      "branches": ["s"],
    },
  }, root);
}

function toBatchAssociateApprovalRuleTemplateWithRepositoriesError(root: jsonP.JSONValue): s.BatchAssociateApprovalRuleTemplateWithRepositoriesError {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "errorCode": "s",
      "errorMessage": "s",
    },
  }, root);
}

function toConflict(root: jsonP.JSONValue): s.Conflict {
  return jsonP.readObj({
    required: {},
    optional: {
      "conflictMetadata": toConflictMetadata,
      "mergeHunks": [toMergeHunk],
    },
  }, root);
}

function toConflictMetadata(root: jsonP.JSONValue): s.ConflictMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "filePath": "s",
      "fileSizes": toFileSizes,
      "fileModes": toFileModes,
      "objectTypes": toObjectTypes,
      "numberOfConflicts": "n",
      "isBinaryFile": toIsBinaryFile,
      "contentConflict": "b",
      "fileModeConflict": "b",
      "objectTypeConflict": "b",
      "mergeOperations": toMergeOperations,
    },
  }, root);
}

function toFileSizes(root: jsonP.JSONValue): s.FileSizes {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": "n",
      "destination": "n",
      "base": "n",
    },
  }, root);
}

function toFileModes(root: jsonP.JSONValue): s.FileModes {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileModeTypeEnum>(x),
      "destination": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileModeTypeEnum>(x),
      "base": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileModeTypeEnum>(x),
    },
  }, root);
}

function toObjectTypes(root: jsonP.JSONValue): s.ObjectTypes {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObjectTypeEnum>(x),
      "destination": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObjectTypeEnum>(x),
      "base": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObjectTypeEnum>(x),
    },
  }, root);
}

function toIsBinaryFile(root: jsonP.JSONValue): s.IsBinaryFile {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": "b",
      "destination": "b",
      "base": "b",
    },
  }, root);
}

function toMergeOperations(root: jsonP.JSONValue): s.MergeOperations {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChangeTypeEnum>(x),
      "destination": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChangeTypeEnum>(x),
    },
  }, root);
}

function toMergeHunk(root: jsonP.JSONValue): s.MergeHunk {
  return jsonP.readObj({
    required: {},
    optional: {
      "isConflict": "b",
      "source": toMergeHunkDetail,
      "destination": toMergeHunkDetail,
      "base": toMergeHunkDetail,
    },
  }, root);
}

function toMergeHunkDetail(root: jsonP.JSONValue): s.MergeHunkDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "startLine": "n",
      "endLine": "n",
      "hunkContent": "s",
    },
  }, root);
}

function toBatchDescribeMergeConflictsError(root: jsonP.JSONValue): s.BatchDescribeMergeConflictsError {
  return jsonP.readObj({
    required: {
      "filePath": "s",
      "exceptionName": "s",
      "message": "s",
    },
    optional: {},
  }, root);
}

function toBatchDisassociateApprovalRuleTemplateFromRepositoriesError(root: jsonP.JSONValue): s.BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "errorCode": "s",
      "errorMessage": "s",
    },
  }, root);
}

function toCommit(root: jsonP.JSONValue): s.Commit {
  return jsonP.readObj({
    required: {},
    optional: {
      "commitId": "s",
      "treeId": "s",
      "parents": ["s"],
      "message": "s",
      "author": toUserInfo,
      "committer": toUserInfo,
      "additionalData": "s",
    },
  }, root);
}

function toUserInfo(root: jsonP.JSONValue): s.UserInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "email": "s",
      "date": "s",
    },
  }, root);
}

function toBatchGetCommitsError(root: jsonP.JSONValue): s.BatchGetCommitsError {
  return jsonP.readObj({
    required: {},
    optional: {
      "commitId": "s",
      "errorCode": "s",
      "errorMessage": "s",
    },
  }, root);
}

function toRepositoryMetadata(root: jsonP.JSONValue): s.RepositoryMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "repositoryId": "s",
      "repositoryName": "s",
      "repositoryDescription": "s",
      "defaultBranch": "s",
      "lastModifiedDate": "d",
      "creationDate": "d",
      "cloneUrlHttp": "s",
      "cloneUrlSsh": "s",
      "Arn": "s",
    },
  }, root);
}

function toApprovalRuleTemplate(root: jsonP.JSONValue): s.ApprovalRuleTemplate {
  return jsonP.readObj({
    required: {},
    optional: {
      "approvalRuleTemplateId": "s",
      "approvalRuleTemplateName": "s",
      "approvalRuleTemplateDescription": "s",
      "approvalRuleTemplateContent": "s",
      "ruleContentSha256": "s",
      "lastModifiedDate": "d",
      "creationDate": "d",
      "lastModifiedUser": "s",
    },
  }, root);
}

function toFileMetadata(root: jsonP.JSONValue): s.FileMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "absolutePath": "s",
      "blobId": "s",
      "fileMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileModeTypeEnum>(x),
    },
  }, root);
}

function toPullRequest(root: jsonP.JSONValue): s.PullRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "pullRequestId": "s",
      "title": "s",
      "description": "s",
      "lastActivityDate": "d",
      "creationDate": "d",
      "pullRequestStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PullRequestStatusEnum>(x),
      "authorArn": "s",
      "pullRequestTargets": [toPullRequestTarget],
      "clientRequestToken": "s",
      "revisionId": "s",
      "approvalRules": [toApprovalRule],
    },
  }, root);
}

function toPullRequestTarget(root: jsonP.JSONValue): s.PullRequestTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "sourceReference": "s",
      "destinationReference": "s",
      "destinationCommit": "s",
      "sourceCommit": "s",
      "mergeBase": "s",
      "mergeMetadata": toMergeMetadata,
    },
  }, root);
}

function toMergeMetadata(root: jsonP.JSONValue): s.MergeMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "isMerged": "b",
      "mergedBy": "s",
      "mergeCommitId": "s",
      "mergeOption": (x: jsonP.JSONValue) => cmnP.readEnum<s.MergeOptionTypeEnum>(x),
    },
  }, root);
}

function toApprovalRule(root: jsonP.JSONValue): s.ApprovalRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "approvalRuleId": "s",
      "approvalRuleName": "s",
      "approvalRuleContent": "s",
      "ruleContentSha256": "s",
      "lastModifiedDate": "d",
      "creationDate": "d",
      "lastModifiedUser": "s",
      "originApprovalRuleTemplate": toOriginApprovalRuleTemplate,
    },
  }, root);
}

function toOriginApprovalRuleTemplate(root: jsonP.JSONValue): s.OriginApprovalRuleTemplate {
  return jsonP.readObj({
    required: {},
    optional: {
      "approvalRuleTemplateId": "s",
      "approvalRuleTemplateName": "s",
    },
  }, root);
}

function toBranchInfo(root: jsonP.JSONValue): s.BranchInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "branchName": "s",
      "commitId": "s",
    },
  }, root);
}

function toComment(root: jsonP.JSONValue): s.Comment {
  return jsonP.readObj({
    required: {},
    optional: {
      "commentId": "s",
      "content": "s",
      "inReplyTo": "s",
      "creationDate": "d",
      "lastModifiedDate": "d",
      "authorArn": "s",
      "deleted": "b",
      "clientRequestToken": "s",
      "callerReactions": ["s"],
      "reactionCounts": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

function toPullRequestEvent(root: jsonP.JSONValue): s.PullRequestEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "pullRequestId": "s",
      "eventDate": "d",
      "pullRequestEventType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PullRequestEventType>(x),
      "actorArn": "s",
      "pullRequestCreatedEventMetadata": toPullRequestCreatedEventMetadata,
      "pullRequestStatusChangedEventMetadata": toPullRequestStatusChangedEventMetadata,
      "pullRequestSourceReferenceUpdatedEventMetadata": toPullRequestSourceReferenceUpdatedEventMetadata,
      "pullRequestMergedStateChangedEventMetadata": toPullRequestMergedStateChangedEventMetadata,
      "approvalRuleEventMetadata": toApprovalRuleEventMetadata,
      "approvalStateChangedEventMetadata": toApprovalStateChangedEventMetadata,
      "approvalRuleOverriddenEventMetadata": toApprovalRuleOverriddenEventMetadata,
    },
  }, root);
}

function toPullRequestCreatedEventMetadata(root: jsonP.JSONValue): s.PullRequestCreatedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "sourceCommitId": "s",
      "destinationCommitId": "s",
      "mergeBase": "s",
    },
  }, root);
}

function toPullRequestStatusChangedEventMetadata(root: jsonP.JSONValue): s.PullRequestStatusChangedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "pullRequestStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PullRequestStatusEnum>(x),
    },
  }, root);
}

function toPullRequestSourceReferenceUpdatedEventMetadata(root: jsonP.JSONValue): s.PullRequestSourceReferenceUpdatedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "beforeCommitId": "s",
      "afterCommitId": "s",
      "mergeBase": "s",
    },
  }, root);
}

function toPullRequestMergedStateChangedEventMetadata(root: jsonP.JSONValue): s.PullRequestMergedStateChangedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "destinationReference": "s",
      "mergeMetadata": toMergeMetadata,
    },
  }, root);
}

function toApprovalRuleEventMetadata(root: jsonP.JSONValue): s.ApprovalRuleEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "approvalRuleName": "s",
      "approvalRuleId": "s",
      "approvalRuleContent": "s",
    },
  }, root);
}

function toApprovalStateChangedEventMetadata(root: jsonP.JSONValue): s.ApprovalStateChangedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "revisionId": "s",
      "approvalStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApprovalState>(x),
    },
  }, root);
}

function toApprovalRuleOverriddenEventMetadata(root: jsonP.JSONValue): s.ApprovalRuleOverriddenEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "revisionId": "s",
      "overrideStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.OverrideStatus>(x),
    },
  }, root);
}

function toEvaluation(root: jsonP.JSONValue): s.Evaluation {
  return jsonP.readObj({
    required: {},
    optional: {
      "approved": "b",
      "overridden": "b",
      "approvalRulesSatisfied": ["s"],
      "approvalRulesNotSatisfied": ["s"],
    },
  }, root);
}

function toReactionForComment(root: jsonP.JSONValue): s.ReactionForComment {
  return jsonP.readObj({
    required: {},
    optional: {
      "reaction": toReactionValueFormats,
      "reactionUsers": ["s"],
      "reactionsFromDeletedUsersCount": "n",
    },
  }, root);
}

function toReactionValueFormats(root: jsonP.JSONValue): s.ReactionValueFormats {
  return jsonP.readObj({
    required: {},
    optional: {
      "emoji": "s",
      "shortCode": "s",
      "unicode": "s",
    },
  }, root);
}

function toCommentsForComparedCommit(root: jsonP.JSONValue): s.CommentsForComparedCommit {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "beforeCommitId": "s",
      "afterCommitId": "s",
      "beforeBlobId": "s",
      "afterBlobId": "s",
      "location": toLocation,
      "comments": [toComment],
    },
  }, root);
}

function toCommentsForPullRequest(root: jsonP.JSONValue): s.CommentsForPullRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "pullRequestId": "s",
      "repositoryName": "s",
      "beforeCommitId": "s",
      "afterCommitId": "s",
      "beforeBlobId": "s",
      "afterBlobId": "s",
      "location": toLocation,
      "comments": [toComment],
    },
  }, root);
}

function toDifference(root: jsonP.JSONValue): s.Difference {
  return jsonP.readObj({
    required: {},
    optional: {
      "beforeBlob": toBlobMetadata,
      "afterBlob": toBlobMetadata,
      "changeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChangeTypeEnum>(x),
    },
  }, root);
}

function toBlobMetadata(root: jsonP.JSONValue): s.BlobMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "blobId": "s",
      "path": "s",
      "mode": "s",
    },
  }, root);
}

function toFolder(root: jsonP.JSONValue): s.Folder {
  return jsonP.readObj({
    required: {},
    optional: {
      "treeId": "s",
      "absolutePath": "s",
      "relativePath": "s",
    },
  }, root);
}

function toFile(root: jsonP.JSONValue): s.File {
  return jsonP.readObj({
    required: {},
    optional: {
      "blobId": "s",
      "absolutePath": "s",
      "relativePath": "s",
      "fileMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileModeTypeEnum>(x),
    },
  }, root);
}

function toSymbolicLink(root: jsonP.JSONValue): s.SymbolicLink {
  return jsonP.readObj({
    required: {},
    optional: {
      "blobId": "s",
      "absolutePath": "s",
      "relativePath": "s",
      "fileMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileModeTypeEnum>(x),
    },
  }, root);
}

function toSubModule(root: jsonP.JSONValue): s.SubModule {
  return jsonP.readObj({
    required: {},
    optional: {
      "commitId": "s",
      "absolutePath": "s",
      "relativePath": "s",
    },
  }, root);
}

function toApproval(root: jsonP.JSONValue): s.Approval {
  return jsonP.readObj({
    required: {},
    optional: {
      "userArn": "s",
      "approvalState": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApprovalState>(x),
    },
  }, root);
}

function toRepositoryNameIdPair(root: jsonP.JSONValue): s.RepositoryNameIdPair {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "repositoryId": "s",
    },
  }, root);
}

function toRepositoryTriggerExecutionFailure(root: jsonP.JSONValue): s.RepositoryTriggerExecutionFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "trigger": "s",
      "failureMessage": "s",
    },
  }, root);
}
