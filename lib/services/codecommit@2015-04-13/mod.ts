// Autogenerated API client for: AWS CodeCommit

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.75.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class CodeCommit {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodeCommit.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2015-04-13",
    "endpointPrefix": "codecommit",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "CodeCommit",
    "serviceFullName": "AWS CodeCommit",
    "serviceId": "CodeCommit",
    "signatureVersion": "v4",
    "targetPrefix": "CodeCommit_20150413",
    "uid": "codecommit-2015-04-13"
  };

  async associateApprovalRuleTemplateWithRepository(
    {abortSignal, ...params}: RequestConfig & AssociateApprovalRuleTemplateWithRepositoryInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateApprovalRuleTemplateWithRepository",
    });
  }

  async batchAssociateApprovalRuleTemplateWithRepositories(
    {abortSignal, ...params}: RequestConfig & BatchAssociateApprovalRuleTemplateWithRepositoriesInput,
  ): Promise<BatchAssociateApprovalRuleTemplateWithRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      repositoryNames: params["repositoryNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchAssociateApprovalRuleTemplateWithRepositories",
    });
    return jsonP.readObj({
      required: {
        "associatedRepositoryNames": ["s"],
        "errors": [toBatchAssociateApprovalRuleTemplateWithRepositoriesError],
      },
      optional: {},
    }, await resp.json());
  }

  async batchDescribeMergeConflicts(
    {abortSignal, ...params}: RequestConfig & BatchDescribeMergeConflictsInput,
  ): Promise<BatchDescribeMergeConflictsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      mergeOption: params["mergeOption"],
      maxMergeHunks: params["maxMergeHunks"],
      maxConflictFiles: params["maxConflictFiles"],
      filePaths: params["filePaths"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDescribeMergeConflicts",
    });
    return jsonP.readObj({
      required: {
        "conflicts": [toConflict],
        "destinationCommitId": "s",
        "sourceCommitId": "s",
      },
      optional: {
        "nextToken": "s",
        "errors": [toBatchDescribeMergeConflictsError],
        "baseCommitId": "s",
      },
    }, await resp.json());
  }

  async batchDisassociateApprovalRuleTemplateFromRepositories(
    {abortSignal, ...params}: RequestConfig & BatchDisassociateApprovalRuleTemplateFromRepositoriesInput,
  ): Promise<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      repositoryNames: params["repositoryNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDisassociateApprovalRuleTemplateFromRepositories",
    });
    return jsonP.readObj({
      required: {
        "disassociatedRepositoryNames": ["s"],
        "errors": [toBatchDisassociateApprovalRuleTemplateFromRepositoriesError],
      },
      optional: {},
    }, await resp.json());
  }

  async batchGetCommits(
    {abortSignal, ...params}: RequestConfig & BatchGetCommitsInput,
  ): Promise<BatchGetCommitsOutput> {
    const body: jsonP.JSONObject = {
      commitIds: params["commitIds"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetCommits",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commits": [toCommit],
        "errors": [toBatchGetCommitsError],
      },
    }, await resp.json());
  }

  async batchGetRepositories(
    {abortSignal, ...params}: RequestConfig & BatchGetRepositoriesInput,
  ): Promise<BatchGetRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      repositoryNames: params["repositoryNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetRepositories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositories": [toRepositoryMetadata],
        "repositoriesNotFound": ["s"],
      },
    }, await resp.json());
  }

  async createApprovalRuleTemplate(
    {abortSignal, ...params}: RequestConfig & CreateApprovalRuleTemplateInput,
  ): Promise<CreateApprovalRuleTemplateOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      approvalRuleTemplateContent: params["approvalRuleTemplateContent"],
      approvalRuleTemplateDescription: params["approvalRuleTemplateDescription"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApprovalRuleTemplate",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async createBranch(
    {abortSignal, ...params}: RequestConfig & CreateBranchInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
      commitId: params["commitId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBranch",
    });
  }

  async createCommit(
    {abortSignal, ...params}: RequestConfig & CreateCommitInput,
  ): Promise<CreateCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
      parentCommitId: params["parentCommitId"],
      authorName: params["authorName"],
      email: params["email"],
      commitMessage: params["commitMessage"],
      keepEmptyFolders: params["keepEmptyFolders"],
      putFiles: params["putFiles"]?.map(x => fromPutFileEntry(x)),
      deleteFiles: params["deleteFiles"]?.map(x => fromDeleteFileEntry(x)),
      setFileModes: params["setFileModes"]?.map(x => fromSetFileModeEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
        "filesAdded": [toFileMetadata],
        "filesUpdated": [toFileMetadata],
        "filesDeleted": [toFileMetadata],
      },
    }, await resp.json());
  }

  async createPullRequest(
    {abortSignal, ...params}: RequestConfig & CreatePullRequestInput,
  ): Promise<CreatePullRequestOutput> {
    const body: jsonP.JSONObject = {
      title: params["title"],
      description: params["description"],
      targets: params["targets"]?.map(x => fromTarget(x)),
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePullRequest",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async createPullRequestApprovalRule(
    {abortSignal, ...params}: RequestConfig & CreatePullRequestApprovalRuleInput,
  ): Promise<CreatePullRequestApprovalRuleOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      approvalRuleName: params["approvalRuleName"],
      approvalRuleContent: params["approvalRuleContent"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePullRequestApprovalRule",
    });
    return jsonP.readObj({
      required: {
        "approvalRule": toApprovalRule,
      },
      optional: {},
    }, await resp.json());
  }

  async createRepository(
    {abortSignal, ...params}: RequestConfig & CreateRepositoryInput,
  ): Promise<CreateRepositoryOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      repositoryDescription: params["repositoryDescription"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryMetadata": toRepositoryMetadata,
      },
    }, await resp.json());
  }

  async createUnreferencedMergeCommit(
    {abortSignal, ...params}: RequestConfig & CreateUnreferencedMergeCommitInput,
  ): Promise<CreateUnreferencedMergeCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      mergeOption: params["mergeOption"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      authorName: params["authorName"],
      email: params["email"],
      commitMessage: params["commitMessage"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUnreferencedMergeCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
      },
    }, await resp.json());
  }

  async deleteApprovalRuleTemplate(
    {abortSignal, ...params}: RequestConfig & DeleteApprovalRuleTemplateInput,
  ): Promise<DeleteApprovalRuleTemplateOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApprovalRuleTemplate",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplateId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteBranch(
    {abortSignal, ...params}: RequestConfig & DeleteBranchInput,
  ): Promise<DeleteBranchOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBranch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deletedBranch": toBranchInfo,
      },
    }, await resp.json());
  }

  async deleteCommentContent(
    {abortSignal, ...params}: RequestConfig & DeleteCommentContentInput,
  ): Promise<DeleteCommentContentOutput> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCommentContent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "comment": toComment,
      },
    }, await resp.json());
  }

  async deleteFile(
    {abortSignal, ...params}: RequestConfig & DeleteFileInput,
  ): Promise<DeleteFileOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
      filePath: params["filePath"],
      parentCommitId: params["parentCommitId"],
      keepEmptyFolders: params["keepEmptyFolders"],
      commitMessage: params["commitMessage"],
      name: params["name"],
      email: params["email"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFile",
    });
    return jsonP.readObj({
      required: {
        "commitId": "s",
        "blobId": "s",
        "treeId": "s",
        "filePath": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deletePullRequestApprovalRule(
    {abortSignal, ...params}: RequestConfig & DeletePullRequestApprovalRuleInput,
  ): Promise<DeletePullRequestApprovalRuleOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      approvalRuleName: params["approvalRuleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePullRequestApprovalRule",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteRepository(
    {abortSignal, ...params}: RequestConfig & DeleteRepositoryInput,
  ): Promise<DeleteRepositoryOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryId": "s",
      },
    }, await resp.json());
  }

  async describeMergeConflicts(
    {abortSignal, ...params}: RequestConfig & DescribeMergeConflictsInput,
  ): Promise<DescribeMergeConflictsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      mergeOption: params["mergeOption"],
      maxMergeHunks: params["maxMergeHunks"],
      filePath: params["filePath"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMergeConflicts",
    });
    return jsonP.readObj({
      required: {
        "conflictMetadata": toConflictMetadata,
        "mergeHunks": [toMergeHunk],
        "destinationCommitId": "s",
        "sourceCommitId": "s",
      },
      optional: {
        "nextToken": "s",
        "baseCommitId": "s",
      },
    }, await resp.json());
  }

  async describePullRequestEvents(
    {abortSignal, ...params}: RequestConfig & DescribePullRequestEventsInput,
  ): Promise<DescribePullRequestEventsOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      pullRequestEventType: params["pullRequestEventType"],
      actorArn: params["actorArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePullRequestEvents",
    });
    return jsonP.readObj({
      required: {
        "pullRequestEvents": [toPullRequestEvent],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async disassociateApprovalRuleTemplateFromRepository(
    {abortSignal, ...params}: RequestConfig & DisassociateApprovalRuleTemplateFromRepositoryInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateApprovalRuleTemplateFromRepository",
    });
  }

  async evaluatePullRequestApprovalRules(
    {abortSignal, ...params}: RequestConfig & EvaluatePullRequestApprovalRulesInput,
  ): Promise<EvaluatePullRequestApprovalRulesOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EvaluatePullRequestApprovalRules",
    });
    return jsonP.readObj({
      required: {
        "evaluation": toEvaluation,
      },
      optional: {},
    }, await resp.json());
  }

  async getApprovalRuleTemplate(
    {abortSignal, ...params}: RequestConfig & GetApprovalRuleTemplateInput,
  ): Promise<GetApprovalRuleTemplateOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetApprovalRuleTemplate",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async getBlob(
    {abortSignal, ...params}: RequestConfig & GetBlobInput,
  ): Promise<GetBlobOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      blobId: params["blobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBlob",
    });
    return jsonP.readObj({
      required: {
        "content": "a",
      },
      optional: {},
    }, await resp.json());
  }

  async getBranch(
    {abortSignal, ...params}: RequestConfig & GetBranchInput = {},
  ): Promise<GetBranchOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBranch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "branch": toBranchInfo,
      },
    }, await resp.json());
  }

  async getComment(
    {abortSignal, ...params}: RequestConfig & GetCommentInput,
  ): Promise<GetCommentOutput> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetComment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "comment": toComment,
      },
    }, await resp.json());
  }

  async getCommentReactions(
    {abortSignal, ...params}: RequestConfig & GetCommentReactionsInput,
  ): Promise<GetCommentReactionsOutput> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
      reactionUserArn: params["reactionUserArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCommentReactions",
    });
    return jsonP.readObj({
      required: {
        "reactionsForComment": [toReactionForComment],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getCommentsForComparedCommit(
    {abortSignal, ...params}: RequestConfig & GetCommentsForComparedCommitInput,
  ): Promise<GetCommentsForComparedCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      beforeCommitId: params["beforeCommitId"],
      afterCommitId: params["afterCommitId"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCommentsForComparedCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commentsForComparedCommitData": [toCommentsForComparedCommit],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getCommentsForPullRequest(
    {abortSignal, ...params}: RequestConfig & GetCommentsForPullRequestInput,
  ): Promise<GetCommentsForPullRequestOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      beforeCommitId: params["beforeCommitId"],
      afterCommitId: params["afterCommitId"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCommentsForPullRequest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commentsForPullRequestData": [toCommentsForPullRequest],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getCommit(
    {abortSignal, ...params}: RequestConfig & GetCommitInput,
  ): Promise<GetCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      commitId: params["commitId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCommit",
    });
    return jsonP.readObj({
      required: {
        "commit": toCommit,
      },
      optional: {},
    }, await resp.json());
  }

  async getDifferences(
    {abortSignal, ...params}: RequestConfig & GetDifferencesInput,
  ): Promise<GetDifferencesOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      beforeCommitSpecifier: params["beforeCommitSpecifier"],
      afterCommitSpecifier: params["afterCommitSpecifier"],
      beforePath: params["beforePath"],
      afterPath: params["afterPath"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDifferences",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "differences": [toDifference],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getFile(
    {abortSignal, ...params}: RequestConfig & GetFileInput,
  ): Promise<GetFileOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      commitSpecifier: params["commitSpecifier"],
      filePath: params["filePath"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFile",
    });
    return jsonP.readObj({
      required: {
        "commitId": "s",
        "blobId": "s",
        "filePath": "s",
        "fileMode": (x: jsonP.JSONValue) => cmnP.readEnum<FileModeTypeEnum>(x),
        "fileSize": "n",
        "fileContent": "a",
      },
      optional: {},
    }, await resp.json());
  }

  async getFolder(
    {abortSignal, ...params}: RequestConfig & GetFolderInput,
  ): Promise<GetFolderOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      commitSpecifier: params["commitSpecifier"],
      folderPath: params["folderPath"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFolder",
    });
    return jsonP.readObj({
      required: {
        "commitId": "s",
        "folderPath": "s",
      },
      optional: {
        "treeId": "s",
        "subFolders": [toFolder],
        "files": [toFile],
        "symbolicLinks": [toSymbolicLink],
        "subModules": [toSubModule],
      },
    }, await resp.json());
  }

  async getMergeCommit(
    {abortSignal, ...params}: RequestConfig & GetMergeCommitInput,
  ): Promise<GetMergeCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMergeCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "sourceCommitId": "s",
        "destinationCommitId": "s",
        "baseCommitId": "s",
        "mergedCommitId": "s",
      },
    }, await resp.json());
  }

  async getMergeConflicts(
    {abortSignal, ...params}: RequestConfig & GetMergeConflictsInput,
  ): Promise<GetMergeConflictsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      mergeOption: params["mergeOption"],
      conflictDetailLevel: params["conflictDetailLevel"],
      maxConflictFiles: params["maxConflictFiles"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMergeConflicts",
    });
    return jsonP.readObj({
      required: {
        "mergeable": "b",
        "destinationCommitId": "s",
        "sourceCommitId": "s",
        "conflictMetadataList": [toConflictMetadata],
      },
      optional: {
        "baseCommitId": "s",
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getMergeOptions(
    {abortSignal, ...params}: RequestConfig & GetMergeOptionsInput,
  ): Promise<GetMergeOptionsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMergeOptions",
    });
    return jsonP.readObj({
      required: {
        "mergeOptions": [(x: jsonP.JSONValue) => cmnP.readEnum<MergeOptionTypeEnum>(x)],
        "sourceCommitId": "s",
        "destinationCommitId": "s",
        "baseCommitId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getPullRequest(
    {abortSignal, ...params}: RequestConfig & GetPullRequestInput,
  ): Promise<GetPullRequestOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPullRequest",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async getPullRequestApprovalStates(
    {abortSignal, ...params}: RequestConfig & GetPullRequestApprovalStatesInput,
  ): Promise<GetPullRequestApprovalStatesOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPullRequestApprovalStates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "approvals": [toApproval],
      },
    }, await resp.json());
  }

  async getPullRequestOverrideState(
    {abortSignal, ...params}: RequestConfig & GetPullRequestOverrideStateInput,
  ): Promise<GetPullRequestOverrideStateOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPullRequestOverrideState",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "overridden": "b",
        "overrider": "s",
      },
    }, await resp.json());
  }

  async getRepository(
    {abortSignal, ...params}: RequestConfig & GetRepositoryInput,
  ): Promise<GetRepositoryOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryMetadata": toRepositoryMetadata,
      },
    }, await resp.json());
  }

  async getRepositoryTriggers(
    {abortSignal, ...params}: RequestConfig & GetRepositoryTriggersInput,
  ): Promise<GetRepositoryTriggersOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRepositoryTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "configurationId": "s",
        "triggers": [toRepositoryTrigger],
      },
    }, await resp.json());
  }

  async listApprovalRuleTemplates(
    {abortSignal, ...params}: RequestConfig & ListApprovalRuleTemplatesInput = {},
  ): Promise<ListApprovalRuleTemplatesOutput> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListApprovalRuleTemplates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "approvalRuleTemplateNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAssociatedApprovalRuleTemplatesForRepository(
    {abortSignal, ...params}: RequestConfig & ListAssociatedApprovalRuleTemplatesForRepositoryInput,
  ): Promise<ListAssociatedApprovalRuleTemplatesForRepositoryOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAssociatedApprovalRuleTemplatesForRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "approvalRuleTemplateNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBranches(
    {abortSignal, ...params}: RequestConfig & ListBranchesInput,
  ): Promise<ListBranchesOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBranches",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "branches": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPullRequests(
    {abortSignal, ...params}: RequestConfig & ListPullRequestsInput,
  ): Promise<ListPullRequestsOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      authorArn: params["authorArn"],
      pullRequestStatus: params["pullRequestStatus"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPullRequests",
    });
    return jsonP.readObj({
      required: {
        "pullRequestIds": ["s"],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRepositories(
    {abortSignal, ...params}: RequestConfig & ListRepositoriesInput = {},
  ): Promise<ListRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      sortBy: params["sortBy"],
      order: params["order"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRepositories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositories": [toRepositoryNameIdPair],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRepositoriesForApprovalRuleTemplate(
    {abortSignal, ...params}: RequestConfig & ListRepositoriesForApprovalRuleTemplateInput,
  ): Promise<ListRepositoriesForApprovalRuleTemplateOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRepositoriesForApprovalRuleTemplate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryNames": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceInput,
  ): Promise<ListTagsForResourceOutput> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async mergeBranchesByFastForward(
    {abortSignal, ...params}: RequestConfig & MergeBranchesByFastForwardInput,
  ): Promise<MergeBranchesByFastForwardOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      targetBranch: params["targetBranch"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergeBranchesByFastForward",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
      },
    }, await resp.json());
  }

  async mergeBranchesBySquash(
    {abortSignal, ...params}: RequestConfig & MergeBranchesBySquashInput,
  ): Promise<MergeBranchesBySquashOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      targetBranch: params["targetBranch"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      authorName: params["authorName"],
      email: params["email"],
      commitMessage: params["commitMessage"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergeBranchesBySquash",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
      },
    }, await resp.json());
  }

  async mergeBranchesByThreeWay(
    {abortSignal, ...params}: RequestConfig & MergeBranchesByThreeWayInput,
  ): Promise<MergeBranchesByThreeWayOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      sourceCommitSpecifier: params["sourceCommitSpecifier"],
      destinationCommitSpecifier: params["destinationCommitSpecifier"],
      targetBranch: params["targetBranch"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      authorName: params["authorName"],
      email: params["email"],
      commitMessage: params["commitMessage"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergeBranchesByThreeWay",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "commitId": "s",
        "treeId": "s",
      },
    }, await resp.json());
  }

  async mergePullRequestByFastForward(
    {abortSignal, ...params}: RequestConfig & MergePullRequestByFastForwardInput,
  ): Promise<MergePullRequestByFastForwardOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      sourceCommitId: params["sourceCommitId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergePullRequestByFastForward",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pullRequest": toPullRequest,
      },
    }, await resp.json());
  }

  async mergePullRequestBySquash(
    {abortSignal, ...params}: RequestConfig & MergePullRequestBySquashInput,
  ): Promise<MergePullRequestBySquashOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      sourceCommitId: params["sourceCommitId"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      commitMessage: params["commitMessage"],
      authorName: params["authorName"],
      email: params["email"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergePullRequestBySquash",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pullRequest": toPullRequest,
      },
    }, await resp.json());
  }

  async mergePullRequestByThreeWay(
    {abortSignal, ...params}: RequestConfig & MergePullRequestByThreeWayInput,
  ): Promise<MergePullRequestByThreeWayOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      sourceCommitId: params["sourceCommitId"],
      conflictDetailLevel: params["conflictDetailLevel"],
      conflictResolutionStrategy: params["conflictResolutionStrategy"],
      commitMessage: params["commitMessage"],
      authorName: params["authorName"],
      email: params["email"],
      keepEmptyFolders: params["keepEmptyFolders"],
      conflictResolution: fromConflictResolution(params["conflictResolution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MergePullRequestByThreeWay",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pullRequest": toPullRequest,
      },
    }, await resp.json());
  }

  async overridePullRequestApprovalRules(
    {abortSignal, ...params}: RequestConfig & OverridePullRequestApprovalRulesInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
      overrideStatus: params["overrideStatus"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "OverridePullRequestApprovalRules",
    });
  }

  async postCommentForComparedCommit(
    {abortSignal, ...params}: RequestConfig & PostCommentForComparedCommitInput,
  ): Promise<PostCommentForComparedCommitOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      beforeCommitId: params["beforeCommitId"],
      afterCommitId: params["afterCommitId"],
      location: fromLocation(params["location"]),
      content: params["content"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PostCommentForComparedCommit",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryName": "s",
        "beforeCommitId": "s",
        "afterCommitId": "s",
        "beforeBlobId": "s",
        "afterBlobId": "s",
        "location": toLocation,
        "comment": toComment,
      },
    }, await resp.json());
  }

  async postCommentForPullRequest(
    {abortSignal, ...params}: RequestConfig & PostCommentForPullRequestInput,
  ): Promise<PostCommentForPullRequestOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      repositoryName: params["repositoryName"],
      beforeCommitId: params["beforeCommitId"],
      afterCommitId: params["afterCommitId"],
      location: fromLocation(params["location"]),
      content: params["content"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PostCommentForPullRequest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryName": "s",
        "pullRequestId": "s",
        "beforeCommitId": "s",
        "afterCommitId": "s",
        "beforeBlobId": "s",
        "afterBlobId": "s",
        "location": toLocation,
        "comment": toComment,
      },
    }, await resp.json());
  }

  async postCommentReply(
    {abortSignal, ...params}: RequestConfig & PostCommentReplyInput,
  ): Promise<PostCommentReplyOutput> {
    const body: jsonP.JSONObject = {
      inReplyTo: params["inReplyTo"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
      content: params["content"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PostCommentReply",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "comment": toComment,
      },
    }, await resp.json());
  }

  async putCommentReaction(
    {abortSignal, ...params}: RequestConfig & PutCommentReactionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
      reactionValue: params["reactionValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutCommentReaction",
    });
  }

  async putFile(
    {abortSignal, ...params}: RequestConfig & PutFileInput,
  ): Promise<PutFileOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      branchName: params["branchName"],
      fileContent: jsonP.serializeBlob(params["fileContent"]),
      filePath: params["filePath"],
      fileMode: params["fileMode"],
      parentCommitId: params["parentCommitId"],
      commitMessage: params["commitMessage"],
      name: params["name"],
      email: params["email"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutFile",
    });
    return jsonP.readObj({
      required: {
        "commitId": "s",
        "blobId": "s",
        "treeId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async putRepositoryTriggers(
    {abortSignal, ...params}: RequestConfig & PutRepositoryTriggersInput,
  ): Promise<PutRepositoryTriggersOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      triggers: params["triggers"]?.map(x => fromRepositoryTrigger(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRepositoryTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "configurationId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
  }

  async testRepositoryTriggers(
    {abortSignal, ...params}: RequestConfig & TestRepositoryTriggersInput,
  ): Promise<TestRepositoryTriggersOutput> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      triggers: params["triggers"]?.map(x => fromRepositoryTrigger(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestRepositoryTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "successfulExecutions": ["s"],
        "failedExecutions": [toRepositoryTriggerExecutionFailure],
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
  }

  async updateApprovalRuleTemplateContent(
    {abortSignal, ...params}: RequestConfig & UpdateApprovalRuleTemplateContentInput,
  ): Promise<UpdateApprovalRuleTemplateContentOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      newRuleContent: params["newRuleContent"],
      existingRuleContentSha256: params["existingRuleContentSha256"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApprovalRuleTemplateContent",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async updateApprovalRuleTemplateDescription(
    {abortSignal, ...params}: RequestConfig & UpdateApprovalRuleTemplateDescriptionInput,
  ): Promise<UpdateApprovalRuleTemplateDescriptionOutput> {
    const body: jsonP.JSONObject = {
      approvalRuleTemplateName: params["approvalRuleTemplateName"],
      approvalRuleTemplateDescription: params["approvalRuleTemplateDescription"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApprovalRuleTemplateDescription",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async updateApprovalRuleTemplateName(
    {abortSignal, ...params}: RequestConfig & UpdateApprovalRuleTemplateNameInput,
  ): Promise<UpdateApprovalRuleTemplateNameOutput> {
    const body: jsonP.JSONObject = {
      oldApprovalRuleTemplateName: params["oldApprovalRuleTemplateName"],
      newApprovalRuleTemplateName: params["newApprovalRuleTemplateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApprovalRuleTemplateName",
    });
    return jsonP.readObj({
      required: {
        "approvalRuleTemplate": toApprovalRuleTemplate,
      },
      optional: {},
    }, await resp.json());
  }

  async updateComment(
    {abortSignal, ...params}: RequestConfig & UpdateCommentInput,
  ): Promise<UpdateCommentOutput> {
    const body: jsonP.JSONObject = {
      commentId: params["commentId"],
      content: params["content"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateComment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "comment": toComment,
      },
    }, await resp.json());
  }

  async updateDefaultBranch(
    {abortSignal, ...params}: RequestConfig & UpdateDefaultBranchInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      defaultBranchName: params["defaultBranchName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDefaultBranch",
    });
  }

  async updatePullRequestApprovalRuleContent(
    {abortSignal, ...params}: RequestConfig & UpdatePullRequestApprovalRuleContentInput,
  ): Promise<UpdatePullRequestApprovalRuleContentOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      approvalRuleName: params["approvalRuleName"],
      existingRuleContentSha256: params["existingRuleContentSha256"],
      newRuleContent: params["newRuleContent"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestApprovalRuleContent",
    });
    return jsonP.readObj({
      required: {
        "approvalRule": toApprovalRule,
      },
      optional: {},
    }, await resp.json());
  }

  async updatePullRequestApprovalState(
    {abortSignal, ...params}: RequestConfig & UpdatePullRequestApprovalStateInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      revisionId: params["revisionId"],
      approvalState: params["approvalState"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestApprovalState",
    });
  }

  async updatePullRequestDescription(
    {abortSignal, ...params}: RequestConfig & UpdatePullRequestDescriptionInput,
  ): Promise<UpdatePullRequestDescriptionOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestDescription",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async updatePullRequestStatus(
    {abortSignal, ...params}: RequestConfig & UpdatePullRequestStatusInput,
  ): Promise<UpdatePullRequestStatusOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      pullRequestStatus: params["pullRequestStatus"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestStatus",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async updatePullRequestTitle(
    {abortSignal, ...params}: RequestConfig & UpdatePullRequestTitleInput,
  ): Promise<UpdatePullRequestTitleOutput> {
    const body: jsonP.JSONObject = {
      pullRequestId: params["pullRequestId"],
      title: params["title"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePullRequestTitle",
    });
    return jsonP.readObj({
      required: {
        "pullRequest": toPullRequest,
      },
      optional: {},
    }, await resp.json());
  }

  async updateRepositoryDescription(
    {abortSignal, ...params}: RequestConfig & UpdateRepositoryDescriptionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      repositoryDescription: params["repositoryDescription"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRepositoryDescription",
    });
  }

  async updateRepositoryName(
    {abortSignal, ...params}: RequestConfig & UpdateRepositoryNameInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      oldName: params["oldName"],
      newName: params["newName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRepositoryName",
    });
  }

}

// refs: 1 - tags: named, input
export interface AssociateApprovalRuleTemplateWithRepositoryInput {
  approvalRuleTemplateName: string;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface BatchAssociateApprovalRuleTemplateWithRepositoriesInput {
  approvalRuleTemplateName: string;
  repositoryNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchDescribeMergeConflictsInput {
  repositoryName: string;
  destinationCommitSpecifier: string;
  sourceCommitSpecifier: string;
  mergeOption: MergeOptionTypeEnum;
  maxMergeHunks?: number | null;
  maxConflictFiles?: number | null;
  filePaths?: string[] | null;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface BatchDisassociateApprovalRuleTemplateFromRepositoriesInput {
  approvalRuleTemplateName: string;
  repositoryNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetCommitsInput {
  commitIds: string[];
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface BatchGetRepositoriesInput {
  repositoryNames: string[];
}

// refs: 1 - tags: named, input
export interface CreateApprovalRuleTemplateInput {
  approvalRuleTemplateName: string;
  approvalRuleTemplateContent: string;
  approvalRuleTemplateDescription?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateBranchInput {
  repositoryName: string;
  branchName: string;
  commitId: string;
}

// refs: 1 - tags: named, input
export interface CreateCommitInput {
  repositoryName: string;
  branchName: string;
  parentCommitId?: string | null;
  authorName?: string | null;
  email?: string | null;
  commitMessage?: string | null;
  keepEmptyFolders?: boolean | null;
  putFiles?: PutFileEntry[] | null;
  deleteFiles?: DeleteFileEntry[] | null;
  setFileModes?: SetFileModeEntry[] | null;
}

// refs: 1 - tags: named, input
export interface CreatePullRequestInput {
  title: string;
  description?: string | null;
  targets: Target[];
  clientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreatePullRequestApprovalRuleInput {
  pullRequestId: string;
  approvalRuleName: string;
  approvalRuleContent: string;
}

// refs: 1 - tags: named, input
export interface CreateRepositoryInput {
  repositoryName: string;
  repositoryDescription?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateUnreferencedMergeCommitInput {
  repositoryName: string;
  sourceCommitSpecifier: string;
  destinationCommitSpecifier: string;
  mergeOption: MergeOptionTypeEnum;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
  authorName?: string | null;
  email?: string | null;
  commitMessage?: string | null;
  keepEmptyFolders?: boolean | null;
  conflictResolution?: ConflictResolution | null;
}

// refs: 1 - tags: named, input
export interface DeleteApprovalRuleTemplateInput {
  approvalRuleTemplateName: string;
}

// refs: 1 - tags: named, input
export interface DeleteBranchInput {
  repositoryName: string;
  branchName: string;
}

// refs: 1 - tags: named, input
export interface DeleteCommentContentInput {
  commentId: string;
}

// refs: 1 - tags: named, input
export interface DeleteFileInput {
  repositoryName: string;
  branchName: string;
  filePath: string;
  parentCommitId: string;
  keepEmptyFolders?: boolean | null;
  commitMessage?: string | null;
  name?: string | null;
  email?: string | null;
}

// refs: 1 - tags: named, input
export interface DeletePullRequestApprovalRuleInput {
  pullRequestId: string;
  approvalRuleName: string;
}

// refs: 1 - tags: named, input
export interface DeleteRepositoryInput {
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface DescribeMergeConflictsInput {
  repositoryName: string;
  destinationCommitSpecifier: string;
  sourceCommitSpecifier: string;
  mergeOption: MergeOptionTypeEnum;
  maxMergeHunks?: number | null;
  filePath: string;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribePullRequestEventsInput {
  pullRequestId: string;
  pullRequestEventType?: PullRequestEventType | null;
  actorArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DisassociateApprovalRuleTemplateFromRepositoryInput {
  approvalRuleTemplateName: string;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface EvaluatePullRequestApprovalRulesInput {
  pullRequestId: string;
  revisionId: string;
}

// refs: 1 - tags: named, input
export interface GetApprovalRuleTemplateInput {
  approvalRuleTemplateName: string;
}

// refs: 1 - tags: named, input
export interface GetBlobInput {
  repositoryName: string;
  blobId: string;
}

// refs: 1 - tags: named, input
export interface GetBranchInput {
  repositoryName?: string | null;
  branchName?: string | null;
}

// refs: 1 - tags: named, input
export interface GetCommentInput {
  commentId: string;
}

// refs: 1 - tags: named, input
export interface GetCommentReactionsInput {
  commentId: string;
  reactionUserArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetCommentsForComparedCommitInput {
  repositoryName: string;
  beforeCommitId?: string | null;
  afterCommitId: string;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetCommentsForPullRequestInput {
  pullRequestId: string;
  repositoryName?: string | null;
  beforeCommitId?: string | null;
  afterCommitId?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetCommitInput {
  repositoryName: string;
  commitId: string;
}

// refs: 1 - tags: named, input
export interface GetDifferencesInput {
  repositoryName: string;
  beforeCommitSpecifier?: string | null;
  afterCommitSpecifier: string;
  beforePath?: string | null;
  afterPath?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetFileInput {
  repositoryName: string;
  commitSpecifier?: string | null;
  filePath: string;
}

// refs: 1 - tags: named, input
export interface GetFolderInput {
  repositoryName: string;
  commitSpecifier?: string | null;
  folderPath: string;
}

// refs: 1 - tags: named, input
export interface GetMergeCommitInput {
  repositoryName: string;
  sourceCommitSpecifier: string;
  destinationCommitSpecifier: string;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
}

// refs: 1 - tags: named, input
export interface GetMergeConflictsInput {
  repositoryName: string;
  destinationCommitSpecifier: string;
  sourceCommitSpecifier: string;
  mergeOption: MergeOptionTypeEnum;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  maxConflictFiles?: number | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetMergeOptionsInput {
  repositoryName: string;
  sourceCommitSpecifier: string;
  destinationCommitSpecifier: string;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
}

// refs: 1 - tags: named, input
export interface GetPullRequestInput {
  pullRequestId: string;
}

// refs: 1 - tags: named, input
export interface GetPullRequestApprovalStatesInput {
  pullRequestId: string;
  revisionId: string;
}

// refs: 1 - tags: named, input
export interface GetPullRequestOverrideStateInput {
  pullRequestId: string;
  revisionId: string;
}

// refs: 1 - tags: named, input
export interface GetRepositoryInput {
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface GetRepositoryTriggersInput {
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface ListApprovalRuleTemplatesInput {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListAssociatedApprovalRuleTemplatesForRepositoryInput {
  repositoryName: string;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListBranchesInput {
  repositoryName: string;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPullRequestsInput {
  repositoryName: string;
  authorArn?: string | null;
  pullRequestStatus?: PullRequestStatusEnum | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListRepositoriesInput {
  nextToken?: string | null;
  sortBy?: SortByEnum | null;
  order?: OrderEnum | null;
}

// refs: 1 - tags: named, input
export interface ListRepositoriesForApprovalRuleTemplateInput {
  approvalRuleTemplateName: string;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceInput {
  resourceArn: string;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface MergeBranchesByFastForwardInput {
  repositoryName: string;
  sourceCommitSpecifier: string;
  destinationCommitSpecifier: string;
  targetBranch?: string | null;
}

// refs: 1 - tags: named, input
export interface MergeBranchesBySquashInput {
  repositoryName: string;
  sourceCommitSpecifier: string;
  destinationCommitSpecifier: string;
  targetBranch?: string | null;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
  authorName?: string | null;
  email?: string | null;
  commitMessage?: string | null;
  keepEmptyFolders?: boolean | null;
  conflictResolution?: ConflictResolution | null;
}

// refs: 1 - tags: named, input
export interface MergeBranchesByThreeWayInput {
  repositoryName: string;
  sourceCommitSpecifier: string;
  destinationCommitSpecifier: string;
  targetBranch?: string | null;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
  authorName?: string | null;
  email?: string | null;
  commitMessage?: string | null;
  keepEmptyFolders?: boolean | null;
  conflictResolution?: ConflictResolution | null;
}

// refs: 1 - tags: named, input
export interface MergePullRequestByFastForwardInput {
  pullRequestId: string;
  repositoryName: string;
  sourceCommitId?: string | null;
}

// refs: 1 - tags: named, input
export interface MergePullRequestBySquashInput {
  pullRequestId: string;
  repositoryName: string;
  sourceCommitId?: string | null;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
  commitMessage?: string | null;
  authorName?: string | null;
  email?: string | null;
  keepEmptyFolders?: boolean | null;
  conflictResolution?: ConflictResolution | null;
}

// refs: 1 - tags: named, input
export interface MergePullRequestByThreeWayInput {
  pullRequestId: string;
  repositoryName: string;
  sourceCommitId?: string | null;
  conflictDetailLevel?: ConflictDetailLevelTypeEnum | null;
  conflictResolutionStrategy?: ConflictResolutionStrategyTypeEnum | null;
  commitMessage?: string | null;
  authorName?: string | null;
  email?: string | null;
  keepEmptyFolders?: boolean | null;
  conflictResolution?: ConflictResolution | null;
}

// refs: 1 - tags: named, input
export interface OverridePullRequestApprovalRulesInput {
  pullRequestId: string;
  revisionId: string;
  overrideStatus: OverrideStatus;
}

// refs: 1 - tags: named, input
export interface PostCommentForComparedCommitInput {
  repositoryName: string;
  beforeCommitId?: string | null;
  afterCommitId: string;
  location?: Location | null;
  content: string;
  clientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PostCommentForPullRequestInput {
  pullRequestId: string;
  repositoryName: string;
  beforeCommitId: string;
  afterCommitId: string;
  location?: Location | null;
  content: string;
  clientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PostCommentReplyInput {
  inReplyTo: string;
  clientRequestToken?: string | null;
  content: string;
}

// refs: 1 - tags: named, input
export interface PutCommentReactionInput {
  commentId: string;
  reactionValue: string;
}

// refs: 1 - tags: named, input
export interface PutFileInput {
  repositoryName: string;
  branchName: string;
  fileContent: Uint8Array | string;
  filePath: string;
  fileMode?: FileModeTypeEnum | null;
  parentCommitId?: string | null;
  commitMessage?: string | null;
  name?: string | null;
  email?: string | null;
}

// refs: 1 - tags: named, input
export interface PutRepositoryTriggersInput {
  repositoryName: string;
  triggers: RepositoryTrigger[];
}

// refs: 1 - tags: named, input
export interface TagResourceInput {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface TestRepositoryTriggersInput {
  repositoryName: string;
  triggers: RepositoryTrigger[];
}

// refs: 1 - tags: named, input
export interface UntagResourceInput {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateApprovalRuleTemplateContentInput {
  approvalRuleTemplateName: string;
  newRuleContent: string;
  existingRuleContentSha256?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateApprovalRuleTemplateDescriptionInput {
  approvalRuleTemplateName: string;
  approvalRuleTemplateDescription: string;
}

// refs: 1 - tags: named, input
export interface UpdateApprovalRuleTemplateNameInput {
  oldApprovalRuleTemplateName: string;
  newApprovalRuleTemplateName: string;
}

// refs: 1 - tags: named, input
export interface UpdateCommentInput {
  commentId: string;
  content: string;
}

// refs: 1 - tags: named, input
export interface UpdateDefaultBranchInput {
  repositoryName: string;
  defaultBranchName: string;
}

// refs: 1 - tags: named, input
export interface UpdatePullRequestApprovalRuleContentInput {
  pullRequestId: string;
  approvalRuleName: string;
  existingRuleContentSha256?: string | null;
  newRuleContent: string;
}

// refs: 1 - tags: named, input
export interface UpdatePullRequestApprovalStateInput {
  pullRequestId: string;
  revisionId: string;
  approvalState: ApprovalState;
}

// refs: 1 - tags: named, input
export interface UpdatePullRequestDescriptionInput {
  pullRequestId: string;
  description: string;
}

// refs: 1 - tags: named, input
export interface UpdatePullRequestStatusInput {
  pullRequestId: string;
  pullRequestStatus: PullRequestStatusEnum;
}

// refs: 1 - tags: named, input
export interface UpdatePullRequestTitleInput {
  pullRequestId: string;
  title: string;
}

// refs: 1 - tags: named, input
export interface UpdateRepositoryDescriptionInput {
  repositoryName: string;
  repositoryDescription?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateRepositoryNameInput {
  oldName: string;
  newName: string;
}

// refs: 1 - tags: named, output
export interface BatchAssociateApprovalRuleTemplateWithRepositoriesOutput {
  associatedRepositoryNames: string[];
  errors: BatchAssociateApprovalRuleTemplateWithRepositoriesError[];
}

// refs: 1 - tags: named, output
export interface BatchDescribeMergeConflictsOutput {
  conflicts: Conflict[];
  nextToken?: string | null;
  errors?: BatchDescribeMergeConflictsError[] | null;
  destinationCommitId: string;
  sourceCommitId: string;
  baseCommitId?: string | null;
}

// refs: 1 - tags: named, output
export interface BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput {
  disassociatedRepositoryNames: string[];
  errors: BatchDisassociateApprovalRuleTemplateFromRepositoriesError[];
}

// refs: 1 - tags: named, output
export interface BatchGetCommitsOutput {
  commits?: Commit[] | null;
  errors?: BatchGetCommitsError[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetRepositoriesOutput {
  repositories?: RepositoryMetadata[] | null;
  repositoriesNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface CreateApprovalRuleTemplateOutput {
  approvalRuleTemplate: ApprovalRuleTemplate;
}

// refs: 1 - tags: named, output
export interface CreateCommitOutput {
  commitId?: string | null;
  treeId?: string | null;
  filesAdded?: FileMetadata[] | null;
  filesUpdated?: FileMetadata[] | null;
  filesDeleted?: FileMetadata[] | null;
}

// refs: 1 - tags: named, output
export interface CreatePullRequestOutput {
  pullRequest: PullRequest;
}

// refs: 1 - tags: named, output
export interface CreatePullRequestApprovalRuleOutput {
  approvalRule: ApprovalRule;
}

// refs: 1 - tags: named, output
export interface CreateRepositoryOutput {
  repositoryMetadata?: RepositoryMetadata | null;
}

// refs: 1 - tags: named, output
export interface CreateUnreferencedMergeCommitOutput {
  commitId?: string | null;
  treeId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteApprovalRuleTemplateOutput {
  approvalRuleTemplateId: string;
}

// refs: 1 - tags: named, output
export interface DeleteBranchOutput {
  deletedBranch?: BranchInfo | null;
}

// refs: 1 - tags: named, output
export interface DeleteCommentContentOutput {
  comment?: Comment | null;
}

// refs: 1 - tags: named, output
export interface DeleteFileOutput {
  commitId: string;
  blobId: string;
  treeId: string;
  filePath: string;
}

// refs: 1 - tags: named, output
export interface DeletePullRequestApprovalRuleOutput {
  approvalRuleId: string;
}

// refs: 1 - tags: named, output
export interface DeleteRepositoryOutput {
  repositoryId?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeMergeConflictsOutput {
  conflictMetadata: ConflictMetadata;
  mergeHunks: MergeHunk[];
  nextToken?: string | null;
  destinationCommitId: string;
  sourceCommitId: string;
  baseCommitId?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribePullRequestEventsOutput {
  pullRequestEvents: PullRequestEvent[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface EvaluatePullRequestApprovalRulesOutput {
  evaluation: Evaluation;
}

// refs: 1 - tags: named, output
export interface GetApprovalRuleTemplateOutput {
  approvalRuleTemplate: ApprovalRuleTemplate;
}

// refs: 1 - tags: named, output
export interface GetBlobOutput {
  content: Uint8Array | string;
}

// refs: 1 - tags: named, output
export interface GetBranchOutput {
  branch?: BranchInfo | null;
}

// refs: 1 - tags: named, output
export interface GetCommentOutput {
  comment?: Comment | null;
}

// refs: 1 - tags: named, output
export interface GetCommentReactionsOutput {
  reactionsForComment: ReactionForComment[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCommentsForComparedCommitOutput {
  commentsForComparedCommitData?: CommentsForComparedCommit[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCommentsForPullRequestOutput {
  commentsForPullRequestData?: CommentsForPullRequest[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCommitOutput {
  commit: Commit;
}

// refs: 1 - tags: named, output
export interface GetDifferencesOutput {
  differences?: Difference[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetFileOutput {
  commitId: string;
  blobId: string;
  filePath: string;
  fileMode: FileModeTypeEnum;
  fileSize: number;
  fileContent: Uint8Array | string;
}

// refs: 1 - tags: named, output
export interface GetFolderOutput {
  commitId: string;
  folderPath: string;
  treeId?: string | null;
  subFolders?: Folder[] | null;
  files?: File[] | null;
  symbolicLinks?: SymbolicLink[] | null;
  subModules?: SubModule[] | null;
}

// refs: 1 - tags: named, output
export interface GetMergeCommitOutput {
  sourceCommitId?: string | null;
  destinationCommitId?: string | null;
  baseCommitId?: string | null;
  mergedCommitId?: string | null;
}

// refs: 1 - tags: named, output
export interface GetMergeConflictsOutput {
  mergeable: boolean;
  destinationCommitId: string;
  sourceCommitId: string;
  baseCommitId?: string | null;
  conflictMetadataList: ConflictMetadata[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetMergeOptionsOutput {
  mergeOptions: MergeOptionTypeEnum[];
  sourceCommitId: string;
  destinationCommitId: string;
  baseCommitId: string;
}

// refs: 1 - tags: named, output
export interface GetPullRequestOutput {
  pullRequest: PullRequest;
}

// refs: 1 - tags: named, output
export interface GetPullRequestApprovalStatesOutput {
  approvals?: Approval[] | null;
}

// refs: 1 - tags: named, output
export interface GetPullRequestOverrideStateOutput {
  overridden?: boolean | null;
  overrider?: string | null;
}

// refs: 1 - tags: named, output
export interface GetRepositoryOutput {
  repositoryMetadata?: RepositoryMetadata | null;
}

// refs: 1 - tags: named, output
export interface GetRepositoryTriggersOutput {
  configurationId?: string | null;
  triggers?: RepositoryTrigger[] | null;
}

// refs: 1 - tags: named, output
export interface ListApprovalRuleTemplatesOutput {
  approvalRuleTemplateNames?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAssociatedApprovalRuleTemplatesForRepositoryOutput {
  approvalRuleTemplateNames?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListBranchesOutput {
  branches?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPullRequestsOutput {
  pullRequestIds: string[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRepositoriesOutput {
  repositories?: RepositoryNameIdPair[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRepositoriesForApprovalRuleTemplateOutput {
  repositoryNames?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceOutput {
  tags?: { [key: string]: string | null | undefined } | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface MergeBranchesByFastForwardOutput {
  commitId?: string | null;
  treeId?: string | null;
}

// refs: 1 - tags: named, output
export interface MergeBranchesBySquashOutput {
  commitId?: string | null;
  treeId?: string | null;
}

// refs: 1 - tags: named, output
export interface MergeBranchesByThreeWayOutput {
  commitId?: string | null;
  treeId?: string | null;
}

// refs: 1 - tags: named, output
export interface MergePullRequestByFastForwardOutput {
  pullRequest?: PullRequest | null;
}

// refs: 1 - tags: named, output
export interface MergePullRequestBySquashOutput {
  pullRequest?: PullRequest | null;
}

// refs: 1 - tags: named, output
export interface MergePullRequestByThreeWayOutput {
  pullRequest?: PullRequest | null;
}

// refs: 1 - tags: named, output
export interface PostCommentForComparedCommitOutput {
  repositoryName?: string | null;
  beforeCommitId?: string | null;
  afterCommitId?: string | null;
  beforeBlobId?: string | null;
  afterBlobId?: string | null;
  location?: Location | null;
  comment?: Comment | null;
}

// refs: 1 - tags: named, output
export interface PostCommentForPullRequestOutput {
  repositoryName?: string | null;
  pullRequestId?: string | null;
  beforeCommitId?: string | null;
  afterCommitId?: string | null;
  beforeBlobId?: string | null;
  afterBlobId?: string | null;
  location?: Location | null;
  comment?: Comment | null;
}

// refs: 1 - tags: named, output
export interface PostCommentReplyOutput {
  comment?: Comment | null;
}

// refs: 1 - tags: named, output
export interface PutFileOutput {
  commitId: string;
  blobId: string;
  treeId: string;
}

// refs: 1 - tags: named, output
export interface PutRepositoryTriggersOutput {
  configurationId?: string | null;
}

// refs: 1 - tags: named, output
export interface TestRepositoryTriggersOutput {
  successfulExecutions?: string[] | null;
  failedExecutions?: RepositoryTriggerExecutionFailure[] | null;
}

// refs: 1 - tags: named, output
export interface UpdateApprovalRuleTemplateContentOutput {
  approvalRuleTemplate: ApprovalRuleTemplate;
}

// refs: 1 - tags: named, output
export interface UpdateApprovalRuleTemplateDescriptionOutput {
  approvalRuleTemplate: ApprovalRuleTemplate;
}

// refs: 1 - tags: named, output
export interface UpdateApprovalRuleTemplateNameOutput {
  approvalRuleTemplate: ApprovalRuleTemplate;
}

// refs: 1 - tags: named, output
export interface UpdateCommentOutput {
  comment?: Comment | null;
}

// refs: 1 - tags: named, output
export interface UpdatePullRequestApprovalRuleContentOutput {
  approvalRule: ApprovalRule;
}

// refs: 1 - tags: named, output
export interface UpdatePullRequestDescriptionOutput {
  pullRequest: PullRequest;
}

// refs: 1 - tags: named, output
export interface UpdatePullRequestStatusOutput {
  pullRequest: PullRequest;
}

// refs: 1 - tags: named, output
export interface UpdatePullRequestTitleOutput {
  pullRequest: PullRequest;
}

// refs: 14 - tags: input, named, enum, output
export type MergeOptionTypeEnum =
| "FAST_FORWARD_MERGE"
| "SQUASH_MERGE"
| "THREE_WAY_MERGE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum
export type ConflictDetailLevelTypeEnum =
| "FILE_LEVEL"
| "LINE_LEVEL"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum
export type ConflictResolutionStrategyTypeEnum =
| "NONE"
| "ACCEPT_SOURCE"
| "ACCEPT_DESTINATION"
| "AUTOMERGE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface PutFileEntry {
  filePath: string;
  fileMode?: FileModeTypeEnum | null;
  fileContent?: Uint8Array | string | null;
  sourceFile?: SourceFileSpecifier | null;
}
function fromPutFileEntry(input?: PutFileEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    fileMode: input["fileMode"],
    fileContent: jsonP.serializeBlob(input["fileContent"]),
    sourceFile: fromSourceFileSpecifier(input["sourceFile"]),
  }
}

// refs: 28 - tags: input, named, enum, output
export type FileModeTypeEnum =
| "EXECUTABLE"
| "NORMAL"
| "SYMLINK"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SourceFileSpecifier {
  filePath: string;
  isMove?: boolean | null;
}
function fromSourceFileSpecifier(input?: SourceFileSpecifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    isMove: input["isMove"],
  }
}

// refs: 6 - tags: input, named, interface
export interface DeleteFileEntry {
  filePath: string;
}
function fromDeleteFileEntry(input?: DeleteFileEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
  }
}

// refs: 6 - tags: input, named, interface
export interface SetFileModeEntry {
  filePath: string;
  fileMode: FileModeTypeEnum;
}
function fromSetFileModeEntry(input?: SetFileModeEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    fileMode: input["fileMode"],
  }
}

// refs: 1 - tags: input, named, interface
export interface Target {
  repositoryName: string;
  sourceReference: string;
  destinationReference?: string | null;
}
function fromTarget(input?: Target | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    repositoryName: input["repositoryName"],
    sourceReference: input["sourceReference"],
    destinationReference: input["destinationReference"],
  }
}

// refs: 5 - tags: input, named, interface
export interface ConflictResolution {
  replaceContents?: ReplaceContentEntry[] | null;
  deleteFiles?: DeleteFileEntry[] | null;
  setFileModes?: SetFileModeEntry[] | null;
}
function fromConflictResolution(input?: ConflictResolution | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    replaceContents: input["replaceContents"]?.map(x => fromReplaceContentEntry(x)),
    deleteFiles: input["deleteFiles"]?.map(x => fromDeleteFileEntry(x)),
    setFileModes: input["setFileModes"]?.map(x => fromSetFileModeEntry(x)),
  }
}

// refs: 5 - tags: input, named, interface
export interface ReplaceContentEntry {
  filePath: string;
  replacementType: ReplacementTypeEnum;
  content?: Uint8Array | string | null;
  fileMode?: FileModeTypeEnum | null;
}
function fromReplaceContentEntry(input?: ReplaceContentEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    replacementType: input["replacementType"],
    content: jsonP.serializeBlob(input["content"]),
    fileMode: input["fileMode"],
  }
}

// refs: 5 - tags: input, named, enum
export type ReplacementTypeEnum =
| "KEEP_BASE"
| "KEEP_SOURCE"
| "KEEP_DESTINATION"
| "USE_NEW_CONTENT"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type PullRequestEventType =
| "PULL_REQUEST_CREATED"
| "PULL_REQUEST_STATUS_CHANGED"
| "PULL_REQUEST_SOURCE_REFERENCE_UPDATED"
| "PULL_REQUEST_MERGE_STATE_CHANGED"
| "PULL_REQUEST_APPROVAL_RULE_CREATED"
| "PULL_REQUEST_APPROVAL_RULE_UPDATED"
| "PULL_REQUEST_APPROVAL_RULE_DELETED"
| "PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN"
| "PULL_REQUEST_APPROVAL_STATE_CHANGED"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, enum, output
export type PullRequestStatusEnum =
| "OPEN"
| "CLOSED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SortByEnum =
| "repositoryName"
| "lastModifiedDate"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type OrderEnum =
| "ascending"
| "descending"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type OverrideStatus =
| "OVERRIDE"
| "REVOKE"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface Location {
  filePath?: string | null;
  filePosition?: number | null;
  relativeFileVersion?: RelativeFileVersionEnum | null;
}
function fromLocation(input?: Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filePath: input["filePath"],
    filePosition: input["filePosition"],
    relativeFileVersion: input["relativeFileVersion"],
  }
}
function toLocation(root: jsonP.JSONValue): Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "filePath": "s",
      "filePosition": "n",
      "relativeFileVersion": (x: jsonP.JSONValue) => cmnP.readEnum<RelativeFileVersionEnum>(x),
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type RelativeFileVersionEnum =
| "BEFORE"
| "AFTER"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface RepositoryTrigger {
  name: string;
  destinationArn: string;
  customData?: string | null;
  branches?: string[] | null;
  events: RepositoryTriggerEventEnum[];
}
function fromRepositoryTrigger(input?: RepositoryTrigger | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    destinationArn: input["destinationArn"],
    customData: input["customData"],
    branches: input["branches"],
    events: input["events"],
  }
}
function toRepositoryTrigger(root: jsonP.JSONValue): RepositoryTrigger {
  return jsonP.readObj({
    required: {
      "name": "s",
      "destinationArn": "s",
      "events": [(x: jsonP.JSONValue) => cmnP.readEnum<RepositoryTriggerEventEnum>(x)],
    },
    optional: {
      "customData": "s",
      "branches": ["s"],
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type RepositoryTriggerEventEnum =
| "all"
| "updateReference"
| "createReference"
| "deleteReference"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ApprovalState =
| "APPROVE"
| "REVOKE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface BatchAssociateApprovalRuleTemplateWithRepositoriesError {
  repositoryName?: string | null;
  errorCode?: string | null;
  errorMessage?: string | null;
}
function toBatchAssociateApprovalRuleTemplateWithRepositoriesError(root: jsonP.JSONValue): BatchAssociateApprovalRuleTemplateWithRepositoriesError {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "errorCode": "s",
      "errorMessage": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Conflict {
  conflictMetadata?: ConflictMetadata | null;
  mergeHunks?: MergeHunk[] | null;
}
function toConflict(root: jsonP.JSONValue): Conflict {
  return jsonP.readObj({
    required: {},
    optional: {
      "conflictMetadata": toConflictMetadata,
      "mergeHunks": [toMergeHunk],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface ConflictMetadata {
  filePath?: string | null;
  fileSizes?: FileSizes | null;
  fileModes?: FileModes | null;
  objectTypes?: ObjectTypes | null;
  numberOfConflicts?: number | null;
  isBinaryFile?: IsBinaryFile | null;
  contentConflict?: boolean | null;
  fileModeConflict?: boolean | null;
  objectTypeConflict?: boolean | null;
  mergeOperations?: MergeOperations | null;
}
function toConflictMetadata(root: jsonP.JSONValue): ConflictMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "filePath": "s",
      "fileSizes": toFileSizes,
      "fileModes": toFileModes,
      "objectTypes": toObjectTypes,
      "numberOfConflicts": "n",
      "isBinaryFile": toIsBinaryFile,
      "contentConflict": "b",
      "fileModeConflict": "b",
      "objectTypeConflict": "b",
      "mergeOperations": toMergeOperations,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface FileSizes {
  source?: number | null;
  destination?: number | null;
  base?: number | null;
}
function toFileSizes(root: jsonP.JSONValue): FileSizes {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": "n",
      "destination": "n",
      "base": "n",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface FileModes {
  source?: FileModeTypeEnum | null;
  destination?: FileModeTypeEnum | null;
  base?: FileModeTypeEnum | null;
}
function toFileModes(root: jsonP.JSONValue): FileModes {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": (x: jsonP.JSONValue) => cmnP.readEnum<FileModeTypeEnum>(x),
      "destination": (x: jsonP.JSONValue) => cmnP.readEnum<FileModeTypeEnum>(x),
      "base": (x: jsonP.JSONValue) => cmnP.readEnum<FileModeTypeEnum>(x),
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface ObjectTypes {
  source?: ObjectTypeEnum | null;
  destination?: ObjectTypeEnum | null;
  base?: ObjectTypeEnum | null;
}
function toObjectTypes(root: jsonP.JSONValue): ObjectTypes {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": (x: jsonP.JSONValue) => cmnP.readEnum<ObjectTypeEnum>(x),
      "destination": (x: jsonP.JSONValue) => cmnP.readEnum<ObjectTypeEnum>(x),
      "base": (x: jsonP.JSONValue) => cmnP.readEnum<ObjectTypeEnum>(x),
    },
  }, root);
}

// refs: 9 - tags: output, named, enum
export type ObjectTypeEnum =
| "FILE"
| "DIRECTORY"
| "GIT_LINK"
| "SYMBOLIC_LINK"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface IsBinaryFile {
  source?: boolean | null;
  destination?: boolean | null;
  base?: boolean | null;
}
function toIsBinaryFile(root: jsonP.JSONValue): IsBinaryFile {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": "b",
      "destination": "b",
      "base": "b",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface MergeOperations {
  source?: ChangeTypeEnum | null;
  destination?: ChangeTypeEnum | null;
}
function toMergeOperations(root: jsonP.JSONValue): MergeOperations {
  return jsonP.readObj({
    required: {},
    optional: {
      "source": (x: jsonP.JSONValue) => cmnP.readEnum<ChangeTypeEnum>(x),
      "destination": (x: jsonP.JSONValue) => cmnP.readEnum<ChangeTypeEnum>(x),
    },
  }, root);
}

// refs: 7 - tags: output, named, enum
export type ChangeTypeEnum =
| "A"
| "M"
| "D"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface MergeHunk {
  isConflict?: boolean | null;
  source?: MergeHunkDetail | null;
  destination?: MergeHunkDetail | null;
  base?: MergeHunkDetail | null;
}
function toMergeHunk(root: jsonP.JSONValue): MergeHunk {
  return jsonP.readObj({
    required: {},
    optional: {
      "isConflict": "b",
      "source": toMergeHunkDetail,
      "destination": toMergeHunkDetail,
      "base": toMergeHunkDetail,
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface MergeHunkDetail {
  startLine?: number | null;
  endLine?: number | null;
  hunkContent?: string | null;
}
function toMergeHunkDetail(root: jsonP.JSONValue): MergeHunkDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "startLine": "n",
      "endLine": "n",
      "hunkContent": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchDescribeMergeConflictsError {
  filePath: string;
  exceptionName: string;
  message: string;
}
function toBatchDescribeMergeConflictsError(root: jsonP.JSONValue): BatchDescribeMergeConflictsError {
  return jsonP.readObj({
    required: {
      "filePath": "s",
      "exceptionName": "s",
      "message": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
  repositoryName?: string | null;
  errorCode?: string | null;
  errorMessage?: string | null;
}
function toBatchDisassociateApprovalRuleTemplateFromRepositoriesError(root: jsonP.JSONValue): BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "errorCode": "s",
      "errorMessage": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Commit {
  commitId?: string | null;
  treeId?: string | null;
  parents?: string[] | null;
  message?: string | null;
  author?: UserInfo | null;
  committer?: UserInfo | null;
  additionalData?: string | null;
}
function toCommit(root: jsonP.JSONValue): Commit {
  return jsonP.readObj({
    required: {},
    optional: {
      "commitId": "s",
      "treeId": "s",
      "parents": ["s"],
      "message": "s",
      "author": toUserInfo,
      "committer": toUserInfo,
      "additionalData": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface UserInfo {
  name?: string | null;
  email?: string | null;
  date?: string | null;
}
function toUserInfo(root: jsonP.JSONValue): UserInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "email": "s",
      "date": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchGetCommitsError {
  commitId?: string | null;
  errorCode?: string | null;
  errorMessage?: string | null;
}
function toBatchGetCommitsError(root: jsonP.JSONValue): BatchGetCommitsError {
  return jsonP.readObj({
    required: {},
    optional: {
      "commitId": "s",
      "errorCode": "s",
      "errorMessage": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface RepositoryMetadata {
  accountId?: string | null;
  repositoryId?: string | null;
  repositoryName?: string | null;
  repositoryDescription?: string | null;
  defaultBranch?: string | null;
  lastModifiedDate?: Date | number | null;
  creationDate?: Date | number | null;
  cloneUrlHttp?: string | null;
  cloneUrlSsh?: string | null;
  Arn?: string | null;
}
function toRepositoryMetadata(root: jsonP.JSONValue): RepositoryMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "repositoryId": "s",
      "repositoryName": "s",
      "repositoryDescription": "s",
      "defaultBranch": "s",
      "lastModifiedDate": "d",
      "creationDate": "d",
      "cloneUrlHttp": "s",
      "cloneUrlSsh": "s",
      "Arn": "s",
    },
  }, root);
}

// refs: 5 - tags: output, named, interface
export interface ApprovalRuleTemplate {
  approvalRuleTemplateId?: string | null;
  approvalRuleTemplateName?: string | null;
  approvalRuleTemplateDescription?: string | null;
  approvalRuleTemplateContent?: string | null;
  ruleContentSha256?: string | null;
  lastModifiedDate?: Date | number | null;
  creationDate?: Date | number | null;
  lastModifiedUser?: string | null;
}
function toApprovalRuleTemplate(root: jsonP.JSONValue): ApprovalRuleTemplate {
  return jsonP.readObj({
    required: {},
    optional: {
      "approvalRuleTemplateId": "s",
      "approvalRuleTemplateName": "s",
      "approvalRuleTemplateDescription": "s",
      "approvalRuleTemplateContent": "s",
      "ruleContentSha256": "s",
      "lastModifiedDate": "d",
      "creationDate": "d",
      "lastModifiedUser": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface FileMetadata {
  absolutePath?: string | null;
  blobId?: string | null;
  fileMode?: FileModeTypeEnum | null;
}
function toFileMetadata(root: jsonP.JSONValue): FileMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "absolutePath": "s",
      "blobId": "s",
      "fileMode": (x: jsonP.JSONValue) => cmnP.readEnum<FileModeTypeEnum>(x),
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface PullRequest {
  pullRequestId?: string | null;
  title?: string | null;
  description?: string | null;
  lastActivityDate?: Date | number | null;
  creationDate?: Date | number | null;
  pullRequestStatus?: PullRequestStatusEnum | null;
  authorArn?: string | null;
  pullRequestTargets?: PullRequestTarget[] | null;
  clientRequestToken?: string | null;
  revisionId?: string | null;
  approvalRules?: ApprovalRule[] | null;
}
function toPullRequest(root: jsonP.JSONValue): PullRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "pullRequestId": "s",
      "title": "s",
      "description": "s",
      "lastActivityDate": "d",
      "creationDate": "d",
      "pullRequestStatus": (x: jsonP.JSONValue) => cmnP.readEnum<PullRequestStatusEnum>(x),
      "authorArn": "s",
      "pullRequestTargets": [toPullRequestTarget],
      "clientRequestToken": "s",
      "revisionId": "s",
      "approvalRules": [toApprovalRule],
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface PullRequestTarget {
  repositoryName?: string | null;
  sourceReference?: string | null;
  destinationReference?: string | null;
  destinationCommit?: string | null;
  sourceCommit?: string | null;
  mergeBase?: string | null;
  mergeMetadata?: MergeMetadata | null;
}
function toPullRequestTarget(root: jsonP.JSONValue): PullRequestTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "sourceReference": "s",
      "destinationReference": "s",
      "destinationCommit": "s",
      "sourceCommit": "s",
      "mergeBase": "s",
      "mergeMetadata": toMergeMetadata,
    },
  }, root);
}

// refs: 9 - tags: output, named, interface
export interface MergeMetadata {
  isMerged?: boolean | null;
  mergedBy?: string | null;
  mergeCommitId?: string | null;
  mergeOption?: MergeOptionTypeEnum | null;
}
function toMergeMetadata(root: jsonP.JSONValue): MergeMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "isMerged": "b",
      "mergedBy": "s",
      "mergeCommitId": "s",
      "mergeOption": (x: jsonP.JSONValue) => cmnP.readEnum<MergeOptionTypeEnum>(x),
    },
  }, root);
}

// refs: 10 - tags: output, named, interface
export interface ApprovalRule {
  approvalRuleId?: string | null;
  approvalRuleName?: string | null;
  approvalRuleContent?: string | null;
  ruleContentSha256?: string | null;
  lastModifiedDate?: Date | number | null;
  creationDate?: Date | number | null;
  lastModifiedUser?: string | null;
  originApprovalRuleTemplate?: OriginApprovalRuleTemplate | null;
}
function toApprovalRule(root: jsonP.JSONValue): ApprovalRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "approvalRuleId": "s",
      "approvalRuleName": "s",
      "approvalRuleContent": "s",
      "ruleContentSha256": "s",
      "lastModifiedDate": "d",
      "creationDate": "d",
      "lastModifiedUser": "s",
      "originApprovalRuleTemplate": toOriginApprovalRuleTemplate,
    },
  }, root);
}

// refs: 10 - tags: output, named, interface
export interface OriginApprovalRuleTemplate {
  approvalRuleTemplateId?: string | null;
  approvalRuleTemplateName?: string | null;
}
function toOriginApprovalRuleTemplate(root: jsonP.JSONValue): OriginApprovalRuleTemplate {
  return jsonP.readObj({
    required: {},
    optional: {
      "approvalRuleTemplateId": "s",
      "approvalRuleTemplateName": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface BranchInfo {
  branchName?: string | null;
  commitId?: string | null;
}
function toBranchInfo(root: jsonP.JSONValue): BranchInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "branchName": "s",
      "commitId": "s",
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface Comment {
  commentId?: string | null;
  content?: string | null;
  inReplyTo?: string | null;
  creationDate?: Date | number | null;
  lastModifiedDate?: Date | number | null;
  authorArn?: string | null;
  deleted?: boolean | null;
  clientRequestToken?: string | null;
  callerReactions?: string[] | null;
  reactionCounts?: { [key: string]: number | null | undefined } | null;
}
function toComment(root: jsonP.JSONValue): Comment {
  return jsonP.readObj({
    required: {},
    optional: {
      "commentId": "s",
      "content": "s",
      "inReplyTo": "s",
      "creationDate": "d",
      "lastModifiedDate": "d",
      "authorArn": "s",
      "deleted": "b",
      "clientRequestToken": "s",
      "callerReactions": ["s"],
      "reactionCounts": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PullRequestEvent {
  pullRequestId?: string | null;
  eventDate?: Date | number | null;
  pullRequestEventType?: PullRequestEventType | null;
  actorArn?: string | null;
  pullRequestCreatedEventMetadata?: PullRequestCreatedEventMetadata | null;
  pullRequestStatusChangedEventMetadata?: PullRequestStatusChangedEventMetadata | null;
  pullRequestSourceReferenceUpdatedEventMetadata?: PullRequestSourceReferenceUpdatedEventMetadata | null;
  pullRequestMergedStateChangedEventMetadata?: PullRequestMergedStateChangedEventMetadata | null;
  approvalRuleEventMetadata?: ApprovalRuleEventMetadata | null;
  approvalStateChangedEventMetadata?: ApprovalStateChangedEventMetadata | null;
  approvalRuleOverriddenEventMetadata?: ApprovalRuleOverriddenEventMetadata | null;
}
function toPullRequestEvent(root: jsonP.JSONValue): PullRequestEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "pullRequestId": "s",
      "eventDate": "d",
      "pullRequestEventType": (x: jsonP.JSONValue) => cmnP.readEnum<PullRequestEventType>(x),
      "actorArn": "s",
      "pullRequestCreatedEventMetadata": toPullRequestCreatedEventMetadata,
      "pullRequestStatusChangedEventMetadata": toPullRequestStatusChangedEventMetadata,
      "pullRequestSourceReferenceUpdatedEventMetadata": toPullRequestSourceReferenceUpdatedEventMetadata,
      "pullRequestMergedStateChangedEventMetadata": toPullRequestMergedStateChangedEventMetadata,
      "approvalRuleEventMetadata": toApprovalRuleEventMetadata,
      "approvalStateChangedEventMetadata": toApprovalStateChangedEventMetadata,
      "approvalRuleOverriddenEventMetadata": toApprovalRuleOverriddenEventMetadata,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PullRequestCreatedEventMetadata {
  repositoryName?: string | null;
  sourceCommitId?: string | null;
  destinationCommitId?: string | null;
  mergeBase?: string | null;
}
function toPullRequestCreatedEventMetadata(root: jsonP.JSONValue): PullRequestCreatedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "sourceCommitId": "s",
      "destinationCommitId": "s",
      "mergeBase": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PullRequestStatusChangedEventMetadata {
  pullRequestStatus?: PullRequestStatusEnum | null;
}
function toPullRequestStatusChangedEventMetadata(root: jsonP.JSONValue): PullRequestStatusChangedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "pullRequestStatus": (x: jsonP.JSONValue) => cmnP.readEnum<PullRequestStatusEnum>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PullRequestSourceReferenceUpdatedEventMetadata {
  repositoryName?: string | null;
  beforeCommitId?: string | null;
  afterCommitId?: string | null;
  mergeBase?: string | null;
}
function toPullRequestSourceReferenceUpdatedEventMetadata(root: jsonP.JSONValue): PullRequestSourceReferenceUpdatedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "beforeCommitId": "s",
      "afterCommitId": "s",
      "mergeBase": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PullRequestMergedStateChangedEventMetadata {
  repositoryName?: string | null;
  destinationReference?: string | null;
  mergeMetadata?: MergeMetadata | null;
}
function toPullRequestMergedStateChangedEventMetadata(root: jsonP.JSONValue): PullRequestMergedStateChangedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "destinationReference": "s",
      "mergeMetadata": toMergeMetadata,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ApprovalRuleEventMetadata {
  approvalRuleName?: string | null;
  approvalRuleId?: string | null;
  approvalRuleContent?: string | null;
}
function toApprovalRuleEventMetadata(root: jsonP.JSONValue): ApprovalRuleEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "approvalRuleName": "s",
      "approvalRuleId": "s",
      "approvalRuleContent": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ApprovalStateChangedEventMetadata {
  revisionId?: string | null;
  approvalStatus?: ApprovalState | null;
}
function toApprovalStateChangedEventMetadata(root: jsonP.JSONValue): ApprovalStateChangedEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "revisionId": "s",
      "approvalStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ApprovalState>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ApprovalRuleOverriddenEventMetadata {
  revisionId?: string | null;
  overrideStatus?: OverrideStatus | null;
}
function toApprovalRuleOverriddenEventMetadata(root: jsonP.JSONValue): ApprovalRuleOverriddenEventMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "revisionId": "s",
      "overrideStatus": (x: jsonP.JSONValue) => cmnP.readEnum<OverrideStatus>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Evaluation {
  approved?: boolean | null;
  overridden?: boolean | null;
  approvalRulesSatisfied?: string[] | null;
  approvalRulesNotSatisfied?: string[] | null;
}
function toEvaluation(root: jsonP.JSONValue): Evaluation {
  return jsonP.readObj({
    required: {},
    optional: {
      "approved": "b",
      "overridden": "b",
      "approvalRulesSatisfied": ["s"],
      "approvalRulesNotSatisfied": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReactionForComment {
  reaction?: ReactionValueFormats | null;
  reactionUsers?: string[] | null;
  reactionsFromDeletedUsersCount?: number | null;
}
function toReactionForComment(root: jsonP.JSONValue): ReactionForComment {
  return jsonP.readObj({
    required: {},
    optional: {
      "reaction": toReactionValueFormats,
      "reactionUsers": ["s"],
      "reactionsFromDeletedUsersCount": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReactionValueFormats {
  emoji?: string | null;
  shortCode?: string | null;
  unicode?: string | null;
}
function toReactionValueFormats(root: jsonP.JSONValue): ReactionValueFormats {
  return jsonP.readObj({
    required: {},
    optional: {
      "emoji": "s",
      "shortCode": "s",
      "unicode": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CommentsForComparedCommit {
  repositoryName?: string | null;
  beforeCommitId?: string | null;
  afterCommitId?: string | null;
  beforeBlobId?: string | null;
  afterBlobId?: string | null;
  location?: Location | null;
  comments?: Comment[] | null;
}
function toCommentsForComparedCommit(root: jsonP.JSONValue): CommentsForComparedCommit {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "beforeCommitId": "s",
      "afterCommitId": "s",
      "beforeBlobId": "s",
      "afterBlobId": "s",
      "location": toLocation,
      "comments": [toComment],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CommentsForPullRequest {
  pullRequestId?: string | null;
  repositoryName?: string | null;
  beforeCommitId?: string | null;
  afterCommitId?: string | null;
  beforeBlobId?: string | null;
  afterBlobId?: string | null;
  location?: Location | null;
  comments?: Comment[] | null;
}
function toCommentsForPullRequest(root: jsonP.JSONValue): CommentsForPullRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "pullRequestId": "s",
      "repositoryName": "s",
      "beforeCommitId": "s",
      "afterCommitId": "s",
      "beforeBlobId": "s",
      "afterBlobId": "s",
      "location": toLocation,
      "comments": [toComment],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Difference {
  beforeBlob?: BlobMetadata | null;
  afterBlob?: BlobMetadata | null;
  changeType?: ChangeTypeEnum | null;
}
function toDifference(root: jsonP.JSONValue): Difference {
  return jsonP.readObj({
    required: {},
    optional: {
      "beforeBlob": toBlobMetadata,
      "afterBlob": toBlobMetadata,
      "changeType": (x: jsonP.JSONValue) => cmnP.readEnum<ChangeTypeEnum>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface BlobMetadata {
  blobId?: string | null;
  path?: string | null;
  mode?: string | null;
}
function toBlobMetadata(root: jsonP.JSONValue): BlobMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "blobId": "s",
      "path": "s",
      "mode": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Folder {
  treeId?: string | null;
  absolutePath?: string | null;
  relativePath?: string | null;
}
function toFolder(root: jsonP.JSONValue): Folder {
  return jsonP.readObj({
    required: {},
    optional: {
      "treeId": "s",
      "absolutePath": "s",
      "relativePath": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface File {
  blobId?: string | null;
  absolutePath?: string | null;
  relativePath?: string | null;
  fileMode?: FileModeTypeEnum | null;
}
function toFile(root: jsonP.JSONValue): File {
  return jsonP.readObj({
    required: {},
    optional: {
      "blobId": "s",
      "absolutePath": "s",
      "relativePath": "s",
      "fileMode": (x: jsonP.JSONValue) => cmnP.readEnum<FileModeTypeEnum>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SymbolicLink {
  blobId?: string | null;
  absolutePath?: string | null;
  relativePath?: string | null;
  fileMode?: FileModeTypeEnum | null;
}
function toSymbolicLink(root: jsonP.JSONValue): SymbolicLink {
  return jsonP.readObj({
    required: {},
    optional: {
      "blobId": "s",
      "absolutePath": "s",
      "relativePath": "s",
      "fileMode": (x: jsonP.JSONValue) => cmnP.readEnum<FileModeTypeEnum>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SubModule {
  commitId?: string | null;
  absolutePath?: string | null;
  relativePath?: string | null;
}
function toSubModule(root: jsonP.JSONValue): SubModule {
  return jsonP.readObj({
    required: {},
    optional: {
      "commitId": "s",
      "absolutePath": "s",
      "relativePath": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Approval {
  userArn?: string | null;
  approvalState?: ApprovalState | null;
}
function toApproval(root: jsonP.JSONValue): Approval {
  return jsonP.readObj({
    required: {},
    optional: {
      "userArn": "s",
      "approvalState": (x: jsonP.JSONValue) => cmnP.readEnum<ApprovalState>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RepositoryNameIdPair {
  repositoryName?: string | null;
  repositoryId?: string | null;
}
function toRepositoryNameIdPair(root: jsonP.JSONValue): RepositoryNameIdPair {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "repositoryId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RepositoryTriggerExecutionFailure {
  trigger?: string | null;
  failureMessage?: string | null;
}
function toRepositoryTriggerExecutionFailure(root: jsonP.JSONValue): RepositoryTriggerExecutionFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "trigger": "s",
      "failureMessage": "s",
    },
  }, root);
}
