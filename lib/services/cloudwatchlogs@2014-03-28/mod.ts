// Autogenerated API client for: Amazon CloudWatch Logs

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class CloudWatchLogs {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudWatchLogs.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2014-03-28",
    "endpointPrefix": "logs",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon CloudWatch Logs",
    "serviceId": "CloudWatch Logs",
    "signatureVersion": "v4",
    "targetPrefix": "Logs_20140328",
    "uid": "logs-2014-03-28"
  };

  async associateKmsKey(
    {abortSignal, ...params}: RequestConfig & s.AssociateKmsKeyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      kmsKeyId: params["kmsKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateKmsKey",
    });
  }

  async cancelExportTask(
    {abortSignal, ...params}: RequestConfig & s.CancelExportTaskRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      taskId: params["taskId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelExportTask",
    });
  }

  async createExportTask(
    {abortSignal, ...params}: RequestConfig & s.CreateExportTaskRequest,
  ): Promise<s.CreateExportTaskResponse> {
    const body: jsonP.JSONObject = {
      taskName: params["taskName"],
      logGroupName: params["logGroupName"],
      logStreamNamePrefix: params["logStreamNamePrefix"],
      from: params["from"],
      to: params["to"],
      destination: params["destination"],
      destinationPrefix: params["destinationPrefix"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateExportTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskId": "s",
      },
    }, await resp.json());
  }

  async createLogGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateLogGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      kmsKeyId: params["kmsKeyId"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLogGroup",
    });
  }

  async createLogStream(
    {abortSignal, ...params}: RequestConfig & s.CreateLogStreamRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      logStreamName: params["logStreamName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLogStream",
    });
  }

  async deleteDestination(
    {abortSignal, ...params}: RequestConfig & s.DeleteDestinationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      destinationName: params["destinationName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDestination",
    });
  }

  async deleteLogGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteLogGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLogGroup",
    });
  }

  async deleteLogStream(
    {abortSignal, ...params}: RequestConfig & s.DeleteLogStreamRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      logStreamName: params["logStreamName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLogStream",
    });
  }

  async deleteMetricFilter(
    {abortSignal, ...params}: RequestConfig & s.DeleteMetricFilterRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      filterName: params["filterName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMetricFilter",
    });
  }

  async deleteQueryDefinition(
    {abortSignal, ...params}: RequestConfig & s.DeleteQueryDefinitionRequest,
  ): Promise<s.DeleteQueryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      queryDefinitionId: params["queryDefinitionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteQueryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "success": "b",
      },
    }, await resp.json());
  }

  async deleteResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteResourcePolicyRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      policyName: params["policyName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourcePolicy",
    });
  }

  async deleteRetentionPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteRetentionPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRetentionPolicy",
    });
  }

  async deleteSubscriptionFilter(
    {abortSignal, ...params}: RequestConfig & s.DeleteSubscriptionFilterRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      filterName: params["filterName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSubscriptionFilter",
    });
  }

  async describeDestinations(
    {abortSignal, ...params}: RequestConfig & s.DescribeDestinationsRequest = {},
  ): Promise<s.DescribeDestinationsResponse> {
    const body: jsonP.JSONObject = {
      DestinationNamePrefix: params["DestinationNamePrefix"],
      nextToken: params["nextToken"],
      limit: params["limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDestinations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "destinations": [toDestination],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeExportTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeExportTasksRequest = {},
  ): Promise<s.DescribeExportTasksResponse> {
    const body: jsonP.JSONObject = {
      taskId: params["taskId"],
      statusCode: params["statusCode"],
      nextToken: params["nextToken"],
      limit: params["limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExportTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "exportTasks": [toExportTask],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeLogGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeLogGroupsRequest = {},
  ): Promise<s.DescribeLogGroupsResponse> {
    const body: jsonP.JSONObject = {
      logGroupNamePrefix: params["logGroupNamePrefix"],
      nextToken: params["nextToken"],
      limit: params["limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLogGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "logGroups": [toLogGroup],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeLogStreams(
    {abortSignal, ...params}: RequestConfig & s.DescribeLogStreamsRequest,
  ): Promise<s.DescribeLogStreamsResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      logStreamNamePrefix: params["logStreamNamePrefix"],
      orderBy: params["orderBy"],
      descending: params["descending"],
      nextToken: params["nextToken"],
      limit: params["limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLogStreams",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "logStreams": [toLogStream],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeMetricFilters(
    {abortSignal, ...params}: RequestConfig & s.DescribeMetricFiltersRequest = {},
  ): Promise<s.DescribeMetricFiltersResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      filterNamePrefix: params["filterNamePrefix"],
      nextToken: params["nextToken"],
      limit: params["limit"],
      metricName: params["metricName"],
      metricNamespace: params["metricNamespace"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMetricFilters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricFilters": [toMetricFilter],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeQueries(
    {abortSignal, ...params}: RequestConfig & s.DescribeQueriesRequest = {},
  ): Promise<s.DescribeQueriesResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      status: params["status"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeQueries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "queries": [toQueryInfo],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeQueryDefinitions(
    {abortSignal, ...params}: RequestConfig & s.DescribeQueryDefinitionsRequest = {},
  ): Promise<s.DescribeQueryDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      queryDefinitionNamePrefix: params["queryDefinitionNamePrefix"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeQueryDefinitions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "queryDefinitions": [toQueryDefinition],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeResourcePolicies(
    {abortSignal, ...params}: RequestConfig & s.DescribeResourcePoliciesRequest = {},
  ): Promise<s.DescribeResourcePoliciesResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      limit: params["limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeResourcePolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resourcePolicies": [toResourcePolicy],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeSubscriptionFilters(
    {abortSignal, ...params}: RequestConfig & s.DescribeSubscriptionFiltersRequest,
  ): Promise<s.DescribeSubscriptionFiltersResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      filterNamePrefix: params["filterNamePrefix"],
      nextToken: params["nextToken"],
      limit: params["limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSubscriptionFilters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "subscriptionFilters": [toSubscriptionFilter],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async disassociateKmsKey(
    {abortSignal, ...params}: RequestConfig & s.DisassociateKmsKeyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateKmsKey",
    });
  }

  async filterLogEvents(
    {abortSignal, ...params}: RequestConfig & s.FilterLogEventsRequest,
  ): Promise<s.FilterLogEventsResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      logStreamNames: params["logStreamNames"],
      logStreamNamePrefix: params["logStreamNamePrefix"],
      startTime: params["startTime"],
      endTime: params["endTime"],
      filterPattern: params["filterPattern"],
      nextToken: params["nextToken"],
      limit: params["limit"],
      interleaved: params["interleaved"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "FilterLogEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "events": [toFilteredLogEvent],
        "searchedLogStreams": [toSearchedLogStream],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getLogEvents(
    {abortSignal, ...params}: RequestConfig & s.GetLogEventsRequest,
  ): Promise<s.GetLogEventsResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      logStreamName: params["logStreamName"],
      startTime: params["startTime"],
      endTime: params["endTime"],
      nextToken: params["nextToken"],
      limit: params["limit"],
      startFromHead: params["startFromHead"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLogEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "events": [toOutputLogEvent],
        "nextForwardToken": "s",
        "nextBackwardToken": "s",
      },
    }, await resp.json());
  }

  async getLogGroupFields(
    {abortSignal, ...params}: RequestConfig & s.GetLogGroupFieldsRequest,
  ): Promise<s.GetLogGroupFieldsResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      time: params["time"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLogGroupFields",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "logGroupFields": [toLogGroupField],
      },
    }, await resp.json());
  }

  async getLogRecord(
    {abortSignal, ...params}: RequestConfig & s.GetLogRecordRequest,
  ): Promise<s.GetLogRecordResponse> {
    const body: jsonP.JSONObject = {
      logRecordPointer: params["logRecordPointer"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLogRecord",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "logRecord": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getQueryResults(
    {abortSignal, ...params}: RequestConfig & s.GetQueryResultsRequest,
  ): Promise<s.GetQueryResultsResponse> {
    const body: jsonP.JSONObject = {
      queryId: params["queryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetQueryResults",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "results": [x => jsonP.readList(toResultField, x)],
        "statistics": toQueryStatistics,
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.QueryStatus>(x),
      },
    }, await resp.json());
  }

  async listTagsLogGroup(
    {abortSignal, ...params}: RequestConfig & s.ListTagsLogGroupRequest,
  ): Promise<s.ListTagsLogGroupResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsLogGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async putDestination(
    {abortSignal, ...params}: RequestConfig & s.PutDestinationRequest,
  ): Promise<s.PutDestinationResponse> {
    const body: jsonP.JSONObject = {
      destinationName: params["destinationName"],
      targetArn: params["targetArn"],
      roleArn: params["roleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDestination",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "destination": toDestination,
      },
    }, await resp.json());
  }

  async putDestinationPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutDestinationPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      destinationName: params["destinationName"],
      accessPolicy: params["accessPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDestinationPolicy",
    });
  }

  async putLogEvents(
    {abortSignal, ...params}: RequestConfig & s.PutLogEventsRequest,
  ): Promise<s.PutLogEventsResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      logStreamName: params["logStreamName"],
      logEvents: params["logEvents"]?.map(x => fromInputLogEvent(x)),
      sequenceToken: params["sequenceToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLogEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextSequenceToken": "s",
        "rejectedLogEventsInfo": toRejectedLogEventsInfo,
      },
    }, await resp.json());
  }

  async putMetricFilter(
    {abortSignal, ...params}: RequestConfig & s.PutMetricFilterRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      filterName: params["filterName"],
      filterPattern: params["filterPattern"],
      metricTransformations: params["metricTransformations"]?.map(x => fromMetricTransformation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutMetricFilter",
    });
  }

  async putQueryDefinition(
    {abortSignal, ...params}: RequestConfig & s.PutQueryDefinitionRequest,
  ): Promise<s.PutQueryDefinitionResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      queryDefinitionId: params["queryDefinitionId"],
      logGroupNames: params["logGroupNames"],
      queryString: params["queryString"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutQueryDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "queryDefinitionId": "s",
      },
    }, await resp.json());
  }

  async putResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.PutResourcePolicyRequest = {},
  ): Promise<s.PutResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      policyName: params["policyName"],
      policyDocument: params["policyDocument"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resourcePolicy": toResourcePolicy,
      },
    }, await resp.json());
  }

  async putRetentionPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutRetentionPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      retentionInDays: params["retentionInDays"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRetentionPolicy",
    });
  }

  async putSubscriptionFilter(
    {abortSignal, ...params}: RequestConfig & s.PutSubscriptionFilterRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      filterName: params["filterName"],
      filterPattern: params["filterPattern"],
      destinationArn: params["destinationArn"],
      roleArn: params["roleArn"],
      distribution: params["distribution"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutSubscriptionFilter",
    });
  }

  async startQuery(
    {abortSignal, ...params}: RequestConfig & s.StartQueryRequest,
  ): Promise<s.StartQueryResponse> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      logGroupNames: params["logGroupNames"],
      startTime: params["startTime"],
      endTime: params["endTime"],
      queryString: params["queryString"],
      limit: params["limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartQuery",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "queryId": "s",
      },
    }, await resp.json());
  }

  async stopQuery(
    {abortSignal, ...params}: RequestConfig & s.StopQueryRequest,
  ): Promise<s.StopQueryResponse> {
    const body: jsonP.JSONObject = {
      queryId: params["queryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopQuery",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "success": "b",
      },
    }, await resp.json());
  }

  async tagLogGroup(
    {abortSignal, ...params}: RequestConfig & s.TagLogGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagLogGroup",
    });
  }

  async testMetricFilter(
    {abortSignal, ...params}: RequestConfig & s.TestMetricFilterRequest,
  ): Promise<s.TestMetricFilterResponse> {
    const body: jsonP.JSONObject = {
      filterPattern: params["filterPattern"],
      logEventMessages: params["logEventMessages"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestMetricFilter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "matches": [toMetricFilterMatchRecord],
      },
    }, await resp.json());
  }

  async untagLogGroup(
    {abortSignal, ...params}: RequestConfig & s.UntagLogGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      logGroupName: params["logGroupName"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagLogGroup",
    });
  }

}

function fromInputLogEvent(input?: s.InputLogEvent | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timestamp: input["timestamp"],
    message: input["message"],
  }
}

function fromMetricTransformation(input?: s.MetricTransformation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    metricName: input["metricName"],
    metricNamespace: input["metricNamespace"],
    metricValue: input["metricValue"],
    defaultValue: input["defaultValue"],
  }
}
function toMetricTransformation(root: jsonP.JSONValue): s.MetricTransformation {
  return jsonP.readObj({
    required: {
      "metricName": "s",
      "metricNamespace": "s",
      "metricValue": "s",
    },
    optional: {
      "defaultValue": "n",
    },
  }, root);
}

function toDestination(root: jsonP.JSONValue): s.Destination {
  return jsonP.readObj({
    required: {},
    optional: {
      "destinationName": "s",
      "targetArn": "s",
      "roleArn": "s",
      "accessPolicy": "s",
      "arn": "s",
      "creationTime": "n",
    },
  }, root);
}

function toExportTask(root: jsonP.JSONValue): s.ExportTask {
  return jsonP.readObj({
    required: {},
    optional: {
      "taskId": "s",
      "taskName": "s",
      "logGroupName": "s",
      "from": "n",
      "to": "n",
      "destination": "s",
      "destinationPrefix": "s",
      "status": toExportTaskStatus,
      "executionInfo": toExportTaskExecutionInfo,
    },
  }, root);
}

function toExportTaskStatus(root: jsonP.JSONValue): s.ExportTaskStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExportTaskStatusCode>(x),
      "message": "s",
    },
  }, root);
}

function toExportTaskExecutionInfo(root: jsonP.JSONValue): s.ExportTaskExecutionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "creationTime": "n",
      "completionTime": "n",
    },
  }, root);
}

function toLogGroup(root: jsonP.JSONValue): s.LogGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "logGroupName": "s",
      "creationTime": "n",
      "retentionInDays": "n",
      "metricFilterCount": "n",
      "arn": "s",
      "storedBytes": "n",
      "kmsKeyId": "s",
    },
  }, root);
}

function toLogStream(root: jsonP.JSONValue): s.LogStream {
  return jsonP.readObj({
    required: {},
    optional: {
      "logStreamName": "s",
      "creationTime": "n",
      "firstEventTimestamp": "n",
      "lastEventTimestamp": "n",
      "lastIngestionTime": "n",
      "uploadSequenceToken": "s",
      "arn": "s",
      "storedBytes": "n",
    },
  }, root);
}

function toMetricFilter(root: jsonP.JSONValue): s.MetricFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "filterName": "s",
      "filterPattern": "s",
      "metricTransformations": [toMetricTransformation],
      "creationTime": "n",
      "logGroupName": "s",
    },
  }, root);
}

function toQueryInfo(root: jsonP.JSONValue): s.QueryInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "queryId": "s",
      "queryString": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.QueryStatus>(x),
      "createTime": "n",
      "logGroupName": "s",
    },
  }, root);
}

function toQueryDefinition(root: jsonP.JSONValue): s.QueryDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "queryDefinitionId": "s",
      "name": "s",
      "queryString": "s",
      "lastModified": "n",
      "logGroupNames": ["s"],
    },
  }, root);
}

function toResourcePolicy(root: jsonP.JSONValue): s.ResourcePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "policyName": "s",
      "policyDocument": "s",
      "lastUpdatedTime": "n",
    },
  }, root);
}

function toSubscriptionFilter(root: jsonP.JSONValue): s.SubscriptionFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "filterName": "s",
      "logGroupName": "s",
      "filterPattern": "s",
      "destinationArn": "s",
      "roleArn": "s",
      "distribution": (x: jsonP.JSONValue) => cmnP.readEnum<s.Distribution>(x),
      "creationTime": "n",
    },
  }, root);
}

function toFilteredLogEvent(root: jsonP.JSONValue): s.FilteredLogEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "logStreamName": "s",
      "timestamp": "n",
      "message": "s",
      "ingestionTime": "n",
      "eventId": "s",
    },
  }, root);
}

function toSearchedLogStream(root: jsonP.JSONValue): s.SearchedLogStream {
  return jsonP.readObj({
    required: {},
    optional: {
      "logStreamName": "s",
      "searchedCompletely": "b",
    },
  }, root);
}

function toOutputLogEvent(root: jsonP.JSONValue): s.OutputLogEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "timestamp": "n",
      "message": "s",
      "ingestionTime": "n",
    },
  }, root);
}

function toLogGroupField(root: jsonP.JSONValue): s.LogGroupField {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "percent": "n",
    },
  }, root);
}

function toResultField(root: jsonP.JSONValue): s.ResultField {
  return jsonP.readObj({
    required: {},
    optional: {
      "field": "s",
      "value": "s",
    },
  }, root);
}

function toQueryStatistics(root: jsonP.JSONValue): s.QueryStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "recordsMatched": "n",
      "recordsScanned": "n",
      "bytesScanned": "n",
    },
  }, root);
}

function toRejectedLogEventsInfo(root: jsonP.JSONValue): s.RejectedLogEventsInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "tooNewLogEventStartIndex": "n",
      "tooOldLogEventEndIndex": "n",
      "expiredLogEventEndIndex": "n",
    },
  }, root);
}

function toMetricFilterMatchRecord(root: jsonP.JSONValue): s.MetricFilterMatchRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "eventNumber": "n",
      "eventMessage": "s",
      "extractedValues": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
