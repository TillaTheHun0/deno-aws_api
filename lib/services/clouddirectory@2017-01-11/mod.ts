// Autogenerated API client for: Amazon CloudDirectory

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class CloudDirectory {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudDirectory.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-01-11",
    "endpointPrefix": "clouddirectory",
    "protocol": "rest-json",
    "serviceFullName": "Amazon CloudDirectory",
    "serviceId": "CloudDirectory",
    "signatureVersion": "v4",
    "signingName": "clouddirectory",
    "uid": "clouddirectory-2017-01-11"
  };

  async addFacetToObject(
    {abortSignal, ...params}: RequestConfig & AddFacetToObjectRequest,
  ): Promise<AddFacetToObjectResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      SchemaFacet: fromSchemaFacet(params["SchemaFacet"]),
      ObjectAttributeList: params["ObjectAttributeList"]?.map(x => fromAttributeKeyAndValue(x)),
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AddFacetToObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/facets",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async applySchema(
    {abortSignal, ...params}: RequestConfig & ApplySchemaRequest,
  ): Promise<ApplySchemaResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      PublishedSchemaArn: params["PublishedSchemaArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ApplySchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/apply",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "AppliedSchemaArn": "s",
          "DirectoryArn": "s",
        },
      }, await resp.json()),
  };
  }

  async attachObject(
    {abortSignal, ...params}: RequestConfig & AttachObjectRequest,
  ): Promise<AttachObjectResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      ParentReference: fromObjectReference(params["ParentReference"]),
      ChildReference: fromObjectReference(params["ChildReference"]),
      LinkName: params["LinkName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AttachObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/attach",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "AttachedObjectIdentifier": "s",
        },
      }, await resp.json()),
  };
  }

  async attachPolicy(
    {abortSignal, ...params}: RequestConfig & AttachPolicyRequest,
  ): Promise<AttachPolicyResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      PolicyReference: fromObjectReference(params["PolicyReference"]),
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AttachPolicy",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/policy/attach",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async attachToIndex(
    {abortSignal, ...params}: RequestConfig & AttachToIndexRequest,
  ): Promise<AttachToIndexResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      IndexReference: fromObjectReference(params["IndexReference"]),
      TargetReference: fromObjectReference(params["TargetReference"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AttachToIndex",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/index/attach",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "AttachedObjectIdentifier": "s",
        },
      }, await resp.json()),
  };
  }

  async attachTypedLink(
    {abortSignal, ...params}: RequestConfig & AttachTypedLinkRequest,
  ): Promise<AttachTypedLinkResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      SourceObjectReference: fromObjectReference(params["SourceObjectReference"]),
      TargetObjectReference: fromObjectReference(params["TargetObjectReference"]),
      TypedLinkFacet: fromTypedLinkSchemaAndFacetName(params["TypedLinkFacet"]),
      Attributes: params["Attributes"]?.map(x => fromAttributeNameAndValue(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AttachTypedLink",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/attach",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "TypedLinkSpecifier": toTypedLinkSpecifier,
        },
      }, await resp.json()),
  };
  }

  async batchRead(
    {abortSignal, ...params}: RequestConfig & BatchReadRequest,
  ): Promise<BatchReadResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      Operations: params["Operations"]?.map(x => fromBatchReadOperation(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "BatchRead",
      requestUri: "/amazonclouddirectory/2017-01-11/batchread",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Responses": [toBatchReadOperationResponse],
        },
      }, await resp.json()),
  };
  }

  async batchWrite(
    {abortSignal, ...params}: RequestConfig & BatchWriteRequest,
  ): Promise<BatchWriteResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      Operations: params["Operations"]?.map(x => fromBatchWriteOperation(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "BatchWrite",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/batchwrite",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Responses": [toBatchWriteOperationResponse],
        },
      }, await resp.json()),
  };
  }

  async createDirectory(
    {abortSignal, ...params}: RequestConfig & CreateDirectoryRequest,
  ): Promise<CreateDirectoryResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateDirectory",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/create",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "DirectoryArn": "s",
          "Name": "s",
          "ObjectIdentifier": "s",
          "AppliedSchemaArn": "s",
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async createFacet(
    {abortSignal, ...params}: RequestConfig & CreateFacetRequest,
  ): Promise<CreateFacetResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Attributes: params["Attributes"]?.map(x => fromFacetAttribute(x)),
      ObjectType: params["ObjectType"],
      FacetStyle: params["FacetStyle"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/facet/create",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async createIndex(
    {abortSignal, ...params}: RequestConfig & CreateIndexRequest,
  ): Promise<CreateIndexResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      OrderedIndexedAttributeList: params["OrderedIndexedAttributeList"]?.map(x => fromAttributeKey(x)),
      IsUnique: params["IsUnique"],
      ParentReference: fromObjectReference(params["ParentReference"]),
      LinkName: params["LinkName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateIndex",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/index",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ObjectIdentifier": "s",
        },
      }, await resp.json()),
  };
  }

  async createObject(
    {abortSignal, ...params}: RequestConfig & CreateObjectRequest,
  ): Promise<CreateObjectResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      SchemaFacets: params["SchemaFacets"]?.map(x => fromSchemaFacet(x)),
      ObjectAttributeList: params["ObjectAttributeList"]?.map(x => fromAttributeKeyAndValue(x)),
      ParentReference: fromObjectReference(params["ParentReference"]),
      LinkName: params["LinkName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ObjectIdentifier": "s",
        },
      }, await resp.json()),
  };
  }

  async createSchema(
    {abortSignal, ...params}: RequestConfig & CreateSchemaRequest,
  ): Promise<CreateSchemaResponse> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/create",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SchemaArn": "s",
        },
      }, await resp.json()),
  };
  }

  async createTypedLinkFacet(
    {abortSignal, ...params}: RequestConfig & CreateTypedLinkFacetRequest,
  ): Promise<CreateTypedLinkFacetResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Facet: fromTypedLinkFacet(params["Facet"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateTypedLinkFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/create",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async deleteDirectory(
    {abortSignal, ...params}: RequestConfig & DeleteDirectoryRequest,
  ): Promise<DeleteDirectoryResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteDirectory",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/directory",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "DirectoryArn": "s",
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async deleteFacet(
    {abortSignal, ...params}: RequestConfig & DeleteFacetRequest,
  ): Promise<DeleteFacetResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DeleteFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/facet/delete",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async deleteObject(
    {abortSignal, ...params}: RequestConfig & DeleteObjectRequest,
  ): Promise<DeleteObjectResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DeleteObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/delete",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async deleteSchema(
    {abortSignal, ...params}: RequestConfig & DeleteSchemaRequest,
  ): Promise<DeleteSchemaResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SchemaArn": "s",
        },
      }, await resp.json()),
  };
  }

  async deleteTypedLinkFacet(
    {abortSignal, ...params}: RequestConfig & DeleteTypedLinkFacetRequest,
  ): Promise<DeleteTypedLinkFacetResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DeleteTypedLinkFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/delete",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async detachFromIndex(
    {abortSignal, ...params}: RequestConfig & DetachFromIndexRequest,
  ): Promise<DetachFromIndexResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      IndexReference: fromObjectReference(params["IndexReference"]),
      TargetReference: fromObjectReference(params["TargetReference"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DetachFromIndex",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/index/detach",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "DetachedObjectIdentifier": "s",
        },
      }, await resp.json()),
  };
  }

  async detachObject(
    {abortSignal, ...params}: RequestConfig & DetachObjectRequest,
  ): Promise<DetachObjectResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      ParentReference: fromObjectReference(params["ParentReference"]),
      LinkName: params["LinkName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DetachObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/detach",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "DetachedObjectIdentifier": "s",
        },
      }, await resp.json()),
  };
  }

  async detachPolicy(
    {abortSignal, ...params}: RequestConfig & DetachPolicyRequest,
  ): Promise<DetachPolicyResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      PolicyReference: fromObjectReference(params["PolicyReference"]),
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DetachPolicy",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/policy/detach",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async detachTypedLink(
    {abortSignal, ...params}: RequestConfig & DetachTypedLinkRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      TypedLinkSpecifier: fromTypedLinkSpecifier(params["TypedLinkSpecifier"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DetachTypedLink",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/detach",
      responseCode: 200,
    });
  }

  async disableDirectory(
    {abortSignal, ...params}: RequestConfig & DisableDirectoryRequest,
  ): Promise<DisableDirectoryResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DisableDirectory",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/disable",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "DirectoryArn": "s",
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async enableDirectory(
    {abortSignal, ...params}: RequestConfig & EnableDirectoryRequest,
  ): Promise<EnableDirectoryResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "EnableDirectory",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/enable",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "DirectoryArn": "s",
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async getAppliedSchemaVersion(
    {abortSignal, ...params}: RequestConfig & GetAppliedSchemaVersionRequest,
  ): Promise<GetAppliedSchemaVersionResponse> {
    const body: jsonP.JSONObject = params ? {
      SchemaArn: params["SchemaArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAppliedSchemaVersion",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/getappliedschema",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "AppliedSchemaArn": "s",
        },
      }, await resp.json()),
  };
  }

  async getDirectory(
    {abortSignal, ...params}: RequestConfig & GetDirectoryRequest,
  ): Promise<GetDirectoryResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetDirectory",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/get",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "Directory": toDirectory,
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async getFacet(
    {abortSignal, ...params}: RequestConfig & GetFacetRequest,
  ): Promise<GetFacetResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetFacet",
      requestUri: "/amazonclouddirectory/2017-01-11/facet",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Facet": toFacet,
        },
      }, await resp.json()),
  };
  }

  async getLinkAttributes(
    {abortSignal, ...params}: RequestConfig & GetLinkAttributesRequest,
  ): Promise<GetLinkAttributesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      TypedLinkSpecifier: fromTypedLinkSpecifier(params["TypedLinkSpecifier"]),
      AttributeNames: params["AttributeNames"],
      ConsistencyLevel: params["ConsistencyLevel"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetLinkAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/attributes/get",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Attributes": [toAttributeKeyAndValue],
        },
      }, await resp.json()),
  };
  }

  async getObjectAttributes(
    {abortSignal, ...params}: RequestConfig & GetObjectAttributesRequest,
  ): Promise<GetObjectAttributesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      SchemaFacet: fromSchemaFacet(params["SchemaFacet"]),
      AttributeNames: params["AttributeNames"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetObjectAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/object/attributes/get",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Attributes": [toAttributeKeyAndValue],
        },
      }, await resp.json()),
  };
  }

  async getObjectInformation(
    {abortSignal, ...params}: RequestConfig & GetObjectInformationRequest,
  ): Promise<GetObjectInformationResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetObjectInformation",
      requestUri: "/amazonclouddirectory/2017-01-11/object/information",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SchemaFacets": [toSchemaFacet],
          "ObjectIdentifier": "s",
        },
      }, await resp.json()),
  };
  }

  async getSchemaAsJson(
    {abortSignal, ...params}: RequestConfig & GetSchemaAsJsonRequest,
  ): Promise<GetSchemaAsJsonResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetSchemaAsJson",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/json",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Name": "s",
          "Document": "s",
        },
      }, await resp.json()),
  };
  }

  async getTypedLinkFacetInformation(
    {abortSignal, ...params}: RequestConfig & GetTypedLinkFacetInformationRequest,
  ): Promise<GetTypedLinkFacetInformationResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetTypedLinkFacetInformation",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/get",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "IdentityAttributeOrder": ["s"],
        },
      }, await resp.json()),
  };
  }

  async listAppliedSchemaArns(
    {abortSignal, ...params}: RequestConfig & ListAppliedSchemaArnsRequest,
  ): Promise<ListAppliedSchemaArnsResponse> {
    const body: jsonP.JSONObject = params ? {
      DirectoryArn: params["DirectoryArn"],
      SchemaArn: params["SchemaArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAppliedSchemaArns",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/applied",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SchemaArns": ["s"],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listAttachedIndices(
    {abortSignal, ...params}: RequestConfig & ListAttachedIndicesRequest,
  ): Promise<ListAttachedIndicesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      TargetReference: fromObjectReference(params["TargetReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListAttachedIndices",
      requestUri: "/amazonclouddirectory/2017-01-11/object/indices",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "IndexAttachments": [toIndexAttachment],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listDevelopmentSchemaArns(
    {abortSignal, ...params}: RequestConfig & ListDevelopmentSchemaArnsRequest = {},
  ): Promise<ListDevelopmentSchemaArnsResponse> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDevelopmentSchemaArns",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/development",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SchemaArns": ["s"],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listDirectories(
    {abortSignal, ...params}: RequestConfig & ListDirectoriesRequest = {},
  ): Promise<ListDirectoriesResponse> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      state: params["state"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDirectories",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/list",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {
          "Directories": [toDirectory],
        },
        optional: {
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listFacetAttributes(
    {abortSignal, ...params}: RequestConfig & ListFacetAttributesRequest,
  ): Promise<ListFacetAttributesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListFacetAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/facet/attributes",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Attributes": [toFacetAttribute],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listFacetNames(
    {abortSignal, ...params}: RequestConfig & ListFacetNamesRequest,
  ): Promise<ListFacetNamesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListFacetNames",
      requestUri: "/amazonclouddirectory/2017-01-11/facet/list",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "FacetNames": ["s"],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listIncomingTypedLinks(
    {abortSignal, ...params}: RequestConfig & ListIncomingTypedLinksRequest,
  ): Promise<ListIncomingTypedLinksResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      FilterAttributeRanges: params["FilterAttributeRanges"]?.map(x => fromTypedLinkAttributeRange(x)),
      FilterTypedLink: fromTypedLinkSchemaAndFacetName(params["FilterTypedLink"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ConsistencyLevel: params["ConsistencyLevel"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListIncomingTypedLinks",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/incoming",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "LinkSpecifiers": [toTypedLinkSpecifier],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listIndex(
    {abortSignal, ...params}: RequestConfig & ListIndexRequest,
  ): Promise<ListIndexResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      RangesOnIndexedValues: params["RangesOnIndexedValues"]?.map(x => fromObjectAttributeRange(x)),
      IndexReference: fromObjectReference(params["IndexReference"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListIndex",
      requestUri: "/amazonclouddirectory/2017-01-11/index/targets",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "IndexAttachments": [toIndexAttachment],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listManagedSchemaArns(
    {abortSignal, ...params}: RequestConfig & ListManagedSchemaArnsRequest = {},
  ): Promise<ListManagedSchemaArnsResponse> {
    const body: jsonP.JSONObject = params ? {
      SchemaArn: params["SchemaArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListManagedSchemaArns",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/managed",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SchemaArns": ["s"],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listObjectAttributes(
    {abortSignal, ...params}: RequestConfig & ListObjectAttributesRequest,
  ): Promise<ListObjectAttributesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      FacetFilter: fromSchemaFacet(params["FacetFilter"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/object/attributes",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Attributes": [toAttributeKeyAndValue],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listObjectChildren(
    {abortSignal, ...params}: RequestConfig & ListObjectChildrenRequest,
  ): Promise<ListObjectChildrenResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectChildren",
      requestUri: "/amazonclouddirectory/2017-01-11/object/children",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Children": x => jsonP.readMap(String, String, x),
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listObjectParentPaths(
    {abortSignal, ...params}: RequestConfig & ListObjectParentPathsRequest,
  ): Promise<ListObjectParentPathsResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectParentPaths",
      requestUri: "/amazonclouddirectory/2017-01-11/object/parentpaths",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "PathToObjectIdentifiersList": [toPathToObjectIdentifiers],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listObjectParents(
    {abortSignal, ...params}: RequestConfig & ListObjectParentsRequest,
  ): Promise<ListObjectParentsResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      IncludeAllLinksToEachParent: params["IncludeAllLinksToEachParent"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectParents",
      requestUri: "/amazonclouddirectory/2017-01-11/object/parent",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Parents": x => jsonP.readMap(String, String, x),
          "NextToken": "s",
          "ParentLinks": [toObjectIdentifierAndLinkNameTuple],
        },
      }, await resp.json()),
  };
  }

  async listObjectPolicies(
    {abortSignal, ...params}: RequestConfig & ListObjectPoliciesRequest,
  ): Promise<ListObjectPoliciesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectPolicies",
      requestUri: "/amazonclouddirectory/2017-01-11/object/policy",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "AttachedPolicyIds": ["s"],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listOutgoingTypedLinks(
    {abortSignal, ...params}: RequestConfig & ListOutgoingTypedLinksRequest,
  ): Promise<ListOutgoingTypedLinksResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      FilterAttributeRanges: params["FilterAttributeRanges"]?.map(x => fromTypedLinkAttributeRange(x)),
      FilterTypedLink: fromTypedLinkSchemaAndFacetName(params["FilterTypedLink"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ConsistencyLevel: params["ConsistencyLevel"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListOutgoingTypedLinks",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/outgoing",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "TypedLinkSpecifiers": [toTypedLinkSpecifier],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listPolicyAttachments(
    {abortSignal, ...params}: RequestConfig & ListPolicyAttachmentsRequest,
  ): Promise<ListPolicyAttachmentsResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const body: jsonP.JSONObject = params ? {
      PolicyReference: fromObjectReference(params["PolicyReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListPolicyAttachments",
      requestUri: "/amazonclouddirectory/2017-01-11/policy/attachment",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ObjectIdentifiers": ["s"],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listPublishedSchemaArns(
    {abortSignal, ...params}: RequestConfig & ListPublishedSchemaArnsRequest = {},
  ): Promise<ListPublishedSchemaArnsResponse> {
    const body: jsonP.JSONObject = params ? {
      SchemaArn: params["SchemaArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPublishedSchemaArns",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/published",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SchemaArns": ["s"],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
      requestUri: "/amazonclouddirectory/2017-01-11/tags",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Tags": [toTag],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listTypedLinkFacetAttributes(
    {abortSignal, ...params}: RequestConfig & ListTypedLinkFacetAttributesRequest,
  ): Promise<ListTypedLinkFacetAttributesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListTypedLinkFacetAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/attributes",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Attributes": [toTypedLinkAttributeDefinition],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listTypedLinkFacetNames(
    {abortSignal, ...params}: RequestConfig & ListTypedLinkFacetNamesRequest,
  ): Promise<ListTypedLinkFacetNamesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListTypedLinkFacetNames",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/list",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "FacetNames": ["s"],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async lookupPolicy(
    {abortSignal, ...params}: RequestConfig & LookupPolicyRequest,
  ): Promise<LookupPolicyResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "LookupPolicy",
      requestUri: "/amazonclouddirectory/2017-01-11/policy/lookup",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "PolicyToPathList": [toPolicyToPath],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async publishSchema(
    {abortSignal, ...params}: RequestConfig & PublishSchemaRequest,
  ): Promise<PublishSchemaResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DevelopmentSchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Version: params["Version"],
      MinorVersion: params["MinorVersion"],
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PublishSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/publish",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "PublishedSchemaArn": "s",
        },
      }, await resp.json()),
  };
  }

  async putSchemaFromJson(
    {abortSignal, ...params}: RequestConfig & PutSchemaFromJsonRequest,
  ): Promise<PutSchemaFromJsonResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Document: params["Document"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutSchemaFromJson",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/json",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Arn": "s",
        },
      }, await resp.json()),
  };
  }

  async removeFacetFromObject(
    {abortSignal, ...params}: RequestConfig & RemoveFacetFromObjectRequest,
  ): Promise<RemoveFacetFromObjectResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      SchemaFacet: fromSchemaFacet(params["SchemaFacet"]),
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "RemoveFacetFromObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/facets/delete",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/tags/add",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/tags/remove",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async updateFacet(
    {abortSignal, ...params}: RequestConfig & UpdateFacetRequest,
  ): Promise<UpdateFacetResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      AttributeUpdates: params["AttributeUpdates"]?.map(x => fromFacetAttributeUpdate(x)),
      ObjectType: params["ObjectType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/facet",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async updateLinkAttributes(
    {abortSignal, ...params}: RequestConfig & UpdateLinkAttributesRequest,
  ): Promise<UpdateLinkAttributesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      TypedLinkSpecifier: fromTypedLinkSpecifier(params["TypedLinkSpecifier"]),
      AttributeUpdates: params["AttributeUpdates"]?.map(x => fromLinkAttributeUpdate(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateLinkAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/attributes/update",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async updateObjectAttributes(
    {abortSignal, ...params}: RequestConfig & UpdateObjectAttributesRequest,
  ): Promise<UpdateObjectAttributesResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const body: jsonP.JSONObject = params ? {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      AttributeUpdates: params["AttributeUpdates"]?.map(x => fromObjectAttributeUpdate(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateObjectAttributes",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/update",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ObjectIdentifier": "s",
        },
      }, await resp.json()),
  };
  }

  async updateSchema(
    {abortSignal, ...params}: RequestConfig & UpdateSchemaRequest,
  ): Promise<UpdateSchemaResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/update",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "SchemaArn": "s",
        },
      }, await resp.json()),
  };
  }

  async updateTypedLinkFacet(
    {abortSignal, ...params}: RequestConfig & UpdateTypedLinkFacetRequest,
  ): Promise<UpdateTypedLinkFacetResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      AttributeUpdates: params["AttributeUpdates"]?.map(x => fromTypedLinkFacetAttributeUpdate(x)),
      IdentityAttributeOrder: params["IdentityAttributeOrder"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateTypedLinkFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async upgradeAppliedSchema(
    {abortSignal, ...params}: RequestConfig & UpgradeAppliedSchemaRequest,
  ): Promise<UpgradeAppliedSchemaResponse> {
    const body: jsonP.JSONObject = params ? {
      PublishedSchemaArn: params["PublishedSchemaArn"],
      DirectoryArn: params["DirectoryArn"],
      DryRun: params["DryRun"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpgradeAppliedSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/upgradeapplied",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "UpgradedSchemaArn": "s",
          "DirectoryArn": "s",
        },
      }, await resp.json()),
  };
  }

  async upgradePublishedSchema(
    {abortSignal, ...params}: RequestConfig & UpgradePublishedSchemaRequest,
  ): Promise<UpgradePublishedSchemaResponse> {
    const body: jsonP.JSONObject = params ? {
      DevelopmentSchemaArn: params["DevelopmentSchemaArn"],
      PublishedSchemaArn: params["PublishedSchemaArn"],
      MinorVersion: params["MinorVersion"],
      DryRun: params["DryRun"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpgradePublishedSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/upgradepublished",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "UpgradedSchemaArn": "s",
        },
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface AddFacetToObjectRequest {
  DirectoryArn: string;
  SchemaFacet: SchemaFacet;
  ObjectAttributeList?: AttributeKeyAndValue[] | null;
  ObjectReference: ObjectReference;
}

// refs: 1 - tags: named, input
export interface ApplySchemaRequest {
  PublishedSchemaArn: string;
  DirectoryArn: string;
}

// refs: 1 - tags: named, input
export interface AttachObjectRequest {
  DirectoryArn: string;
  ParentReference: ObjectReference;
  ChildReference: ObjectReference;
  LinkName: string;
}

// refs: 1 - tags: named, input
export interface AttachPolicyRequest {
  DirectoryArn: string;
  PolicyReference: ObjectReference;
  ObjectReference: ObjectReference;
}

// refs: 1 - tags: named, input
export interface AttachToIndexRequest {
  DirectoryArn: string;
  IndexReference: ObjectReference;
  TargetReference: ObjectReference;
}

// refs: 1 - tags: named, input
export interface AttachTypedLinkRequest {
  DirectoryArn: string;
  SourceObjectReference: ObjectReference;
  TargetObjectReference: ObjectReference;
  TypedLinkFacet: TypedLinkSchemaAndFacetName;
  Attributes: AttributeNameAndValue[];
}

// refs: 1 - tags: named, input
export interface BatchReadRequest {
  DirectoryArn: string;
  Operations: BatchReadOperation[];
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface BatchWriteRequest {
  DirectoryArn: string;
  Operations: BatchWriteOperation[];
}

// refs: 1 - tags: named, input
export interface CreateDirectoryRequest {
  Name: string;
  SchemaArn: string;
}

// refs: 1 - tags: named, input
export interface CreateFacetRequest {
  SchemaArn: string;
  Name: string;
  Attributes?: FacetAttribute[] | null;
  ObjectType?: ObjectType | null;
  FacetStyle?: FacetStyle | null;
}

// refs: 1 - tags: named, input
export interface CreateIndexRequest {
  DirectoryArn: string;
  OrderedIndexedAttributeList: AttributeKey[];
  IsUnique: boolean;
  ParentReference?: ObjectReference | null;
  LinkName?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateObjectRequest {
  DirectoryArn: string;
  SchemaFacets: SchemaFacet[];
  ObjectAttributeList?: AttributeKeyAndValue[] | null;
  ParentReference?: ObjectReference | null;
  LinkName?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateSchemaRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface CreateTypedLinkFacetRequest {
  SchemaArn: string;
  Facet: TypedLinkFacet;
}

// refs: 1 - tags: named, input
export interface DeleteDirectoryRequest {
  DirectoryArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteFacetRequest {
  SchemaArn: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteObjectRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
}

// refs: 1 - tags: named, input
export interface DeleteSchemaRequest {
  SchemaArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteTypedLinkFacetRequest {
  SchemaArn: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DetachFromIndexRequest {
  DirectoryArn: string;
  IndexReference: ObjectReference;
  TargetReference: ObjectReference;
}

// refs: 1 - tags: named, input
export interface DetachObjectRequest {
  DirectoryArn: string;
  ParentReference: ObjectReference;
  LinkName: string;
}

// refs: 1 - tags: named, input
export interface DetachPolicyRequest {
  DirectoryArn: string;
  PolicyReference: ObjectReference;
  ObjectReference: ObjectReference;
}

// refs: 1 - tags: named, input
export interface DetachTypedLinkRequest {
  DirectoryArn: string;
  TypedLinkSpecifier: TypedLinkSpecifier;
}

// refs: 1 - tags: named, input
export interface DisableDirectoryRequest {
  DirectoryArn: string;
}

// refs: 1 - tags: named, input
export interface EnableDirectoryRequest {
  DirectoryArn: string;
}

// refs: 1 - tags: named, input
export interface GetAppliedSchemaVersionRequest {
  SchemaArn: string;
}

// refs: 1 - tags: named, input
export interface GetDirectoryRequest {
  DirectoryArn: string;
}

// refs: 1 - tags: named, input
export interface GetFacetRequest {
  SchemaArn: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetLinkAttributesRequest {
  DirectoryArn: string;
  TypedLinkSpecifier: TypedLinkSpecifier;
  AttributeNames: string[];
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface GetObjectAttributesRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  ConsistencyLevel?: ConsistencyLevel | null;
  SchemaFacet: SchemaFacet;
  AttributeNames: string[];
}

// refs: 1 - tags: named, input
export interface GetObjectInformationRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface GetSchemaAsJsonRequest {
  SchemaArn: string;
}

// refs: 1 - tags: named, input
export interface GetTypedLinkFacetInformationRequest {
  SchemaArn: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface ListAppliedSchemaArnsRequest {
  DirectoryArn: string;
  SchemaArn?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListAttachedIndicesRequest {
  DirectoryArn: string;
  TargetReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface ListDevelopmentSchemaArnsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListDirectoriesRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  state?: DirectoryState | null;
}

// refs: 1 - tags: named, input
export interface ListFacetAttributesRequest {
  SchemaArn: string;
  Name: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListFacetNamesRequest {
  SchemaArn: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListIncomingTypedLinksRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  FilterAttributeRanges?: TypedLinkAttributeRange[] | null;
  FilterTypedLink?: TypedLinkSchemaAndFacetName | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface ListIndexRequest {
  DirectoryArn: string;
  RangesOnIndexedValues?: ObjectAttributeRange[] | null;
  IndexReference: ObjectReference;
  MaxResults?: number | null;
  NextToken?: string | null;
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface ListManagedSchemaArnsRequest {
  SchemaArn?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListObjectAttributesRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
  ConsistencyLevel?: ConsistencyLevel | null;
  FacetFilter?: SchemaFacet | null;
}

// refs: 1 - tags: named, input
export interface ListObjectChildrenRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface ListObjectParentPathsRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListObjectParentsRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
  ConsistencyLevel?: ConsistencyLevel | null;
  IncludeAllLinksToEachParent?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ListObjectPoliciesRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface ListOutgoingTypedLinksRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  FilterAttributeRanges?: TypedLinkAttributeRange[] | null;
  FilterTypedLink?: TypedLinkSchemaAndFacetName | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface ListPolicyAttachmentsRequest {
  DirectoryArn: string;
  PolicyReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
  ConsistencyLevel?: ConsistencyLevel | null;
}

// refs: 1 - tags: named, input
export interface ListPublishedSchemaArnsRequest {
  SchemaArn?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceArn: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTypedLinkFacetAttributesRequest {
  SchemaArn: string;
  Name: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTypedLinkFacetNamesRequest {
  SchemaArn: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface LookupPolicyRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface PublishSchemaRequest {
  DevelopmentSchemaArn: string;
  Version: string;
  MinorVersion?: string | null;
  Name?: string | null;
}

// refs: 1 - tags: named, input
export interface PutSchemaFromJsonRequest {
  SchemaArn: string;
  Document: string;
}

// refs: 1 - tags: named, input
export interface RemoveFacetFromObjectRequest {
  DirectoryArn: string;
  SchemaFacet: SchemaFacet;
  ObjectReference: ObjectReference;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceArn: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateFacetRequest {
  SchemaArn: string;
  Name: string;
  AttributeUpdates?: FacetAttributeUpdate[] | null;
  ObjectType?: ObjectType | null;
}

// refs: 1 - tags: named, input
export interface UpdateLinkAttributesRequest {
  DirectoryArn: string;
  TypedLinkSpecifier: TypedLinkSpecifier;
  AttributeUpdates: LinkAttributeUpdate[];
}

// refs: 1 - tags: named, input
export interface UpdateObjectAttributesRequest {
  DirectoryArn: string;
  ObjectReference: ObjectReference;
  AttributeUpdates: ObjectAttributeUpdate[];
}

// refs: 1 - tags: named, input
export interface UpdateSchemaRequest {
  SchemaArn: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface UpdateTypedLinkFacetRequest {
  SchemaArn: string;
  Name: string;
  AttributeUpdates: TypedLinkFacetAttributeUpdate[];
  IdentityAttributeOrder: string[];
}

// refs: 1 - tags: named, input
export interface UpgradeAppliedSchemaRequest {
  PublishedSchemaArn: string;
  DirectoryArn: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UpgradePublishedSchemaRequest {
  DevelopmentSchemaArn: string;
  PublishedSchemaArn: string;
  MinorVersion: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, output
export interface AddFacetToObjectResponse {
}

// refs: 1 - tags: named, output
export interface ApplySchemaResponse {
  AppliedSchemaArn?: string | null;
  DirectoryArn?: string | null;
}

// refs: 1 - tags: named, output
export interface AttachObjectResponse {
  AttachedObjectIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface AttachPolicyResponse {
}

// refs: 1 - tags: named, output
export interface AttachToIndexResponse {
  AttachedObjectIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface AttachTypedLinkResponse {
  TypedLinkSpecifier?: TypedLinkSpecifier | null;
}

// refs: 1 - tags: named, output
export interface BatchReadResponse {
  Responses?: BatchReadOperationResponse[] | null;
}

// refs: 1 - tags: named, output
export interface BatchWriteResponse {
  Responses?: BatchWriteOperationResponse[] | null;
}

// refs: 1 - tags: named, output
export interface CreateDirectoryResponse {
  DirectoryArn: string;
  Name: string;
  ObjectIdentifier: string;
  AppliedSchemaArn: string;
}

// refs: 1 - tags: named, output
export interface CreateFacetResponse {
}

// refs: 1 - tags: named, output
export interface CreateIndexResponse {
  ObjectIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateObjectResponse {
  ObjectIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSchemaResponse {
  SchemaArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateTypedLinkFacetResponse {
}

// refs: 1 - tags: named, output
export interface DeleteDirectoryResponse {
  DirectoryArn: string;
}

// refs: 1 - tags: named, output
export interface DeleteFacetResponse {
}

// refs: 1 - tags: named, output
export interface DeleteObjectResponse {
}

// refs: 1 - tags: named, output
export interface DeleteSchemaResponse {
  SchemaArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteTypedLinkFacetResponse {
}

// refs: 1 - tags: named, output
export interface DetachFromIndexResponse {
  DetachedObjectIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface DetachObjectResponse {
  DetachedObjectIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface DetachPolicyResponse {
}

// refs: 1 - tags: named, output
export interface DisableDirectoryResponse {
  DirectoryArn: string;
}

// refs: 1 - tags: named, output
export interface EnableDirectoryResponse {
  DirectoryArn: string;
}

// refs: 1 - tags: named, output
export interface GetAppliedSchemaVersionResponse {
  AppliedSchemaArn?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDirectoryResponse {
  Directory: Directory;
}

// refs: 1 - tags: named, output
export interface GetFacetResponse {
  Facet?: Facet | null;
}

// refs: 1 - tags: named, output
export interface GetLinkAttributesResponse {
  Attributes?: AttributeKeyAndValue[] | null;
}

// refs: 1 - tags: named, output
export interface GetObjectAttributesResponse {
  Attributes?: AttributeKeyAndValue[] | null;
}

// refs: 1 - tags: named, output
export interface GetObjectInformationResponse {
  SchemaFacets?: SchemaFacet[] | null;
  ObjectIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSchemaAsJsonResponse {
  Name?: string | null;
  Document?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTypedLinkFacetInformationResponse {
  IdentityAttributeOrder?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListAppliedSchemaArnsResponse {
  SchemaArns?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAttachedIndicesResponse {
  IndexAttachments?: IndexAttachment[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDevelopmentSchemaArnsResponse {
  SchemaArns?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDirectoriesResponse {
  Directories: Directory[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListFacetAttributesResponse {
  Attributes?: FacetAttribute[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListFacetNamesResponse {
  FacetNames?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListIncomingTypedLinksResponse {
  LinkSpecifiers?: TypedLinkSpecifier[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListIndexResponse {
  IndexAttachments?: IndexAttachment[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListManagedSchemaArnsResponse {
  SchemaArns?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListObjectAttributesResponse {
  Attributes?: AttributeKeyAndValue[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListObjectChildrenResponse {
  Children?: { [key: string]: string | null | undefined } | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListObjectParentPathsResponse {
  PathToObjectIdentifiersList?: PathToObjectIdentifiers[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListObjectParentsResponse {
  Parents?: { [key: string]: string | null | undefined } | null;
  NextToken?: string | null;
  ParentLinks?: ObjectIdentifierAndLinkNameTuple[] | null;
}

// refs: 1 - tags: named, output
export interface ListObjectPoliciesResponse {
  AttachedPolicyIds?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListOutgoingTypedLinksResponse {
  TypedLinkSpecifiers?: TypedLinkSpecifier[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPolicyAttachmentsResponse {
  ObjectIdentifiers?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPublishedSchemaArnsResponse {
  SchemaArns?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: Tag[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTypedLinkFacetAttributesResponse {
  Attributes?: TypedLinkAttributeDefinition[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTypedLinkFacetNamesResponse {
  FacetNames?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface LookupPolicyResponse {
  PolicyToPathList?: PolicyToPath[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PublishSchemaResponse {
  PublishedSchemaArn?: string | null;
}

// refs: 1 - tags: named, output
export interface PutSchemaFromJsonResponse {
  Arn?: string | null;
}

// refs: 1 - tags: named, output
export interface RemoveFacetFromObjectResponse {
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateFacetResponse {
}

// refs: 1 - tags: named, output
export interface UpdateLinkAttributesResponse {
}

// refs: 1 - tags: named, output
export interface UpdateObjectAttributesResponse {
  ObjectIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateSchemaResponse {
  SchemaArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateTypedLinkFacetResponse {
}

// refs: 1 - tags: named, output
export interface UpgradeAppliedSchemaResponse {
  UpgradedSchemaArn?: string | null;
  DirectoryArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpgradePublishedSchemaResponse {
  UpgradedSchemaArn?: string | null;
}

// refs: 12 - tags: input, named, interface, output
export interface SchemaFacet {
  SchemaArn?: string | null;
  FacetName?: string | null;
}
function fromSchemaFacet(input?: SchemaFacet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaArn: input["SchemaArn"],
    FacetName: input["FacetName"],
  }
}
function toSchemaFacet(root: jsonP.JSONValue): SchemaFacet {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaArn": "s",
      "FacetName": "s",
    },
  }, root);
}

// refs: 14 - tags: input, named, interface, output
export interface AttributeKeyAndValue {
  Key: AttributeKey;
  Value: TypedAttributeValue;
}
function fromAttributeKeyAndValue(input?: AttributeKeyAndValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: fromAttributeKey(input["Key"]),
    Value: fromTypedAttributeValue(input["Value"]),
  }
}
function toAttributeKeyAndValue(root: jsonP.JSONValue): AttributeKeyAndValue {
  return jsonP.readObj({
    required: {
      "Key": toAttributeKey,
      "Value": toTypedAttributeValue,
    },
    optional: {},
  }, root);
}

// refs: 22 - tags: input, named, interface, output
export interface AttributeKey {
  SchemaArn: string;
  FacetName: string;
  Name: string;
}
function fromAttributeKey(input?: AttributeKey | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaArn: input["SchemaArn"],
    FacetName: input["FacetName"],
    Name: input["Name"],
  }
}
function toAttributeKey(root: jsonP.JSONValue): AttributeKey {
  return jsonP.readObj({
    required: {
      "SchemaArn": "s",
      "FacetName": "s",
      "Name": "s",
    },
    optional: {},
  }, root);
}

// refs: 50 - tags: input, named, interface, output
export interface TypedAttributeValue {
  StringValue?: string | null;
  BinaryValue?: Uint8Array | string | null;
  BooleanValue?: boolean | null;
  NumberValue?: string | null;
  DatetimeValue?: Date | number | null;
}
function fromTypedAttributeValue(input?: TypedAttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StringValue: input["StringValue"],
    BinaryValue: jsonP.serializeBlob(input["BinaryValue"]),
    BooleanValue: input["BooleanValue"],
    NumberValue: input["NumberValue"],
    DatetimeValue: jsonP.serializeDate_unixTimestamp(input["DatetimeValue"]),
  }
}
function toTypedAttributeValue(root: jsonP.JSONValue): TypedAttributeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "StringValue": "s",
      "BinaryValue": "a",
      "BooleanValue": "b",
      "NumberValue": "s",
      "DatetimeValue": "d",
    },
  }, root);
}

// refs: 88 - tags: input, named, interface, output
export interface ObjectReference {
  Selector?: string | null;
}
function fromObjectReference(input?: ObjectReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Selector: input["Selector"],
  }
}
function toObjectReference(root: jsonP.JSONValue): ObjectReference {
  return jsonP.readObj({
    required: {},
    optional: {
      "Selector": "s",
    },
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface TypedLinkSchemaAndFacetName {
  SchemaArn: string;
  TypedLinkName: string;
}
function fromTypedLinkSchemaAndFacetName(input?: TypedLinkSchemaAndFacetName | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaArn: input["SchemaArn"],
    TypedLinkName: input["TypedLinkName"],
  }
}
function toTypedLinkSchemaAndFacetName(root: jsonP.JSONValue): TypedLinkSchemaAndFacetName {
  return jsonP.readObj({
    required: {
      "SchemaArn": "s",
      "TypedLinkName": "s",
    },
    optional: {},
  }, root);
}

// refs: 14 - tags: input, named, interface, output
export interface AttributeNameAndValue {
  AttributeName: string;
  Value: TypedAttributeValue;
}
function fromAttributeNameAndValue(input?: AttributeNameAndValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    Value: fromTypedAttributeValue(input["Value"]),
  }
}
function toAttributeNameAndValue(root: jsonP.JSONValue): AttributeNameAndValue {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "Value": toTypedAttributeValue,
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface BatchReadOperation {
  ListObjectAttributes?: BatchListObjectAttributes | null;
  ListObjectChildren?: BatchListObjectChildren | null;
  ListAttachedIndices?: BatchListAttachedIndices | null;
  ListObjectParentPaths?: BatchListObjectParentPaths | null;
  GetObjectInformation?: BatchGetObjectInformation | null;
  GetObjectAttributes?: BatchGetObjectAttributes | null;
  ListObjectParents?: BatchListObjectParents | null;
  ListObjectPolicies?: BatchListObjectPolicies | null;
  ListPolicyAttachments?: BatchListPolicyAttachments | null;
  LookupPolicy?: BatchLookupPolicy | null;
  ListIndex?: BatchListIndex | null;
  ListOutgoingTypedLinks?: BatchListOutgoingTypedLinks | null;
  ListIncomingTypedLinks?: BatchListIncomingTypedLinks | null;
  GetLinkAttributes?: BatchGetLinkAttributes | null;
}
function fromBatchReadOperation(input?: BatchReadOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ListObjectAttributes: fromBatchListObjectAttributes(input["ListObjectAttributes"]),
    ListObjectChildren: fromBatchListObjectChildren(input["ListObjectChildren"]),
    ListAttachedIndices: fromBatchListAttachedIndices(input["ListAttachedIndices"]),
    ListObjectParentPaths: fromBatchListObjectParentPaths(input["ListObjectParentPaths"]),
    GetObjectInformation: fromBatchGetObjectInformation(input["GetObjectInformation"]),
    GetObjectAttributes: fromBatchGetObjectAttributes(input["GetObjectAttributes"]),
    ListObjectParents: fromBatchListObjectParents(input["ListObjectParents"]),
    ListObjectPolicies: fromBatchListObjectPolicies(input["ListObjectPolicies"]),
    ListPolicyAttachments: fromBatchListPolicyAttachments(input["ListPolicyAttachments"]),
    LookupPolicy: fromBatchLookupPolicy(input["LookupPolicy"]),
    ListIndex: fromBatchListIndex(input["ListIndex"]),
    ListOutgoingTypedLinks: fromBatchListOutgoingTypedLinks(input["ListOutgoingTypedLinks"]),
    ListIncomingTypedLinks: fromBatchListIncomingTypedLinks(input["ListIncomingTypedLinks"]),
    GetLinkAttributes: fromBatchGetLinkAttributes(input["GetLinkAttributes"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchListObjectAttributes {
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
  FacetFilter?: SchemaFacet | null;
}
function fromBatchListObjectAttributes(input?: BatchListObjectAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
    FacetFilter: fromSchemaFacet(input["FacetFilter"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchListObjectChildren {
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
}
function fromBatchListObjectChildren(input?: BatchListObjectChildren | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchListAttachedIndices {
  TargetReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
}
function fromBatchListAttachedIndices(input?: BatchListAttachedIndices | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetReference: fromObjectReference(input["TargetReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchListObjectParentPaths {
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
}
function fromBatchListObjectParentPaths(input?: BatchListObjectParentPaths | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchGetObjectInformation {
  ObjectReference: ObjectReference;
}
function fromBatchGetObjectInformation(input?: BatchGetObjectInformation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchGetObjectAttributes {
  ObjectReference: ObjectReference;
  SchemaFacet: SchemaFacet;
  AttributeNames: string[];
}
function fromBatchGetObjectAttributes(input?: BatchGetObjectAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    SchemaFacet: fromSchemaFacet(input["SchemaFacet"]),
    AttributeNames: input["AttributeNames"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchListObjectParents {
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
}
function fromBatchListObjectParents(input?: BatchListObjectParents | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchListObjectPolicies {
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
}
function fromBatchListObjectPolicies(input?: BatchListObjectPolicies | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchListPolicyAttachments {
  PolicyReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
}
function fromBatchListPolicyAttachments(input?: BatchListPolicyAttachments | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyReference: fromObjectReference(input["PolicyReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchLookupPolicy {
  ObjectReference: ObjectReference;
  NextToken?: string | null;
  MaxResults?: number | null;
}
function fromBatchLookupPolicy(input?: BatchLookupPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchListIndex {
  RangesOnIndexedValues?: ObjectAttributeRange[] | null;
  IndexReference: ObjectReference;
  MaxResults?: number | null;
  NextToken?: string | null;
}
function fromBatchListIndex(input?: BatchListIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RangesOnIndexedValues: input["RangesOnIndexedValues"]?.map(x => fromObjectAttributeRange(x)),
    IndexReference: fromObjectReference(input["IndexReference"]),
    MaxResults: input["MaxResults"],
    NextToken: input["NextToken"],
  }
}

// refs: 2 - tags: input, named, interface
export interface ObjectAttributeRange {
  AttributeKey?: AttributeKey | null;
  Range?: TypedAttributeValueRange | null;
}
function fromObjectAttributeRange(input?: ObjectAttributeRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeKey: fromAttributeKey(input["AttributeKey"]),
    Range: fromTypedAttributeValueRange(input["Range"]),
  }
}

// refs: 6 - tags: input, named, interface
export interface TypedAttributeValueRange {
  StartMode: RangeMode;
  StartValue?: TypedAttributeValue | null;
  EndMode: RangeMode;
  EndValue?: TypedAttributeValue | null;
}
function fromTypedAttributeValueRange(input?: TypedAttributeValueRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartMode: input["StartMode"],
    StartValue: fromTypedAttributeValue(input["StartValue"]),
    EndMode: input["EndMode"],
    EndValue: fromTypedAttributeValue(input["EndValue"]),
  }
}

// refs: 12 - tags: input, named, enum
export type RangeMode =
| "FIRST"
| "LAST"
| "LAST_BEFORE_MISSING_VALUES"
| "INCLUSIVE"
| "EXCLUSIVE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface BatchListOutgoingTypedLinks {
  ObjectReference: ObjectReference;
  FilterAttributeRanges?: TypedLinkAttributeRange[] | null;
  FilterTypedLink?: TypedLinkSchemaAndFacetName | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}
function fromBatchListOutgoingTypedLinks(input?: BatchListOutgoingTypedLinks | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    FilterAttributeRanges: input["FilterAttributeRanges"]?.map(x => fromTypedLinkAttributeRange(x)),
    FilterTypedLink: fromTypedLinkSchemaAndFacetName(input["FilterTypedLink"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

// refs: 4 - tags: input, named, interface
export interface TypedLinkAttributeRange {
  AttributeName?: string | null;
  Range: TypedAttributeValueRange;
}
function fromTypedLinkAttributeRange(input?: TypedLinkAttributeRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    Range: fromTypedAttributeValueRange(input["Range"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchListIncomingTypedLinks {
  ObjectReference: ObjectReference;
  FilterAttributeRanges?: TypedLinkAttributeRange[] | null;
  FilterTypedLink?: TypedLinkSchemaAndFacetName | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}
function fromBatchListIncomingTypedLinks(input?: BatchListIncomingTypedLinks | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    FilterAttributeRanges: input["FilterAttributeRanges"]?.map(x => fromTypedLinkAttributeRange(x)),
    FilterTypedLink: fromTypedLinkSchemaAndFacetName(input["FilterTypedLink"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchGetLinkAttributes {
  TypedLinkSpecifier: TypedLinkSpecifier;
  AttributeNames: string[];
}
function fromBatchGetLinkAttributes(input?: BatchGetLinkAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypedLinkSpecifier: fromTypedLinkSpecifier(input["TypedLinkSpecifier"]),
    AttributeNames: input["AttributeNames"],
  }
}

// refs: 12 - tags: input, named, interface, output
export interface TypedLinkSpecifier {
  TypedLinkFacet: TypedLinkSchemaAndFacetName;
  SourceObjectReference: ObjectReference;
  TargetObjectReference: ObjectReference;
  IdentityAttributeValues: AttributeNameAndValue[];
}
function fromTypedLinkSpecifier(input?: TypedLinkSpecifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypedLinkFacet: fromTypedLinkSchemaAndFacetName(input["TypedLinkFacet"]),
    SourceObjectReference: fromObjectReference(input["SourceObjectReference"]),
    TargetObjectReference: fromObjectReference(input["TargetObjectReference"]),
    IdentityAttributeValues: input["IdentityAttributeValues"]?.map(x => fromAttributeNameAndValue(x)),
  }
}
function toTypedLinkSpecifier(root: jsonP.JSONValue): TypedLinkSpecifier {
  return jsonP.readObj({
    required: {
      "TypedLinkFacet": toTypedLinkSchemaAndFacetName,
      "SourceObjectReference": toObjectReference,
      "TargetObjectReference": toObjectReference,
      "IdentityAttributeValues": [toAttributeNameAndValue],
    },
    optional: {},
  }, root);
}

// refs: 13 - tags: input, named, enum
export type ConsistencyLevel =
| "SERIALIZABLE"
| "EVENTUAL"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface BatchWriteOperation {
  CreateObject?: BatchCreateObject | null;
  AttachObject?: BatchAttachObject | null;
  DetachObject?: BatchDetachObject | null;
  UpdateObjectAttributes?: BatchUpdateObjectAttributes | null;
  DeleteObject?: BatchDeleteObject | null;
  AddFacetToObject?: BatchAddFacetToObject | null;
  RemoveFacetFromObject?: BatchRemoveFacetFromObject | null;
  AttachPolicy?: BatchAttachPolicy | null;
  DetachPolicy?: BatchDetachPolicy | null;
  CreateIndex?: BatchCreateIndex | null;
  AttachToIndex?: BatchAttachToIndex | null;
  DetachFromIndex?: BatchDetachFromIndex | null;
  AttachTypedLink?: BatchAttachTypedLink | null;
  DetachTypedLink?: BatchDetachTypedLink | null;
  UpdateLinkAttributes?: BatchUpdateLinkAttributes | null;
}
function fromBatchWriteOperation(input?: BatchWriteOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CreateObject: fromBatchCreateObject(input["CreateObject"]),
    AttachObject: fromBatchAttachObject(input["AttachObject"]),
    DetachObject: fromBatchDetachObject(input["DetachObject"]),
    UpdateObjectAttributes: fromBatchUpdateObjectAttributes(input["UpdateObjectAttributes"]),
    DeleteObject: fromBatchDeleteObject(input["DeleteObject"]),
    AddFacetToObject: fromBatchAddFacetToObject(input["AddFacetToObject"]),
    RemoveFacetFromObject: fromBatchRemoveFacetFromObject(input["RemoveFacetFromObject"]),
    AttachPolicy: fromBatchAttachPolicy(input["AttachPolicy"]),
    DetachPolicy: fromBatchDetachPolicy(input["DetachPolicy"]),
    CreateIndex: fromBatchCreateIndex(input["CreateIndex"]),
    AttachToIndex: fromBatchAttachToIndex(input["AttachToIndex"]),
    DetachFromIndex: fromBatchDetachFromIndex(input["DetachFromIndex"]),
    AttachTypedLink: fromBatchAttachTypedLink(input["AttachTypedLink"]),
    DetachTypedLink: fromBatchDetachTypedLink(input["DetachTypedLink"]),
    UpdateLinkAttributes: fromBatchUpdateLinkAttributes(input["UpdateLinkAttributes"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchCreateObject {
  SchemaFacet: SchemaFacet[];
  ObjectAttributeList: AttributeKeyAndValue[];
  ParentReference?: ObjectReference | null;
  LinkName?: string | null;
  BatchReferenceName?: string | null;
}
function fromBatchCreateObject(input?: BatchCreateObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaFacet: input["SchemaFacet"]?.map(x => fromSchemaFacet(x)),
    ObjectAttributeList: input["ObjectAttributeList"]?.map(x => fromAttributeKeyAndValue(x)),
    ParentReference: fromObjectReference(input["ParentReference"]),
    LinkName: input["LinkName"],
    BatchReferenceName: input["BatchReferenceName"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchAttachObject {
  ParentReference: ObjectReference;
  ChildReference: ObjectReference;
  LinkName: string;
}
function fromBatchAttachObject(input?: BatchAttachObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParentReference: fromObjectReference(input["ParentReference"]),
    ChildReference: fromObjectReference(input["ChildReference"]),
    LinkName: input["LinkName"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchDetachObject {
  ParentReference: ObjectReference;
  LinkName: string;
  BatchReferenceName?: string | null;
}
function fromBatchDetachObject(input?: BatchDetachObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParentReference: fromObjectReference(input["ParentReference"]),
    LinkName: input["LinkName"],
    BatchReferenceName: input["BatchReferenceName"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchUpdateObjectAttributes {
  ObjectReference: ObjectReference;
  AttributeUpdates: ObjectAttributeUpdate[];
}
function fromBatchUpdateObjectAttributes(input?: BatchUpdateObjectAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    AttributeUpdates: input["AttributeUpdates"]?.map(x => fromObjectAttributeUpdate(x)),
  }
}

// refs: 2 - tags: input, named, interface
export interface ObjectAttributeUpdate {
  ObjectAttributeKey?: AttributeKey | null;
  ObjectAttributeAction?: ObjectAttributeAction | null;
}
function fromObjectAttributeUpdate(input?: ObjectAttributeUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectAttributeKey: fromAttributeKey(input["ObjectAttributeKey"]),
    ObjectAttributeAction: fromObjectAttributeAction(input["ObjectAttributeAction"]),
  }
}

// refs: 2 - tags: input, named, interface
export interface ObjectAttributeAction {
  ObjectAttributeActionType?: UpdateActionType | null;
  ObjectAttributeUpdateValue?: TypedAttributeValue | null;
}
function fromObjectAttributeAction(input?: ObjectAttributeAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectAttributeActionType: input["ObjectAttributeActionType"],
    ObjectAttributeUpdateValue: fromTypedAttributeValue(input["ObjectAttributeUpdateValue"]),
  }
}

// refs: 6 - tags: input, named, enum
export type UpdateActionType =
| "CREATE_OR_UPDATE"
| "DELETE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface BatchDeleteObject {
  ObjectReference: ObjectReference;
}
function fromBatchDeleteObject(input?: BatchDeleteObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchAddFacetToObject {
  SchemaFacet: SchemaFacet;
  ObjectAttributeList: AttributeKeyAndValue[];
  ObjectReference: ObjectReference;
}
function fromBatchAddFacetToObject(input?: BatchAddFacetToObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaFacet: fromSchemaFacet(input["SchemaFacet"]),
    ObjectAttributeList: input["ObjectAttributeList"]?.map(x => fromAttributeKeyAndValue(x)),
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchRemoveFacetFromObject {
  SchemaFacet: SchemaFacet;
  ObjectReference: ObjectReference;
}
function fromBatchRemoveFacetFromObject(input?: BatchRemoveFacetFromObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaFacet: fromSchemaFacet(input["SchemaFacet"]),
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchAttachPolicy {
  PolicyReference: ObjectReference;
  ObjectReference: ObjectReference;
}
function fromBatchAttachPolicy(input?: BatchAttachPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyReference: fromObjectReference(input["PolicyReference"]),
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchDetachPolicy {
  PolicyReference: ObjectReference;
  ObjectReference: ObjectReference;
}
function fromBatchDetachPolicy(input?: BatchDetachPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyReference: fromObjectReference(input["PolicyReference"]),
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchCreateIndex {
  OrderedIndexedAttributeList: AttributeKey[];
  IsUnique: boolean;
  ParentReference?: ObjectReference | null;
  LinkName?: string | null;
  BatchReferenceName?: string | null;
}
function fromBatchCreateIndex(input?: BatchCreateIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OrderedIndexedAttributeList: input["OrderedIndexedAttributeList"]?.map(x => fromAttributeKey(x)),
    IsUnique: input["IsUnique"],
    ParentReference: fromObjectReference(input["ParentReference"]),
    LinkName: input["LinkName"],
    BatchReferenceName: input["BatchReferenceName"],
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchAttachToIndex {
  IndexReference: ObjectReference;
  TargetReference: ObjectReference;
}
function fromBatchAttachToIndex(input?: BatchAttachToIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexReference: fromObjectReference(input["IndexReference"]),
    TargetReference: fromObjectReference(input["TargetReference"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchDetachFromIndex {
  IndexReference: ObjectReference;
  TargetReference: ObjectReference;
}
function fromBatchDetachFromIndex(input?: BatchDetachFromIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexReference: fromObjectReference(input["IndexReference"]),
    TargetReference: fromObjectReference(input["TargetReference"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchAttachTypedLink {
  SourceObjectReference: ObjectReference;
  TargetObjectReference: ObjectReference;
  TypedLinkFacet: TypedLinkSchemaAndFacetName;
  Attributes: AttributeNameAndValue[];
}
function fromBatchAttachTypedLink(input?: BatchAttachTypedLink | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceObjectReference: fromObjectReference(input["SourceObjectReference"]),
    TargetObjectReference: fromObjectReference(input["TargetObjectReference"]),
    TypedLinkFacet: fromTypedLinkSchemaAndFacetName(input["TypedLinkFacet"]),
    Attributes: input["Attributes"]?.map(x => fromAttributeNameAndValue(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchDetachTypedLink {
  TypedLinkSpecifier: TypedLinkSpecifier;
}
function fromBatchDetachTypedLink(input?: BatchDetachTypedLink | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypedLinkSpecifier: fromTypedLinkSpecifier(input["TypedLinkSpecifier"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface BatchUpdateLinkAttributes {
  TypedLinkSpecifier: TypedLinkSpecifier;
  AttributeUpdates: LinkAttributeUpdate[];
}
function fromBatchUpdateLinkAttributes(input?: BatchUpdateLinkAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypedLinkSpecifier: fromTypedLinkSpecifier(input["TypedLinkSpecifier"]),
    AttributeUpdates: input["AttributeUpdates"]?.map(x => fromLinkAttributeUpdate(x)),
  }
}

// refs: 2 - tags: input, named, interface
export interface LinkAttributeUpdate {
  AttributeKey?: AttributeKey | null;
  AttributeAction?: LinkAttributeAction | null;
}
function fromLinkAttributeUpdate(input?: LinkAttributeUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeKey: fromAttributeKey(input["AttributeKey"]),
    AttributeAction: fromLinkAttributeAction(input["AttributeAction"]),
  }
}

// refs: 2 - tags: input, named, interface
export interface LinkAttributeAction {
  AttributeActionType?: UpdateActionType | null;
  AttributeUpdateValue?: TypedAttributeValue | null;
}
function fromLinkAttributeAction(input?: LinkAttributeAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeActionType: input["AttributeActionType"],
    AttributeUpdateValue: fromTypedAttributeValue(input["AttributeUpdateValue"]),
  }
}

// refs: 3 - tags: input, named, interface, output
export interface FacetAttribute {
  Name: string;
  AttributeDefinition?: FacetAttributeDefinition | null;
  AttributeReference?: FacetAttributeReference | null;
  RequiredBehavior?: RequiredAttributeBehavior | null;
}
function fromFacetAttribute(input?: FacetAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    AttributeDefinition: fromFacetAttributeDefinition(input["AttributeDefinition"]),
    AttributeReference: fromFacetAttributeReference(input["AttributeReference"]),
    RequiredBehavior: input["RequiredBehavior"],
  }
}
function toFacetAttribute(root: jsonP.JSONValue): FacetAttribute {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "AttributeDefinition": toFacetAttributeDefinition,
      "AttributeReference": toFacetAttributeReference,
      "RequiredBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<RequiredAttributeBehavior>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface FacetAttributeDefinition {
  Type: FacetAttributeType;
  DefaultValue?: TypedAttributeValue | null;
  IsImmutable?: boolean | null;
  Rules?: { [key: string]: Rule | null | undefined } | null;
}
function fromFacetAttributeDefinition(input?: FacetAttributeDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    DefaultValue: fromTypedAttributeValue(input["DefaultValue"]),
    IsImmutable: input["IsImmutable"],
    Rules: jsonP.serializeMap(input["Rules"], x => fromRule(x)),
  }
}
function toFacetAttributeDefinition(root: jsonP.JSONValue): FacetAttributeDefinition {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<FacetAttributeType>(x),
    },
    optional: {
      "DefaultValue": toTypedAttributeValue,
      "IsImmutable": "b",
      "Rules": x => jsonP.readMap(String, toRule, x),
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type FacetAttributeType =
| "STRING"
| "BINARY"
| "BOOLEAN"
| "NUMBER"
| "DATETIME"
| "VARIANT"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface Rule {
  Type?: RuleType | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
}
function fromRule(input?: Rule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Parameters: input["Parameters"],
  }
}
function toRule(root: jsonP.JSONValue): Rule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<RuleType>(x),
      "Parameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type RuleType =
| "BINARY_LENGTH"
| "NUMBER_COMPARISON"
| "STRING_FROM_SET"
| "STRING_LENGTH"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface FacetAttributeReference {
  TargetFacetName: string;
  TargetAttributeName: string;
}
function fromFacetAttributeReference(input?: FacetAttributeReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetFacetName: input["TargetFacetName"],
    TargetAttributeName: input["TargetAttributeName"],
  }
}
function toFacetAttributeReference(root: jsonP.JSONValue): FacetAttributeReference {
  return jsonP.readObj({
    required: {
      "TargetFacetName": "s",
      "TargetAttributeName": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type RequiredAttributeBehavior =
| "REQUIRED_ALWAYS"
| "NOT_REQUIRED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ObjectType =
| "NODE"
| "LEAF_NODE"
| "POLICY"
| "INDEX"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type FacetStyle =
| "STATIC"
| "DYNAMIC"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TypedLinkFacet {
  Name: string;
  Attributes: TypedLinkAttributeDefinition[];
  IdentityAttributeOrder: string[];
}
function fromTypedLinkFacet(input?: TypedLinkFacet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Attributes: input["Attributes"]?.map(x => fromTypedLinkAttributeDefinition(x)),
    IdentityAttributeOrder: input["IdentityAttributeOrder"],
  }
}

// refs: 3 - tags: input, named, interface, output
export interface TypedLinkAttributeDefinition {
  Name: string;
  Type: FacetAttributeType;
  DefaultValue?: TypedAttributeValue | null;
  IsImmutable?: boolean | null;
  Rules?: { [key: string]: Rule | null | undefined } | null;
  RequiredBehavior: RequiredAttributeBehavior;
}
function fromTypedLinkAttributeDefinition(input?: TypedLinkAttributeDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Type: input["Type"],
    DefaultValue: fromTypedAttributeValue(input["DefaultValue"]),
    IsImmutable: input["IsImmutable"],
    Rules: jsonP.serializeMap(input["Rules"], x => fromRule(x)),
    RequiredBehavior: input["RequiredBehavior"],
  }
}
function toTypedLinkAttributeDefinition(root: jsonP.JSONValue): TypedLinkAttributeDefinition {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<FacetAttributeType>(x),
      "RequiredBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<RequiredAttributeBehavior>(x),
    },
    optional: {
      "DefaultValue": toTypedAttributeValue,
      "IsImmutable": "b",
      "Rules": x => jsonP.readMap(String, toRule, x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type DirectoryState =
| "ENABLED"
| "DISABLED"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface FacetAttributeUpdate {
  Attribute?: FacetAttribute | null;
  Action?: UpdateActionType | null;
}
function fromFacetAttributeUpdate(input?: FacetAttributeUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attribute: fromFacetAttribute(input["Attribute"]),
    Action: input["Action"],
  }
}

// refs: 1 - tags: input, named, interface
export interface TypedLinkFacetAttributeUpdate {
  Attribute: TypedLinkAttributeDefinition;
  Action: UpdateActionType;
}
function fromTypedLinkFacetAttributeUpdate(input?: TypedLinkFacetAttributeUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attribute: fromTypedLinkAttributeDefinition(input["Attribute"]),
    Action: input["Action"],
  }
}

// refs: 1 - tags: output, named, interface
export interface BatchReadOperationResponse {
  SuccessfulResponse?: BatchReadSuccessfulResponse | null;
  ExceptionResponse?: BatchReadException | null;
}
function toBatchReadOperationResponse(root: jsonP.JSONValue): BatchReadOperationResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "SuccessfulResponse": toBatchReadSuccessfulResponse,
      "ExceptionResponse": toBatchReadException,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchReadSuccessfulResponse {
  ListObjectAttributes?: BatchListObjectAttributesResponse | null;
  ListObjectChildren?: BatchListObjectChildrenResponse | null;
  GetObjectInformation?: BatchGetObjectInformationResponse | null;
  GetObjectAttributes?: BatchGetObjectAttributesResponse | null;
  ListAttachedIndices?: BatchListAttachedIndicesResponse | null;
  ListObjectParentPaths?: BatchListObjectParentPathsResponse | null;
  ListObjectPolicies?: BatchListObjectPoliciesResponse | null;
  ListPolicyAttachments?: BatchListPolicyAttachmentsResponse | null;
  LookupPolicy?: BatchLookupPolicyResponse | null;
  ListIndex?: BatchListIndexResponse | null;
  ListOutgoingTypedLinks?: BatchListOutgoingTypedLinksResponse | null;
  ListIncomingTypedLinks?: BatchListIncomingTypedLinksResponse | null;
  GetLinkAttributes?: BatchGetLinkAttributesResponse | null;
  ListObjectParents?: BatchListObjectParentsResponse | null;
}
function toBatchReadSuccessfulResponse(root: jsonP.JSONValue): BatchReadSuccessfulResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ListObjectAttributes": toBatchListObjectAttributesResponse,
      "ListObjectChildren": toBatchListObjectChildrenResponse,
      "GetObjectInformation": toBatchGetObjectInformationResponse,
      "GetObjectAttributes": toBatchGetObjectAttributesResponse,
      "ListAttachedIndices": toBatchListAttachedIndicesResponse,
      "ListObjectParentPaths": toBatchListObjectParentPathsResponse,
      "ListObjectPolicies": toBatchListObjectPoliciesResponse,
      "ListPolicyAttachments": toBatchListPolicyAttachmentsResponse,
      "LookupPolicy": toBatchLookupPolicyResponse,
      "ListIndex": toBatchListIndexResponse,
      "ListOutgoingTypedLinks": toBatchListOutgoingTypedLinksResponse,
      "ListIncomingTypedLinks": toBatchListIncomingTypedLinksResponse,
      "GetLinkAttributes": toBatchGetLinkAttributesResponse,
      "ListObjectParents": toBatchListObjectParentsResponse,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListObjectAttributesResponse {
  Attributes?: AttributeKeyAndValue[] | null;
  NextToken?: string | null;
}
function toBatchListObjectAttributesResponse(root: jsonP.JSONValue): BatchListObjectAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": [toAttributeKeyAndValue],
      "NextToken": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListObjectChildrenResponse {
  Children?: { [key: string]: string | null | undefined } | null;
  NextToken?: string | null;
}
function toBatchListObjectChildrenResponse(root: jsonP.JSONValue): BatchListObjectChildrenResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Children": x => jsonP.readMap(String, String, x),
      "NextToken": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchGetObjectInformationResponse {
  SchemaFacets?: SchemaFacet[] | null;
  ObjectIdentifier?: string | null;
}
function toBatchGetObjectInformationResponse(root: jsonP.JSONValue): BatchGetObjectInformationResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaFacets": [toSchemaFacet],
      "ObjectIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchGetObjectAttributesResponse {
  Attributes?: AttributeKeyAndValue[] | null;
}
function toBatchGetObjectAttributesResponse(root: jsonP.JSONValue): BatchGetObjectAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": [toAttributeKeyAndValue],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListAttachedIndicesResponse {
  IndexAttachments?: IndexAttachment[] | null;
  NextToken?: string | null;
}
function toBatchListAttachedIndicesResponse(root: jsonP.JSONValue): BatchListAttachedIndicesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexAttachments": [toIndexAttachment],
      "NextToken": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface IndexAttachment {
  IndexedAttributes?: AttributeKeyAndValue[] | null;
  ObjectIdentifier?: string | null;
}
function toIndexAttachment(root: jsonP.JSONValue): IndexAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexedAttributes": [toAttributeKeyAndValue],
      "ObjectIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListObjectParentPathsResponse {
  PathToObjectIdentifiersList?: PathToObjectIdentifiers[] | null;
  NextToken?: string | null;
}
function toBatchListObjectParentPathsResponse(root: jsonP.JSONValue): BatchListObjectParentPathsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "PathToObjectIdentifiersList": [toPathToObjectIdentifiers],
      "NextToken": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface PathToObjectIdentifiers {
  Path?: string | null;
  ObjectIdentifiers?: string[] | null;
}
function toPathToObjectIdentifiers(root: jsonP.JSONValue): PathToObjectIdentifiers {
  return jsonP.readObj({
    required: {},
    optional: {
      "Path": "s",
      "ObjectIdentifiers": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListObjectPoliciesResponse {
  AttachedPolicyIds?: string[] | null;
  NextToken?: string | null;
}
function toBatchListObjectPoliciesResponse(root: jsonP.JSONValue): BatchListObjectPoliciesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedPolicyIds": ["s"],
      "NextToken": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListPolicyAttachmentsResponse {
  ObjectIdentifiers?: string[] | null;
  NextToken?: string | null;
}
function toBatchListPolicyAttachmentsResponse(root: jsonP.JSONValue): BatchListPolicyAttachmentsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifiers": ["s"],
      "NextToken": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchLookupPolicyResponse {
  PolicyToPathList?: PolicyToPath[] | null;
  NextToken?: string | null;
}
function toBatchLookupPolicyResponse(root: jsonP.JSONValue): BatchLookupPolicyResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyToPathList": [toPolicyToPath],
      "NextToken": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface PolicyToPath {
  Path?: string | null;
  Policies?: PolicyAttachment[] | null;
}
function toPolicyToPath(root: jsonP.JSONValue): PolicyToPath {
  return jsonP.readObj({
    required: {},
    optional: {
      "Path": "s",
      "Policies": [toPolicyAttachment],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface PolicyAttachment {
  PolicyId?: string | null;
  ObjectIdentifier?: string | null;
  PolicyType?: string | null;
}
function toPolicyAttachment(root: jsonP.JSONValue): PolicyAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyId": "s",
      "ObjectIdentifier": "s",
      "PolicyType": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListIndexResponse {
  IndexAttachments?: IndexAttachment[] | null;
  NextToken?: string | null;
}
function toBatchListIndexResponse(root: jsonP.JSONValue): BatchListIndexResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexAttachments": [toIndexAttachment],
      "NextToken": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListOutgoingTypedLinksResponse {
  TypedLinkSpecifiers?: TypedLinkSpecifier[] | null;
  NextToken?: string | null;
}
function toBatchListOutgoingTypedLinksResponse(root: jsonP.JSONValue): BatchListOutgoingTypedLinksResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "TypedLinkSpecifiers": [toTypedLinkSpecifier],
      "NextToken": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListIncomingTypedLinksResponse {
  LinkSpecifiers?: TypedLinkSpecifier[] | null;
  NextToken?: string | null;
}
function toBatchListIncomingTypedLinksResponse(root: jsonP.JSONValue): BatchListIncomingTypedLinksResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "LinkSpecifiers": [toTypedLinkSpecifier],
      "NextToken": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchGetLinkAttributesResponse {
  Attributes?: AttributeKeyAndValue[] | null;
}
function toBatchGetLinkAttributesResponse(root: jsonP.JSONValue): BatchGetLinkAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": [toAttributeKeyAndValue],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchListObjectParentsResponse {
  ParentLinks?: ObjectIdentifierAndLinkNameTuple[] | null;
  NextToken?: string | null;
}
function toBatchListObjectParentsResponse(root: jsonP.JSONValue): BatchListObjectParentsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParentLinks": [toObjectIdentifierAndLinkNameTuple],
      "NextToken": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ObjectIdentifierAndLinkNameTuple {
  ObjectIdentifier?: string | null;
  LinkName?: string | null;
}
function toObjectIdentifierAndLinkNameTuple(root: jsonP.JSONValue): ObjectIdentifierAndLinkNameTuple {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifier": "s",
      "LinkName": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchReadException {
  Type?: BatchReadExceptionType | null;
  Message?: string | null;
}
function toBatchReadException(root: jsonP.JSONValue): BatchReadException {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<BatchReadExceptionType>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type BatchReadExceptionType =
| "ValidationException"
| "InvalidArnException"
| "ResourceNotFoundException"
| "InvalidNextTokenException"
| "AccessDeniedException"
| "NotNodeException"
| "FacetValidationException"
| "CannotListParentOfRootException"
| "NotIndexException"
| "NotPolicyException"
| "DirectoryNotEnabledException"
| "LimitExceededException"
| "InternalServiceException"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface BatchWriteOperationResponse {
  CreateObject?: BatchCreateObjectResponse | null;
  AttachObject?: BatchAttachObjectResponse | null;
  DetachObject?: BatchDetachObjectResponse | null;
  UpdateObjectAttributes?: BatchUpdateObjectAttributesResponse | null;
  DeleteObject?: BatchDeleteObjectResponse | null;
  AddFacetToObject?: BatchAddFacetToObjectResponse | null;
  RemoveFacetFromObject?: BatchRemoveFacetFromObjectResponse | null;
  AttachPolicy?: BatchAttachPolicyResponse | null;
  DetachPolicy?: BatchDetachPolicyResponse | null;
  CreateIndex?: BatchCreateIndexResponse | null;
  AttachToIndex?: BatchAttachToIndexResponse | null;
  DetachFromIndex?: BatchDetachFromIndexResponse | null;
  AttachTypedLink?: BatchAttachTypedLinkResponse | null;
  DetachTypedLink?: BatchDetachTypedLinkResponse | null;
  UpdateLinkAttributes?: BatchUpdateLinkAttributesResponse | null;
}
function toBatchWriteOperationResponse(root: jsonP.JSONValue): BatchWriteOperationResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreateObject": toBatchCreateObjectResponse,
      "AttachObject": toBatchAttachObjectResponse,
      "DetachObject": toBatchDetachObjectResponse,
      "UpdateObjectAttributes": toBatchUpdateObjectAttributesResponse,
      "DeleteObject": toBatchDeleteObjectResponse,
      "AddFacetToObject": toBatchAddFacetToObjectResponse,
      "RemoveFacetFromObject": toBatchRemoveFacetFromObjectResponse,
      "AttachPolicy": toBatchAttachPolicyResponse,
      "DetachPolicy": toBatchDetachPolicyResponse,
      "CreateIndex": toBatchCreateIndexResponse,
      "AttachToIndex": toBatchAttachToIndexResponse,
      "DetachFromIndex": toBatchDetachFromIndexResponse,
      "AttachTypedLink": toBatchAttachTypedLinkResponse,
      "DetachTypedLink": toBatchDetachTypedLinkResponse,
      "UpdateLinkAttributes": toBatchUpdateLinkAttributesResponse,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchCreateObjectResponse {
  ObjectIdentifier?: string | null;
}
function toBatchCreateObjectResponse(root: jsonP.JSONValue): BatchCreateObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchAttachObjectResponse {
  attachedObjectIdentifier?: string | null;
}
function toBatchAttachObjectResponse(root: jsonP.JSONValue): BatchAttachObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "attachedObjectIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchDetachObjectResponse {
  detachedObjectIdentifier?: string | null;
}
function toBatchDetachObjectResponse(root: jsonP.JSONValue): BatchDetachObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "detachedObjectIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchUpdateObjectAttributesResponse {
  ObjectIdentifier?: string | null;
}
function toBatchUpdateObjectAttributesResponse(root: jsonP.JSONValue): BatchUpdateObjectAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchDeleteObjectResponse {
}
function toBatchDeleteObjectResponse(root: jsonP.JSONValue): BatchDeleteObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchAddFacetToObjectResponse {
}
function toBatchAddFacetToObjectResponse(root: jsonP.JSONValue): BatchAddFacetToObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchRemoveFacetFromObjectResponse {
}
function toBatchRemoveFacetFromObjectResponse(root: jsonP.JSONValue): BatchRemoveFacetFromObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchAttachPolicyResponse {
}
function toBatchAttachPolicyResponse(root: jsonP.JSONValue): BatchAttachPolicyResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchDetachPolicyResponse {
}
function toBatchDetachPolicyResponse(root: jsonP.JSONValue): BatchDetachPolicyResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchCreateIndexResponse {
  ObjectIdentifier?: string | null;
}
function toBatchCreateIndexResponse(root: jsonP.JSONValue): BatchCreateIndexResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchAttachToIndexResponse {
  AttachedObjectIdentifier?: string | null;
}
function toBatchAttachToIndexResponse(root: jsonP.JSONValue): BatchAttachToIndexResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedObjectIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchDetachFromIndexResponse {
  DetachedObjectIdentifier?: string | null;
}
function toBatchDetachFromIndexResponse(root: jsonP.JSONValue): BatchDetachFromIndexResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "DetachedObjectIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchAttachTypedLinkResponse {
  TypedLinkSpecifier?: TypedLinkSpecifier | null;
}
function toBatchAttachTypedLinkResponse(root: jsonP.JSONValue): BatchAttachTypedLinkResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "TypedLinkSpecifier": toTypedLinkSpecifier,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchDetachTypedLinkResponse {
}
function toBatchDetachTypedLinkResponse(root: jsonP.JSONValue): BatchDetachTypedLinkResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchUpdateLinkAttributesResponse {
}
function toBatchUpdateLinkAttributesResponse(root: jsonP.JSONValue): BatchUpdateLinkAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Directory {
  Name?: string | null;
  DirectoryArn?: string | null;
  State?: DirectoryState | null;
  CreationDateTime?: Date | number | null;
}
function toDirectory(root: jsonP.JSONValue): Directory {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "DirectoryArn": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<DirectoryState>(x),
      "CreationDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Facet {
  Name?: string | null;
  ObjectType?: ObjectType | null;
  FacetStyle?: FacetStyle | null;
}
function toFacet(root: jsonP.JSONValue): Facet {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ObjectType": (x: jsonP.JSONValue) => cmnP.readEnum<ObjectType>(x),
      "FacetStyle": (x: jsonP.JSONValue) => cmnP.readEnum<FacetStyle>(x),
    },
  }, root);
}
