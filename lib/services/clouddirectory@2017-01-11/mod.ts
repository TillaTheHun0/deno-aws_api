// Autogenerated API client for: Amazon CloudDirectory

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class CloudDirectory {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudDirectory.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-01-11",
    "endpointPrefix": "clouddirectory",
    "protocol": "rest-json",
    "serviceFullName": "Amazon CloudDirectory",
    "serviceId": "CloudDirectory",
    "signatureVersion": "v4",
    "signingName": "clouddirectory",
    "uid": "clouddirectory-2017-01-11"
  };

  async addFacetToObject(
    {abortSignal, ...params}: RequestConfig & s.AddFacetToObjectRequest,
  ): Promise<s.AddFacetToObjectResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      SchemaFacet: fromSchemaFacet(params["SchemaFacet"]),
      ObjectAttributeList: params["ObjectAttributeList"]?.map(x => fromAttributeKeyAndValue(x)),
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AddFacetToObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/facets",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async applySchema(
    {abortSignal, ...params}: RequestConfig & s.ApplySchemaRequest,
  ): Promise<s.ApplySchemaResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      PublishedSchemaArn: params["PublishedSchemaArn"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ApplySchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/apply",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppliedSchemaArn": "s",
        "DirectoryArn": "s",
      },
    }, await resp.json());
  }

  async attachObject(
    {abortSignal, ...params}: RequestConfig & s.AttachObjectRequest,
  ): Promise<s.AttachObjectResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ParentReference: fromObjectReference(params["ParentReference"]),
      ChildReference: fromObjectReference(params["ChildReference"]),
      LinkName: params["LinkName"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AttachObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/attach",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AttachedObjectIdentifier": "s",
      },
    }, await resp.json());
  }

  async attachPolicy(
    {abortSignal, ...params}: RequestConfig & s.AttachPolicyRequest,
  ): Promise<s.AttachPolicyResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      PolicyReference: fromObjectReference(params["PolicyReference"]),
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AttachPolicy",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/policy/attach",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async attachToIndex(
    {abortSignal, ...params}: RequestConfig & s.AttachToIndexRequest,
  ): Promise<s.AttachToIndexResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      IndexReference: fromObjectReference(params["IndexReference"]),
      TargetReference: fromObjectReference(params["TargetReference"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AttachToIndex",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/index/attach",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AttachedObjectIdentifier": "s",
      },
    }, await resp.json());
  }

  async attachTypedLink(
    {abortSignal, ...params}: RequestConfig & s.AttachTypedLinkRequest,
  ): Promise<s.AttachTypedLinkResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      SourceObjectReference: fromObjectReference(params["SourceObjectReference"]),
      TargetObjectReference: fromObjectReference(params["TargetObjectReference"]),
      TypedLinkFacet: fromTypedLinkSchemaAndFacetName(params["TypedLinkFacet"]),
      Attributes: params["Attributes"]?.map(x => fromAttributeNameAndValue(x)),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AttachTypedLink",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/attach",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TypedLinkSpecifier": toTypedLinkSpecifier,
      },
    }, await resp.json());
  }

  async batchRead(
    {abortSignal, ...params}: RequestConfig & s.BatchReadRequest,
  ): Promise<s.BatchReadResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Operations: params["Operations"]?.map(x => fromBatchReadOperation(x)),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "BatchRead",
      requestUri: "/amazonclouddirectory/2017-01-11/batchread",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": [toBatchReadOperationResponse],
      },
    }, await resp.json());
  }

  async batchWrite(
    {abortSignal, ...params}: RequestConfig & s.BatchWriteRequest,
  ): Promise<s.BatchWriteResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Operations: params["Operations"]?.map(x => fromBatchWriteOperation(x)),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "BatchWrite",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/batchwrite",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": [toBatchWriteOperationResponse],
      },
    }, await resp.json());
  }

  async createDirectory(
    {abortSignal, ...params}: RequestConfig & s.CreateDirectoryRequest,
  ): Promise<s.CreateDirectoryResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateDirectory",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/create",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "DirectoryArn": "s",
        "Name": "s",
        "ObjectIdentifier": "s",
        "AppliedSchemaArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createFacet(
    {abortSignal, ...params}: RequestConfig & s.CreateFacetRequest,
  ): Promise<s.CreateFacetResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Attributes: params["Attributes"]?.map(x => fromFacetAttribute(x)),
      ObjectType: params["ObjectType"],
      FacetStyle: params["FacetStyle"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/facet/create",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createIndex(
    {abortSignal, ...params}: RequestConfig & s.CreateIndexRequest,
  ): Promise<s.CreateIndexResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      OrderedIndexedAttributeList: params["OrderedIndexedAttributeList"]?.map(x => fromAttributeKey(x)),
      IsUnique: params["IsUnique"],
      ParentReference: fromObjectReference(params["ParentReference"]),
      LinkName: params["LinkName"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateIndex",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/index",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ObjectIdentifier": "s",
      },
    }, await resp.json());
  }

  async createObject(
    {abortSignal, ...params}: RequestConfig & s.CreateObjectRequest,
  ): Promise<s.CreateObjectResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      SchemaFacets: params["SchemaFacets"]?.map(x => fromSchemaFacet(x)),
      ObjectAttributeList: params["ObjectAttributeList"]?.map(x => fromAttributeKeyAndValue(x)),
      ParentReference: fromObjectReference(params["ParentReference"]),
      LinkName: params["LinkName"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ObjectIdentifier": "s",
      },
    }, await resp.json());
  }

  async createSchema(
    {abortSignal, ...params}: RequestConfig & s.CreateSchemaRequest,
  ): Promise<s.CreateSchemaResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/create",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
      },
    }, await resp.json());
  }

  async createTypedLinkFacet(
    {abortSignal, ...params}: RequestConfig & s.CreateTypedLinkFacetRequest,
  ): Promise<s.CreateTypedLinkFacetResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Facet: fromTypedLinkFacet(params["Facet"]),
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateTypedLinkFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/create",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDirectory(
    {abortSignal, ...params}: RequestConfig & s.DeleteDirectoryRequest,
  ): Promise<s.DeleteDirectoryResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteDirectory",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/directory",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "DirectoryArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteFacet(
    {abortSignal, ...params}: RequestConfig & s.DeleteFacetRequest,
  ): Promise<s.DeleteFacetResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DeleteFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/facet/delete",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteObject(
    {abortSignal, ...params}: RequestConfig & s.DeleteObjectRequest,
  ): Promise<s.DeleteObjectResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DeleteObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/delete",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteSchema(
    {abortSignal, ...params}: RequestConfig & s.DeleteSchemaRequest,
  ): Promise<s.DeleteSchemaResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
      },
    }, await resp.json());
  }

  async deleteTypedLinkFacet(
    {abortSignal, ...params}: RequestConfig & s.DeleteTypedLinkFacetRequest,
  ): Promise<s.DeleteTypedLinkFacetResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DeleteTypedLinkFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/delete",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async detachFromIndex(
    {abortSignal, ...params}: RequestConfig & s.DetachFromIndexRequest,
  ): Promise<s.DetachFromIndexResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      IndexReference: fromObjectReference(params["IndexReference"]),
      TargetReference: fromObjectReference(params["TargetReference"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DetachFromIndex",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/index/detach",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DetachedObjectIdentifier": "s",
      },
    }, await resp.json());
  }

  async detachObject(
    {abortSignal, ...params}: RequestConfig & s.DetachObjectRequest,
  ): Promise<s.DetachObjectResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ParentReference: fromObjectReference(params["ParentReference"]),
      LinkName: params["LinkName"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DetachObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/detach",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DetachedObjectIdentifier": "s",
      },
    }, await resp.json());
  }

  async detachPolicy(
    {abortSignal, ...params}: RequestConfig & s.DetachPolicyRequest,
  ): Promise<s.DetachPolicyResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      PolicyReference: fromObjectReference(params["PolicyReference"]),
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DetachPolicy",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/policy/detach",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async detachTypedLink(
    {abortSignal, ...params}: RequestConfig & s.DetachTypedLinkRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      TypedLinkSpecifier: fromTypedLinkSpecifier(params["TypedLinkSpecifier"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DetachTypedLink",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/detach",
      responseCode: 200,
    });
  }

  async disableDirectory(
    {abortSignal, ...params}: RequestConfig & s.DisableDirectoryRequest,
  ): Promise<s.DisableDirectoryResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DisableDirectory",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/disable",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "DirectoryArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async enableDirectory(
    {abortSignal, ...params}: RequestConfig & s.EnableDirectoryRequest,
  ): Promise<s.EnableDirectoryResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "EnableDirectory",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/enable",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "DirectoryArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getAppliedSchemaVersion(
    {abortSignal, ...params}: RequestConfig & s.GetAppliedSchemaVersionRequest,
  ): Promise<s.GetAppliedSchemaVersionResponse> {
    const body: jsonP.JSONObject = {
      SchemaArn: params["SchemaArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAppliedSchemaVersion",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/getappliedschema",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppliedSchemaArn": "s",
      },
    }, await resp.json());
  }

  async getDirectory(
    {abortSignal, ...params}: RequestConfig & s.GetDirectoryRequest,
  ): Promise<s.GetDirectoryResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetDirectory",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/get",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "Directory": toDirectory,
      },
      optional: {},
    }, await resp.json());
  }

  async getFacet(
    {abortSignal, ...params}: RequestConfig & s.GetFacetRequest,
  ): Promise<s.GetFacetResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetFacet",
      requestUri: "/amazonclouddirectory/2017-01-11/facet",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Facet": toFacet,
      },
    }, await resp.json());
  }

  async getLinkAttributes(
    {abortSignal, ...params}: RequestConfig & s.GetLinkAttributesRequest,
  ): Promise<s.GetLinkAttributesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      TypedLinkSpecifier: fromTypedLinkSpecifier(params["TypedLinkSpecifier"]),
      AttributeNames: params["AttributeNames"],
      ConsistencyLevel: params["ConsistencyLevel"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetLinkAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/attributes/get",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": [toAttributeKeyAndValue],
      },
    }, await resp.json());
  }

  async getObjectAttributes(
    {abortSignal, ...params}: RequestConfig & s.GetObjectAttributesRequest,
  ): Promise<s.GetObjectAttributesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      SchemaFacet: fromSchemaFacet(params["SchemaFacet"]),
      AttributeNames: params["AttributeNames"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetObjectAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/object/attributes/get",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": [toAttributeKeyAndValue],
      },
    }, await resp.json());
  }

  async getObjectInformation(
    {abortSignal, ...params}: RequestConfig & s.GetObjectInformationRequest,
  ): Promise<s.GetObjectInformationResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetObjectInformation",
      requestUri: "/amazonclouddirectory/2017-01-11/object/information",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaFacets": [toSchemaFacet],
        "ObjectIdentifier": "s",
      },
    }, await resp.json());
  }

  async getSchemaAsJson(
    {abortSignal, ...params}: RequestConfig & s.GetSchemaAsJsonRequest,
  ): Promise<s.GetSchemaAsJsonResponse> {
    const headers = new Headers;
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetSchemaAsJson",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/json",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Document": "s",
      },
    }, await resp.json());
  }

  async getTypedLinkFacetInformation(
    {abortSignal, ...params}: RequestConfig & s.GetTypedLinkFacetInformationRequest,
  ): Promise<s.GetTypedLinkFacetInformationResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "GetTypedLinkFacetInformation",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/get",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "IdentityAttributeOrder": ["s"],
      },
    }, await resp.json());
  }

  async listAppliedSchemaArns(
    {abortSignal, ...params}: RequestConfig & s.ListAppliedSchemaArnsRequest,
  ): Promise<s.ListAppliedSchemaArnsResponse> {
    const body: jsonP.JSONObject = {
      DirectoryArn: params["DirectoryArn"],
      SchemaArn: params["SchemaArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAppliedSchemaArns",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/applied",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArns": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listAttachedIndices(
    {abortSignal, ...params}: RequestConfig & s.ListAttachedIndicesRequest,
  ): Promise<s.ListAttachedIndicesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      TargetReference: fromObjectReference(params["TargetReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListAttachedIndices",
      requestUri: "/amazonclouddirectory/2017-01-11/object/indices",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "IndexAttachments": [toIndexAttachment],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDevelopmentSchemaArns(
    {abortSignal, ...params}: RequestConfig & s.ListDevelopmentSchemaArnsRequest = {},
  ): Promise<s.ListDevelopmentSchemaArnsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDevelopmentSchemaArns",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/development",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArns": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDirectories(
    {abortSignal, ...params}: RequestConfig & s.ListDirectoriesRequest = {},
  ): Promise<s.ListDirectoriesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      state: params["state"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDirectories",
      requestUri: "/amazonclouddirectory/2017-01-11/directory/list",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "Directories": [toDirectory],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listFacetAttributes(
    {abortSignal, ...params}: RequestConfig & s.ListFacetAttributesRequest,
  ): Promise<s.ListFacetAttributesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListFacetAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/facet/attributes",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": [toFacetAttribute],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listFacetNames(
    {abortSignal, ...params}: RequestConfig & s.ListFacetNamesRequest,
  ): Promise<s.ListFacetNamesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListFacetNames",
      requestUri: "/amazonclouddirectory/2017-01-11/facet/list",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FacetNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listIncomingTypedLinks(
    {abortSignal, ...params}: RequestConfig & s.ListIncomingTypedLinksRequest,
  ): Promise<s.ListIncomingTypedLinksResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      FilterAttributeRanges: params["FilterAttributeRanges"]?.map(x => fromTypedLinkAttributeRange(x)),
      FilterTypedLink: fromTypedLinkSchemaAndFacetName(params["FilterTypedLink"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ConsistencyLevel: params["ConsistencyLevel"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListIncomingTypedLinks",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/incoming",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LinkSpecifiers": [toTypedLinkSpecifier],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listIndex(
    {abortSignal, ...params}: RequestConfig & s.ListIndexRequest,
  ): Promise<s.ListIndexResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      RangesOnIndexedValues: params["RangesOnIndexedValues"]?.map(x => fromObjectAttributeRange(x)),
      IndexReference: fromObjectReference(params["IndexReference"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListIndex",
      requestUri: "/amazonclouddirectory/2017-01-11/index/targets",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "IndexAttachments": [toIndexAttachment],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listManagedSchemaArns(
    {abortSignal, ...params}: RequestConfig & s.ListManagedSchemaArnsRequest = {},
  ): Promise<s.ListManagedSchemaArnsResponse> {
    const body: jsonP.JSONObject = {
      SchemaArn: params["SchemaArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListManagedSchemaArns",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/managed",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArns": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listObjectAttributes(
    {abortSignal, ...params}: RequestConfig & s.ListObjectAttributesRequest,
  ): Promise<s.ListObjectAttributesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      FacetFilter: fromSchemaFacet(params["FacetFilter"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/object/attributes",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": [toAttributeKeyAndValue],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listObjectChildren(
    {abortSignal, ...params}: RequestConfig & s.ListObjectChildrenRequest,
  ): Promise<s.ListObjectChildrenResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectChildren",
      requestUri: "/amazonclouddirectory/2017-01-11/object/children",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Children": x => jsonP.readMap(String, String, x),
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listObjectParentPaths(
    {abortSignal, ...params}: RequestConfig & s.ListObjectParentPathsRequest,
  ): Promise<s.ListObjectParentPathsResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectParentPaths",
      requestUri: "/amazonclouddirectory/2017-01-11/object/parentpaths",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PathToObjectIdentifiersList": [toPathToObjectIdentifiers],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listObjectParents(
    {abortSignal, ...params}: RequestConfig & s.ListObjectParentsRequest,
  ): Promise<s.ListObjectParentsResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      IncludeAllLinksToEachParent: params["IncludeAllLinksToEachParent"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectParents",
      requestUri: "/amazonclouddirectory/2017-01-11/object/parent",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Parents": x => jsonP.readMap(String, String, x),
        "NextToken": "s",
        "ParentLinks": [toObjectIdentifierAndLinkNameTuple],
      },
    }, await resp.json());
  }

  async listObjectPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListObjectPoliciesRequest,
  ): Promise<s.ListObjectPoliciesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListObjectPolicies",
      requestUri: "/amazonclouddirectory/2017-01-11/object/policy",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AttachedPolicyIds": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listOutgoingTypedLinks(
    {abortSignal, ...params}: RequestConfig & s.ListOutgoingTypedLinksRequest,
  ): Promise<s.ListOutgoingTypedLinksResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      FilterAttributeRanges: params["FilterAttributeRanges"]?.map(x => fromTypedLinkAttributeRange(x)),
      FilterTypedLink: fromTypedLinkSchemaAndFacetName(params["FilterTypedLink"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ConsistencyLevel: params["ConsistencyLevel"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListOutgoingTypedLinks",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/outgoing",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TypedLinkSpecifiers": [toTypedLinkSpecifier],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPolicyAttachments(
    {abortSignal, ...params}: RequestConfig & s.ListPolicyAttachmentsRequest,
  ): Promise<s.ListPolicyAttachmentsResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      PolicyReference: fromObjectReference(params["PolicyReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    if (params["ConsistencyLevel"] != null) headers.append("x-amz-consistency-level", params["ConsistencyLevel"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListPolicyAttachments",
      requestUri: "/amazonclouddirectory/2017-01-11/policy/attachment",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ObjectIdentifiers": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPublishedSchemaArns(
    {abortSignal, ...params}: RequestConfig & s.ListPublishedSchemaArnsRequest = {},
  ): Promise<s.ListPublishedSchemaArnsResponse> {
    const body: jsonP.JSONObject = {
      SchemaArn: params["SchemaArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPublishedSchemaArns",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/published",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArns": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
      requestUri: "/amazonclouddirectory/2017-01-11/tags",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTypedLinkFacetAttributes(
    {abortSignal, ...params}: RequestConfig & s.ListTypedLinkFacetAttributesRequest,
  ): Promise<s.ListTypedLinkFacetAttributesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListTypedLinkFacetAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/attributes",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": [toTypedLinkAttributeDefinition],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTypedLinkFacetNames(
    {abortSignal, ...params}: RequestConfig & s.ListTypedLinkFacetNamesRequest,
  ): Promise<s.ListTypedLinkFacetNamesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "ListTypedLinkFacetNames",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet/list",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FacetNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async lookupPolicy(
    {abortSignal, ...params}: RequestConfig & s.LookupPolicyRequest,
  ): Promise<s.LookupPolicyResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "LookupPolicy",
      requestUri: "/amazonclouddirectory/2017-01-11/policy/lookup",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyToPathList": [toPolicyToPath],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async publishSchema(
    {abortSignal, ...params}: RequestConfig & s.PublishSchemaRequest,
  ): Promise<s.PublishSchemaResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Version: params["Version"],
      MinorVersion: params["MinorVersion"],
      Name: params["Name"],
    };
    headers.append("x-amz-data-partition", params["DevelopmentSchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PublishSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/publish",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PublishedSchemaArn": "s",
      },
    }, await resp.json());
  }

  async putSchemaFromJson(
    {abortSignal, ...params}: RequestConfig & s.PutSchemaFromJsonRequest,
  ): Promise<s.PutSchemaFromJsonResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Document: params["Document"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutSchemaFromJson",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/json",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
      },
    }, await resp.json());
  }

  async removeFacetFromObject(
    {abortSignal, ...params}: RequestConfig & s.RemoveFacetFromObjectRequest,
  ): Promise<s.RemoveFacetFromObjectResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      SchemaFacet: fromSchemaFacet(params["SchemaFacet"]),
      ObjectReference: fromObjectReference(params["ObjectReference"]),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "RemoveFacetFromObject",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/facets/delete",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/tags/add",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/tags/remove",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateFacet(
    {abortSignal, ...params}: RequestConfig & s.UpdateFacetRequest,
  ): Promise<s.UpdateFacetResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      AttributeUpdates: params["AttributeUpdates"]?.map(x => fromFacetAttributeUpdate(x)),
      ObjectType: params["ObjectType"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/facet",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateLinkAttributes(
    {abortSignal, ...params}: RequestConfig & s.UpdateLinkAttributesRequest,
  ): Promise<s.UpdateLinkAttributesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      TypedLinkSpecifier: fromTypedLinkSpecifier(params["TypedLinkSpecifier"]),
      AttributeUpdates: params["AttributeUpdates"]?.map(x => fromLinkAttributeUpdate(x)),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateLinkAttributes",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/attributes/update",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateObjectAttributes(
    {abortSignal, ...params}: RequestConfig & s.UpdateObjectAttributesRequest,
  ): Promise<s.UpdateObjectAttributesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ObjectReference: fromObjectReference(params["ObjectReference"]),
      AttributeUpdates: params["AttributeUpdates"]?.map(x => fromObjectAttributeUpdate(x)),
    };
    headers.append("x-amz-data-partition", params["DirectoryArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateObjectAttributes",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/object/update",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ObjectIdentifier": "s",
      },
    }, await resp.json());
  }

  async updateSchema(
    {abortSignal, ...params}: RequestConfig & s.UpdateSchemaRequest,
  ): Promise<s.UpdateSchemaResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/update",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
      },
    }, await resp.json());
  }

  async updateTypedLinkFacet(
    {abortSignal, ...params}: RequestConfig & s.UpdateTypedLinkFacetRequest,
  ): Promise<s.UpdateTypedLinkFacetResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      AttributeUpdates: params["AttributeUpdates"]?.map(x => fromTypedLinkFacetAttributeUpdate(x)),
      IdentityAttributeOrder: params["IdentityAttributeOrder"],
    };
    headers.append("x-amz-data-partition", params["SchemaArn"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateTypedLinkFacet",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/typedlink/facet",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async upgradeAppliedSchema(
    {abortSignal, ...params}: RequestConfig & s.UpgradeAppliedSchemaRequest,
  ): Promise<s.UpgradeAppliedSchemaResponse> {
    const body: jsonP.JSONObject = {
      PublishedSchemaArn: params["PublishedSchemaArn"],
      DirectoryArn: params["DirectoryArn"],
      DryRun: params["DryRun"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpgradeAppliedSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/upgradeapplied",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UpgradedSchemaArn": "s",
        "DirectoryArn": "s",
      },
    }, await resp.json());
  }

  async upgradePublishedSchema(
    {abortSignal, ...params}: RequestConfig & s.UpgradePublishedSchemaRequest,
  ): Promise<s.UpgradePublishedSchemaResponse> {
    const body: jsonP.JSONObject = {
      DevelopmentSchemaArn: params["DevelopmentSchemaArn"],
      PublishedSchemaArn: params["PublishedSchemaArn"],
      MinorVersion: params["MinorVersion"],
      DryRun: params["DryRun"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpgradePublishedSchema",
      method: "PUT",
      requestUri: "/amazonclouddirectory/2017-01-11/schema/upgradepublished",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UpgradedSchemaArn": "s",
      },
    }, await resp.json());
  }

}

function fromSchemaFacet(input?: s.SchemaFacet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaArn: input["SchemaArn"],
    FacetName: input["FacetName"],
  }
}
function toSchemaFacet(root: jsonP.JSONValue): s.SchemaFacet {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaArn": "s",
      "FacetName": "s",
    },
  }, root);
}

function fromAttributeKeyAndValue(input?: s.AttributeKeyAndValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: fromAttributeKey(input["Key"]),
    Value: fromTypedAttributeValue(input["Value"]),
  }
}
function toAttributeKeyAndValue(root: jsonP.JSONValue): s.AttributeKeyAndValue {
  return jsonP.readObj({
    required: {
      "Key": toAttributeKey,
      "Value": toTypedAttributeValue,
    },
    optional: {},
  }, root);
}

function fromAttributeKey(input?: s.AttributeKey | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaArn: input["SchemaArn"],
    FacetName: input["FacetName"],
    Name: input["Name"],
  }
}
function toAttributeKey(root: jsonP.JSONValue): s.AttributeKey {
  return jsonP.readObj({
    required: {
      "SchemaArn": "s",
      "FacetName": "s",
      "Name": "s",
    },
    optional: {},
  }, root);
}

function fromTypedAttributeValue(input?: s.TypedAttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StringValue: input["StringValue"],
    BinaryValue: serializeBlob(input["BinaryValue"]),
    BooleanValue: input["BooleanValue"],
    NumberValue: input["NumberValue"],
    DatetimeValue: jsonP.serializeDate_unixTimestamp(input["DatetimeValue"]),
  }
}
function toTypedAttributeValue(root: jsonP.JSONValue): s.TypedAttributeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "StringValue": "s",
      "BinaryValue": "a",
      "BooleanValue": "b",
      "NumberValue": "s",
      "DatetimeValue": "d",
    },
  }, root);
}

function fromObjectReference(input?: s.ObjectReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Selector: input["Selector"],
  }
}
function toObjectReference(root: jsonP.JSONValue): s.ObjectReference {
  return jsonP.readObj({
    required: {},
    optional: {
      "Selector": "s",
    },
  }, root);
}

function fromTypedLinkSchemaAndFacetName(input?: s.TypedLinkSchemaAndFacetName | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaArn: input["SchemaArn"],
    TypedLinkName: input["TypedLinkName"],
  }
}
function toTypedLinkSchemaAndFacetName(root: jsonP.JSONValue): s.TypedLinkSchemaAndFacetName {
  return jsonP.readObj({
    required: {
      "SchemaArn": "s",
      "TypedLinkName": "s",
    },
    optional: {},
  }, root);
}

function fromAttributeNameAndValue(input?: s.AttributeNameAndValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    Value: fromTypedAttributeValue(input["Value"]),
  }
}
function toAttributeNameAndValue(root: jsonP.JSONValue): s.AttributeNameAndValue {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "Value": toTypedAttributeValue,
    },
    optional: {},
  }, root);
}

function fromBatchReadOperation(input?: s.BatchReadOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ListObjectAttributes: fromBatchListObjectAttributes(input["ListObjectAttributes"]),
    ListObjectChildren: fromBatchListObjectChildren(input["ListObjectChildren"]),
    ListAttachedIndices: fromBatchListAttachedIndices(input["ListAttachedIndices"]),
    ListObjectParentPaths: fromBatchListObjectParentPaths(input["ListObjectParentPaths"]),
    GetObjectInformation: fromBatchGetObjectInformation(input["GetObjectInformation"]),
    GetObjectAttributes: fromBatchGetObjectAttributes(input["GetObjectAttributes"]),
    ListObjectParents: fromBatchListObjectParents(input["ListObjectParents"]),
    ListObjectPolicies: fromBatchListObjectPolicies(input["ListObjectPolicies"]),
    ListPolicyAttachments: fromBatchListPolicyAttachments(input["ListPolicyAttachments"]),
    LookupPolicy: fromBatchLookupPolicy(input["LookupPolicy"]),
    ListIndex: fromBatchListIndex(input["ListIndex"]),
    ListOutgoingTypedLinks: fromBatchListOutgoingTypedLinks(input["ListOutgoingTypedLinks"]),
    ListIncomingTypedLinks: fromBatchListIncomingTypedLinks(input["ListIncomingTypedLinks"]),
    GetLinkAttributes: fromBatchGetLinkAttributes(input["GetLinkAttributes"]),
  }
}

function fromBatchListObjectAttributes(input?: s.BatchListObjectAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
    FacetFilter: fromSchemaFacet(input["FacetFilter"]),
  }
}

function fromBatchListObjectChildren(input?: s.BatchListObjectChildren | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

function fromBatchListAttachedIndices(input?: s.BatchListAttachedIndices | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetReference: fromObjectReference(input["TargetReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

function fromBatchListObjectParentPaths(input?: s.BatchListObjectParentPaths | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

function fromBatchGetObjectInformation(input?: s.BatchGetObjectInformation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

function fromBatchGetObjectAttributes(input?: s.BatchGetObjectAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    SchemaFacet: fromSchemaFacet(input["SchemaFacet"]),
    AttributeNames: input["AttributeNames"],
  }
}

function fromBatchListObjectParents(input?: s.BatchListObjectParents | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

function fromBatchListObjectPolicies(input?: s.BatchListObjectPolicies | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

function fromBatchListPolicyAttachments(input?: s.BatchListPolicyAttachments | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyReference: fromObjectReference(input["PolicyReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

function fromBatchLookupPolicy(input?: s.BatchLookupPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

function fromBatchListIndex(input?: s.BatchListIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RangesOnIndexedValues: input["RangesOnIndexedValues"]?.map(x => fromObjectAttributeRange(x)),
    IndexReference: fromObjectReference(input["IndexReference"]),
    MaxResults: input["MaxResults"],
    NextToken: input["NextToken"],
  }
}

function fromObjectAttributeRange(input?: s.ObjectAttributeRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeKey: fromAttributeKey(input["AttributeKey"]),
    Range: fromTypedAttributeValueRange(input["Range"]),
  }
}

function fromTypedAttributeValueRange(input?: s.TypedAttributeValueRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartMode: input["StartMode"],
    StartValue: fromTypedAttributeValue(input["StartValue"]),
    EndMode: input["EndMode"],
    EndValue: fromTypedAttributeValue(input["EndValue"]),
  }
}

function fromBatchListOutgoingTypedLinks(input?: s.BatchListOutgoingTypedLinks | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    FilterAttributeRanges: input["FilterAttributeRanges"]?.map(x => fromTypedLinkAttributeRange(x)),
    FilterTypedLink: fromTypedLinkSchemaAndFacetName(input["FilterTypedLink"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

function fromTypedLinkAttributeRange(input?: s.TypedLinkAttributeRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    Range: fromTypedAttributeValueRange(input["Range"]),
  }
}

function fromBatchListIncomingTypedLinks(input?: s.BatchListIncomingTypedLinks | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    FilterAttributeRanges: input["FilterAttributeRanges"]?.map(x => fromTypedLinkAttributeRange(x)),
    FilterTypedLink: fromTypedLinkSchemaAndFacetName(input["FilterTypedLink"]),
    NextToken: input["NextToken"],
    MaxResults: input["MaxResults"],
  }
}

function fromBatchGetLinkAttributes(input?: s.BatchGetLinkAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypedLinkSpecifier: fromTypedLinkSpecifier(input["TypedLinkSpecifier"]),
    AttributeNames: input["AttributeNames"],
  }
}

function fromTypedLinkSpecifier(input?: s.TypedLinkSpecifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypedLinkFacet: fromTypedLinkSchemaAndFacetName(input["TypedLinkFacet"]),
    SourceObjectReference: fromObjectReference(input["SourceObjectReference"]),
    TargetObjectReference: fromObjectReference(input["TargetObjectReference"]),
    IdentityAttributeValues: input["IdentityAttributeValues"]?.map(x => fromAttributeNameAndValue(x)),
  }
}
function toTypedLinkSpecifier(root: jsonP.JSONValue): s.TypedLinkSpecifier {
  return jsonP.readObj({
    required: {
      "TypedLinkFacet": toTypedLinkSchemaAndFacetName,
      "SourceObjectReference": toObjectReference,
      "TargetObjectReference": toObjectReference,
      "IdentityAttributeValues": [toAttributeNameAndValue],
    },
    optional: {},
  }, root);
}

function fromBatchWriteOperation(input?: s.BatchWriteOperation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CreateObject: fromBatchCreateObject(input["CreateObject"]),
    AttachObject: fromBatchAttachObject(input["AttachObject"]),
    DetachObject: fromBatchDetachObject(input["DetachObject"]),
    UpdateObjectAttributes: fromBatchUpdateObjectAttributes(input["UpdateObjectAttributes"]),
    DeleteObject: fromBatchDeleteObject(input["DeleteObject"]),
    AddFacetToObject: fromBatchAddFacetToObject(input["AddFacetToObject"]),
    RemoveFacetFromObject: fromBatchRemoveFacetFromObject(input["RemoveFacetFromObject"]),
    AttachPolicy: fromBatchAttachPolicy(input["AttachPolicy"]),
    DetachPolicy: fromBatchDetachPolicy(input["DetachPolicy"]),
    CreateIndex: fromBatchCreateIndex(input["CreateIndex"]),
    AttachToIndex: fromBatchAttachToIndex(input["AttachToIndex"]),
    DetachFromIndex: fromBatchDetachFromIndex(input["DetachFromIndex"]),
    AttachTypedLink: fromBatchAttachTypedLink(input["AttachTypedLink"]),
    DetachTypedLink: fromBatchDetachTypedLink(input["DetachTypedLink"]),
    UpdateLinkAttributes: fromBatchUpdateLinkAttributes(input["UpdateLinkAttributes"]),
  }
}

function fromBatchCreateObject(input?: s.BatchCreateObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaFacet: input["SchemaFacet"]?.map(x => fromSchemaFacet(x)),
    ObjectAttributeList: input["ObjectAttributeList"]?.map(x => fromAttributeKeyAndValue(x)),
    ParentReference: fromObjectReference(input["ParentReference"]),
    LinkName: input["LinkName"],
    BatchReferenceName: input["BatchReferenceName"],
  }
}

function fromBatchAttachObject(input?: s.BatchAttachObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParentReference: fromObjectReference(input["ParentReference"]),
    ChildReference: fromObjectReference(input["ChildReference"]),
    LinkName: input["LinkName"],
  }
}

function fromBatchDetachObject(input?: s.BatchDetachObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParentReference: fromObjectReference(input["ParentReference"]),
    LinkName: input["LinkName"],
    BatchReferenceName: input["BatchReferenceName"],
  }
}

function fromBatchUpdateObjectAttributes(input?: s.BatchUpdateObjectAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
    AttributeUpdates: input["AttributeUpdates"]?.map(x => fromObjectAttributeUpdate(x)),
  }
}

function fromObjectAttributeUpdate(input?: s.ObjectAttributeUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectAttributeKey: fromAttributeKey(input["ObjectAttributeKey"]),
    ObjectAttributeAction: fromObjectAttributeAction(input["ObjectAttributeAction"]),
  }
}

function fromObjectAttributeAction(input?: s.ObjectAttributeAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectAttributeActionType: input["ObjectAttributeActionType"],
    ObjectAttributeUpdateValue: fromTypedAttributeValue(input["ObjectAttributeUpdateValue"]),
  }
}

function fromBatchDeleteObject(input?: s.BatchDeleteObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

function fromBatchAddFacetToObject(input?: s.BatchAddFacetToObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaFacet: fromSchemaFacet(input["SchemaFacet"]),
    ObjectAttributeList: input["ObjectAttributeList"]?.map(x => fromAttributeKeyAndValue(x)),
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

function fromBatchRemoveFacetFromObject(input?: s.BatchRemoveFacetFromObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaFacet: fromSchemaFacet(input["SchemaFacet"]),
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

function fromBatchAttachPolicy(input?: s.BatchAttachPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyReference: fromObjectReference(input["PolicyReference"]),
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

function fromBatchDetachPolicy(input?: s.BatchDetachPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyReference: fromObjectReference(input["PolicyReference"]),
    ObjectReference: fromObjectReference(input["ObjectReference"]),
  }
}

function fromBatchCreateIndex(input?: s.BatchCreateIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OrderedIndexedAttributeList: input["OrderedIndexedAttributeList"]?.map(x => fromAttributeKey(x)),
    IsUnique: input["IsUnique"],
    ParentReference: fromObjectReference(input["ParentReference"]),
    LinkName: input["LinkName"],
    BatchReferenceName: input["BatchReferenceName"],
  }
}

function fromBatchAttachToIndex(input?: s.BatchAttachToIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexReference: fromObjectReference(input["IndexReference"]),
    TargetReference: fromObjectReference(input["TargetReference"]),
  }
}

function fromBatchDetachFromIndex(input?: s.BatchDetachFromIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexReference: fromObjectReference(input["IndexReference"]),
    TargetReference: fromObjectReference(input["TargetReference"]),
  }
}

function fromBatchAttachTypedLink(input?: s.BatchAttachTypedLink | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceObjectReference: fromObjectReference(input["SourceObjectReference"]),
    TargetObjectReference: fromObjectReference(input["TargetObjectReference"]),
    TypedLinkFacet: fromTypedLinkSchemaAndFacetName(input["TypedLinkFacet"]),
    Attributes: input["Attributes"]?.map(x => fromAttributeNameAndValue(x)),
  }
}

function fromBatchDetachTypedLink(input?: s.BatchDetachTypedLink | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypedLinkSpecifier: fromTypedLinkSpecifier(input["TypedLinkSpecifier"]),
  }
}

function fromBatchUpdateLinkAttributes(input?: s.BatchUpdateLinkAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypedLinkSpecifier: fromTypedLinkSpecifier(input["TypedLinkSpecifier"]),
    AttributeUpdates: input["AttributeUpdates"]?.map(x => fromLinkAttributeUpdate(x)),
  }
}

function fromLinkAttributeUpdate(input?: s.LinkAttributeUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeKey: fromAttributeKey(input["AttributeKey"]),
    AttributeAction: fromLinkAttributeAction(input["AttributeAction"]),
  }
}

function fromLinkAttributeAction(input?: s.LinkAttributeAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeActionType: input["AttributeActionType"],
    AttributeUpdateValue: fromTypedAttributeValue(input["AttributeUpdateValue"]),
  }
}

function fromFacetAttribute(input?: s.FacetAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    AttributeDefinition: fromFacetAttributeDefinition(input["AttributeDefinition"]),
    AttributeReference: fromFacetAttributeReference(input["AttributeReference"]),
    RequiredBehavior: input["RequiredBehavior"],
  }
}
function toFacetAttribute(root: jsonP.JSONValue): s.FacetAttribute {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "AttributeDefinition": toFacetAttributeDefinition,
      "AttributeReference": toFacetAttributeReference,
      "RequiredBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.RequiredAttributeBehavior>(x),
    },
  }, root);
}

function fromFacetAttributeDefinition(input?: s.FacetAttributeDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    DefaultValue: fromTypedAttributeValue(input["DefaultValue"]),
    IsImmutable: input["IsImmutable"],
    Rules: jsonP.serializeMap(input["Rules"], x => fromRule(x)),
  }
}
function toFacetAttributeDefinition(root: jsonP.JSONValue): s.FacetAttributeDefinition {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.FacetAttributeType>(x),
    },
    optional: {
      "DefaultValue": toTypedAttributeValue,
      "IsImmutable": "b",
      "Rules": x => jsonP.readMap(String, toRule, x),
    },
  }, root);
}

function fromRule(input?: s.Rule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Parameters: input["Parameters"],
  }
}
function toRule(root: jsonP.JSONValue): s.Rule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.RuleType>(x),
      "Parameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromFacetAttributeReference(input?: s.FacetAttributeReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetFacetName: input["TargetFacetName"],
    TargetAttributeName: input["TargetAttributeName"],
  }
}
function toFacetAttributeReference(root: jsonP.JSONValue): s.FacetAttributeReference {
  return jsonP.readObj({
    required: {
      "TargetFacetName": "s",
      "TargetAttributeName": "s",
    },
    optional: {},
  }, root);
}

function fromTypedLinkFacet(input?: s.TypedLinkFacet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Attributes: input["Attributes"]?.map(x => fromTypedLinkAttributeDefinition(x)),
    IdentityAttributeOrder: input["IdentityAttributeOrder"],
  }
}

function fromTypedLinkAttributeDefinition(input?: s.TypedLinkAttributeDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Type: input["Type"],
    DefaultValue: fromTypedAttributeValue(input["DefaultValue"]),
    IsImmutable: input["IsImmutable"],
    Rules: jsonP.serializeMap(input["Rules"], x => fromRule(x)),
    RequiredBehavior: input["RequiredBehavior"],
  }
}
function toTypedLinkAttributeDefinition(root: jsonP.JSONValue): s.TypedLinkAttributeDefinition {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.FacetAttributeType>(x),
      "RequiredBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.RequiredAttributeBehavior>(x),
    },
    optional: {
      "DefaultValue": toTypedAttributeValue,
      "IsImmutable": "b",
      "Rules": x => jsonP.readMap(String, toRule, x),
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromFacetAttributeUpdate(input?: s.FacetAttributeUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attribute: fromFacetAttribute(input["Attribute"]),
    Action: input["Action"],
  }
}

function fromTypedLinkFacetAttributeUpdate(input?: s.TypedLinkFacetAttributeUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attribute: fromTypedLinkAttributeDefinition(input["Attribute"]),
    Action: input["Action"],
  }
}

function toBatchReadOperationResponse(root: jsonP.JSONValue): s.BatchReadOperationResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "SuccessfulResponse": toBatchReadSuccessfulResponse,
      "ExceptionResponse": toBatchReadException,
    },
  }, root);
}

function toBatchReadSuccessfulResponse(root: jsonP.JSONValue): s.BatchReadSuccessfulResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ListObjectAttributes": toBatchListObjectAttributesResponse,
      "ListObjectChildren": toBatchListObjectChildrenResponse,
      "GetObjectInformation": toBatchGetObjectInformationResponse,
      "GetObjectAttributes": toBatchGetObjectAttributesResponse,
      "ListAttachedIndices": toBatchListAttachedIndicesResponse,
      "ListObjectParentPaths": toBatchListObjectParentPathsResponse,
      "ListObjectPolicies": toBatchListObjectPoliciesResponse,
      "ListPolicyAttachments": toBatchListPolicyAttachmentsResponse,
      "LookupPolicy": toBatchLookupPolicyResponse,
      "ListIndex": toBatchListIndexResponse,
      "ListOutgoingTypedLinks": toBatchListOutgoingTypedLinksResponse,
      "ListIncomingTypedLinks": toBatchListIncomingTypedLinksResponse,
      "GetLinkAttributes": toBatchGetLinkAttributesResponse,
      "ListObjectParents": toBatchListObjectParentsResponse,
    },
  }, root);
}

function toBatchListObjectAttributesResponse(root: jsonP.JSONValue): s.BatchListObjectAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": [toAttributeKeyAndValue],
      "NextToken": "s",
    },
  }, root);
}

function toBatchListObjectChildrenResponse(root: jsonP.JSONValue): s.BatchListObjectChildrenResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Children": x => jsonP.readMap(String, String, x),
      "NextToken": "s",
    },
  }, root);
}

function toBatchGetObjectInformationResponse(root: jsonP.JSONValue): s.BatchGetObjectInformationResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaFacets": [toSchemaFacet],
      "ObjectIdentifier": "s",
    },
  }, root);
}

function toBatchGetObjectAttributesResponse(root: jsonP.JSONValue): s.BatchGetObjectAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": [toAttributeKeyAndValue],
    },
  }, root);
}

function toBatchListAttachedIndicesResponse(root: jsonP.JSONValue): s.BatchListAttachedIndicesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexAttachments": [toIndexAttachment],
      "NextToken": "s",
    },
  }, root);
}

function toIndexAttachment(root: jsonP.JSONValue): s.IndexAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexedAttributes": [toAttributeKeyAndValue],
      "ObjectIdentifier": "s",
    },
  }, root);
}

function toBatchListObjectParentPathsResponse(root: jsonP.JSONValue): s.BatchListObjectParentPathsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "PathToObjectIdentifiersList": [toPathToObjectIdentifiers],
      "NextToken": "s",
    },
  }, root);
}

function toPathToObjectIdentifiers(root: jsonP.JSONValue): s.PathToObjectIdentifiers {
  return jsonP.readObj({
    required: {},
    optional: {
      "Path": "s",
      "ObjectIdentifiers": ["s"],
    },
  }, root);
}

function toBatchListObjectPoliciesResponse(root: jsonP.JSONValue): s.BatchListObjectPoliciesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedPolicyIds": ["s"],
      "NextToken": "s",
    },
  }, root);
}

function toBatchListPolicyAttachmentsResponse(root: jsonP.JSONValue): s.BatchListPolicyAttachmentsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifiers": ["s"],
      "NextToken": "s",
    },
  }, root);
}

function toBatchLookupPolicyResponse(root: jsonP.JSONValue): s.BatchLookupPolicyResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyToPathList": [toPolicyToPath],
      "NextToken": "s",
    },
  }, root);
}

function toPolicyToPath(root: jsonP.JSONValue): s.PolicyToPath {
  return jsonP.readObj({
    required: {},
    optional: {
      "Path": "s",
      "Policies": [toPolicyAttachment],
    },
  }, root);
}

function toPolicyAttachment(root: jsonP.JSONValue): s.PolicyAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyId": "s",
      "ObjectIdentifier": "s",
      "PolicyType": "s",
    },
  }, root);
}

function toBatchListIndexResponse(root: jsonP.JSONValue): s.BatchListIndexResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexAttachments": [toIndexAttachment],
      "NextToken": "s",
    },
  }, root);
}

function toBatchListOutgoingTypedLinksResponse(root: jsonP.JSONValue): s.BatchListOutgoingTypedLinksResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "TypedLinkSpecifiers": [toTypedLinkSpecifier],
      "NextToken": "s",
    },
  }, root);
}

function toBatchListIncomingTypedLinksResponse(root: jsonP.JSONValue): s.BatchListIncomingTypedLinksResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "LinkSpecifiers": [toTypedLinkSpecifier],
      "NextToken": "s",
    },
  }, root);
}

function toBatchGetLinkAttributesResponse(root: jsonP.JSONValue): s.BatchGetLinkAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": [toAttributeKeyAndValue],
    },
  }, root);
}

function toBatchListObjectParentsResponse(root: jsonP.JSONValue): s.BatchListObjectParentsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParentLinks": [toObjectIdentifierAndLinkNameTuple],
      "NextToken": "s",
    },
  }, root);
}

function toObjectIdentifierAndLinkNameTuple(root: jsonP.JSONValue): s.ObjectIdentifierAndLinkNameTuple {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifier": "s",
      "LinkName": "s",
    },
  }, root);
}

function toBatchReadException(root: jsonP.JSONValue): s.BatchReadException {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.BatchReadExceptionType>(x),
      "Message": "s",
    },
  }, root);
}

function toBatchWriteOperationResponse(root: jsonP.JSONValue): s.BatchWriteOperationResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreateObject": toBatchCreateObjectResponse,
      "AttachObject": toBatchAttachObjectResponse,
      "DetachObject": toBatchDetachObjectResponse,
      "UpdateObjectAttributes": toBatchUpdateObjectAttributesResponse,
      "DeleteObject": toBatchDeleteObjectResponse,
      "AddFacetToObject": toBatchAddFacetToObjectResponse,
      "RemoveFacetFromObject": toBatchRemoveFacetFromObjectResponse,
      "AttachPolicy": toBatchAttachPolicyResponse,
      "DetachPolicy": toBatchDetachPolicyResponse,
      "CreateIndex": toBatchCreateIndexResponse,
      "AttachToIndex": toBatchAttachToIndexResponse,
      "DetachFromIndex": toBatchDetachFromIndexResponse,
      "AttachTypedLink": toBatchAttachTypedLinkResponse,
      "DetachTypedLink": toBatchDetachTypedLinkResponse,
      "UpdateLinkAttributes": toBatchUpdateLinkAttributesResponse,
    },
  }, root);
}

function toBatchCreateObjectResponse(root: jsonP.JSONValue): s.BatchCreateObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifier": "s",
    },
  }, root);
}

function toBatchAttachObjectResponse(root: jsonP.JSONValue): s.BatchAttachObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "attachedObjectIdentifier": "s",
    },
  }, root);
}

function toBatchDetachObjectResponse(root: jsonP.JSONValue): s.BatchDetachObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "detachedObjectIdentifier": "s",
    },
  }, root);
}

function toBatchUpdateObjectAttributesResponse(root: jsonP.JSONValue): s.BatchUpdateObjectAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifier": "s",
    },
  }, root);
}

function toBatchDeleteObjectResponse(root: jsonP.JSONValue): s.BatchDeleteObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function toBatchAddFacetToObjectResponse(root: jsonP.JSONValue): s.BatchAddFacetToObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function toBatchRemoveFacetFromObjectResponse(root: jsonP.JSONValue): s.BatchRemoveFacetFromObjectResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function toBatchAttachPolicyResponse(root: jsonP.JSONValue): s.BatchAttachPolicyResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function toBatchDetachPolicyResponse(root: jsonP.JSONValue): s.BatchDetachPolicyResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function toBatchCreateIndexResponse(root: jsonP.JSONValue): s.BatchCreateIndexResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ObjectIdentifier": "s",
    },
  }, root);
}

function toBatchAttachToIndexResponse(root: jsonP.JSONValue): s.BatchAttachToIndexResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedObjectIdentifier": "s",
    },
  }, root);
}

function toBatchDetachFromIndexResponse(root: jsonP.JSONValue): s.BatchDetachFromIndexResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "DetachedObjectIdentifier": "s",
    },
  }, root);
}

function toBatchAttachTypedLinkResponse(root: jsonP.JSONValue): s.BatchAttachTypedLinkResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "TypedLinkSpecifier": toTypedLinkSpecifier,
    },
  }, root);
}

function toBatchDetachTypedLinkResponse(root: jsonP.JSONValue): s.BatchDetachTypedLinkResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function toBatchUpdateLinkAttributesResponse(root: jsonP.JSONValue): s.BatchUpdateLinkAttributesResponse {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function toDirectory(root: jsonP.JSONValue): s.Directory {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "DirectoryArn": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectoryState>(x),
      "CreationDateTime": "d",
    },
  }, root);
}

function toFacet(root: jsonP.JSONValue): s.Facet {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ObjectType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObjectType>(x),
      "FacetStyle": (x: jsonP.JSONValue) => cmnP.readEnum<s.FacetStyle>(x),
    },
  }, root);
}
