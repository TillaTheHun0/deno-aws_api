// Autogenerated API client for: Managed Streaming for Kafka

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Kafka {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Kafka.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-11-14",
    "endpointPrefix": "kafka",
    "signingName": "kafka",
    "serviceFullName": "Managed Streaming for Kafka",
    "serviceAbbreviation": "Kafka",
    "serviceId": "Kafka",
    "protocol": "rest-json",
    "jsonVersion": "1.1",
    "uid": "kafka-2018-11-14",
    "signatureVersion": "v4"
  };

  async batchAssociateScramSecret(
    {abortSignal, ...params}: RequestConfig & BatchAssociateScramSecretRequest,
  ): Promise<BatchAssociateScramSecretResponse> {
    const body: jsonP.JSONObject = {
      secretArnList: params["SecretArnList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchAssociateScramSecret",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/scram-secrets`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "UnprocessedScramSecrets": [toUnprocessedScramSecret],
      },
    }, await resp.json());
  }

  async createCluster(
    {abortSignal, ...params}: RequestConfig & CreateClusterRequest,
  ): Promise<CreateClusterResponse> {
    const body: jsonP.JSONObject = {
      brokerNodeGroupInfo: fromBrokerNodeGroupInfo(params["BrokerNodeGroupInfo"]),
      clientAuthentication: fromClientAuthentication(params["ClientAuthentication"]),
      clusterName: params["ClusterName"],
      configurationInfo: fromConfigurationInfo(params["ConfigurationInfo"]),
      encryptionInfo: fromEncryptionInfo(params["EncryptionInfo"]),
      enhancedMonitoring: params["EnhancedMonitoring"],
      openMonitoring: fromOpenMonitoringInfo(params["OpenMonitoring"]),
      kafkaVersion: params["KafkaVersion"],
      loggingInfo: fromLoggingInfo(params["LoggingInfo"]),
      numberOfBrokerNodes: params["NumberOfBrokerNodes"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
      requestUri: "/v1/clusters",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterName": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ClusterState>(x),
      },
    }, await resp.json());
  }

  async createConfiguration(
    {abortSignal, ...params}: RequestConfig & CreateConfigurationRequest,
  ): Promise<CreateConfigurationResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      kafkaVersions: params["KafkaVersions"],
      name: params["Name"],
      serverProperties: jsonP.serializeBlob(params["ServerProperties"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConfiguration",
      requestUri: "/v1/configurations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CreationTime": "d",
        "LatestRevision": toConfigurationRevision,
        "Name": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ConfigurationState>(x),
      },
    }, await resp.json());
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & DeleteClusterRequest,
  ): Promise<DeleteClusterResponse> {
    const query = new URLSearchParams;
    if (params["CurrentVersion"] != null) query.set("currentVersion", params["CurrentVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteCluster",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ClusterState>(x),
      },
    }, await resp.json());
  }

  async deleteConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteConfigurationRequest,
  ): Promise<DeleteConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ConfigurationState>(x),
      },
    }, await resp.json());
  }

  async describeCluster(
    {abortSignal, ...params}: RequestConfig & DescribeClusterRequest,
  ): Promise<DescribeClusterResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeCluster",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterInfo": toClusterInfo,
      },
    }, await resp.json());
  }

  async describeClusterOperation(
    {abortSignal, ...params}: RequestConfig & DescribeClusterOperationRequest,
  ): Promise<DescribeClusterOperationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeClusterOperation",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/operations/${params["ClusterOperationArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterOperationInfo": toClusterOperationInfo,
      },
    }, await resp.json());
  }

  async describeConfiguration(
    {abortSignal, ...params}: RequestConfig & DescribeConfigurationRequest,
  ): Promise<DescribeConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CreationTime": "d",
        "Description": "s",
        "KafkaVersions": ["s"],
        "LatestRevision": toConfigurationRevision,
        "Name": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ConfigurationState>(x),
      },
    }, await resp.json());
  }

  async describeConfigurationRevision(
    {abortSignal, ...params}: RequestConfig & DescribeConfigurationRevisionRequest,
  ): Promise<DescribeConfigurationRevisionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeConfigurationRevision",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}/revisions/${params["Revision"].toString()}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CreationTime": "d",
        "Description": "s",
        "Revision": "n",
        "ServerProperties": "a",
      },
    }, await resp.json());
  }

  async batchDisassociateScramSecret(
    {abortSignal, ...params}: RequestConfig & BatchDisassociateScramSecretRequest,
  ): Promise<BatchDisassociateScramSecretResponse> {
    const body: jsonP.JSONObject = {
      secretArnList: params["SecretArnList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDisassociateScramSecret",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/scram-secrets`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "UnprocessedScramSecrets": [toUnprocessedScramSecret],
      },
    }, await resp.json());
  }

  async getBootstrapBrokers(
    {abortSignal, ...params}: RequestConfig & GetBootstrapBrokersRequest,
  ): Promise<GetBootstrapBrokersResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBootstrapBrokers",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/bootstrap-brokers`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BootstrapBrokerString": "s",
        "BootstrapBrokerStringTls": "s",
        "BootstrapBrokerStringSaslScram": "s",
      },
    }, await resp.json());
  }

  async getCompatibleKafkaVersions(
    {abortSignal, ...params}: RequestConfig & GetCompatibleKafkaVersionsRequest = {},
  ): Promise<GetCompatibleKafkaVersionsResponse> {
    const query = new URLSearchParams;
    if (params["ClusterArn"] != null) query.set("clusterArn", params["ClusterArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetCompatibleKafkaVersions",
      method: "GET",
      requestUri: "/v1/compatible-kafka-versions",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CompatibleKafkaVersions": [toCompatibleKafkaVersion],
      },
    }, await resp.json());
  }

  async listClusterOperations(
    {abortSignal, ...params}: RequestConfig & ListClusterOperationsRequest,
  ): Promise<ListClusterOperationsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListClusterOperations",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/operations`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterOperationInfoList": [toClusterOperationInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listClusters(
    {abortSignal, ...params}: RequestConfig & ListClustersRequest = {},
  ): Promise<ListClustersResponse> {
    const query = new URLSearchParams;
    if (params["ClusterNameFilter"] != null) query.set("clusterNameFilter", params["ClusterNameFilter"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListClusters",
      method: "GET",
      requestUri: "/v1/clusters",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterInfoList": [toClusterInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listConfigurationRevisions(
    {abortSignal, ...params}: RequestConfig & ListConfigurationRevisionsRequest,
  ): Promise<ListConfigurationRevisionsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListConfigurationRevisions",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}/revisions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Revisions": [toConfigurationRevision],
      },
    }, await resp.json());
  }

  async listConfigurations(
    {abortSignal, ...params}: RequestConfig & ListConfigurationsRequest = {},
  ): Promise<ListConfigurationsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListConfigurations",
      method: "GET",
      requestUri: "/v1/configurations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configurations": [toConfiguration],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listKafkaVersions(
    {abortSignal, ...params}: RequestConfig & ListKafkaVersionsRequest = {},
  ): Promise<ListKafkaVersionsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListKafkaVersions",
      method: "GET",
      requestUri: "/v1/kafka-versions",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KafkaVersions": [toKafkaVersion],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listNodes(
    {abortSignal, ...params}: RequestConfig & ListNodesRequest,
  ): Promise<ListNodesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListNodes",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/nodes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NodeInfoList": [toNodeInfo],
      },
    }, await resp.json());
  }

  async listScramSecrets(
    {abortSignal, ...params}: RequestConfig & ListScramSecretsRequest,
  ): Promise<ListScramSecretsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListScramSecrets",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/scram-secrets`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "SecretArnList": ["s"],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async rebootBroker(
    {abortSignal, ...params}: RequestConfig & RebootBrokerRequest,
  ): Promise<RebootBrokerResponse> {
    const body: jsonP.JSONObject = {
      brokerIds: params["BrokerIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootBroker",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/reboot-broker`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/v1/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async updateBrokerCount(
    {abortSignal, ...params}: RequestConfig & UpdateBrokerCountRequest,
  ): Promise<UpdateBrokerCountResponse> {
    const body: jsonP.JSONObject = {
      currentVersion: params["CurrentVersion"],
      targetNumberOfBrokerNodes: params["TargetNumberOfBrokerNodes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBrokerCount",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/nodes/count`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateBrokerType(
    {abortSignal, ...params}: RequestConfig & UpdateBrokerTypeRequest,
  ): Promise<UpdateBrokerTypeResponse> {
    const body: jsonP.JSONObject = {
      currentVersion: params["CurrentVersion"],
      targetInstanceType: params["TargetInstanceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBrokerType",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/nodes/type`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateBrokerStorage(
    {abortSignal, ...params}: RequestConfig & UpdateBrokerStorageRequest,
  ): Promise<UpdateBrokerStorageResponse> {
    const body: jsonP.JSONObject = {
      currentVersion: params["CurrentVersion"],
      targetBrokerEBSVolumeInfo: params["TargetBrokerEBSVolumeInfo"]?.map(x => fromBrokerEBSVolumeInfo(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBrokerStorage",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/nodes/storage`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateConfiguration(
    {abortSignal, ...params}: RequestConfig & UpdateConfigurationRequest,
  ): Promise<UpdateConfigurationResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      serverProperties: jsonP.serializeBlob(params["ServerProperties"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "LatestRevision": toConfigurationRevision,
      },
    }, await resp.json());
  }

  async updateClusterConfiguration(
    {abortSignal, ...params}: RequestConfig & UpdateClusterConfigurationRequest,
  ): Promise<UpdateClusterConfigurationResponse> {
    const body: jsonP.JSONObject = {
      configurationInfo: fromConfigurationInfo(params["ConfigurationInfo"]),
      currentVersion: params["CurrentVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/configuration`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateClusterKafkaVersion(
    {abortSignal, ...params}: RequestConfig & UpdateClusterKafkaVersionRequest,
  ): Promise<UpdateClusterKafkaVersionResponse> {
    const body: jsonP.JSONObject = {
      configurationInfo: fromConfigurationInfo(params["ConfigurationInfo"]),
      currentVersion: params["CurrentVersion"],
      targetKafkaVersion: params["TargetKafkaVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterKafkaVersion",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/version`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateMonitoring(
    {abortSignal, ...params}: RequestConfig & UpdateMonitoringRequest,
  ): Promise<UpdateMonitoringResponse> {
    const body: jsonP.JSONObject = {
      currentVersion: params["CurrentVersion"],
      enhancedMonitoring: params["EnhancedMonitoring"],
      openMonitoring: fromOpenMonitoringInfo(params["OpenMonitoring"]),
      loggingInfo: fromLoggingInfo(params["LoggingInfo"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMonitoring",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/monitoring`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface BatchAssociateScramSecretRequest {
  ClusterArn: string;
  SecretArnList: string[];
}

// refs: 1 - tags: named, input
export interface CreateClusterRequest {
  BrokerNodeGroupInfo: BrokerNodeGroupInfo;
  ClientAuthentication?: ClientAuthentication | null;
  ClusterName: string;
  ConfigurationInfo?: ConfigurationInfo | null;
  EncryptionInfo?: EncryptionInfo | null;
  EnhancedMonitoring?: EnhancedMonitoring | null;
  OpenMonitoring?: OpenMonitoringInfo | null;
  KafkaVersion: string;
  LoggingInfo?: LoggingInfo | null;
  NumberOfBrokerNodes: number;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateConfigurationRequest {
  Description?: string | null;
  KafkaVersions?: string[] | null;
  Name: string;
  ServerProperties: Uint8Array | string;
}

// refs: 1 - tags: named, input
export interface DeleteClusterRequest {
  ClusterArn: string;
  CurrentVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteConfigurationRequest {
  Arn: string;
}

// refs: 1 - tags: named, input
export interface DescribeClusterRequest {
  ClusterArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeClusterOperationRequest {
  ClusterOperationArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeConfigurationRequest {
  Arn: string;
}

// refs: 1 - tags: named, input
export interface DescribeConfigurationRevisionRequest {
  Arn: string;
  Revision: number;
}

// refs: 1 - tags: named, input
export interface BatchDisassociateScramSecretRequest {
  ClusterArn: string;
  SecretArnList: string[];
}

// refs: 1 - tags: named, input
export interface GetBootstrapBrokersRequest {
  ClusterArn: string;
}

// refs: 1 - tags: named, input
export interface GetCompatibleKafkaVersionsRequest {
  ClusterArn?: string | null;
}

// refs: 1 - tags: named, input
export interface ListClusterOperationsRequest {
  ClusterArn: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListClustersRequest {
  ClusterNameFilter?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListConfigurationRevisionsRequest {
  Arn: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListConfigurationsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListKafkaVersionsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListNodesRequest {
  ClusterArn: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListScramSecretsRequest {
  ClusterArn: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface RebootBrokerRequest {
  BrokerIds: string[];
  ClusterArn: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceArn: string;
  Tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateBrokerCountRequest {
  ClusterArn: string;
  CurrentVersion: string;
  TargetNumberOfBrokerNodes: number;
}

// refs: 1 - tags: named, input
export interface UpdateBrokerTypeRequest {
  ClusterArn: string;
  CurrentVersion: string;
  TargetInstanceType: string;
}

// refs: 1 - tags: named, input
export interface UpdateBrokerStorageRequest {
  ClusterArn: string;
  CurrentVersion: string;
  TargetBrokerEBSVolumeInfo: BrokerEBSVolumeInfo[];
}

// refs: 1 - tags: named, input
export interface UpdateConfigurationRequest {
  Arn: string;
  Description?: string | null;
  ServerProperties: Uint8Array | string;
}

// refs: 1 - tags: named, input
export interface UpdateClusterConfigurationRequest {
  ClusterArn: string;
  ConfigurationInfo: ConfigurationInfo;
  CurrentVersion: string;
}

// refs: 1 - tags: named, input
export interface UpdateClusterKafkaVersionRequest {
  ClusterArn: string;
  ConfigurationInfo?: ConfigurationInfo | null;
  CurrentVersion: string;
  TargetKafkaVersion: string;
}

// refs: 1 - tags: named, input
export interface UpdateMonitoringRequest {
  ClusterArn: string;
  CurrentVersion: string;
  EnhancedMonitoring?: EnhancedMonitoring | null;
  OpenMonitoring?: OpenMonitoringInfo | null;
  LoggingInfo?: LoggingInfo | null;
}

// refs: 1 - tags: named, output
export interface BatchAssociateScramSecretResponse {
  ClusterArn?: string | null;
  UnprocessedScramSecrets?: UnprocessedScramSecret[] | null;
}

// refs: 1 - tags: named, output
export interface CreateClusterResponse {
  ClusterArn?: string | null;
  ClusterName?: string | null;
  State?: ClusterState | null;
}

// refs: 1 - tags: named, output
export interface CreateConfigurationResponse {
  Arn?: string | null;
  CreationTime?: Date | number | null;
  LatestRevision?: ConfigurationRevision | null;
  Name?: string | null;
  State?: ConfigurationState | null;
}

// refs: 1 - tags: named, output
export interface DeleteClusterResponse {
  ClusterArn?: string | null;
  State?: ClusterState | null;
}

// refs: 1 - tags: named, output
export interface DeleteConfigurationResponse {
  Arn?: string | null;
  State?: ConfigurationState | null;
}

// refs: 1 - tags: named, output
export interface DescribeClusterResponse {
  ClusterInfo?: ClusterInfo | null;
}

// refs: 1 - tags: named, output
export interface DescribeClusterOperationResponse {
  ClusterOperationInfo?: ClusterOperationInfo | null;
}

// refs: 1 - tags: named, output
export interface DescribeConfigurationResponse {
  Arn?: string | null;
  CreationTime?: Date | number | null;
  Description?: string | null;
  KafkaVersions?: string[] | null;
  LatestRevision?: ConfigurationRevision | null;
  Name?: string | null;
  State?: ConfigurationState | null;
}

// refs: 1 - tags: named, output
export interface DescribeConfigurationRevisionResponse {
  Arn?: string | null;
  CreationTime?: Date | number | null;
  Description?: string | null;
  Revision?: number | null;
  ServerProperties?: Uint8Array | string | null;
}

// refs: 1 - tags: named, output
export interface BatchDisassociateScramSecretResponse {
  ClusterArn?: string | null;
  UnprocessedScramSecrets?: UnprocessedScramSecret[] | null;
}

// refs: 1 - tags: named, output
export interface GetBootstrapBrokersResponse {
  BootstrapBrokerString?: string | null;
  BootstrapBrokerStringTls?: string | null;
  BootstrapBrokerStringSaslScram?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCompatibleKafkaVersionsResponse {
  CompatibleKafkaVersions?: CompatibleKafkaVersion[] | null;
}

// refs: 1 - tags: named, output
export interface ListClusterOperationsResponse {
  ClusterOperationInfoList?: ClusterOperationInfo[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListClustersResponse {
  ClusterInfoList?: ClusterInfo[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListConfigurationRevisionsResponse {
  NextToken?: string | null;
  Revisions?: ConfigurationRevision[] | null;
}

// refs: 1 - tags: named, output
export interface ListConfigurationsResponse {
  Configurations?: Configuration[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListKafkaVersionsResponse {
  KafkaVersions?: KafkaVersion[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListNodesResponse {
  NextToken?: string | null;
  NodeInfoList?: NodeInfo[] | null;
}

// refs: 1 - tags: named, output
export interface ListScramSecretsResponse {
  NextToken?: string | null;
  SecretArnList?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface RebootBrokerResponse {
  ClusterArn?: string | null;
  ClusterOperationArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateBrokerCountResponse {
  ClusterArn?: string | null;
  ClusterOperationArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateBrokerTypeResponse {
  ClusterArn?: string | null;
  ClusterOperationArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateBrokerStorageResponse {
  ClusterArn?: string | null;
  ClusterOperationArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateConfigurationResponse {
  Arn?: string | null;
  LatestRevision?: ConfigurationRevision | null;
}

// refs: 1 - tags: named, output
export interface UpdateClusterConfigurationResponse {
  ClusterArn?: string | null;
  ClusterOperationArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateClusterKafkaVersionResponse {
  ClusterArn?: string | null;
  ClusterOperationArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateMonitoringResponse {
  ClusterArn?: string | null;
  ClusterOperationArn?: string | null;
}

// refs: 3 - tags: input, named, interface, output
export interface BrokerNodeGroupInfo {
  BrokerAZDistribution?: BrokerAZDistribution | null;
  ClientSubnets: string[];
  InstanceType: string;
  SecurityGroups?: string[] | null;
  StorageInfo?: StorageInfo | null;
}
function fromBrokerNodeGroupInfo(input?: BrokerNodeGroupInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    brokerAZDistribution: input["BrokerAZDistribution"],
    clientSubnets: input["ClientSubnets"],
    instanceType: input["InstanceType"],
    securityGroups: input["SecurityGroups"],
    storageInfo: fromStorageInfo(input["StorageInfo"]),
  }
}
function toBrokerNodeGroupInfo(root: jsonP.JSONValue): BrokerNodeGroupInfo {
  return jsonP.readObj({
    required: {
      "ClientSubnets": ["s"],
      "InstanceType": "s",
    },
    optional: {
      "BrokerAZDistribution": (x: jsonP.JSONValue) => cmnP.readEnum<BrokerAZDistribution>(x),
      "SecurityGroups": ["s"],
      "StorageInfo": toStorageInfo,
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type BrokerAZDistribution =
| "DEFAULT"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface StorageInfo {
  EbsStorageInfo?: EBSStorageInfo | null;
}
function fromStorageInfo(input?: StorageInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ebsStorageInfo: fromEBSStorageInfo(input["EbsStorageInfo"]),
  }
}
function toStorageInfo(root: jsonP.JSONValue): StorageInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "EbsStorageInfo": toEBSStorageInfo,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface EBSStorageInfo {
  VolumeSize?: number | null;
}
function fromEBSStorageInfo(input?: EBSStorageInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    volumeSize: input["VolumeSize"],
  }
}
function toEBSStorageInfo(root: jsonP.JSONValue): EBSStorageInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeSize": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ClientAuthentication {
  Sasl?: Sasl | null;
  Tls?: Tls | null;
}
function fromClientAuthentication(input?: ClientAuthentication | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sasl: fromSasl(input["Sasl"]),
    tls: fromTls(input["Tls"]),
  }
}
function toClientAuthentication(root: jsonP.JSONValue): ClientAuthentication {
  return jsonP.readObj({
    required: {},
    optional: {
      "Sasl": toSasl,
      "Tls": toTls,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Sasl {
  Scram?: Scram | null;
}
function fromSasl(input?: Sasl | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scram: fromScram(input["Scram"]),
  }
}
function toSasl(root: jsonP.JSONValue): Sasl {
  return jsonP.readObj({
    required: {},
    optional: {
      "Scram": toScram,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Scram {
  Enabled?: boolean | null;
}
function fromScram(input?: Scram | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["Enabled"],
  }
}
function toScram(root: jsonP.JSONValue): Scram {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Tls {
  CertificateAuthorityArnList?: string[] | null;
}
function fromTls(input?: Tls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateAuthorityArnList: input["CertificateAuthorityArnList"],
  }
}
function toTls(root: jsonP.JSONValue): Tls {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateAuthorityArnList": ["s"],
    },
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface ConfigurationInfo {
  Arn: string;
  Revision: number;
}
function fromConfigurationInfo(input?: ConfigurationInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    arn: input["Arn"],
    revision: input["Revision"],
  }
}
function toConfigurationInfo(root: jsonP.JSONValue): ConfigurationInfo {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "Revision": "n",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface EncryptionInfo {
  EncryptionAtRest?: EncryptionAtRest | null;
  EncryptionInTransit?: EncryptionInTransit | null;
}
function fromEncryptionInfo(input?: EncryptionInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryptionAtRest: fromEncryptionAtRest(input["EncryptionAtRest"]),
    encryptionInTransit: fromEncryptionInTransit(input["EncryptionInTransit"]),
  }
}
function toEncryptionInfo(root: jsonP.JSONValue): EncryptionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionAtRest": toEncryptionAtRest,
      "EncryptionInTransit": toEncryptionInTransit,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface EncryptionAtRest {
  DataVolumeKMSKeyId: string;
}
function fromEncryptionAtRest(input?: EncryptionAtRest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dataVolumeKMSKeyId: input["DataVolumeKMSKeyId"],
  }
}
function toEncryptionAtRest(root: jsonP.JSONValue): EncryptionAtRest {
  return jsonP.readObj({
    required: {
      "DataVolumeKMSKeyId": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface EncryptionInTransit {
  ClientBroker?: ClientBroker | null;
  InCluster?: boolean | null;
}
function fromEncryptionInTransit(input?: EncryptionInTransit | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clientBroker: input["ClientBroker"],
    inCluster: input["InCluster"],
  }
}
function toEncryptionInTransit(root: jsonP.JSONValue): EncryptionInTransit {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClientBroker": (x: jsonP.JSONValue) => cmnP.readEnum<ClientBroker>(x),
      "InCluster": "b",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ClientBroker =
| "TLS"
| "TLS_PLAINTEXT"
| "PLAINTEXT"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, enum, output
export type EnhancedMonitoring =
| "DEFAULT"
| "PER_BROKER"
| "PER_TOPIC_PER_BROKER"
| "PER_TOPIC_PER_PARTITION"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface OpenMonitoringInfo {
  Prometheus: PrometheusInfo;
}
function fromOpenMonitoringInfo(input?: OpenMonitoringInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    prometheus: fromPrometheusInfo(input["Prometheus"]),
  }
}

// refs: 2 - tags: input, named, interface
export interface PrometheusInfo {
  JmxExporter?: JmxExporterInfo | null;
  NodeExporter?: NodeExporterInfo | null;
}
function fromPrometheusInfo(input?: PrometheusInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    jmxExporter: fromJmxExporterInfo(input["JmxExporter"]),
    nodeExporter: fromNodeExporterInfo(input["NodeExporter"]),
  }
}

// refs: 2 - tags: input, named, interface
export interface JmxExporterInfo {
  EnabledInBroker: boolean;
}
function fromJmxExporterInfo(input?: JmxExporterInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabledInBroker: input["EnabledInBroker"],
  }
}

// refs: 2 - tags: input, named, interface
export interface NodeExporterInfo {
  EnabledInBroker: boolean;
}
function fromNodeExporterInfo(input?: NodeExporterInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabledInBroker: input["EnabledInBroker"],
  }
}

// refs: 8 - tags: input, named, interface, output
export interface LoggingInfo {
  BrokerLogs: BrokerLogs;
}
function fromLoggingInfo(input?: LoggingInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    brokerLogs: fromBrokerLogs(input["BrokerLogs"]),
  }
}
function toLoggingInfo(root: jsonP.JSONValue): LoggingInfo {
  return jsonP.readObj({
    required: {
      "BrokerLogs": toBrokerLogs,
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface BrokerLogs {
  CloudWatchLogs?: CloudWatchLogs | null;
  Firehose?: Firehose | null;
  S3?: S3 | null;
}
function fromBrokerLogs(input?: BrokerLogs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cloudWatchLogs: fromCloudWatchLogs(input["CloudWatchLogs"]),
    firehose: fromFirehose(input["Firehose"]),
    s3: fromS3(input["S3"]),
  }
}
function toBrokerLogs(root: jsonP.JSONValue): BrokerLogs {
  return jsonP.readObj({
    required: {},
    optional: {
      "CloudWatchLogs": toCloudWatchLogs,
      "Firehose": toFirehose,
      "S3": toS3,
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface CloudWatchLogs {
  Enabled: boolean;
  LogGroup?: string | null;
}
function fromCloudWatchLogs(input?: CloudWatchLogs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["Enabled"],
    logGroup: input["LogGroup"],
  }
}
function toCloudWatchLogs(root: jsonP.JSONValue): CloudWatchLogs {
  return jsonP.readObj({
    required: {
      "Enabled": "b",
    },
    optional: {
      "LogGroup": "s",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface Firehose {
  DeliveryStream?: string | null;
  Enabled: boolean;
}
function fromFirehose(input?: Firehose | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deliveryStream: input["DeliveryStream"],
    enabled: input["Enabled"],
  }
}
function toFirehose(root: jsonP.JSONValue): Firehose {
  return jsonP.readObj({
    required: {
      "Enabled": "b",
    },
    optional: {
      "DeliveryStream": "s",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface S3 {
  Bucket?: string | null;
  Enabled: boolean;
  Prefix?: string | null;
}
function fromS3(input?: S3 | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["Bucket"],
    enabled: input["Enabled"],
    prefix: input["Prefix"],
  }
}
function toS3(root: jsonP.JSONValue): S3 {
  return jsonP.readObj({
    required: {
      "Enabled": "b",
    },
    optional: {
      "Bucket": "s",
      "Prefix": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface BrokerEBSVolumeInfo {
  KafkaBrokerNodeId: string;
  VolumeSizeGB: number;
}
function fromBrokerEBSVolumeInfo(input?: BrokerEBSVolumeInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    kafkaBrokerNodeId: input["KafkaBrokerNodeId"],
    volumeSizeGB: input["VolumeSizeGB"],
  }
}
function toBrokerEBSVolumeInfo(root: jsonP.JSONValue): BrokerEBSVolumeInfo {
  return jsonP.readObj({
    required: {
      "KafkaBrokerNodeId": "s",
      "VolumeSizeGB": "n",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface UnprocessedScramSecret {
  ErrorCode?: string | null;
  ErrorMessage?: string | null;
  SecretArn?: string | null;
}
function toUnprocessedScramSecret(root: jsonP.JSONValue): UnprocessedScramSecret {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorMessage": "s",
      "SecretArn": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type ClusterState =
| "ACTIVE"
| "CREATING"
| "DELETING"
| "FAILED"
| "HEALING"
| "MAINTENANCE"
| "REBOOTING_BROKER"
| "UPDATING"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, interface
export interface ConfigurationRevision {
  CreationTime: Date | number;
  Description?: string | null;
  Revision: number;
}
function toConfigurationRevision(root: jsonP.JSONValue): ConfigurationRevision {
  return jsonP.readObj({
    required: {
      "CreationTime": "d",
      "Revision": "n",
    },
    optional: {
      "Description": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type ConfigurationState =
| "ACTIVE"
| "DELETING"
| "DELETE_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ClusterInfo {
  ActiveOperationArn?: string | null;
  BrokerNodeGroupInfo?: BrokerNodeGroupInfo | null;
  ClientAuthentication?: ClientAuthentication | null;
  ClusterArn?: string | null;
  ClusterName?: string | null;
  CreationTime?: Date | number | null;
  CurrentBrokerSoftwareInfo?: BrokerSoftwareInfo | null;
  CurrentVersion?: string | null;
  EncryptionInfo?: EncryptionInfo | null;
  EnhancedMonitoring?: EnhancedMonitoring | null;
  OpenMonitoring?: OpenMonitoring | null;
  LoggingInfo?: LoggingInfo | null;
  NumberOfBrokerNodes?: number | null;
  State?: ClusterState | null;
  StateInfo?: StateInfo | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  ZookeeperConnectString?: string | null;
  ZookeeperConnectStringTls?: string | null;
}
function toClusterInfo(root: jsonP.JSONValue): ClusterInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveOperationArn": "s",
      "BrokerNodeGroupInfo": toBrokerNodeGroupInfo,
      "ClientAuthentication": toClientAuthentication,
      "ClusterArn": "s",
      "ClusterName": "s",
      "CreationTime": "d",
      "CurrentBrokerSoftwareInfo": toBrokerSoftwareInfo,
      "CurrentVersion": "s",
      "EncryptionInfo": toEncryptionInfo,
      "EnhancedMonitoring": (x: jsonP.JSONValue) => cmnP.readEnum<EnhancedMonitoring>(x),
      "OpenMonitoring": toOpenMonitoring,
      "LoggingInfo": toLoggingInfo,
      "NumberOfBrokerNodes": "n",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<ClusterState>(x),
      "StateInfo": toStateInfo,
      "Tags": x => jsonP.readMap(String, String, x),
      "ZookeeperConnectString": "s",
      "ZookeeperConnectStringTls": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface BrokerSoftwareInfo {
  ConfigurationArn?: string | null;
  ConfigurationRevision?: number | null;
  KafkaVersion?: string | null;
}
function toBrokerSoftwareInfo(root: jsonP.JSONValue): BrokerSoftwareInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConfigurationArn": "s",
      "ConfigurationRevision": "n",
      "KafkaVersion": "s",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface OpenMonitoring {
  Prometheus: Prometheus;
}
function toOpenMonitoring(root: jsonP.JSONValue): OpenMonitoring {
  return jsonP.readObj({
    required: {
      "Prometheus": toPrometheus,
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface Prometheus {
  JmxExporter?: JmxExporter | null;
  NodeExporter?: NodeExporter | null;
}
function toPrometheus(root: jsonP.JSONValue): Prometheus {
  return jsonP.readObj({
    required: {},
    optional: {
      "JmxExporter": toJmxExporter,
      "NodeExporter": toNodeExporter,
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface JmxExporter {
  EnabledInBroker: boolean;
}
function toJmxExporter(root: jsonP.JSONValue): JmxExporter {
  return jsonP.readObj({
    required: {
      "EnabledInBroker": "b",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface NodeExporter {
  EnabledInBroker: boolean;
}
function toNodeExporter(root: jsonP.JSONValue): NodeExporter {
  return jsonP.readObj({
    required: {
      "EnabledInBroker": "b",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface StateInfo {
  Code?: string | null;
  Message?: string | null;
}
function toStateInfo(root: jsonP.JSONValue): StateInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ClusterOperationInfo {
  ClientRequestId?: string | null;
  ClusterArn?: string | null;
  CreationTime?: Date | number | null;
  EndTime?: Date | number | null;
  ErrorInfo?: ErrorInfo | null;
  OperationArn?: string | null;
  OperationState?: string | null;
  OperationSteps?: ClusterOperationStep[] | null;
  OperationType?: string | null;
  SourceClusterInfo?: MutableClusterInfo | null;
  TargetClusterInfo?: MutableClusterInfo | null;
}
function toClusterOperationInfo(root: jsonP.JSONValue): ClusterOperationInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClientRequestId": "s",
      "ClusterArn": "s",
      "CreationTime": "d",
      "EndTime": "d",
      "ErrorInfo": toErrorInfo,
      "OperationArn": "s",
      "OperationState": "s",
      "OperationSteps": [toClusterOperationStep],
      "OperationType": "s",
      "SourceClusterInfo": toMutableClusterInfo,
      "TargetClusterInfo": toMutableClusterInfo,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ErrorInfo {
  ErrorCode?: string | null;
  ErrorString?: string | null;
}
function toErrorInfo(root: jsonP.JSONValue): ErrorInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorString": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ClusterOperationStep {
  StepInfo?: ClusterOperationStepInfo | null;
  StepName?: string | null;
}
function toClusterOperationStep(root: jsonP.JSONValue): ClusterOperationStep {
  return jsonP.readObj({
    required: {},
    optional: {
      "StepInfo": toClusterOperationStepInfo,
      "StepName": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ClusterOperationStepInfo {
  StepStatus?: string | null;
}
function toClusterOperationStepInfo(root: jsonP.JSONValue): ClusterOperationStepInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "StepStatus": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface MutableClusterInfo {
  BrokerEBSVolumeInfo?: BrokerEBSVolumeInfo[] | null;
  ConfigurationInfo?: ConfigurationInfo | null;
  NumberOfBrokerNodes?: number | null;
  EnhancedMonitoring?: EnhancedMonitoring | null;
  OpenMonitoring?: OpenMonitoring | null;
  KafkaVersion?: string | null;
  LoggingInfo?: LoggingInfo | null;
  InstanceType?: string | null;
}
function toMutableClusterInfo(root: jsonP.JSONValue): MutableClusterInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "BrokerEBSVolumeInfo": [toBrokerEBSVolumeInfo],
      "ConfigurationInfo": toConfigurationInfo,
      "NumberOfBrokerNodes": "n",
      "EnhancedMonitoring": (x: jsonP.JSONValue) => cmnP.readEnum<EnhancedMonitoring>(x),
      "OpenMonitoring": toOpenMonitoring,
      "KafkaVersion": "s",
      "LoggingInfo": toLoggingInfo,
      "InstanceType": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CompatibleKafkaVersion {
  SourceVersion?: string | null;
  TargetVersions?: string[] | null;
}
function toCompatibleKafkaVersion(root: jsonP.JSONValue): CompatibleKafkaVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceVersion": "s",
      "TargetVersions": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Configuration {
  Arn: string;
  CreationTime: Date | number;
  Description: string;
  KafkaVersions: string[];
  LatestRevision: ConfigurationRevision;
  Name: string;
  State: ConfigurationState;
}
function toConfiguration(root: jsonP.JSONValue): Configuration {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "CreationTime": "d",
      "Description": "s",
      "KafkaVersions": ["s"],
      "LatestRevision": toConfigurationRevision,
      "Name": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<ConfigurationState>(x),
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface KafkaVersion {
  Version?: string | null;
  Status?: KafkaVersionStatus | null;
}
function toKafkaVersion(root: jsonP.JSONValue): KafkaVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Version": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<KafkaVersionStatus>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type KafkaVersionStatus =
| "ACTIVE"
| "DEPRECATED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface NodeInfo {
  AddedToClusterTime?: string | null;
  BrokerNodeInfo?: BrokerNodeInfo | null;
  InstanceType?: string | null;
  NodeARN?: string | null;
  NodeType?: NodeType | null;
  ZookeeperNodeInfo?: ZookeeperNodeInfo | null;
}
function toNodeInfo(root: jsonP.JSONValue): NodeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AddedToClusterTime": "s",
      "BrokerNodeInfo": toBrokerNodeInfo,
      "InstanceType": "s",
      "NodeARN": "s",
      "NodeType": (x: jsonP.JSONValue) => cmnP.readEnum<NodeType>(x),
      "ZookeeperNodeInfo": toZookeeperNodeInfo,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BrokerNodeInfo {
  AttachedENIId?: string | null;
  BrokerId?: number | null;
  ClientSubnet?: string | null;
  ClientVpcIpAddress?: string | null;
  CurrentBrokerSoftwareInfo?: BrokerSoftwareInfo | null;
  Endpoints?: string[] | null;
}
function toBrokerNodeInfo(root: jsonP.JSONValue): BrokerNodeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedENIId": "s",
      "BrokerId": "n",
      "ClientSubnet": "s",
      "ClientVpcIpAddress": "s",
      "CurrentBrokerSoftwareInfo": toBrokerSoftwareInfo,
      "Endpoints": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type NodeType =
| "BROKER"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ZookeeperNodeInfo {
  AttachedENIId?: string | null;
  ClientVpcIpAddress?: string | null;
  Endpoints?: string[] | null;
  ZookeeperId?: number | null;
  ZookeeperVersion?: string | null;
}
function toZookeeperNodeInfo(root: jsonP.JSONValue): ZookeeperNodeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedENIId": "s",
      "ClientVpcIpAddress": "s",
      "Endpoints": ["s"],
      "ZookeeperId": "n",
      "ZookeeperVersion": "s",
    },
  }, root);
}
