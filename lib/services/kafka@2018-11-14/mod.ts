// Autogenerated API client for: Managed Streaming for Kafka

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class Kafka {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Kafka.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-11-14",
    "endpointPrefix": "kafka",
    "signingName": "kafka",
    "serviceFullName": "Managed Streaming for Kafka",
    "serviceAbbreviation": "Kafka",
    "serviceId": "Kafka",
    "protocol": "rest-json",
    "jsonVersion": "1.1",
    "uid": "kafka-2018-11-14",
    "signatureVersion": "v4"
  };

  async batchAssociateScramSecret(
    {abortSignal, ...params}: RequestConfig & s.BatchAssociateScramSecretRequest,
  ): Promise<s.BatchAssociateScramSecretResponse> {
    const body: jsonP.JSONObject = {
      secretArnList: params["SecretArnList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchAssociateScramSecret",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/scram-secrets`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "UnprocessedScramSecrets": [toUnprocessedScramSecret],
      },
    }, await resp.json());
  }

  async createCluster(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterRequest,
  ): Promise<s.CreateClusterResponse> {
    const body: jsonP.JSONObject = {
      brokerNodeGroupInfo: fromBrokerNodeGroupInfo(params["BrokerNodeGroupInfo"]),
      clientAuthentication: fromClientAuthentication(params["ClientAuthentication"]),
      clusterName: params["ClusterName"],
      configurationInfo: fromConfigurationInfo(params["ConfigurationInfo"]),
      encryptionInfo: fromEncryptionInfo(params["EncryptionInfo"]),
      enhancedMonitoring: params["EnhancedMonitoring"],
      openMonitoring: fromOpenMonitoringInfo(params["OpenMonitoring"]),
      kafkaVersion: params["KafkaVersion"],
      loggingInfo: fromLoggingInfo(params["LoggingInfo"]),
      numberOfBrokerNodes: params["NumberOfBrokerNodes"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
      requestUri: "/v1/clusters",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterName": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClusterState>(x),
      },
    }, await resp.json());
  }

  async createConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateConfigurationRequest,
  ): Promise<s.CreateConfigurationResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      kafkaVersions: params["KafkaVersions"],
      name: params["Name"],
      serverProperties: serializeBlob(params["ServerProperties"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConfiguration",
      requestUri: "/v1/configurations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CreationTime": "d",
        "LatestRevision": toConfigurationRevision,
        "Name": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConfigurationState>(x),
      },
    }, await resp.json());
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterRequest,
  ): Promise<s.DeleteClusterResponse> {
    const query = new URLSearchParams;
    if (params["CurrentVersion"] != null) query.set("currentVersion", params["CurrentVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteCluster",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClusterState>(x),
      },
    }, await resp.json());
  }

  async deleteConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteConfigurationRequest,
  ): Promise<s.DeleteConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConfigurationState>(x),
      },
    }, await resp.json());
  }

  async describeCluster(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterRequest,
  ): Promise<s.DescribeClusterResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeCluster",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterInfo": toClusterInfo,
      },
    }, await resp.json());
  }

  async describeClusterOperation(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterOperationRequest,
  ): Promise<s.DescribeClusterOperationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeClusterOperation",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/operations/${params["ClusterOperationArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterOperationInfo": toClusterOperationInfo,
      },
    }, await resp.json());
  }

  async describeConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DescribeConfigurationRequest,
  ): Promise<s.DescribeConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CreationTime": "d",
        "Description": "s",
        "KafkaVersions": ["s"],
        "LatestRevision": toConfigurationRevision,
        "Name": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConfigurationState>(x),
      },
    }, await resp.json());
  }

  async describeConfigurationRevision(
    {abortSignal, ...params}: RequestConfig & s.DescribeConfigurationRevisionRequest,
  ): Promise<s.DescribeConfigurationRevisionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeConfigurationRevision",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}/revisions/${params["Revision"].toString()}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CreationTime": "d",
        "Description": "s",
        "Revision": "n",
        "ServerProperties": "a",
      },
    }, await resp.json());
  }

  async batchDisassociateScramSecret(
    {abortSignal, ...params}: RequestConfig & s.BatchDisassociateScramSecretRequest,
  ): Promise<s.BatchDisassociateScramSecretResponse> {
    const body: jsonP.JSONObject = {
      secretArnList: params["SecretArnList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDisassociateScramSecret",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/scram-secrets`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "UnprocessedScramSecrets": [toUnprocessedScramSecret],
      },
    }, await resp.json());
  }

  async getBootstrapBrokers(
    {abortSignal, ...params}: RequestConfig & s.GetBootstrapBrokersRequest,
  ): Promise<s.GetBootstrapBrokersResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBootstrapBrokers",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/bootstrap-brokers`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BootstrapBrokerString": "s",
        "BootstrapBrokerStringTls": "s",
        "BootstrapBrokerStringSaslScram": "s",
      },
    }, await resp.json());
  }

  async getCompatibleKafkaVersions(
    {abortSignal, ...params}: RequestConfig & s.GetCompatibleKafkaVersionsRequest = {},
  ): Promise<s.GetCompatibleKafkaVersionsResponse> {
    const query = new URLSearchParams;
    if (params["ClusterArn"] != null) query.set("clusterArn", params["ClusterArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetCompatibleKafkaVersions",
      method: "GET",
      requestUri: "/v1/compatible-kafka-versions",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CompatibleKafkaVersions": [toCompatibleKafkaVersion],
      },
    }, await resp.json());
  }

  async listClusterOperations(
    {abortSignal, ...params}: RequestConfig & s.ListClusterOperationsRequest,
  ): Promise<s.ListClusterOperationsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListClusterOperations",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/operations`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterOperationInfoList": [toClusterOperationInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listClusters(
    {abortSignal, ...params}: RequestConfig & s.ListClustersRequest = {},
  ): Promise<s.ListClustersResponse> {
    const query = new URLSearchParams;
    if (params["ClusterNameFilter"] != null) query.set("clusterNameFilter", params["ClusterNameFilter"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListClusters",
      method: "GET",
      requestUri: "/v1/clusters",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterInfoList": [toClusterInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listConfigurationRevisions(
    {abortSignal, ...params}: RequestConfig & s.ListConfigurationRevisionsRequest,
  ): Promise<s.ListConfigurationRevisionsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListConfigurationRevisions",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}/revisions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Revisions": [toConfigurationRevision],
      },
    }, await resp.json());
  }

  async listConfigurations(
    {abortSignal, ...params}: RequestConfig & s.ListConfigurationsRequest = {},
  ): Promise<s.ListConfigurationsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListConfigurations",
      method: "GET",
      requestUri: "/v1/configurations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configurations": [toConfiguration],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listKafkaVersions(
    {abortSignal, ...params}: RequestConfig & s.ListKafkaVersionsRequest = {},
  ): Promise<s.ListKafkaVersionsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListKafkaVersions",
      method: "GET",
      requestUri: "/v1/kafka-versions",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KafkaVersions": [toKafkaVersion],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listNodes(
    {abortSignal, ...params}: RequestConfig & s.ListNodesRequest,
  ): Promise<s.ListNodesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListNodes",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/nodes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NodeInfoList": [toNodeInfo],
      },
    }, await resp.json());
  }

  async listScramSecrets(
    {abortSignal, ...params}: RequestConfig & s.ListScramSecretsRequest,
  ): Promise<s.ListScramSecretsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListScramSecrets",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/scram-secrets`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "SecretArnList": ["s"],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async rebootBroker(
    {abortSignal, ...params}: RequestConfig & s.RebootBrokerRequest,
  ): Promise<s.RebootBrokerResponse> {
    const body: jsonP.JSONObject = {
      brokerIds: params["BrokerIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootBroker",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/reboot-broker`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/v1/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
    await resp.text();
  }

  async updateBrokerCount(
    {abortSignal, ...params}: RequestConfig & s.UpdateBrokerCountRequest,
  ): Promise<s.UpdateBrokerCountResponse> {
    const body: jsonP.JSONObject = {
      currentVersion: params["CurrentVersion"],
      targetNumberOfBrokerNodes: params["TargetNumberOfBrokerNodes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBrokerCount",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/nodes/count`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateBrokerType(
    {abortSignal, ...params}: RequestConfig & s.UpdateBrokerTypeRequest,
  ): Promise<s.UpdateBrokerTypeResponse> {
    const body: jsonP.JSONObject = {
      currentVersion: params["CurrentVersion"],
      targetInstanceType: params["TargetInstanceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBrokerType",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/nodes/type`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateBrokerStorage(
    {abortSignal, ...params}: RequestConfig & s.UpdateBrokerStorageRequest,
  ): Promise<s.UpdateBrokerStorageResponse> {
    const body: jsonP.JSONObject = {
      currentVersion: params["CurrentVersion"],
      targetBrokerEBSVolumeInfo: params["TargetBrokerEBSVolumeInfo"]?.map(x => fromBrokerEBSVolumeInfo(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBrokerStorage",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/nodes/storage`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateConfigurationRequest,
  ): Promise<s.UpdateConfigurationResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      serverProperties: serializeBlob(params["ServerProperties"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/configurations/${params["Arn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "LatestRevision": toConfigurationRevision,
      },
    }, await resp.json());
  }

  async updateClusterConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateClusterConfigurationRequest,
  ): Promise<s.UpdateClusterConfigurationResponse> {
    const body: jsonP.JSONObject = {
      configurationInfo: fromConfigurationInfo(params["ConfigurationInfo"]),
      currentVersion: params["CurrentVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/configuration`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateClusterKafkaVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateClusterKafkaVersionRequest,
  ): Promise<s.UpdateClusterKafkaVersionResponse> {
    const body: jsonP.JSONObject = {
      configurationInfo: fromConfigurationInfo(params["ConfigurationInfo"]),
      currentVersion: params["CurrentVersion"],
      targetKafkaVersion: params["TargetKafkaVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterKafkaVersion",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/version`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

  async updateMonitoring(
    {abortSignal, ...params}: RequestConfig & s.UpdateMonitoringRequest,
  ): Promise<s.UpdateMonitoringResponse> {
    const body: jsonP.JSONObject = {
      currentVersion: params["CurrentVersion"],
      enhancedMonitoring: params["EnhancedMonitoring"],
      openMonitoring: fromOpenMonitoringInfo(params["OpenMonitoring"]),
      loggingInfo: fromLoggingInfo(params["LoggingInfo"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMonitoring",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/clusters/${params["ClusterArn"]}/monitoring`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterArn": "s",
        "ClusterOperationArn": "s",
      },
    }, await resp.json());
  }

}

function fromBrokerNodeGroupInfo(input?: s.BrokerNodeGroupInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    brokerAZDistribution: input["BrokerAZDistribution"],
    clientSubnets: input["ClientSubnets"],
    instanceType: input["InstanceType"],
    securityGroups: input["SecurityGroups"],
    storageInfo: fromStorageInfo(input["StorageInfo"]),
  }
}
function toBrokerNodeGroupInfo(root: jsonP.JSONValue): s.BrokerNodeGroupInfo {
  return jsonP.readObj({
    required: {
      "ClientSubnets": ["s"],
      "InstanceType": "s",
    },
    optional: {
      "BrokerAZDistribution": (x: jsonP.JSONValue) => cmnP.readEnum<s.BrokerAZDistribution>(x),
      "SecurityGroups": ["s"],
      "StorageInfo": toStorageInfo,
    },
  }, root);
}

function fromStorageInfo(input?: s.StorageInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ebsStorageInfo: fromEBSStorageInfo(input["EbsStorageInfo"]),
  }
}
function toStorageInfo(root: jsonP.JSONValue): s.StorageInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "EbsStorageInfo": toEBSStorageInfo,
    },
  }, root);
}

function fromEBSStorageInfo(input?: s.EBSStorageInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    volumeSize: input["VolumeSize"],
  }
}
function toEBSStorageInfo(root: jsonP.JSONValue): s.EBSStorageInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeSize": "n",
    },
  }, root);
}

function fromClientAuthentication(input?: s.ClientAuthentication | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sasl: fromSasl(input["Sasl"]),
    tls: fromTls(input["Tls"]),
  }
}
function toClientAuthentication(root: jsonP.JSONValue): s.ClientAuthentication {
  return jsonP.readObj({
    required: {},
    optional: {
      "Sasl": toSasl,
      "Tls": toTls,
    },
  }, root);
}

function fromSasl(input?: s.Sasl | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scram: fromScram(input["Scram"]),
  }
}
function toSasl(root: jsonP.JSONValue): s.Sasl {
  return jsonP.readObj({
    required: {},
    optional: {
      "Scram": toScram,
    },
  }, root);
}

function fromScram(input?: s.Scram | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["Enabled"],
  }
}
function toScram(root: jsonP.JSONValue): s.Scram {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
    },
  }, root);
}

function fromTls(input?: s.Tls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateAuthorityArnList: input["CertificateAuthorityArnList"],
  }
}
function toTls(root: jsonP.JSONValue): s.Tls {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateAuthorityArnList": ["s"],
    },
  }, root);
}

function fromConfigurationInfo(input?: s.ConfigurationInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    arn: input["Arn"],
    revision: input["Revision"],
  }
}
function toConfigurationInfo(root: jsonP.JSONValue): s.ConfigurationInfo {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "Revision": "n",
    },
    optional: {},
  }, root);
}

function fromEncryptionInfo(input?: s.EncryptionInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryptionAtRest: fromEncryptionAtRest(input["EncryptionAtRest"]),
    encryptionInTransit: fromEncryptionInTransit(input["EncryptionInTransit"]),
  }
}
function toEncryptionInfo(root: jsonP.JSONValue): s.EncryptionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionAtRest": toEncryptionAtRest,
      "EncryptionInTransit": toEncryptionInTransit,
    },
  }, root);
}

function fromEncryptionAtRest(input?: s.EncryptionAtRest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dataVolumeKMSKeyId: input["DataVolumeKMSKeyId"],
  }
}
function toEncryptionAtRest(root: jsonP.JSONValue): s.EncryptionAtRest {
  return jsonP.readObj({
    required: {
      "DataVolumeKMSKeyId": "s",
    },
    optional: {},
  }, root);
}

function fromEncryptionInTransit(input?: s.EncryptionInTransit | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clientBroker: input["ClientBroker"],
    inCluster: input["InCluster"],
  }
}
function toEncryptionInTransit(root: jsonP.JSONValue): s.EncryptionInTransit {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClientBroker": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClientBroker>(x),
      "InCluster": "b",
    },
  }, root);
}

function fromOpenMonitoringInfo(input?: s.OpenMonitoringInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    prometheus: fromPrometheusInfo(input["Prometheus"]),
  }
}

function fromPrometheusInfo(input?: s.PrometheusInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    jmxExporter: fromJmxExporterInfo(input["JmxExporter"]),
    nodeExporter: fromNodeExporterInfo(input["NodeExporter"]),
  }
}

function fromJmxExporterInfo(input?: s.JmxExporterInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabledInBroker: input["EnabledInBroker"],
  }
}

function fromNodeExporterInfo(input?: s.NodeExporterInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabledInBroker: input["EnabledInBroker"],
  }
}

function fromLoggingInfo(input?: s.LoggingInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    brokerLogs: fromBrokerLogs(input["BrokerLogs"]),
  }
}
function toLoggingInfo(root: jsonP.JSONValue): s.LoggingInfo {
  return jsonP.readObj({
    required: {
      "BrokerLogs": toBrokerLogs,
    },
    optional: {},
  }, root);
}

function fromBrokerLogs(input?: s.BrokerLogs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cloudWatchLogs: fromCloudWatchLogs(input["CloudWatchLogs"]),
    firehose: fromFirehose(input["Firehose"]),
    s3: fromS3(input["S3"]),
  }
}
function toBrokerLogs(root: jsonP.JSONValue): s.BrokerLogs {
  return jsonP.readObj({
    required: {},
    optional: {
      "CloudWatchLogs": toCloudWatchLogs,
      "Firehose": toFirehose,
      "S3": toS3,
    },
  }, root);
}

function fromCloudWatchLogs(input?: s.CloudWatchLogs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["Enabled"],
    logGroup: input["LogGroup"],
  }
}
function toCloudWatchLogs(root: jsonP.JSONValue): s.CloudWatchLogs {
  return jsonP.readObj({
    required: {
      "Enabled": "b",
    },
    optional: {
      "LogGroup": "s",
    },
  }, root);
}

function fromFirehose(input?: s.Firehose | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deliveryStream: input["DeliveryStream"],
    enabled: input["Enabled"],
  }
}
function toFirehose(root: jsonP.JSONValue): s.Firehose {
  return jsonP.readObj({
    required: {
      "Enabled": "b",
    },
    optional: {
      "DeliveryStream": "s",
    },
  }, root);
}

function fromS3(input?: s.S3 | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["Bucket"],
    enabled: input["Enabled"],
    prefix: input["Prefix"],
  }
}
function toS3(root: jsonP.JSONValue): s.S3 {
  return jsonP.readObj({
    required: {
      "Enabled": "b",
    },
    optional: {
      "Bucket": "s",
      "Prefix": "s",
    },
  }, root);
}

function fromBrokerEBSVolumeInfo(input?: s.BrokerEBSVolumeInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    kafkaBrokerNodeId: input["KafkaBrokerNodeId"],
    volumeSizeGB: input["VolumeSizeGB"],
  }
}
function toBrokerEBSVolumeInfo(root: jsonP.JSONValue): s.BrokerEBSVolumeInfo {
  return jsonP.readObj({
    required: {
      "KafkaBrokerNodeId": "s",
      "VolumeSizeGB": "n",
    },
    optional: {},
  }, root);
}

function toUnprocessedScramSecret(root: jsonP.JSONValue): s.UnprocessedScramSecret {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorMessage": "s",
      "SecretArn": "s",
    },
  }, root);
}

function toConfigurationRevision(root: jsonP.JSONValue): s.ConfigurationRevision {
  return jsonP.readObj({
    required: {
      "CreationTime": "d",
      "Revision": "n",
    },
    optional: {
      "Description": "s",
    },
  }, root);
}

function toClusterInfo(root: jsonP.JSONValue): s.ClusterInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveOperationArn": "s",
      "BrokerNodeGroupInfo": toBrokerNodeGroupInfo,
      "ClientAuthentication": toClientAuthentication,
      "ClusterArn": "s",
      "ClusterName": "s",
      "CreationTime": "d",
      "CurrentBrokerSoftwareInfo": toBrokerSoftwareInfo,
      "CurrentVersion": "s",
      "EncryptionInfo": toEncryptionInfo,
      "EnhancedMonitoring": (x: jsonP.JSONValue) => cmnP.readEnum<s.EnhancedMonitoring>(x),
      "OpenMonitoring": toOpenMonitoring,
      "LoggingInfo": toLoggingInfo,
      "NumberOfBrokerNodes": "n",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClusterState>(x),
      "StateInfo": toStateInfo,
      "Tags": x => jsonP.readMap(String, String, x),
      "ZookeeperConnectString": "s",
      "ZookeeperConnectStringTls": "s",
    },
  }, root);
}

function toBrokerSoftwareInfo(root: jsonP.JSONValue): s.BrokerSoftwareInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConfigurationArn": "s",
      "ConfigurationRevision": "n",
      "KafkaVersion": "s",
    },
  }, root);
}

function toOpenMonitoring(root: jsonP.JSONValue): s.OpenMonitoring {
  return jsonP.readObj({
    required: {
      "Prometheus": toPrometheus,
    },
    optional: {},
  }, root);
}

function toPrometheus(root: jsonP.JSONValue): s.Prometheus {
  return jsonP.readObj({
    required: {},
    optional: {
      "JmxExporter": toJmxExporter,
      "NodeExporter": toNodeExporter,
    },
  }, root);
}

function toJmxExporter(root: jsonP.JSONValue): s.JmxExporter {
  return jsonP.readObj({
    required: {
      "EnabledInBroker": "b",
    },
    optional: {},
  }, root);
}

function toNodeExporter(root: jsonP.JSONValue): s.NodeExporter {
  return jsonP.readObj({
    required: {
      "EnabledInBroker": "b",
    },
    optional: {},
  }, root);
}

function toStateInfo(root: jsonP.JSONValue): s.StateInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": "s",
      "Message": "s",
    },
  }, root);
}

function toClusterOperationInfo(root: jsonP.JSONValue): s.ClusterOperationInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClientRequestId": "s",
      "ClusterArn": "s",
      "CreationTime": "d",
      "EndTime": "d",
      "ErrorInfo": toErrorInfo,
      "OperationArn": "s",
      "OperationState": "s",
      "OperationSteps": [toClusterOperationStep],
      "OperationType": "s",
      "SourceClusterInfo": toMutableClusterInfo,
      "TargetClusterInfo": toMutableClusterInfo,
    },
  }, root);
}

function toErrorInfo(root: jsonP.JSONValue): s.ErrorInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorString": "s",
    },
  }, root);
}

function toClusterOperationStep(root: jsonP.JSONValue): s.ClusterOperationStep {
  return jsonP.readObj({
    required: {},
    optional: {
      "StepInfo": toClusterOperationStepInfo,
      "StepName": "s",
    },
  }, root);
}

function toClusterOperationStepInfo(root: jsonP.JSONValue): s.ClusterOperationStepInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "StepStatus": "s",
    },
  }, root);
}

function toMutableClusterInfo(root: jsonP.JSONValue): s.MutableClusterInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "BrokerEBSVolumeInfo": [toBrokerEBSVolumeInfo],
      "ConfigurationInfo": toConfigurationInfo,
      "NumberOfBrokerNodes": "n",
      "EnhancedMonitoring": (x: jsonP.JSONValue) => cmnP.readEnum<s.EnhancedMonitoring>(x),
      "OpenMonitoring": toOpenMonitoring,
      "KafkaVersion": "s",
      "LoggingInfo": toLoggingInfo,
      "InstanceType": "s",
    },
  }, root);
}

function toCompatibleKafkaVersion(root: jsonP.JSONValue): s.CompatibleKafkaVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceVersion": "s",
      "TargetVersions": ["s"],
    },
  }, root);
}

function toConfiguration(root: jsonP.JSONValue): s.Configuration {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "CreationTime": "d",
      "Description": "s",
      "KafkaVersions": ["s"],
      "LatestRevision": toConfigurationRevision,
      "Name": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConfigurationState>(x),
    },
    optional: {},
  }, root);
}

function toKafkaVersion(root: jsonP.JSONValue): s.KafkaVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Version": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.KafkaVersionStatus>(x),
    },
  }, root);
}

function toNodeInfo(root: jsonP.JSONValue): s.NodeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AddedToClusterTime": "s",
      "BrokerNodeInfo": toBrokerNodeInfo,
      "InstanceType": "s",
      "NodeARN": "s",
      "NodeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.NodeType>(x),
      "ZookeeperNodeInfo": toZookeeperNodeInfo,
    },
  }, root);
}

function toBrokerNodeInfo(root: jsonP.JSONValue): s.BrokerNodeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedENIId": "s",
      "BrokerId": "n",
      "ClientSubnet": "s",
      "ClientVpcIpAddress": "s",
      "CurrentBrokerSoftwareInfo": toBrokerSoftwareInfo,
      "Endpoints": ["s"],
    },
  }, root);
}

function toZookeeperNodeInfo(root: jsonP.JSONValue): s.ZookeeperNodeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedENIId": "s",
      "ClientVpcIpAddress": "s",
      "Endpoints": ["s"],
      "ZookeeperId": "n",
      "ZookeeperVersion": "s",
    },
  }, root);
}
