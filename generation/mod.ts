import * as path from "https://deno.land/std@0.70.0/path/mod.ts";
import type * as Schema from './sdk-schema.ts';

if (Deno.args.length !== 2) {
  console.error(`Usage:`);
  console.error(`  ${Deno.mainModule} <apis path> <api uid> [out path (TODO)]`);
  console.error(`Examples:`);
  console.error(`  ${Deno.mainModule} apis-v2.761.0 sns-2010-03-31`);
  console.error(``);
  Deno.exit(1);
}
const apisPath = Deno.args[0];
const apiUid = Deno.args[1];

const jsonPath = (suffix: string) =>
  path.join(apisPath, `${apiUid}.${suffix}.json`);
const maybeReadFile = (path: string): Promise<any> =>
  Deno.readTextFile(path).catch(err => {
    if (err.name === 'NotFound') return null;
    return Promise.reject(err);
  });

const serviceSpec = JSON.parse(await Deno.readTextFile(jsonPath('normal'))) as Schema.Api;
const pagerSpec = JSON.parse(await maybeReadFile(jsonPath('paginators'))) as Schema.Pagination;
const waitingSpec = JSON.parse(await maybeReadFile(jsonPath('waiters2'))) as Schema.Waiters;

const apiCamelName = serviceSpec.metadata.serviceId.split(' ').map(x => x[0].toUpperCase()+x.slice(1)).join('');
// console.log(wholeSpec.metadata)

const allMethods = new Set(Object.values(serviceSpec.operations).map(x => x.http.method));

const chunks = new Array<string>();
chunks.push(`// Autogenerated API client for: ${serviceSpec.metadata.serviceFullName}`);

type LocationMap = { [param: string]: {
  location: "uri" | "querystring" | "header" | "headers" | "statusCode";
  name?: string;
}};

chunks.push(`
// The HTTP contract put forth by aws-typescript-client/core/mod.ts
interface ApiRequestConfig {
  // fixed per operation
  action: string;
  method: ${Array.from(allMethods).map(x => JSON.stringify(x)).join(' | ')};
  requestUri: string;
  responseCode?: number;
  locationsIn?: ApiParamLocationMap;
  locationsOut?: ApiParamLocationMap;
  // dynamic per call
  input: { [param: string]: any; };
  abortSignal?: AbortSignal;
}
type ApiParamLocationMap = { [param: string]: {
  location: "uri" | "querystring" | "header" | "headers" | "statusCode";
  name?: string;
}}
interface ApiFactory {
  buildServiceClient(apiMetadata: Object): ServiceClient;
}
interface ServiceClient {
  performRequest(request: ApiRequestConfig): Promise<any>;
}

`);

const namedShapes = new Set<string>();

function censorShapeName(name: string): string {
  if (['Object', 'Date', 'String'].includes(name)) {
    return '_'+name;
  }
  return name;
}

function formatStructureType(shape: Schema.ShapeStructure): string {
  const required = new Set(shape.required?.map(x => x.toLowerCase()) || []);
  return ['{',
    ...Object.entries(shape.members).map(([key, spec]) =>
      `    ${key}${required.has(key.toLowerCase()) ? '' : '?'}: ${specifyShapeType(spec)};`),
  '  }'].join('\n');
}
function specifyShapeType(spec: Schema.ShapeRef): string {
  const shape = serviceSpec.shapes[spec.shape];
  if (!shape) return 'any';
  switch (shape.type) {
    case 'string':
    case 'boolean':
      return shape.type;
    case 'double':
    case 'float':
    case 'long':
    case 'integer':
      return 'number';
    case 'list':
      return `Array<${specifyShapeType(shape.member)}>`;
    case 'map':
      return `{ [key: ${specifyShapeType(shape.key)}]: ${specifyShapeType(shape.value)} }`;
    case 'structure':
      namedShapes.add(spec.shape);
      return censorShapeName(spec.shape); // TODO?
    case 'timestamp':
      return 'Date';
    case 'blob':
      return 'Uint8Array'; // TODO
    default:
      throw new Error(`TODO: unimpl shape type ${(shape as any).type}`);
  }
}

chunks.push(`export default class ${apiCamelName} {`);
chunks.push(`  #client: ServiceClient;`);
chunks.push(`  constructor(apiFactory: ApiFactory) {`);
chunks.push(`    this.#client = apiFactory.buildServiceClient(${apiCamelName}.ApiMetadata);`);
chunks.push(`  }\n`);
chunks.push(`  static ApiMetadata: Object = ${JSON.stringify(serviceSpec.metadata, null, 2).replace(/\n/g, `\n  `)};\n`);

for (const operation of Object.values(serviceSpec.operations)) {
  const inputShape = operation.input ? serviceSpec.shapes[operation.input.shape] : null;
  const outputShape = operation.output ? serviceSpec.shapes[operation.output.shape] : null;

  let signature = `(`;
  let hasInputLocations = false;
  const inputLocations: LocationMap = {};
  if (inputShape?.type === 'structure') {
    signature += 'input: '+formatStructureType(inputShape);
    if (!inputShape.required?.length) {
      signature += ' = {}';
    }

    for (const [field, spec] of Object.entries(inputShape.members)) {
      if (!spec.location) continue;
      hasInputLocations = true;
      inputLocations[field] = {location: spec.location, name: spec.locationName};
    }
  } else if (inputShape) {
    throw new Error(`TODO: ${inputShape.type} input`);
  }

  signature += `): Promise<`;
  let hasOutputLocations = false;
  const outputLocations: LocationMap = {};
  if (outputShape?.type === 'structure' && operation.output) {
    signature += specifyShapeType(operation.output);
    // signature += formatStructureType(outputShape);

    for (const [field, spec] of Object.entries(outputShape.members)) {
      if (!spec.location) continue;
      hasOutputLocations = true;
      outputLocations[field] = {location: spec.location, name: spec.locationName};
    }
  } else if (outputShape) {
    throw new Error(`TODO: ${outputShape.type} output`);
  } else {
    signature += 'void';
  }
  signature += '>';

  const lowerCamelName = operation.name[0].toLowerCase() + operation.name.slice(1);
  chunks.push(`  async ${lowerCamelName}${signature} {`);
  chunks.push(`    const resp = await this.#client.performRequest({`);
  chunks.push(`      action: ${JSON.stringify(operation.name)},`);
  chunks.push(`      method: ${JSON.stringify(operation.http.method)},`);
  chunks.push(`      requestUri: ${JSON.stringify(operation.http.requestUri)},`);
  if (operation.http.responseCode) {
    chunks.push(`      responseCode: ${JSON.stringify(operation.http.responseCode)},`);
  }
  if (hasInputLocations) {
    chunks.push(`      locationsIn: ${JSON.stringify(inputLocations)},`);
  }
  if (hasOutputLocations) {
    chunks.push(`      locationsOut: ${JSON.stringify(outputLocations)},`);
  }
  chunks.push(`      input: ${inputShape ? 'input' : '{}'},`);
  chunks.push(`    });`);
  if (serviceSpec.metadata.protocol === 'query' && operation.output?.resultWrapper) {
    chunks.push(`    const data = await resp.json();`);
    chunks.push(`    return data["${operation.name}Response"][${JSON.stringify(operation.output.resultWrapper)}];`);
  } else {
    chunks.push(`    return resp; // TODO`);
  }
  chunks.push(`  }\n`);

  // return Promise.reject("TODO");
  // console.log(operation.name, operation.input?.shape, operation.output?.shape);
}

if (waitingSpec) {
  chunks.push(`  get waitFor(): ${apiCamelName}Waiters {`);
  chunks.push(`    return new ${apiCamelName}Waiters(this);`);
  chunks.push(`  };`);
}

chunks.push(`}\n`);

if (waitingSpec) {
  chunks.push(`class ${apiCamelName}Waiters {`);
  chunks.push(`  #service: ${apiCamelName};`);
  chunks.push(`  constructor(service: ${apiCamelName}) {`);
  chunks.push(`    this.#service = service;`);
  chunks.push(`  }\n`);

  for (const [waiter, spec] of Object.entries(waitingSpec.waiters)) {
    if (spec.description) {
      chunks.push(`  /**\n   * ${spec.description}\n   */`);
    }
    chunks.push(`  ${waiter}(): Promise<any> {`);
    chunks.push(`    return Promise.reject("TODO");`);
    chunks.push(`  }\n`);
  }
  chunks.push(`}\n`);
}

for (const shapeName of namedShapes) {
  const shape = serviceSpec.shapes[shapeName];
  if (!shape) {
    chunks.push(`// TODO: missing shape ${shapeName}\n`);
    continue;
  } else if (shape.type === 'structure') {
    chunks.push(`interface ${censorShapeName(shapeName)} ${formatStructureType(shape)}\n`);
  } else {
    chunks.push(`// TODO: forgotten shape ${shapeName} of type ${shape.type}\n`);
  }
}

await Deno.writeTextFile(path.join('generated', `${serviceSpec.metadata.endpointPrefix}@${serviceSpec.metadata.apiVersion}.ts`), chunks.join('\n'));
