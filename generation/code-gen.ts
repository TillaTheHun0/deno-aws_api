import * as path from "https://deno.land/std@0.70.0/path/mod.ts";
import type * as Schema from './sdk-schema.ts';

export default class ServiceCodeGen {
  apiSpec: Schema.Api;
  pagersSpec: Schema.Pagination | undefined;
  waitersSpec: Schema.Waiters | undefined;
  constructor(specs: {
    api: Schema.Api,
    pagers?: Schema.Pagination,
    waiters?: Schema.Waiters,
  }) {
    this.apiSpec = specs.api;
    this.pagersSpec = specs.pagers;
    this.waitersSpec = specs.waiters;
  }

  #namedShapes = new Set<string>();

  generateTypescript(): string {
    this.#namedShapes.clear();

    // console.log(wholeSpec.metadata)
    const apiCamelName = this.apiSpec.metadata.serviceId.split(' ').map(x => x[0].toUpperCase()+x.slice(1)).join('');

    const allMethods = new Set(Object.values(this.apiSpec.operations).map(x => x.http.method));

    const chunks = new Array<string>();
    chunks.push(`// Autogenerated API client for: ${this.apiSpec.metadata.serviceFullName}`);

    type LocationMap = { [param: string]: {
      location: "uri" | "querystring" | "header" | "headers" | "statusCode";
      name?: string;
    }};

    chunks.push(`
// The HTTP contract put forth by aws-typescript-client/core/mod.ts
interface ApiRequestConfig {
  // fixed per operation
  action: string;
  method: ${Array.from(allMethods).map(x => JSON.stringify(x)).join(' | ')};
  requestUri: string;
  responseCode?: number;
  locationsIn?: ApiParamLocationMap;
  locationsOut?: ApiParamLocationMap;
  // dynamic per call
  input: { [param: string]: any; };
  abortSignal?: AbortSignal;
}
type ApiParamLocationMap = { [param: string]: {
  location: "uri" | "querystring" | "header" | "headers" | "statusCode";
  name?: string;
}}
interface ApiFactory {
  buildServiceClient(apiMetadata: Object): ServiceClient;
}
interface ServiceClient {
  performRequest(request: ApiRequestConfig): Promise<any>;
}

`);


    chunks.push(`export default class ${apiCamelName} {`);
    chunks.push(`  #client: ServiceClient;`);
    chunks.push(`  constructor(apiFactory: ApiFactory) {`);
    chunks.push(`    this.#client = apiFactory.buildServiceClient(${apiCamelName}.ApiMetadata);`);
    chunks.push(`  }\n`);
    chunks.push(`  static ApiMetadata: Object = ${JSON.stringify(this.apiSpec.metadata, null, 2).replace(/\n/g, `\n  `)};\n`);

    for (const operation of Object.values(this.apiSpec.operations)) {
      const inputShape = operation.input ? this.apiSpec.shapes[operation.input.shape] : null;
      const outputShape = operation.output ? this.apiSpec.shapes[operation.output.shape] : null;

      let signature = `(`;
      let hasInputLocations = false;
      const inputLocations: LocationMap = {};
      if (inputShape?.type === 'structure') {
        signature += 'input: '+this.formatStructureType(inputShape);
        if (!inputShape.required?.length) {
          signature += ' = {}';
        }

        for (const [field, spec] of Object.entries(inputShape.members)) {
          if (!spec.location) continue;
          hasInputLocations = true;
          inputLocations[field] = {location: spec.location, name: spec.locationName};
        }
      } else if (inputShape) {
        throw new Error(`TODO: ${inputShape.type} input`);
      }

      signature += `): Promise<`;
      let hasOutputLocations = false;
      const outputLocations: LocationMap = {};
      if (outputShape?.type === 'structure' && operation.output) {
        signature += this.specifyShapeType(operation.output);
        // signature += this.formatStructureType(outputShape);

        for (const [field, spec] of Object.entries(outputShape.members)) {
          if (!spec.location) continue;
          hasOutputLocations = true;
          outputLocations[field] = {location: spec.location, name: spec.locationName};
        }
      } else if (outputShape) {
        throw new Error(`TODO: ${outputShape.type} output`);
      } else {
        signature += 'void';
      }
      signature += '>';

      const lowerCamelName = operation.name[0].toLowerCase() + operation.name.slice(1);
      chunks.push(`  async ${lowerCamelName}${signature} {`);
      chunks.push(`    const resp = await this.#client.performRequest({`);
      chunks.push(`      action: ${JSON.stringify(operation.name)},`);
      chunks.push(`      method: ${JSON.stringify(operation.http.method)},`);
      chunks.push(`      requestUri: ${JSON.stringify(operation.http.requestUri)},`);
      if (operation.http.responseCode) {
        chunks.push(`      responseCode: ${JSON.stringify(operation.http.responseCode)},`);
      }
      if (hasInputLocations) {
        chunks.push(`      locationsIn: ${JSON.stringify(inputLocations)},`);
      }
      if (hasOutputLocations) {
        chunks.push(`      locationsOut: ${JSON.stringify(outputLocations)},`);
      }
      chunks.push(`      input: ${inputShape ? 'input' : '{}'},`);
      chunks.push(`    });`);
      if (this.apiSpec.metadata.protocol === 'query' && operation.output?.resultWrapper) {
        chunks.push(`    const data = await resp.json();`);
        chunks.push(`    return data["${operation.name}Response"][${JSON.stringify(operation.output.resultWrapper)}];`);
      } else {
        chunks.push(`    return resp; // TODO`);
      }
      chunks.push(`  }\n`);

      // return Promise.reject("TODO");
      // console.log(operation.name, operation.input?.shape, operation.output?.shape);
    }

    if (this.waitersSpec) {
      chunks.push(`  // Resource State Waiters\n`);

      for (const [waiter, spec] of Object.entries(this.waitersSpec.waiters)) {
        if (spec.description) {
          chunks.push(`  /**\n   * ${spec.description}\n   */`);
        }
        chunks.push(`  waitFor${waiter}(): Promise<any> {`);
        chunks.push(`    return Promise.reject("TODO");`);
        chunks.push(`  }\n`);
      }
    }

    chunks.push(`}\n`);

    for (const shapeName of this.#namedShapes) {
      const shape = this.apiSpec.shapes[shapeName];
      if (!shape) {
        chunks.push(`// TODO: missing shape ${shapeName}\n`);
        continue;
      } else if (shape.type === 'structure') {
        chunks.push(`interface ${censorShapeName(shapeName)} ${this.formatStructureType(shape)}\n`);
      } else {
        chunks.push(`// TODO: forgotten shape ${shapeName} of type ${shape.type}\n`);
      }
    }

    return chunks.join('\n');
  }


  formatStructureType(shape: Schema.ShapeStructure): string {
    const required = new Set(shape.required?.map(x => x.toLowerCase()) || []);
    return ['{',
      ...Object.entries(shape.members).map(([key, spec]) =>
        `    ${key}${required.has(key.toLowerCase()) ? '' : '?'}: ${this.specifyShapeType(spec)};`),
    '  }'].join('\n');
  }

  specifyShapeType(spec: Schema.ShapeRef): string {
    const shape = this.apiSpec.shapes[spec.shape];
    if (!shape) return 'any';
    switch (shape.type) {
      case 'string':
      case 'boolean':
        return shape.type;
      case 'double':
      case 'float':
      case 'long':
      case 'integer':
        return 'number';
      case 'list':
        return `Array<${this.specifyShapeType(shape.member)}>`;
      case 'map':
        return `{ [key: ${this.specifyShapeType(shape.key)}]: ${this.specifyShapeType(shape.value)} }`;
      case 'structure':
        this.#namedShapes.add(spec.shape);
        return censorShapeName(spec.shape); // TODO?
      case 'timestamp':
        return 'Date';
      case 'blob':
        return 'Uint8Array'; // TODO
      default:
        throw new Error(`TODO: unimpl shape type ${(shape as any).type}`);
    }
  }
}

function censorShapeName(name: string): string {
  if (['Object', 'Date', 'String'].includes(name)) {
    return '_'+name;
  }
  return name;
}
