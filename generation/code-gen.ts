import * as path from "https://deno.land/std@0.70.0/path/mod.ts";
import type * as Schema from './sdk-schema.ts';
import ProtocolQueryCodegen from './protocol-query.ts';
import ShapeLibrary from './shape-library.ts';
// import type { ApiParamSpecMap, ApiParamSpec } from './../deno-client/common.ts';

export default class ServiceCodeGen {
  apiSpec: Schema.Api;
  pagersSpec?: Schema.Pagination;
  waitersSpec?: Schema.Waiters;

  shapes: ShapeLibrary;
  protocol: ProtocolQueryCodegen; // TODO: others too

  constructor(specs: {
    api: Schema.Api,
    pagers?: Schema.Pagination,
    waiters?: Schema.Waiters,
  }) {
    this.apiSpec = specs.api;
    this.pagersSpec = specs.pagers;
    this.waitersSpec = specs.waiters;

    const inputShapes = new Set<string>();
    const outputShapes = new Set<string>();
    for (const op of Object.values(specs.api.operations)) {
      if (op.input) inputShapes.add(op.input.shape);
      if (op.output) outputShapes.add(op.output.shape);
    }

    this.shapes = new ShapeLibrary({
      shapeSpecs: specs.api.shapes,
      inputNames: Array.from(inputShapes),
      outputNames: Array.from(outputShapes),
    });

    switch (specs.api.metadata.protocol) {
      case 'ec2':
        this.protocol = new ProtocolQueryCodegen(this.shapes, {ec2: true});
        break;
      case 'query':
        this.protocol = new ProtocolQueryCodegen(this.shapes);
        break;
      default: throw new Error(
        `TODO: unimpl protocol ${specs.api.metadata.protocol}`);
    }

  }

  // #namedShapes = new Set<string>();
  // #singleRefShapes = new Set<string>();

  generateTypescript(): string {
    // this.#namedShapes.clear();
    // this.#singleRefShapes.clear();

    // console.log(wholeSpec.metadata)
    const apiCamelName = this.apiSpec.metadata.serviceId.split(' ').map(x => x[0].toUpperCase()+x.slice(1)).join('');

    const allMethods = new Set(Object.values(this.apiSpec.operations).map(x => x.http?.method ?? 'POST'));

    const chunks = new Array<string>();
    chunks.push(`// Autogenerated API client for: ${this.apiSpec.metadata.serviceFullName}`);

    // type LocationMap = { [param: string]: {
    //   location: "uri" | "querystring" | "header" | "headers" | "statusCode";
    //   name?: string;
    // }};

    chunks.push(`
// The HTTP contract put forth by aws-typescript-client/core/mod.ts
interface ApiRequestConfig {
  // fixed per operation
  action: string;
  method?: ${Array.from(allMethods).map(x => JSON.stringify(x)).join(' | ')};
  requestUri?: string;
  responseCode?: number;
  hostPrefix?: string;
  // "endpointdiscovery"?: {} // only in dynamodb
// dynamic per call
  headers?: Headers;
  query?: URLSearchParams;
  body?: ${this.protocol.requestBodyTypeName};
  abortSignal?: AbortSignal;
}
export type ApiResponse = Response & {
  xml(resultWrapper?: string): Promise<XmlNode>;
}
// Things that JSON can handle directly
// export type ApiWireStructure = {
//   [param: string]: string | number | boolean | null | ApiWireStructure;
// };
interface ApiFactory {
  buildServiceClient(apiMetadata: Object): ServiceClient;
}
interface ServiceClient {
  performRequest(request: ApiRequestConfig): Promise<ApiResponse>;
  // TODO: runWaiter(, abortSignal: AbortSignal?)
}
interface RequestConfig {
  abortSignal?: AbortSignal;
}
export interface XmlNode {
  name: string;
  attributes: {[key: string]: string};
  content?: string;
  children: XmlNode[];
  getChild(name: string): XmlNode | undefined;
  mapChildren(opts: {lists?: string[]}): [
    {[key: string]: XmlNode},
    {[key: string]: XmlNode[]},
  ];
}

`);
    chunks.push(this.protocol.globalHelpers);

    chunks.push(`export default class ${apiCamelName} {`);
    chunks.push(`  #client: ServiceClient;`);
    chunks.push(`  constructor(apiFactory: ApiFactory) {`);
    chunks.push(`    this.#client = apiFactory.buildServiceClient(${apiCamelName}.ApiMetadata);`);
    chunks.push(`  }\n`);
    chunks.push(`  static ApiMetadata: Object = ${JSON.stringify(this.apiSpec.metadata, null, 2).replace(/\n/g, `\n  `)};\n`);

    for (const operation of Object.values(this.apiSpec.operations)) {
      const inputShape = operation.input ? this.apiSpec.shapes[operation.input.shape] : null;
      const outputShape = operation.output ? this.apiSpec.shapes[operation.output.shape] : null;

      let signature = `(\n    {abortSignal, ...params}: RequestConfig`;
      if (inputShape?.type === 'structure' && operation.input) {
        signature += ' & ' + this.specifyShapeType(operation.input);
        if (!inputShape.required?.length) {
          signature += ' = {}';
        }
      } else if (inputShape) {
        throw new Error(`TODO: ${inputShape.type} input`);
      } else {
        signature += ' = {}';
      }

      signature += `,\n  ): Promise<`;
      if (outputShape?.type === 'structure' && operation.output) {
        // signature += 'string';
        signature += this.specifyShapeType(operation.output);
      } else if (outputShape) {
        throw new Error(`TODO: ${outputShape.type} output`);
      } else {
        // signature += 'string';
        signature += 'void';
      }
      signature += '>';

      const lowerCamelName = operation.name[0].toLowerCase() + operation.name.slice(1);
      chunks.push(`  async ${lowerCamelName}${signature} {`);
      const pathParts = new Map;
      const referencedInputs = new Set(['abortSignal']);
      if (inputShape?.type === 'structure') {
        const {inputParsingCode, inputVariables} = this.protocol
          .generateOperationInputParsingTypescript(inputShape);
        chunks.push(inputParsingCode);
        inputVariables.forEach(x => referencedInputs.add(x));
      }

      chunks.push(`    const resp = await this.#client.performRequest({`);
      chunks.push(`      ${Array.from(referencedInputs).join(', ')},`);
      chunks.push(`      action: ${JSON.stringify(operation.name)},`);
      if (operation.http?.method && operation.http.method !== 'POST') {
        chunks.push(`      method: ${JSON.stringify(operation.http.method)},`);
      }
      if (operation.http?.requestUri && operation.http.requestUri !== '/') {
        const formattedPath = operation.http?.requestUri?.includes('{')
          ? ('encodePath`'+operation.http.requestUri
              .replace(/{[^}]+}/g, x => pathParts.get(x)||x)
            +'`').replace(/\+encodePath``/g, '')
          : JSON.stringify(operation.http?.requestUri || '/');
        chunks.push(`      requestUri: ${formattedPath},`);
      }
      if (operation.http?.responseCode) {
        chunks.push(`      responseCode: ${JSON.stringify(operation.http.responseCode)},`);
      }
      if (operation.endpoint?.hostPrefix) {
        const templatedPrefix = operation.endpoint.hostPrefix.replace(/{/g, '${params.');
        chunks.push(`      hostPrefix: \`${templatedPrefix}\`,`);
      }
      chunks.push(`    });`);

      if (outputShape) {
        chunks.push(`    const xml = await resp.xml(${JSON.stringify(operation.output?.resultWrapper ?? undefined)});`);
        chunks.push(`    const [fields] = xml.mapChildren({});`);
        chunks.push(`    return {`);
        for (const [field, spec] of Object.entries(outputShape?.members)) {
          const fieldShape = this.shapes.get(spec);
          const locationName = fieldShape.spec.locationName ?? spec.locationName ?? field;
          switch (fieldShape.spec.type) {
            case 'string':
              if (fieldShape.spec.enum) {
                // TODO: is there a better way of mapping freetext into enums?
                chunks.push(`      ${field}: fields[${JSON.stringify(locationName)}]?.content as ${fieldShape.spec.enum.map(x => JSON.stringify(x)).join(' | ')},`);
              } else {
                chunks.push(`      ${field}: fields[${JSON.stringify(locationName)}]?.content,`);
              }
              break;
            default:
              chunks.push(`      // TODO: ${field} (${fieldShape.spec.type})`);
          }
        }
        chunks.push(`    };`);
      }

      chunks.push(`  }\n`);
    }

    if (this.waitersSpec) {
      chunks.push(`  // Resource State Waiters\n`);

      for (const [waiter, spec] of Object.entries(this.waitersSpec.waiters)) {
        if (spec.description) {
          chunks.push(`  /**\n   * ${spec.description}\n   */`);
        }
        chunks.push(`  waitFor${waiter}(): Promise<any> {`);
        chunks.push(`    return Promise.reject("TODO");`);
        chunks.push(`  }\n`);
      }
    }

    chunks.push(`}\n`);

    for (const shape of this.shapes.allNamedShapes) {
      if (!shape.tags.has('named')) continue;

      if (shape.spec.type === 'structure') {
        // if (this.#singleRefShapes.has(shape.name)) {
        //   chunks.push(`// TODO: can be inlined (only used once)`);
        // }
        chunks.push(`interface ${shape.censoredName} ${
          this.formatStructureType(shape.spec)}`);
        if (!this.shapes.inputShapes.includes(shape) && shape.tags.has('input')) {
          chunks.push(this.protocol.generateShapeInputParsingTypescript(
            shape.censoredName, shape.spec,
          ).inputParsingFunction);
        }
        chunks.push('');

      } else if (shape.spec.type === 'string' && shape.spec.enum) {
        chunks.push(`type ${shape.censoredName} =`);
        for (const value of shape.spec.enum) {
          chunks.push(`| ${JSON.stringify(value)}`);
        }
        chunks.push(`;\n`);

      } else {
        chunks.push(`// TODO: forgotten shape ${shape.name} of type ${shape.spec.type}\n`);
      }
    }

    return chunks.join('\n');
  }

  formatStructureType(shape: Schema.ShapeStructure): string {
    const required = new Set(shape.required?.map(x => x.toLowerCase()) || []);
    return ['{',
      ...Object.entries(shape.members).map(([key, spec]) =>
        `  ${key}${required.has(key.toLowerCase()) ? '' : '?'}: ${this.specifyShapeType(spec)};`),
    '}'].join('\n');
  }

  specifyShapeType(spec: Schema.ShapeRef, isDictKey = false): string {
    const shape = this.apiSpec.shapes[spec.shape];
    if (!shape) return 'any';
    switch (shape.type) {
      case 'string':
        if (shape.enum && !isDictKey) {
          return shape.enum.map(x => JSON.stringify(x)).join(' | ');
        }
      case 'boolean':
        return shape.type;
      case 'double':
      case 'float':
      case 'long':
      case 'integer':
        return 'number';
      case 'list':
        return `Array<${this.specifyShapeType(shape.member)}>`;
      case 'map':
        return `{ [key: ${this.specifyShapeType(shape.key, true)}]: ${this.specifyShapeType(shape.value)} }`;
      case 'structure':
        if (this.shapes.get(spec).tags.has('named')) {
          return censorShapeName(spec.shape); // TODO?
        } else {
          return this.formatStructureType(shape).replace(/\n/g, '\n  ');
        }
      case 'timestamp':
        return 'Date | number';
      case 'blob':
        return 'Uint8Array | string'; // TODO
      default:
        throw new Error(`TODO: unimpl shape type ${(shape as any).type}`);
    }
  }

}

function censorShapeName(name: string): string {
  if (['Object', 'Date', 'String'].includes(name)) {
    return '_'+name;
  }
  return name;
}
